new JSTreePrinter	JSTreePrinter	printer
"scala.scalajs.js.Dynamic"	String	jsDynamicFqn
None	Option[Boolean]	wasEnabled
ts	Seq[JSNode]	rest
EmptyNode	IRNode	value
Id(prefix.getOrElse(referenceExpression.refName))	Id	id
NoPosition	NoPosition.type	pos
tree.stats	Seq[JSNode]	rest
ScalaNamesUtil.clean(name)	String	cleanName
Ref(id)	Ref	varRef
Position()	Position	pos
Id(reference.refName)	Id	id
Key.create[VirtualFile]("scala.js.file")	Key[VirtualFile]	key
Id(pattern.bindings.head.name)	Id	name
receiveOrDefault(pattern.expr)	IRNode	rightExpr
Id(variable.bindings.head.name)	Id	name
receiveOrDefault(variable.expr)	IRNode	rightExpr
ScalaCompilerConfiguration.instanceIn(project)	ScalaCompilerConfiguration	compilerConfiguration
getJsSettings	JavaScriptDebuggerSettings	jsSettings
collection.mutable.Set[String]()	mutable.Set[String]	addedElements
parameters.getPosition	PsiElement	position
expression.elementScope	ElementScope	elementScope
expression match { case impl: JSReferenceExpressionImpl => impl.getResolveQualifier case _ => expression.getQualifier }	JSExpression	qualifier
new VariantsProcessor( file, expression, JSRootConfiguration.getInstance(file.getProject).isOnlyTypeBasedCompletion, parameters, result)	VariantsProcessor	processor
rest.head	JSNode	x
cases	Seq[(JSNode, JSNode)]	rest
rest.head	(JSNode, JSNode)	next
fields	Seq[(JSNode, JSNode)]	rest
rest.head	(JSNode, JSNode)	x
module.modifiableModel	ModifiableRootModel	model
0	Int	i
i	Int	start
str.charAt(i)	Int	c
2 * (c - 7)	Int	i
0	Int	indentMargin
2	Int	indentStep
receiveChildren(functionDef.paramClauses).map(_.asInstanceOf[ParamDef])	IndexedSeq[ParamDef]	params
Function(params, Return(body))	Function	innerFunction
receiveChildren(stmt.params).map(_.asInstanceOf[ParamDef])	IndexedSeq[ParamDef]	params
receiveChildren(function.paramClauses).map(_.asInstanceOf[ParamDef])	IndexedSeq[ParamDef]	params
constrInvocation.arguments.map { receive(_) }	IndexedSeq[IRNode]	arguments
constrInvocation.newTemplate.flatMap(x => Option(x.nameId)).map(_.getText).getOrElse("<error>")	String	name
receiveOrDefault(statement.condition)	IRNode	condition
receiveOrDefault(statement.thenExpression)	IRNode	thenBranch
receiveOrDefault(statement.elseExpression)	IRNode	elseBranch
receive(statement.leftExpression)	IRNode	leftExpr
receiveOrDefault(statement.rightExpression)	IRNode	rightExpr
call.argumentExpressions.map(receive(_))	IndexedSeq[IRNode]	args
call.deepestInvokedExpr	ScExpression	scExpression
myFixture.getLookup	LookupEx	lookup
reference match { case DynamicResolveProcessor.DynamicReference(results) => results case _ => Seq.empty }	Seq[ResolveResult]	variants
stats flatMap { case Skip() => Nil case Block(subStats) => subStats case other => other :: Nil }	IndexedSeq[IRNode]	flattenedStats
1	Int	Boolean_!
2	Int	IntToLong
3	Int	LongToInt
4	Int	LongToDouble
5	Int	DoubleToInt
6	Int	DoubleToFloat
7	Int	DoubleToLong
stats flatMap { case skip: Skip => Nil case Block(subStats) => subStats case other => other :: Nil }	IndexedSeq[JSNode]	flattenedStats
VarRef(name)(pos)	JSNode	ref
1	Int	===
2	Int	!==
3	Int	String_+
4	Int	Int_+
5	Int	Int_-
6	Int	Int_*
7	Int	Int_/
8	Int	Int_%
9	Int	Int_|
10	Int	Int_&
11	Int	Int_^
12	Int	Int_<<
13	Int	Int_>>>
14	Int	Int_>>
15	Int	Float_+
16	Int	Float_-
17	Int	Float_*
18	Int	Float_/
19	Int	Float_%
20	Int	Double_+
21	Int	Double_-
22	Int	Double_*
23	Int	Double_/
24	Int	Double_%
25	Int	Num_==
26	Int	Num_!=
27	Int	Num_<
28	Int	Num_<=
29	Int	Num_>
value	String	name
30	Int	Num_>=
31	Int	Long_+
32	Int	Long_-
33	Int	Long_*
34	Int	Long_/
35	Int	Long_%
36	Int	Long_|
37	Int	Long_&
38	Int	Long_^
39	Int	Long_<<
40	Int	Long_>>>
41	Int	Long_>>
42	Int	Long_==
43	Int	Long_!=
44	Int	Long_<
45	Int	Long_<=
46	Int	Long_>
47	Int	Long_>=
48	Int	Boolean_==
49	Int	Boolean_!=
50	Int	Boolean_|
51	Int	Boolean_&
1	Int	+
2	Int	-
3	Int	~
4	Int	!
5	Int	typeof
3	Int	+
4	Int	-
5	Int	*
6	Int	/
7	Int	%
8	Int	|
9	Int	&
10	Int	^
args.collect{case assign: Assign => assign}.map{case Assign(left, right) => (left, right)}	IndexedSeq[(IRNode, IRNode)]	updatedArgs
11	Int	<<
12	Int	>>
receiveOrDefault(whileStatement.condition)	IRNode	condition
13	Int	>>>
14	Int	<
15	Int	<=
16	Int	>
receiveOrDefault(whileStatement.expression)	IRNode	body
17	Int	>=
18	Int	&&
19	Int	||
20	Int	in
21	Int	instanceof
receiveOrDefault(doStatement.condition)	IRNode	condition
receiveOrDefault(doStatement.body)	IRNode	body
jsFile.findReferenceAt(offset) match { case jsExpression: JSReferenceExpression => ProgressManager.checkCanceled() Some(evaluate(jsExpression, jsFile)) case _ => None }	Option[T]	result
IREmptyNode	IRNode	specialNode
expression.elementScope	ElementScope	scope
PersistenceCommonUtil.getPersistenceRoles(clazz)	Array[PersistenceClassRole]	roles
new IRGenerator( expression, None, (node: IRNode) => specialNode = node // TODO implements it in more functional way. It looks like java 1.5 )	IRGenerator	irGenerator
receiveChildren(block)	Seq[IRNode]	statements
JSEmptyNode	JSNode	result
new JSAstGenerator( specialNode, (node: JSNode) => result = node ).generate(node)	JSNode	tree
(new JSTreePrinter).printFullTree(tree)	String	text
receiveOrDefault(tryStmt.expression)	IRNode	tryBlock
if (fun.parentOfType(classOf[PsiClass]).flatMap(roles).isDefined) { val attributes = PersistenceHelper.getHelper.getSharedModelBrowser.getPersistenceAttributes(fun) if (attributes.isEmpty) None else Some(attributes) } else None	Option[Nothing]	maybeAttributes
block.getFirstChild match { case i: ScImportStmt => i.getNextSiblingNotWhitespace // for <% import var a ... case a => a }	PsiElement	parent
ScalaPsiElementFactory.createScalaFileFromText(s"class ${reference.refName} ")(manager).typeDefinitions.head	ScTypeDefinition	definition
getStringClazz	PsiClass	clazz
ScalaPsiElementFactory.createScalaFileFromText(s"class $name ")(manager).typeDefinitions.head	ScTypeDefinition	definition
inName.getOrElse(functionElement.getName)	String	name
createPatternFromText("_")	ScPattern	myPattern
tryStmt.catchBlock match { case Some(cb) => cb.expression match { case Some(block: ScBlockExpr) if block.hasCaseClauses => block.caseClauses.toSeq.flatMap(_.caseClauses).map(clause => CatchNode(Id(name), receiveOrDefault(clause.expr))) case _ => Seq(EmptyNode) } case None => Seq(EmptyNode) }	Seq[IRNode with Product with Serializable]	catchBlock
new StringBuilder	StringBuilder	text
receiveOrDefault(tryStmt.finallyBlock.flatMap(_.expression))	IRNode	finallyBlock
new IRGenerator(lookedExpr, prefix, listener)	IRGenerator	qualifierGenerator
new MultiYRGenerator(lookedExpr, listener, prefix)	MultiYRGenerator	generator
new mutable.ListBuffer[IRNode]()	ListBuffer[IRNode]	astNodes
functionElement.getParameterList.getParameterVariables.map(_.getQualifiedName).mkString(", ")	String	params
ScalaPsiElementFactory.createMethodFromText(s"def $name ($params) = ???".stripMargin)(manager)	ScFunction	definition
ProjectScope getAllScope getProject	GlobalSearchScope	scope
Set("org.fusesource.scalate.RenderContext._")	Set[Nothing]	implicitImports
Set("org.fusesource.scalate.RenderContext")	Set[Nothing]	implicitExtends
node match { case ir.EmptyNode => EmptyNode case ir.VarDef(name, rhs) => VarDef(name, rhs) case ir.ParamDef(name) => ParamDef(name)(pos) case ir.Skip() => Skip() case ir.Block(statements) => Block(statements) case ir.Assign(lhs, rhs) => Assign(lhs, rhs) case ir.Return(expr) => Return(expr) case ir.If(cond, thenp, elsep) => If(cond, thenp, elsep) case ir.While(cond, body) => While(cond, body) case ir.DoWhile(body, cond) => DoWhile(body, cond) case ir.Match(selector, cases, default) => Skip() //TODO Fix it case ir.New(ctor, args) => Skip() //Todo fix it case ir.Select(qualifier, item) => DotSelect(qualifier, item) case ir.Apply(receiver, method, args) => Apply(DotSelect(receiver, method), args) case ir.ApplyStatic(method, args) => Apply(method, args) case ir.JSNew(ctor, args) => New(ctor, args) case ir.UnaryOp(op, lhs) => Skip() //TODO Fix it case ir.BinaryOp(op, lhs, rhs) => Skip() //TODO Fix it case ir.NewArray(lengths) => ArrayConstructor(lengths) case ir.ArrayValue(elems) => ArrayConstructor(elems) case ir.ArrayLength(array) => DotSelect(array, ir.Ref(ir.Id("length"))) case ir.ArraySelect(array, index) => BracketSelect(array, index) case ir.RecordValue(elems) => Skip() //TODO Fix it case ir.JSUnaryOp(op, lhs) => UnaryOp(op, lhs) case ir.JSBinaryOp(op, lhs, rhs) => BinaryOp(op, lhs, rhs) case ir.JSObjectConstr(fields) => ObjectConstructor(fields.map{case (key, value) => (generate(key), generate(value))}) case literal: ir.Literal => createJsLiteral(literal) case ir.Ref(ident) => VarRef(ident) case ir.This() => This() case ir.Closure(captureParams, params, body, captureValues) => val innerFunction = Function(params, Return(body)) if (captureParams.isEmpty) { innerFunction } else { Apply( Function(captureParams, Return(innerFunction) ), captureValues) } case ir.ClassDef(name, superClass, interfaces, jsName, defs) => Skip() //TODO Fix it case ir.FieldDef(name, mutable) => Skip() //TODO Fix it case ir.MethodDef(name, args, body) => FunctionDef(Identifier(name.name), args.map(generate(_).asInstanceOf[ParamDef]), body) case ir.Try(block, handler, finalizer) => TryStatement(generate(block), handler.map(generate), generate(finalizer)) case ir.CatchNode(variable, statements) => CatchStatement(variable, generate(statements)) }	JSNode	result
chameleon.getPsi.getProject	Project	project
LanguageParserDefinitions.INSTANCE .forLanguage(ScalaLanguage.INSTANCE) .createLexer(project)	Lexer	lexer
builder.mark()	PsiBuilder.Marker	marker1
builder.mark()	PsiBuilder.Marker	marker2
PsiBuilderFactory.getInstance .createBuilder( project, chameleon, new SspLexer(lexer), ScalaLanguage.INSTANCE, chameleon.getChars )	PsiBuilder	coreBuilder
0	Int	scalaBraces
false	Boolean	isInAttribute
false	Boolean	flushNext
new LayeredParser { register { new RegisteredParserInfo( new ScriptParserWrapper, util.Arrays.asList(classOf[SspElementType]), null, null, TokenSet.EMPTY, null ) setTokenChooser new CustomTokenChooser { var scalaBraces = 0 def isInScala: Boolean = scalaBraces != 0 var isInAttribute = false var flushNext = false def shouldSelectForeignToken(tokenType: IElementType): Boolean = false def shouldRejectOwnToken(tokenType: IElementType): Boolean = !SspTokenTypes.CROSS_SCRIPT_PARTS.contains(tokenType) || (isInAttribute && tokenType == SspTokenTypes.SSP_TAG_END) || !isInScala def processToken(tokenType: IElementType): Unit = { tokenType match { case SspTokenTypes.SSP_ATTRIBUTE_START => isInAttribute = true case SspTokenTypes.SSP_TAG_END => flushNext = true case ScalaTokenTypes.tLBRACE => scalaBraces += 1 case ScalaTokenTypes.tRBRACE if scalaBraces > 0 => scalaBraces -= 1 case _ if flushNext => flushNext = false isInAttribute = false case _ => } } } } register { new RegisteredParserInfo ( new SspHtmlParserWrapper, util.Arrays.asList(classOf[IXmlElementType], classOf[SspElementType]), null, null, TokenSet.create(XmlElementType.HTML_DOCUMENT, XmlElementType.XML_ATTRIBUTE_VALUE), { case XmlElementType.HTML_TAG => SspElementTypes.HTML_BLOCK // case XmlElementType.XML_ATTRIBUTE => SspElementTypes.ATTRIBUTE case a => a } ) setTokenChooser new CustomTokenChooser { var scalaBraces = 0 def isInScala: Boolean = scalaBraces != 0 def processToken(tokenType: IElementType): Unit = { tokenType match { case ScalaTokenTypes.tLBRACE => scalaBraces += 1 case ScalaTokenTypes.tRBRACE if scalaBraces > 0 => scalaBraces -= 1 case _ => } } def shouldSelectForeignToken(tokenType: IElementType): Boolean = false def shouldRejectOwnToken(tokenType: IElementType): Boolean = tokenType != SspTokenTypes.SSP_HTML_PART || !isInScala /*&& tokenType != XmlTokenType.XML_REAL_WHITE_SPACE*/ } } register { new RegisteredContentsParserInfo ( new SspSubParser, util.Arrays.asList(classOf[ScalaTokenType], classOf[SspElementType]), null, null, TokenSet.create(XmlElementType.XML_PROLOG), null ) } setEofExtendedElements(ScCodeBlockElementType.BlockExpression, SspElementTypes.DIR_BODY) setConflictResolver((_: IElementType, astDoneElementType: IElementType, _: IElementType, tokenText: CharSequence) => { tokenText match { case "}" => astDoneElementType != ScCodeBlockElementType.BlockExpression && astDoneElementType != ScalaElementType.FUNCTION_EXPR case ">" | ")" | "]" => false case _ => true } }) setSubRootElements(util.Arrays.asList(SspElementTypes.SSP_TEMPLATE_OBJECT)) }	LayeredParser	layeredParser
scalaTwin	ScalaBlock	myScalaBlock
new HtmlLexer()	HtmlLexer	htmlLexer
0	Int	state
TokenSet.create(SspTokenTypes.SSP_ELSE_DIR, SspTokenTypes.SSP_ELSE_IF_DIR, SspTokenTypes.SSP_END_DIR)	TokenSet	IF_END
true	Boolean	recursiveTemplateBlocksAllowed
myLevel	SspFormattingLevel	level
node.getPsi	PsiElement	psi
selectIndent(child)	Indent	indent
TokenSet.create(SspTokenTypes.SSP_CASE_DIR, SspTokenTypes.SSP_OTHERWISE_DIR, SspTokenTypes.SSP_END_DIR)	TokenSet	CASE_END
TokenSet.create(SspTokenTypes.SSP_END_DIR)	TokenSet	COMMON_END
null	Wrap	wrap
-1	Int	offset
null	Alignment	align
child.getPsi	PsiElement	childPsi
node.getPsi	PsiElement	nodePsi
element.getContainingFile.getViewProvider.getPsi(ScalaLanguage.INSTANCE)	PsiFile	scalaFile
new SspFormattingBlock( null, scalaFile.getNode, null, null, Indent.getNoneIndent, null, settings, this, new ScalaBlock(null, scalaFile.getNode, null, null, Indent.getNoneIndent, null, settings), new SspFormattingLevel )	SspFormattingBlock	block
builder.mark()	PsiBuilder.Marker	marker
builder.mark()	PsiBuilder.Marker	backMarker
builder.mark()	PsiBuilder.Marker	impMarker
0	Int	offset
builder.mark()	PsiBuilder.Marker	blockMarker
builder.mark()	PsiBuilder.Marker	dirMarker
builder.mark()	PsiBuilder.Marker	caseMarker
builder.mark()	PsiBuilder.Marker	matchMarker
builder.mark()	PsiBuilder.Marker	clausesMarker
builder.mark()	PsiBuilder.Marker	m
builder.mark()	PsiBuilder.Marker	ifMarker
false	Boolean	hasNested
getValidChildren	Array[ASTNode]	nodes
createIdentifier(nameInner).getPsi	PsiElement	syntheticId
seq.flatMap { case clazz: ScTypeDefinition => roles(clazz).map(createClassLineMarkerInfo(clazz, _)) case fun: ScFunction if fun.getContext.isInstanceOf[ScTemplateBody] => val maybeAttributes = if (fun.parentOfType(classOf[PsiClass]).flatMap(roles).isDefined) { val attributes = PersistenceHelper.getHelper.getSharedModelBrowser.getPersistenceAttributes(fun) if (attributes.isEmpty) None else Some(attributes) } else None maybeAttributes.map(createAttributeLineMarkerInfo(fun, fun, _)) case _ => None }	IndexedSeq[LineMarkerInfo[_ <: PsiElement]]	infos
named match { case fun: ScNamedElement => fun.nameId case _ => named }	PsiElement	anchor
new ScTemplateDefinitionElementType[ScObject]("SspObject") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScObject], nodeType: this.type, node: ASTNode, debugName: String) = new SspObjectWrapper(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScObject] { def createPsi(stub: ScTemplateDefinitionStub[ScObject], nodeType: this.type, node: ASTNode, debugName: String): SspObjectWrapper }	SSP_TEMPLATE_OBJECT
new SspScalaContent	SspScalaContent	SSP_SCALA_CONTENT
attributes.get(0)	PersistentAttribute	source
JamNavigationGutterIconBuilder.createJamGutterBuilder(ElementPresentationManager.getIcon(source), classOf[CommonModelElement])	JamNavigationGutterIconBuilder[CommonModelElement]	builder
JamNavigationGutterIconBuilder.getElementString(source)	String	tooltipTitle
new SspElementType("SSP OUTER ELEMENT TYPE")	SspTokenTypes.SspElementType	SSP_OUTER_ELEMENT_TYPE
new SspElementType("SSP STUB")	SspTokenTypes.SspElementType	STUB
new THashSet[CommonModelElement]	THashSet[CommonModelElement]	result
editor.getCaretModel.getOffset	Int	offset
editor.getDocument	Document	document
file.getViewProvider.getPsi(SspLanguage.INSTANCE)	PsiFile	myFile
editor.getProject	Project	project
ModelMergerUtil.getImplementation(base, classOf[DomElement])	DomElement	domElement
PersistenceCommonUtil.createSameUnitsModelBrowser(psiClass)	PersistenceModelBrowser	browser
attribute.asInstanceOf[PersistentRelationshipAttribute]	PersistentRelationshipAttribute	relationshipAttribute
obj.asInstanceOf[PersistentEntity]	PersistentEntity	entity
attribute.asInstanceOf[PersistentEmbeddedAttribute]	PersistentEmbeddedAttribute	embeddedAttribute
roles(0)	PersistenceClassRole	role
JamNavigationGutterIconBuilder.createJamGutterBuilder(role.getIcon, classOf[CommonModelElement])	JamNavigationGutterIconBuilder[CommonModelElement]	builder
new ScCodeBlockElementType { override def createNode(text: CharSequence): ASTNode = new SspHtmlBlock(this, text) override def toString: String = "SSP HTML" }	ScCodeBlockElementType { def createNode(text: Any): ASTNode def toString: String }	HTML_BLOCK
if (role.getPersistentObject == null) role.getEntityListener else role.getPersistentObject	CommonModelElement	source
if (role.getPersistentObject != null) role.getPersistentObject else role.getEntityListener	CommonModelElement	element
ModelMergerUtil.getImplementation(element, classOf[DomElement])	DomElement	domElement
new ScCodeBlockElementType { override def createNode(text: CharSequence): ASTNode = new SspAttribute(this, text) override def toString: String = "SSP ATTRIBUTE" }	ScCodeBlockElementType { def createNode(text: Any): ASTNode def toString: String }	ATTRIBUTE
new TemplateDataElementType("SSP TEMPLATE DATA", SspLanguage.INSTANCE, SSP_HTML_PART, SSP_OUTER_ELEMENT_TYPE)	TemplateDataElementType	SSP_TEMPLATE_DATA
new TemplateDataElementType("SSP TEMPLATE EXPR", SspLanguage.INSTANCE, SSP_SCALA_PART, SSP_OUTER_ELEMENT_TYPE)	TemplateDataElementType	SSP_TEMPLATE_EXPR
Map[IElementType, IElementType](SSP_VELOCITY_SCRIPT_START -> SSP_VELOCITY_SCRIPT_END, SSP_DOLLAR_EXPR_START -> SSP_DOLLAR_EXPR_END, SSP_SCRIPT_START -> SSP_TAG_END)	Map[IElementType, IElementType]	EDGES_MAPPING
new ScCodeBlockElementType { override def createNode(text: CharSequence): ASTNode = new SspDirectiveBody(this, text) override def toString: String = "DIR BODY" }	ScCodeBlockElementType { def createNode(text: Any): ASTNode def toString: String }	DIR_BODY
new SspElementType("SSP IMPORT") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspImportDirective(node, toString) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	IMPORT_DIR
new SspElementType("DO DIR") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspDoDirective(node) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	DO_DIR
null	PsiElement	resolved
new SspElementType("FOR DIR") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspForDirective(node) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	FOR_DIR
new ScExtendsBlockImpl(DummyASTNode) { override def getContainingFile: PsiFile = SspObjectWrapper.this.getContainingFile() override def getParent: SspObjectWrapper = SspObjectWrapper.this }	ScExtendsBlockImpl { def getParent: SspObjectWrapper def getContainingFile: PsiFile }	syntheticExtends
file.getViewProvider	FileViewProvider	provider
new SspElementType("CASE DIR") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspCaseDirective(node) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	CASE_DIR
new SspElementType("OTHERWISE DIR") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspOtherwiseDirective(node) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	OTHERWISE_DIR
level.getAdditionalIndents*getNormalIndentSize	Int	spaces
LocalFileSystem.getInstance.findFileByIoFile(new File("../ssp/testdata/resolve/" + fileName))	VirtualFile	vFile
new SspElementType("MATCH DIR") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspMatchDirective(node) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	MATCH_DIR
Map[Char, Either[Map[IElementType, String], (IElementType, String)]]( '{' -> Left(Map(SspTokenTypes.SSP_VELOCITY_SCRIPT_START -> "}#", SspTokenTypes.SSP_DOLLAR_EXPR_START -> "}")), // '@' -> Right((SspTokenTypes.SSP_ATTRIBUTE_START, "%>")), // '=' -> Right((SspTokenTypes.SSP_EXPR_START, "%>")), '%' -> Right((SspTokenTypes.SSP_SCRIPT_START, "%>")) )	Map[Char, Either[Map[IElementType, String], (IElementType, String)]]	BLOCK_MAPPING
new SspElementType("SET DIR") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new SspSetDirective(node) }	SspTokenTypes.SspElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	SET_DIR
level.getAdditionalIndents*getNormalIndentSize	Int	newDepth
i	Int	j
createLightFile("dummy.scala", SspLanguage.INSTANCE, fileText)	PsiFile	testFile
testFile.getViewProvider.findReferenceAt(offset, ScalaLanguage.INSTANCE)	PsiReference	ref
(provider.getVirtualFile match { case light: LightVirtualFile => Option(provider getPsi provider.getBaseLanguage getUserData IndexingDataKeys.VIRTUAL_FILE) getOrElse { Option(light.getOriginalFile) getOrElse light } case other => other }).getParent	VirtualFile	vFile
super.getTextRange()	TextRange	range
if (j == scalaChildren.size() || scalaChildren.get(j).asInstanceOf[ScalaBlock].getNode != n) getNonScalaSubBlock(n, getStubScalaBlock(n)) else { i = j + 1 getNonScalaSubBlock(n, scalaChildren.get(j).asInstanceOf[ScalaBlock]) }	ScalaTwinBlock	block
new TextRange(list.getFirst.getTextRange.getStartOffset, list.getLast.getTextRange.getEndOffset)	TextRange	range
null	ScalaBlock	myScalaBlock
false	Boolean	recursiveTemplateBlocksAllowed
null	Null	level
"Some Default Title"	String	title
""	String	head
"akka.actor.Actor"	String	ACTOR_FQN
"akka.actor.Props"	String	PROPS_FQN
"Props"	String	PROPS_NAME
"Receive"	String	RECEIVE_ALIAS_NAME
"receive"	String	RECEIVE_METHOD_NAME
this.actorTrait	Option[ScTrait]	actorTrait
methodsFinder(actorType)(manager.getProject)	AbstractPropsInspection.ActorMethodsFinder[_]	finder
referenceExpressionUsageType(expression)	UsageType	scalaUsageType
finder.findMethod(parameters)	Option[PsiMethod]	maybeMethod
parameters.map(_.getText).commaSeparated(model = Model.Parentheses)	String	parametersText
parameters.map(_.getText) match { case Seq() if function.isParameterless => "" case strings => strings.commaSeparated(model = Model.Parentheses) }	String	parametersText
argument match { case ClassOfActor(actorType) => actorType.extractClassType case _ => None }	Option[(PsiClass, ScSubstitutor)]	maybeActorClass
maybeActorClass.filter { case (_: ScTrait | _: ScObject, _) => false case _ => true }	Option[(PsiClass, ScSubstitutor)]	maybeClass
scalaUsageType match { case null | RECURSION => None case _ => resolveInvocation(expression).flatMap(functionUsageType) }	Option[UsageType]	maybeAkkaUsageType
actorTrait ++ actorTrait.flatMap(_.baseCompanionModule)	IndexedSeq[ScTypeDefinition]	classes
patternUsageType(pattern)	UsageType	scalaUsageType
scalaUsageType match { case Extractor => resolveDefiningBlock(pattern).flatMap(blockUsageType) case _ => None }	Option[UsageType]	maybeAkkaUsageType
"Send position"	UsageType	SendPosition
"Ask position"	UsageType	AskPosition
"Receiver position"	UsageType	ReceivePosition
Parameter(parameter)	Parameter	firstParameter
createReferenceFromText(propsClass.name, companionObject, companionObject)	ScStableCodeReference	reference
"props"	String	FACTORY_METHOD_NAME
blockExpr.getParent match { case valueOrVariable: ScValueOrVariable => valueOrVariable.typeElement case statement: ScTypedExpression => statement.typeElement case _ => None }	Option[ScTypeElement]	maybeTypeElement
"ActorMutableStateInspection"	String	ID
"Actor mutable state"	String	DESCRIPTION
"scala.collection.mutable"	String	MUTABLE_PACKAGE_NAME
"java.util.Collection"	String	JAVA_COLLECTION_FQN
new PropsConstructorsFinder(actorType)(project).findMethod(parameters)	Option[PsiMethod]	maybeConstructor
Option(function.findDeepestSuperMethod).collect { case function: ScFunction => function }.getOrElse(function)	ScFunction	targetFunction
member.containingClass	ScTemplateDefinition	clazz
clazz.getTypeParameters .map(TypeParameterType(_)) .map(UndefinedType(_))	IndexedSeq[UndefinedType]	parameters
new PropsFactoryMethodsFinder(actorType)(project).findMethod(parameters)	Option[PsiMethod]	maybeFactoryMethod
resultType(member)	ScType	newResultType
"2.4.19"	String	AKKA_VERSION
Option(wrapper.getContainingClass.getContainingClass).collect { case containingClass: ScClass => containingClass case PsiClassWrapper(containingObject: ScObject) if containingObject.containingClass.isInstanceOf[ScClass] => containingObject }.map(ScalaType.designator)	Option[ScType]	maybeType
if (value.typeElement.isDefined) `type`.presentableText else null	String	typeText
Option(constructor.containingClass).collect { case clazz: ScClass => clazz.typeParamString }.getOrElse("")	String	typeParametersText
Seq("akka.pattern.ask")	Seq[String]	convertersNames
for { companion <- finder.actorCompanion method <- maybeMethod if method.isInstanceOf[ScFunction] quickFix <- createQuickFix(companion, method.asInstanceOf[ScFunction], parameters)(methodCall) } yield quickFix	Option[AbstractPropsInspection.AbstractQuickFix]	maybeQuickFix
actorType .extractClass .collect { case scalaClass: ScClass => scalaClass }	Option[ScClass]	actorDefinition
actorDefinition .flatMap(_.baseCompanionModule) .collect { case scalaObject: ScObject => scalaObject }	Option[ScObject]	actorCompanion
Seq( "DurationInt", "DurationLong", "DurationDouble" ).map(shortName => s"scala.concurrent.duration.$shortName")	Seq[String]	convertersNames
new PropsConstructorsFinder(actorType)(project)	PropsParametersInspection.PropsConstructorsFinder	finder
methodSignature(constructor)	Seq[Seq[PsiParameter]]	clauses
finder.actorCompanion.getOrElse(return)	ScObject	companionObject
createReplacement(member, newResultType)	ActorMutableStateInspection.TypeableMember	replacement
Seq(kOVERRIDE, kDEF)	Seq[IElementType]	kindTokens
value.declaredNames.commaSeparated()	String	names
"receive"	String	methodSignature
createText(className, parametersText)	String	text
"mutable\\."	String	MUTABLE_PREFIX_PATTERN
"Receive"	String	typeName
declaredElements(member)	Seq[ScTypedDefinition]	definitions
definition.name + "." + EMPTY_COLLECTION_FACTORY_METHOD_NAME	String	replacement
finder.findMethod(parameters) .flatMap(createFactoryMethodByConstructor(companionObject, _))	Option[ScFunction]	maybeFactoryMethod
"Create a corresponding factory method"	String	FAMILY_NAME
clauses .map(clauseToString(_)) .mkString	String	factoryParametersText
ScalaUsageTypeProvider.Extractor	UsageType	expectedUsageType
definitions.map(_.name)	IndexedSeq[String]	names
s""" |case class Message(text: String = "") | |class Foo extends akka.actor.AbstractActor { | ${kindTokens.mkString(" ")} $methodSignature: $typeName = { | case $clauseText => $text | } |} """.stripMargin	String	fileText
`type`.isAliasType .flatMap(_.lower.toOption) .getOrElse(`type`)	ScType	dealiased
getFixture.getReferenceAtCaretPositionWithAssertion()	PsiReference	reference
"clear"	String	CLEAR_METHOD_NAME
reference.getElement	PsiElement	element
ScalaPsiElementFactory.createExpressionWithContextFromText(text, call.getContext, call)	ScExpression	replacement
AkkaUsageTypeProvider.AskPosition	UsageType	expectedUsageType
clazz.findMethodsByName(ON_MESSAGE_METHOD_NAME, true) match { case Array() => Some(member).zip(findReceiveBody(clazz)).collectFirst(createQuickFix) case _ => None }	Option[ActorMutableStateQuickFix[M]]	maybeQuickFix
member.findFirstChildByType(tokenType)	PsiElement	token
typedDefinitionToString(FACTORY_METHOD_NAME + typeParametersText + factoryParametersText, PROPS_NAME)	String	signature
ScalaUsageTypeProvider.MethodApply	UsageType	expectedUsageType
"empty"	String	EMPTY_COLLECTION_FACTORY_METHOD_NAME
clauses .filterNot(isImplicitClause) .map(clauseToString(_, withTypes = false)) .mkString	String	constructorArgumentsText
AkkaUsageTypeProvider.SendPosition	UsageType	expectedUsageType
AkkaUsageTypeProvider.ReceivePosition	UsageType	expectedUsageType
s"$PROPS_NAME(new ${`object`.name}$constructorArgumentsText)"	String	body
"Actor.Receive"	String	typeName
Seq(kDEF)	Seq[IElementType]	kindTokens
s""" |{ | case $clauseText => |}: Receive """.stripMargin	String	bindingText
s"method(foo: Int)"	String	methodSignature
Seq(kVAL)	Seq[IElementType]	kindTokens
"value"	String	methodSignature
"method"	String	methodSignature
Seq(kVAR)	Seq[IElementType]	kindTokens
"variable"	String	methodSignature
s""" |def innerReceive: Receive = { | val foo = new Object | | return { | case $clauseText => | } | | null |} """.stripMargin	String	functionText
new GeneratePropsFactoryAction.Handler	LanguageCodeInsightActionHandler	handler
matchedParameters.reverse.sortBy { case (_, parameter) => parameter.index }.map { case (expression, _) => expression }	IndexedSeq[ScExpression]	arguments
classOf[PropsParametersInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
AkkaBundle.message("props.constructor.not.found")	String	description
classOf[SimplifyFactoryMethodInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
getEditor.getSelectionModel	SelectionModel	selectionModel
AkkaBundle.message("props.factory.method.simplifiable")	String	description
classOf[PropsFactoryMethodExistenceInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
AkkaBundle.message("props.factory.method.exists")	String	description
reference.bind().collect { case result@ScalaResolveResult(function: ScFunction, _) => (function, result.getActualElement) }.flatMap { case (function, _) if function.name.startsWith(EMPTY_COLLECTION_FACTORY_METHOD_NAME) => resolveClass(baseExpression) case (function, clazz: PsiClass) if function.isApplyMethod => Some(clazz) case _ => None }	Option[PsiClass]	maybeClazz
"java.util.Collections"	String	JAVA_COLLECTIONS_FQN
"unmodifiable"	String	METHOD_PREFIX
classOf[ActorMutableStateInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
DESCRIPTION	String	description
definitions.flatMap(mutationsInfo)	IndexedSeq[ActorMutableStateQuickFix.AssignmentInfo]	infos
info.createReplacement(names)	ScExpression	replacement
companionObject.projectContext	ProjectContext	ctx
createOnMessageMethod(names, newResultType, receiveBody)	ScFunction	onMessageMethod
createReceiveBody(names)	ScExpression	newReceiveBody
"onMessage"	String	ON_MESSAGE_METHOD_NAME
s"Create '$ON_MESSAGE_METHOD_NAME' method"	String	NAME
resultType.presentableText	String	typeText
companionObject.allFunctionsByName(FACTORY_METHOD_NAME) .map(_.parametersTypes).toSeq	Seq[Seq[ScType]]	factories
JavaPsiFacade.getInstance(element.getProject).findPackage("")	PsiPackage	defaultPackage
root.getSubPackages	Array[PsiPackage]	children
constructor.parametersTypes	Seq[ScType]	constructorParametersTypes
parametersNames.map(name => s"$name: $typeText").commaSeparated(model = Model.Parentheses)	String	parameters
element.asInstanceOf[XmlAttributeValue]	XmlAttributeValue	value
target.refName	String	refName
ElementManipulators.getValueTextRange(value).getStartOffset	Int	shift
scalaMethod.effectiveParameterClauses	Seq[ScParameterClause]	clauses
membersNames.map { case `refName` => replacement case name => name }.commaSeparated(model = Model.Parentheses)	String	argumentsText
if (withTypes && isImplicitClause(parameters)) s"$kIMPLICIT " else ""	String	isImplicit
expression.getText	String	replacement
target.refName	String	baseText
{ val baseText = target.refName val argText = argument.getText operation.getText.dropRight(1) match { case operator if operator.endsWith(":") => s"$argText $operator $baseText" case operator => s"$baseText $operator $argText" } }	String	replacement
e.getPresentation	Presentation	presentation
CommonDataKeys.PSI_FILE getData e.getDataContext	PsiFile	file
mutable.HashMap.empty[String, String]	mutable.HashMap[String, String]	cache
mutable.HashSet[File]()	mutable.HashSet[Any]	pluginsCache
Option(Play2SbtStructureSettings.getInstance(project))	Option[Play2SbtStructureSettings]	sst
MyScalaLanguage	ProjectLanguageImportsUtil.MyProjectLanguage	myLanguage
scala.collection.mutable.HashSet.empty[ScImportStmt]	mutable.HashSet[ScImportStmt]	myTemplateImports
firstNode	ASTNode	currentNode
currentNode	ASTNode	prev
ListBuffer.empty[T]	ListBuffer[T]	a
collection.mutable.HashMap[String, Play2ProjectInfo]()	mutable.HashMap[String, Play2SbtStructureSettings.this.Play2ProjectInfo]	info
StringUtil.equalsIgnoreCase(file.getName, "project")	Boolean	isProject
name + ".png"	String	fileName
v.lastIndexOf('-')	Int	i
entry.classRange.shiftRight(shift)	TextRange	classRange
entry.memberRange.shiftRight(shift)	TextRange	memberRange
parameters.getOffset	Int	i
original.getResolveScope	GlobalSearchScope	scope
member match { case named: ScNamedElement => named.name case _ => member.getName }	String	memberName
new Play2RoutePsiClassesFinder	Play2RoutePsiClassesFinder	myFinder
new Play2ProjectInfo()	Play2SbtStructureSettings.this.Play2ProjectInfo	a
(javaImplicitImports ++ ProjectLanguageImportsUtil.TEMPLATE_IMPORTS_NEW) flatMap createImportStmt	IndexedSeq[ScImportStmt]	javaImportStatements
method.getContainingClass getCopyableUserData Play2GoToControllerHandler.ORIGINAL_CONTROLLER_KEY	PsiClass	controller
method.getContainingClass.getContainingClass	PsiClass	routes
LightClassCreationUtil getName original	String	originalName
field.getContainingClass	PsiClass	routes
sc.getContainingFile	PsiFile	file
scope.getProject	Project	project
LightClassCreationUtil.getAllClassesByOriginalName(routes, originalName)	Array[PsiClass]	mirrors
new SimpleModificationTracker()	SimpleModificationTracker	modTracker
scalaFile.getViewProvider()	FileViewProvider	provider
provider getPsi provider.getBaseLanguage	PsiFile	psi
(scalaImplicitImports ++ ProjectLanguageImportsUtil.TEMPLATE_IMPORTS_NEW) flatMap createImportStmt	IndexedSeq[ScImportStmt]	scalaImportStatements
ModuleRootManager.getInstance(module).getSourceRoots(false)	Array[VirtualFile]	srcRoots
virtualPsi getCopyableUserData Play2GoToControllerHandler.ORIGINAL_CONTROLLER_KEY	PsiClass	original
mutable.ArrayBuilder.make[PsiClass]()	mutable.ArrayBuilder[PsiClass]	result
sourceElement.getNode	ASTNode	node
findClassInner(qualifiedName, scope, false)	Array[PsiClass]	result
getForPsi(field)	PsiElement	e
v.substring(i) match { case mExtractor(x) => MilestoneVersion(Integer.parseInt(x)) case rcExtractor(x) => RcVersion(Integer.parseInt(x)) case other => UnknownVersion(other) }	Play2Util.Play2VersionType with Product with Serializable	tpe
PsiSearchHelper getInstance project	PsiSearchHelper	helper
getForPsi(clazz)	PsiElement	e
new TextOccurenceProcessor { /** * @return true if continue processing */ override def execute(element: PsiElement, offsetInElement: Int): Boolean = element match { case ref: ScReference => consumer.process(ref) case _ => true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
prefix + "routes"	String	fqn
Play2RoutesClassesCache.getInstance(project)	Play2RoutesClassesCache	cache
queryParameters.getElementToSearch	PsiElement	element
method.getProject	Project	project
inReadAction(Play2Util.isInstalled(queryParameters.getProject))	Boolean	isPlayInstalled
method.getContainingClass	PsiClass	cont
inReadAction(queryParameters.getElementToSearch)	PsiElement	element
Option { clazz getCopyableUserData Play2GoToControllerHandler.ROUTES_FILE_KEY } map (_ filter (psi => psi != null && psi.isValid)) getOrElse { val e = getForPsi(clazz) if (e == null) null else Array(e) }	Array[PsiElement]	resl
new Key[PsiClass]("Play2OriginalControllerKey")	Key[PsiClass]	ORIGINAL_CONTROLLER_KEY
new Key[Array[PsiElement]]("Play2RoutesFilesArray")	Key[Array[PsiElement]]	ROUTES_FILE_KEY
Play2RoutesClassesCache getInstance project	Play2RoutesClassesCache	lightClassesCache
mutable.ArrayBuilder.make[PsiElement]()	mutable.ArrayBuilder[PsiElement]	allRoutes
TokenSet.create(ScalaTokenTypes.tIDENTIFIER, JavaTokenType.IDENTIFIER)	TokenSet	ids
queryParameters match { case myParameters: MySearchParameters => myParameters.getProcessedElements case _ => Set.empty[PsiElement] }	Set[PsiElement]	alreadyProcessedElements
additionalElements(element)	Set[_ <: PsiElement]	myNewElements
srcRoots.find { root => root.getName == "conf" && root.getChildren.exists(_.getName.endsWith(".conf")) }	Option[VirtualFile]	vDir
alreadyProcessedElements ++ myNewElements	Set[PsiElement]	myNewProcessed
new Key[String]("Play2ReferenceSearchProceedingKey")	Key[String]	proceeding
Map.empty[PsiClass, Signatures]	Map[PsiClass, Play2RoutesClassesCache.this.Signatures]	controllers
myTemplateImports.map(_.getText.stripPrefix("import ")).toArray	Array[Any]	imps
routesClass match { case obj: ScObject => obj.fakeCompanionClassOrCompanionClass.getInnerClasses case other => other.getInnerClasses }	Array[PsiClass]	innerClasses
qualifiedName.split('.').toList.tail.tail	List[String]	withoutPrefix
mutable.ArrayBuilder.make[PsiElement]()	mutable.ArrayBuilder[PsiElement]	result
withoutPrefix.mkString(".")	String	qualNameNoPrefix
result.result()	Array[PsiElement]	array
Play2ProjectSettings.getInstance(project)	Play2ProjectSettings	saved
Set("play.api.templates.PlayMagic._", "play.twirl.api._")	Set[Nothing]	TEMPLATE_IMPORTS_NEW
Set ( "views.html._", "views.xml._", "views.txt._", "models._", "controllers._", "java.lang._", "java.util._", "scala.collection.JavaConversions._", "scala.collection.JavaConverters._", "play.api.i18n._", "play.templates._", "play.core.j.PlayMagicForJava._", "play.mvc._", "play.data._", "play.api.data.Field", "play.mvc.Http.Context.Implicit._" )	Set[Nothing]	javaImplicitImports
Set ( "views.html._", "views.xml._", "views.txt._", "models._", "controllers._", "play.api.i18n._", "play.api.mvc._", "play.api.data._", "play.templates._" )	Set[Nothing]	scalaImplicitImports
(scalaImplicitImports ++ javaImplicitImports) map (_ stripSuffix "._")	Set[String]	allImportNames
PACKAGE_FQN_KEY.elements(packageFqn.hashCode, scope, classOf[ScPackaging])(psiPackage.getProject) .iterator	Iterator[ScPackaging]	scalaPackages
scalaPackages.next()	ScPackaging	packaging
ScalaPsiManager.instance(project).TopLevelModificationTracker	SimpleModificationTracker	modificationTracker
lightClassesCache getRoutesFiles module	Array[PsiElement]	routes
queryParameters.getElementToSearch	PsiElement	e
new Key[Integer]("Play2SearchingForClasses")	Key[Any]	SEARCHING_FOR_CLASSES
2	Int	MAGIC_RECURSION_COUNT
mutable.ArrayBuilder.make[PsiElement]()	mutable.ArrayBuilder[PsiElement]	calcRoutes
JavaPsiFacade.getInstance(project).findPackage("views." + qualifiedNameNoPrefix)	PsiPackage	original
localScope.getScope	Array[PsiElement]	psiScope
extensions.inReadAction { scope match { case globalScope: GlobalSearchScope => if (psiClass == null || psiClass.getQualifiedName == null || !psiClass.getQualifiedName.startsWith("controllers")) return val lightClassesCache = Play2RoutesClassesCache getInstance project val allRoutes = mutable.ArrayBuilder.make[PsiElement]() ModuleManager.getInstance(project).getModules foreach { case module if globalScope.isSearchInModuleContent(module) => var routes = lightClassesCache getRoutesFiles module if (routes.length == 0) { val calcRoutes = mutable.ArrayBuilder.make[PsiElement]() lightClassesCache.getConfigDirFiles(module).foreach { case route: Play2HtmlRoutingPsiFile => calcRoutes += route case _ => } routes = calcRoutes.result() } allRoutes ++= routes case _ => } /* Re-computation of light classes can happen during the search. However the question what should we do if it happen during search in IDEA core is open. */ new LocalSearchScope(allRoutes.result().filter(_.isValid)) case localScope: LocalSearchScope => val psiScope = localScope.getScope if (psiScope.length != 1) return psiScope(0) match { case _: Play2HtmlRoutingPsiFile => localScope case _ => return } case _ => return } }	LocalSearchScope	newScope
call.argumentExpressions	Seq[ScExpression]	args
localScope.getScope	Array[PsiElement]	elements
new SearchParameters(element, new LocalSearchScope(b), queryParameters.isIgnoreAccessScope, queryParameters.getOptimizer)	ReferencesSearch.SearchParameters	params
mutable.WeakHashMap[PsiPackage, Play2TemplatePackage]()	mutable.WeakHashMap[PsiPackage, Play2TemplatePackageFinder.Play2TemplatePackage]	subpackages
new Play2TemplatePackage(fqn :+ originalSub.getName, originalSub)	Play2TemplatePackageFinder.Play2TemplatePackage	t
mutable.ArrayBuilder.make[PsiClass]	mutable.ArrayBuilder[PsiClass]	res
new Processor[PsiReference] { def process(t: PsiReference): Boolean = consumer process t }	Processor[PsiReference] { def process(t: PsiReference): Boolean }	processor
Option(methodContainer).toSeq .flatMap(_.getChildren.toSeq)	IndexedSeq[PsiElement]	children
prevMethod.zip(foundMethod) forall { case ((_, tpe1), (_, tpe2)) => tpe1 == tpe2 }	Boolean	isOk
ref.refName	String	methodName
children.headOption .flatMap(getBaseReturnType) .isDefined	Boolean	isDefined
if (isDefined) { children.collect { case method: PsiMethod => method.getName // { e => isActionMethod(e, isJava, actionTpe) } //todo bug in type inference } } else Seq.empty	Seq[Nothing]	actions
JavaDirectoryService.getInstance()	JavaDirectoryService	dirService
ref.qualifier flatMap { case ref: ScReferenceExpression => ref.multiResolveScala(false).headOption.map(_.getElement) case _ => None }	Option[PsiNamedElement]	resolvedQualifier
play2File.getStub	StubElement[_ <: PsiElement]	stub
parentCall.toSeq.flatMap(play2CallParams)	IndexedSeq[(String, String)]	params
getFilesToRecompute(module)	Array[PsiElement]	files
clazz match { case scObject: ScObject => scObject.fakeCompanionClassOrCompanionClass case other => other }	PsiClass	actualClass
forScala.getOrElse { controllers.keySet.exists { case sc: ScTemplateDefinition => !sc.containingScalaFile.exists(_.isCompiled) case _ => false } }	Boolean	isForScala
if (isForScala) new MyScalaBuilder(context) else new MyJavaBuilder(context)	LightClassCreationUtil.MyTextBuilder	builder
createMirrorClassFor(controller, methodsMap, returnTpe, builder)	PsiClass	mirrorClass
new Play2DummyPsiHelper(this)	Play2DummyPsiHelper	myPsiHelper
collectControllers(files) groupBy { case (clazz, _) => Option(clazz.getContainingFile) .flatMap(_.getContainingDirectory.toOption) .map(dirService.getPackage) .orNull }	Map[PsiPackage, Map[PsiClass, Play2RoutesClassesCache.this.Signatures]]	groupedByPackage
{ getConfigDirFiles(module).filter(_.isInstanceOf[Play2HtmlRoutingPsiFile]) }	Array[PsiElement]	navigationFiles
new DummyParameters(this)	DummyParameters	fakeParams
groupedByPackage.toSet	Set[(PsiPackage, Map[PsiClass, Play2RoutesClassesCache.this.Signatures])]	set
builder.createFieldWithContext(mirrorName.stripPrefix(REVERSE_PREFIX), mirrorName, clazz)	PsiMember	mirrorControllerInstance
createRoutesAssetsClass(context, returnTpe, builder)	PsiClass	assetsClass
builder.createFieldWithContext("Assets", "ReverseAssets", clazz)	PsiMember	assetsInstance
dirService getPackage dir	PsiPackage	pack
createWrapperClass(builder.create())	PsiClass	routesLightClass
createWrapperClass(builder.setClassName(JS_INNER_CLASS_NAME, isTopLevel = false).create())	PsiClass	javascriptClass
createWrapperClass(builder.setClassName(REF_INNER_CLASS_NAME, isTopLevel = false).create())	PsiClass	refClass
context.getProject	Project	project
createIdentifier(parent.nameInner).getPsi	PsiElement	syntheticId
new mutable.StringBuilder()	mutable.StringBuilder	builder
new ScExtendsBlockImpl(DummyASTNode) { override def getContainingFile: PsiFile = parent.getContainingFile override def getParent: ScTypeDefinitionImpl[_] = parent }	ScExtendsBlockImpl { def getParent: ScTypeDefinitionImpl[_] def getContainingFile: PsiFile }	syntheticExtends
new DummyModifierList	DummyModifierList	myModifiersList
_	String	renamed
syntheticMethodsText	Seq[String]	methods
new ScAnnotationsImpl(DummyASTNode) { override def getAnnotations: Array[ScAnnotation] = Array.empty }	ScAnnotationsImpl { def getAnnotations: Array[ScAnnotation] }	fakeAnnotations
new DummyConstructor(this)	DummyConstructor	myConstructor
super.getTextRange	TextRange	range
params map { case (pname, tpe) => if (tpe endsWith "?") s"$pname: ${tpe stripSuffix "?"} = null" else s"$pname: $tpe" } mkString("(", ",", ")")	String	signatureString
false	Boolean	isAmbiguous
super.innerType	result.TypeResult	result
LightClassCreationUtil.createRoutesForControllers(context, navigationFiles, map, forScala)	PsiClass	routesClazz
cachedLightClasses(module)	Set[PsiClass]	classes
null	Play2RoutesClassesCache	myModificationTracker
Array[PsiClass]()	Array[PsiClass]	classesStub
findType("java.lang.String")	Option[ScType]	maybeStringType
findType("scala.Option")	Option[ScType]	maybeOptionType
Try(createMethodWithContext(methodText, this, this)).toOption	Option[ScFunction]	fun
ScalaNamesUtil.escapeKeyword(getText)	String	paramName
super[Play2HtmlTypeOwner].innerType	result.TypeResult	innerType
getChildren	Array[PsiElement]	children
ScParameterizedType(optionType, Seq(stringType))	ValueType	resultType
findFirstChildByType(Play2ASTTokens.PLAY_2_FUN_DEF) match { case fun: ScFunction if fun.nameId.getText == "@" => Option(fun.paramClauses) case _ => None }	Option[ScParameters]	templateParameters
ProjectLanguageImportsUtil.getInstance(getProject).getHtmlTypeFqn	String	myTypeFqn
getHtmlType	PsiClass	clazz
assign findLastChildByType TokenSet.create(ScalaElementType.SIMPLE_TYPE, ScalaElementType.TYPE_GENERIC_CALL)	PsiElement	psi
getFirstChild	PsiElement	placeToInsert
element.getFirstChild.getNode	ASTNode	firstNode
getNode.findChildByType(ScalaTokenTypes.tIDENTIFIER) match { case null => getNode.findChildByType(ScalaTokenTypes.kTHIS) case notNull => notNull }	ASTNode	n
Play2ObjectWrapper.getPlay2HtmlReturnType(getProject)	String	returnType
getStub	ScFunctionStub[ScFunctionDefinition]	funStub
LanguageTokenSeparatorGenerators.INSTANCE.forLanguage(ScalaLanguage.INSTANCE). generateWhitespaceBetweenTokens(firstNode, firstNode.getTreeNext)	ASTNode	ws
s"def apply$parametersText : $returnType = ???"	String	applyMethod
super.processDeclarations(processor, state, lastParent, place)	Boolean	isScalaProcessed
s"def render$effectiveParamsText : $returnType = ???"	String	renderMethod
new util.LayeredParser { register { new RegisteredParserInfo(new ExperimentalPlay2HtmlParserWrapper, ju.Arrays.asList(classOf[IXmlElementType]), null, null, TokenSet.create(XmlElementType.HTML_DOCUMENT, XmlElementType.XML_ATTRIBUTE_VALUE), { case XmlElementType.HTML_TAG => Play2ASTTokens.PLAY_2_HTML_TAG case XmlElementType.XML_TEXT => Play2ASTTokens.PLAY_2_HTML case XmlElementType.XML_ATTRIBUTE => XML_ATTRIBUTE case XmlElementType.XML_ENTITY_REF => Play2ASTTokens.PLAY_2_HTML case a => a }).setTokenChooser(new Play2XmlTokenChooser) } register { new RegisteredContentsParserInfo(new ExperimentalScalaParserWrapper(this), ju.Arrays.asList(classOf[ScalaTokenType], classOf[Play2TemplateElementTypes.Play2ElementType]), null, chameleon, TokenSet.create(XmlElementType.XML_PROLOG), { case FUNCTION_DEFINITION => Play2ASTTokens.PLAY_2_FUN_DEF case BlockExpression => Play2ASTTokens.PLAY_2_MIXED_BLOCK case XML_EXPR => Play2ASTTokens.PLAY_2_HTML case XML_ELEMENT => Play2ASTTokens.PLAY_2_HTML_TAG case a => a }).setTokenChooser(new Play2ScalaTokenChooser) } setEofExtendedElements(Play2ASTTokens.PLAY_2_MIXED_BLOCK, Play2ASTTokens.PLAY_2_FUN_DEF, Play2ASTTokens.PLAY_2_SYNTHETIC_OBJECT, Play2ASTTokens.PLAY_2_SYNTHETIC_CLASS) setConflictResolver((_: IElementType, astDoneElementType: IElementType, _: IElementType, tokenText: CharSequence) => { tokenText match { case "}" => astDoneElementType != BlockExpression && astDoneElementType != FUNCTION_EXPR case ">" | ")" | "]" => false case _ => true } }) setSubRootElements(ju.Arrays.asList(Play2ASTTokens.PLAY_2_SYNTHETIC_OBJECT)) }	LayeredParser	layeredParser
psi.getProject	Project	project
new MyHtmlLexer	Play2ScalaLexerWrapper.this.MyHtmlLexer	xmlLexer
_HtmlLexer.ATTRIBUTE_VALUE_DQ	Int	XML_START_ATTR
findFirstValidChild() match { case Some(e: ScObject) => Seq(e) case _ => Seq.empty[ScTypeDefinition] }	Seq[ScTypeDefinition]	typeDefinitions
_HtmlLexer.ATTRIBUTE_VALUE_SQ	Int	XML_START_ATTR_SQ
_	IElementType	myTokenType
true	Boolean	needAddMethodId
-1	Int	impCounter
0	Int	xmlState
0	Int	tokenStart
0	Int	tokenEnd
0	Int	braceCounter
paramName + " : " + (getContext match { case typed: MyScTypedStatement => typed.typeElement map { case el => el.calcType.canonicalText } getOrElse "String" case assign: MyScAssignment => val psi = assign findLastChildByType TokenSet.create(ScalaElementType.SIMPLE_TYPE, ScalaElementType.TYPE_GENERIC_CALL) if (psi != null) psi.getText else "String" case _ => "String" })	String	txt
myDelegate.getTokenEnd	Int	lineStart
LanguageParserDefinitions.INSTANCE .forLanguage(Play2TemplateLanguage.INSTANCE) .createLexer(project)	Lexer	lexer
indexOf(sequence, '\n', lineStart)	Int	lineEnd
PsiBuilderFactory.getInstance.createBuilder( project, chameleon, new Play2ScalaLexerWrapper(lexer), getLanguage, chameleon.getChars )	PsiBuilder	coreBuilder
if (chameleon.getUserData(BlockSupport.TREE_TO_BE_REPARSED) == null) null else this	Play2ScalaContent	myRootElement
DependencyAwareETSubstitutor.getAny	DependencyAwareETSubstitutor	substitutor
{ val paramName = ScalaNamesUtil.escapeKeyword(getText) val txt = paramName + " : " + (getContext match { case typed: MyScTypedStatement => typed.typeElement map { case el => el.calcType.canonicalText } getOrElse "String" case assign: MyScAssignment => val psi = assign findLastChildByType TokenSet.create(ScalaElementType.SIMPLE_TYPE, ScalaElementType.TYPE_GENERIC_CALL) if (psi != null) psi.getText else "String" case _ => "String" }) Try(createPatternFromText(txt)) getOrElse { createPatternFromText(paramName + " : String") } match { case named: PsiNamedElement => named case _ => null } }	ScPattern with PsiNamedElement	myFakeParameterSymbol
None	Option[Int]	midState
0	Int	newFlags
getState	Int	state
0x40	Int	SEEN_STYLE
0x80	Int	SEEN_TAG
0x100	Int	SEEN_SCRIPT
0x200	Int	SEEN_ATTRIBUTE
0x400	Int	SEEN_CONTENT_TYPE
TokenSet.create(PLAY_2_ROUTING_DYNAMIC_PATH_PART, rPATH_REGEX_NAME)	TokenSet	tokenSet
TokenSet.create(tLSQBRACKET, tLBRACE, tLPARENTHESIS)	TokenSet	OPEN_BRACES
scalaResolve	Array[ScalaResolveResult]	scalaResult
TokenSet.create(tRSQBRACKET, tRBRACE, tRPARENTHESIS)	TokenSet	CLOSE_BRACES
this.findVirtualFile .flatMap(virtualFile => Option(virtualFile.getParent))	Option[VirtualFile]	maybeDirectory
List(SEEN_ATTRIBUTE, SEEN_CONTENT_TYPE, SEEN_SCRIPT, SEEN_STYLE, SEEN_TAG)	List[Int]	allFlags
processor match { case methodProcessor: MethodsProcessor => methodProcessor.getLanguageLevel case _ => PsiUtil.getLanguageLevel(getProject) }	LanguageLevel	languageLevel
new ScFunctionElementType[ScFunctionDefinition]("function definition", Play2Language) { override def createElement(node: ASTNode) = new Play2ScFunctionDefinition(node) override def createPsi(stub: ScFunctionStub[ScFunctionDefinition]) = new ScFunctionDefinitionImpl(stub, this, null) }	ScFunctionElementType[ScFunctionDefinition] { def createPsi(stub: ScFunctionStub[ScFunctionDefinition]): ScFunctionDefinitionImpl def createElement(node: ASTNode): Play2ScFunctionDefinition }	PLAY_2_FUN_DEF
ScalaPsiManager.instance(project)	ScalaPsiManager	psiManager
GlobalSearchScope.allScope(project)	GlobalSearchScope	scope
new Play2PsiBuilderImpl(delegate)	ScalaPsiBuilder	builder
null	PsiBuilder.Marker	methodMarker
true	Boolean	parsingPrologue
false	Boolean	hasDiDeclarations
builder.mark()	PsiBuilder.Marker	diDeclarationsMarker
new Play2ElementType("Play 2 @defining block") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new Play2DefiningBlock(node) }	Play2TemplateElementTypes.Play2ElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	PLAY_2_DEFINING_BLOCK
builder.mark()	PsiBuilder.Marker	blockExprMarker
false	Boolean	afterExprStart
0	Int	scalaBracesCount
new Play2ElementType("Play 2 @defining value") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new Play2DefiningValue(node) }	Play2TemplateElementTypes.Play2ElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	PLAY_2_DEFINING_VALUE
Option(call) map (cl => cl.args.exprs map (Expression(_))) getOrElse Seq.empty	Seq[Compatibility.Expression]	args
ScalaType.designator(clazz)	ScType	tpe
new Play2ElementType("Play 2 Html empty Tag") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new Play2HtmlEmptyTag(node) }	Play2TemplateElementTypes.Play2ElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	PLAY_2_HTML_EMPTY_TAG
new MethodResolveProcessor(this, refName, List(args), Seq.empty, Seq.empty)	MethodResolveProcessor	processor
useNonStaticMembers	Boolean	nonStatic
new ScCodeBlockElementType { override def createNode(text: CharSequence): ASTNode = new Play2ScBlockExpr(this, text) }	ScCodeBlockElementType { def createNode(text: Any): ASTNode }	PLAY_2_MIXED_BLOCK
super.getVariants	Array[Any]	ss
result.caseInsensitive() withPrefixMatcher new StartPlainPrefixMatcher(result.getPrefixMatcher.getPrefix)	CompletionResultSet	newResult
new LookupElement { def getLookupString: String = "controllers" }	LookupElement { def getLookupString: String }	CONTROLLERS_LOOK_UP_ITEM
new Play2PsiBuilderImpl(builder) { override def mark(): PsiBuilder.Marker = new MarkerWrapper(super.mark()) override protected def isAfterTemplate(tokenType: IElementType): Boolean = super.isAfterTemplate(tokenType) || tokenType == TEMPLATE_TEXT }	Play2PsiBuilderImpl { def isAfterTemplate(tokenType: IElementType): Boolean def mark(): PsiBuilder.Marker }	adapter
adapter.mark()	PsiBuilder.Marker	marker
adapter.getCurrentOffset	Int	oldOffset
Set("GET", "POST", "PUT", "DELETE", "HEAD", "PATCH", "OPTIONS")	Set[String]	htmlMethodsNames
builder.mark()	PsiBuilder.Marker	lineMarker
builder.mark()	PsiBuilder.Marker	methodCallMarker
builder.mark()	PsiBuilder.Marker	uriMarker
builder.getDelegate	PsiBuilder	delegate
delegate.mark()	PsiBuilder.Marker	marker
new ScFunctionElementType[ScFunctionDefinition]("Play2DiTemplateHeader", Play2Language) { override def createElement(node: ASTNode) = new Play2TemplateDiDeclaration(node) override def createPsi(stub: ScFunctionStub[ScFunctionDefinition]) = new ScFunctionDefinitionImpl(stub, this, null) }	ScFunctionElementType[ScFunctionDefinition] { def createPsi(stub: ScFunctionStub[ScFunctionDefinition]): ScFunctionDefinitionImpl def createElement(node: ASTNode): Play2TemplateDiDeclaration }	PLAY_2_TEMPLATE_DI_HEADER
builder.mark()	PsiBuilder.Marker	argItemMarker
!method.getContainingClass.isInstanceOf[ScTemplateDefinition]	Boolean	isJava
new Play2ElementType("whitespace") with SelfPsiCreator { def createElement(node: ASTNode): PsiElement = new PsiWhiteSpaceImpl(node.getText) }	Play2TemplateElementTypes.Play2ElementType with SelfPsiCreator { def createElement(node: ASTNode): PsiElement }	PLAY_2_TEMPLATE_WHITESPACE
new ScCodeBlockElementType { override def createNode(text: CharSequence): ASTNode = new Play2Html(this, text) override def toString: String = "Play 2 HTML" }	ScCodeBlockElementType { def createNode(text: Any): ASTNode def toString: String }	PLAY_2_HTML
createFromTemplate(psiDirectory, newName, newName + CreatePlayTemplateAction.PLAY2_EXTENSION, templateName + CreatePlayTemplateAction.PLAY2_EXTENSION)	PsiFile	file
new ScCodeBlockElementType { override def createNode(text: CharSequence) = new Play2HtmlSingleTag(this, text) override def toString: String = "Play 2 HTML Tag" }	ScCodeBlockElementType { def createNode(text: Any): Play2HtmlSingleTag def toString: String }	PLAY_2_HTML_TAG
element match { case l: ScLiteral => l case _ => return Array.empty }	ScLiteral	literal
element.getProject	Project	project
HtmlRoutingParser.htmlMethodsNames map { case name => new LookupElement { def getLookupString: String = name } }	IndexedSeq[LookupElement { def getLookupString: String }]	allMethods
TokenSet.create(rWHITE_SPACE, ScalaTokenTypes.tWHITE_SPACE_IN_LINE)	TokenSet	WhiteSpace
before match { case wrapper: MarkerWrapper => wrapper.delegate case _ => before }	PsiBuilder.Marker	actualBefore
TokenSet.create(rCOMMENT)	TokenSet	Comment
parameters.getOffset	Int	offset
TokenSet.create(rPATH_STATIC_IDENTIFIER)	TokenSet	StringLikeElement
PsiDocumentManager getInstance parameters.getOriginalFile.getProject getDocument parameters.getOriginalFile	Document	doc
args.exprs.indexOf(defExpr)	Int	i
Play2RoutesClassesCache.getInstance(project)	Play2RoutesClassesCache	classes
element.getPrevSibling	PsiElement	sibling
method.parameters	Seq[PsiParameter]	params
mutable.ArrayBuilder.make[Object]()	mutable.ArrayBuilder[Any]	builder
new DeleteUselessSourceSettings	DeleteUselessSourceSettings	mySettings
new ScTemplateDefinitionElementType[ScObject]( Play2Language.getDisplayName + "Object", Play2Language ) { override protected def createPsi(stub: ScTemplateDefinitionStub[ScObject], nodeType: this.type, node: ASTNode, debugName: String) = new Play2ObjectWrapper(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScObject] { def createPsi(stub: ScTemplateDefinitionStub[ScObject], nodeType: this.type, node: ASTNode, debugName: String): Play2ObjectWrapper }	PLAY_2_SYNTHETIC_OBJECT
file.findElementAt(editor.getCaretModel.getOffset)	PsiElement	element
new Play2RoutingPathInplaceRefactoring(CommonDataKeys.EDITOR getData dataContext, namedElement, project)	Play2RoutingPathInplaceRefactoring	renamer
location.getCompletionParameters.getOriginalFile	PsiFile	originalFile
CommonDataKeys.EDITOR getData dataContext	Editor	editor
mutable.WeakHashMap.empty[Project, mutable.HashMap[String, ScType]]	mutable.WeakHashMap[Project, mutable.HashMap[String, ScType]]	markerTypes
mySettings.SHOULD_OFFER_DELETE_SOURCES && !ApplicationManager.getApplication.isUnitTestMode && project.isOpen && Play2Util.isInstalled(project)	Boolean	shouldDoSomething
templateDef.qualifiedName	String	qualifiedName
file findElementAt editor.getCaretModel.getOffset	PsiElement	element
misc	PsiElement	psiCurrent
elementToRename.getContainingFile	PsiFile	myFile
elementToRename.getContainingFile	PsiFile	file
urlPart	PsiElement	current
0	Int	count
element.getNode	ASTNode	node
element.getContainingFile	PsiFile	file
file.getNode	FileASTNode	fileNode
Play2ProjectSettings.getInstance(file.getProject)	Play2ProjectSettings	settings
new Play2RoutesFileBlock(null, fileNode)	Play2RoutesFileBlock	root
new ScTemplateDefinitionElementType[ScClass]( Play2Language.getDisplayName + "Class", Play2Language ) { override protected def createPsi(stub: ScTemplateDefinitionStub[ScClass], nodeType: this.type, node: ASTNode, debugName: String) = new Play2ClassWrapper(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScClass] { def createPsi(stub: ScTemplateDefinitionStub[ScClass], nodeType: this.type, node: ASTNode, debugName: String): Play2ClassWrapper }	PLAY_2_SYNTHETIC_CLASS
new Play2RoutingElementType("ROUTING_PATH")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_PATH
methodsAny.map(createTextElement)	IndexedSeq[Play2TemplateMagicCompletionContributor.MyLookupElement]	elements
TokenSet.create(Play2ASTTokens.PLAY_2_ROUTING_PATH, ScalaElementType.METHOD_CALL, Play2ASTTokens.PLAY_2_ROUTING_METHOD_CALL, ScalaElementType.REFERENCE_EXPRESSION, Play2TemplateElementTypes.rHTML_METHOD_NAME, Play2ASTTokens.PLAY_2_ROUTING_REFERENCE)	TokenSet	tokensWithSpacing
file.findElementAt(offset - 2)	PsiElement	element
new Play2RoutingElementType("ROUTING_SCALA_REF")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_SCALA_REF
new Play2RoutingElementType("ROUTING_DYNAMIC_PATH_PART")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_DYNAMIC_PATH_PART
new Play2RoutingElementType("ROUTING_LINE")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_LINE
new XmlInjectedLanguageBlockBuilder(new HtmlPolicy(settings, FormattingDocumentModelImpl createOn htmlFile))	XmlInjectedLanguageBlockBuilder	myBlockBuilder
Play2ProjectSettings.getInstance(node.getPsi.getProject).SPACES_IN_ROUTES	Int	spCount
new Play2RoutingElementType("ROUTING_REGEXP")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_REGEXP
Alignment.createAlignment(true)	Alignment	uriAlign
Seq.empty[Block]	Seq[Block]	emptySeq
new Play2RoutingElementType("ROUTING_STATIC_REGEXP")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_STATIC_NAMED_PART
new Play2RoutingElementType("ROUTING_REFERENCE")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_REFERENCE
new Play2RoutingElementType("ROUTING_METHOD_CALL")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_ROUTING_METHOD_CALL
Alignment.createAlignment(true)	Alignment	callAlign
misc.parents	Iterator[PsiElement]	parents
new Play2RoutingElementType("GENERIC_CALL")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_GENERIC_CALL
parents.next()	PsiElement	n
new Play2RoutingElementType("LITERAL")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_LITERAL
root.getParent	VirtualFile	parent1
root.getChildren	Array[VirtualFile]	children
new Play2RoutingElementType("INFIX_EXPR")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_INFIX_EXPR
new Play2RoutingElementType("SCALA_ASSIGNMENT")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_SCALA_ASSIGNMENT
SingleLanguageProducer.getAll	Array[SingleLanguageProducer]	allSingleProducers
new Play2RoutingElementType("TYPED_STATEMENT")	Play2TemplateElementTypes.Play2RoutingElementType	PLAY_2_TYPED_STATEMENT
NotificationGroup.balloonGroup("play2")	NotificationGroup	NOTIFICATION_GROUP
parameters.getPosition.getParent match { case ref: ScalaPsiElement => ref.firstChild.collect { case expression: ScExpression => expression } case _ => None }	Option[ScExpression]	maybeExpression
producers.map(_.getLanguage).toSet	Set[Language]	acceptedLanguages
forNode.getTextRange	TextRange	range
maybeExpression .flatMap(_.`type`().toOption) .map(_.canonicalText.stripPrefix("_root_."))	Option[Any]	maybeString
forNode.getChildren(null)	Array[ASTNode]	children
uri.getFirstChild	PsiElement	current
module.modifiableModel	ModifiableRootModel	modifiableModel
maybeString.collect { case "java.lang.String" => methodsAfterString case "java.util.Date" => methodsAfterDate }.getOrElse(Seq.empty)	Seq[Nothing]	additionalMethods
{ val children = forNode.getChildren(null) if (children.isEmpty) range.getStartOffset + 1 else children(0).getTextRange.getEndOffset - 1 }	Int	myStartOffsetToFind
creator()	ScType	tpe
element.getContainingFile.getViewProvider.getPsi(Play2HtmlRoutingLanguage.INSTANCE)	PsiFile	st
mutable.HashMap.empty[String, ScType]	mutable.HashMap[String, ScType]	mapa
new Play2TemplateBlock(scalaFile.getNode, Wrap.createWrap(WrapType.NONE, false), null, null, settings, this, null, new HtmlPolicy(settings, FormattingDocumentModelImpl createOn element.getContainingFile), createInjectedProducer(element, settings))	Play2TemplateBlock	block
TokenSet.create( ScElems.XML_EXPR, ScElems.XML_START_TAG, ScElems.XML_ELEMENT, ScElems.XML_END_TAG, ScElems.XML_EMPTY_TAG )	TokenSet	validXmlTokens
TokenSet.create( XmlTokens.XML_START_TAG_START, XmlTokens.XML_END_TAG_START, ScElems.XML_START_TAG, ScElems.XML_END_TAG, XmlElementType.XML_PROLOG, XmlTokens.XML_DOCTYPE_START )	TokenSet	nonIndentXmlTokens
TokenSet.create( ScTokens.kDEF, ScTokens.tIDENTIFIER, Play2TemplateElementTypes.SCALA_PLAY_EXPRESSION_START )	TokenSet	possiblePlayTokens
(methodsAfterDot ++ additionalMethods).map(createTextElement)	IndexedSeq[Play2TemplateMagicCompletionContributor.MyLookupElement]	elements
parameters.getOriginalPosition	PsiElement	originalPosition
injectionPsi.getTextRange	TextRange	injectedRange
new ResolveProcessor(ref.getKinds(incomplete = false, completion = true), ref, ref.refName)	ResolveProcessor	processor
child.getParent	PsiElement	p
a.getParent	PsiElement	psiParent
testNode.getElementType	IElementType	elementType
Set(tWHITE_SPACE_IN_LINE, kDEF, tIDENTIFIER, Play2TemplateElementTypes.SCALA_PLAY_EXPRESSION_START)	Set[IElementType]	templateFakeTokens
new PathsTree("", None, false, "")	RoutingURLClashInspection.PathsTree	rootPath
Spacing.createSpacing(0, 0, 0, false, 0)	Spacing	noSpacing
Spacing.createSpacing(1, 1, 0, true, 0)	Spacing	withSpacing
mutable.ArrayBuilder.make[ProblemDescriptor]()	mutable.ArrayBuilder[ProblemDescriptor]	problems
Spacing.getReadOnlySpacing	Spacing	readOnlySpacing
Spacing.createSafeSpacing(true, 1)	Spacing	safeTemplateSpacing
right.getNode	ASTNode	rightNode
left.getNode	ASTNode	leftNode
rightNode.getElementType	IElementType	rightElementType
leftNode.getElementType	IElementType	leftElementType
if (Play2TemplateFormatterUtil.shouldInsertSpacingForIndent(leftNode, rightNode)) withSpacing else readOnlySpacing	Spacing	leftDependentSpace
block.getNode	ASTNode	blockNode
getParentNode(left)	Option[ASTNode]	leftParentNode
left.getScalaBlock	ScalaBlock	leftScalaBlock
right.getScalaBlock	ScalaBlock	rightScalaBlock
getFromLine(line)	Option[String]	newPath
if (reference == null || reference.get() == null || !reference.get.isValid) Option(setNewLine()) else getFromLine(reference.get())	Option[String]	pathBase
literal.getValue	literal.V	stringValue
Play2TemplateFormatterUtil isScala getNode	Boolean	isUnderScala
new FileReferenceSet(stringValue.toString.stripPrefix("/"), element, 1, null, !SystemInfo.isWindows, false, null) { protected override def isUrlEncoded: Boolean = true protected override def isSoft: Boolean = true }	FileReferenceSet { def isSoft: Boolean def isUrlEncoded: Boolean }	set
position.getContext.getFirstChild match { case ref: ScReferenceExpressionImpl => val processor = new ResolveProcessor(ref.getKinds(incomplete = false, completion = true), ref, ref.refName) ref.doResolve(processor, accessibilityCheck = false).toSeq case _ => Seq.empty }	Seq[ScalaResolveResult]	resolved
getXmlBlock getChildAttributes newChildIndex	ChildAttributes	attrs
holder.getProject	ProjectContext	project
play2template.getVirtualFile	VirtualFile	vFile
ModuleUtilCore.findModuleForFile(vFile, param.getProject)	Module	module
null	Null	commonAlignment
Alignment.createAlignment()	Alignment	commonAlignment
project.stdTypes.Nothing	StdType { def isFinalType: Boolean }	bottomType
acc.result()	Array[ASTNode]	currentNodes
getNode.getFirstChildNode	ASTNode	currentNode
getNode.getLastChildNode	ASTNode	backwardNode
Play2NodeIterator(getChildrenNodes(0), getChildrenNodes.last.getTreeNext)	Play2Util.Play2NodeIterator	iterator
Play2TemplateFormatterUtil needMerge this	Boolean	needMerge
iterator.next()	ASTNode	cur
0	Int	j
mutable.ListBuffer[Block]()	ListBuffer[Block]	result
main(i)	Block	b1
additional(j)	Block	b2
if (i >= main.size) { j += 1 additional(j-1) } else if (j >= additional.size) { i += 1 main(i-1) } else { val b1 = main(i) val b2 = additional(j) if (b1.getTextRange intersectsStrict b2.getTextRange) { i += 1 do { j += 1 } while (j < additional.size && b1.getTextRange.intersectsStrict(additional(j).getTextRange)) main(i-1) } else if (b1.getTextRange.getStartOffset > b2.getTextRange.getStartOffset) { j += 1 additional(j-1) } else { i += 1 main(i-1) } }	Block	block
mutable.ArrayBuilder.make[PsiFile]()	mutable.ArrayBuilder[PsiFile]	allRoutes
resolved.map(_.getElement).flatMap { case syn: ScPackage => play2TemplatePackage(originalPosition.getProject, syn.getQualifiedName) case _ => None }.flatMap(_.getSubPackages)	IndexedSeq[PsiPackage]	packages
Play2RoutesClassesCache.getInstance(element.getProject)	Play2RoutesClassesCache	classes
element.getParent match { case m: PsiMethod => m case _ => return }	PsiMethod	method
RoutingURLClashInspection.tokenizeUrl(path).toArray map { case p => p.result() map (_.getText) mkString "" }	IndexedSeq[String]	urlPathParts
project	ProjectContext	ctx
element.isInstanceOf[ScFunction]	Boolean	isJava
element.getBody.getFirstChild	PsiElement	ret
ret.getTextRange	TextRange	range
Option( paramExpr findLastChildByType TokenSet.create(ScalaElementType.SIMPLE_TYPE, ScalaElementType.TYPE_GENERIC_CALL) ) collect { case typeElement: ScTypeElement => typeElement.calcType } getOrElse { ScalaPsiManager instance paramExpr.getProject getCachedClass ( paramExpr.getResolveScope, "java.lang.String" ) collect { case clazz: PsiClass => ScDesignatorType(clazz) } getOrElse bottomType }	ScType	assignType
play2File.getViewProvider.getPsi(ScalaLanguage.INSTANCE) match { case sc: ScalaFile => sc case _ => highlightAll(Collections.emptyList()) return }	ScalaFile	scalaFile
PsiDocumentManager.getInstance(project).getDocument(element.getContainingFile)	Document	document
UsageTracker.getUnusedImports(scalaFile)	Seq[ImportUsed]	unusedImports
ref.getParent match { case call: ScMethodCall => call.args.exprs case line: PsiElement if line.getNode.getElementType == Play2ASTTokens.PLAY_2_ROUTING_LINE => Seq.empty case fullRef: Play2RoutingReference => ref.getFirstChild match { case packageRef: Play2RoutingReference if packageRef.resolve().isInstanceOf[PsiPackage] => createClass(ref) applyInner(project, descriptor, fullRef) return case _ => return } case _ => return }	Seq[ScExpression]	paramExprs
ref.getFirstChild match { case validRef: ScReferenceExpression if validRef.resolve() != null => validRef case _ => return }	ScReferenceExpression	classRef
(method.getContainingClass match { case obj: ScObject => obj.qualifiedName case clazz => clazz.getQualifiedName }) + "." + method.getName	String	qualifiedName
packages.map(create).map(withBuilder)	IndexedSeq[LookupElementBuilder]	elements
allRoutes.result()	Array[PsiFile]	routes
play2File.getName	String	fileName
PlatformPatterns.psiElement.and(new FilterPattern(new LeftNeighbour(new TextFilter("."))))	PsiElementPattern.Capture[PsiElement]	DOT_PSI_FILTER
PlatformPatterns.psiElement().and(new FilterPattern(new NotFilter(new LeftNeighbour(new TextFilter(".")))))	PsiElementPattern.Capture[PsiElement]	NO_DOT_PSI_FILTER
Seq("defining", "using")	Seq[Nothing]	methodsAny
Seq("?:")	Seq[Nothing]	methodsAfterDot
Seq("format")	Seq[Nothing]	methodsAfterDate
Seq("when")	Seq[Nothing]	methodsAfterString
psiFile.add(Play2PsiElementFactory.createRoutingLine(psiFile, s"GET / $qualifiedName"))	PsiElement	element
element.getFirstChild.getNextSibling.getNextSibling.getTextRange	TextRange	range
method.getContainingClass	PsiClass	clazz
collectAnnotations(unusedImports, new AnnotationHolderImpl(new AnnotationSession(file)))	Seq[Annotation]	annotations
element.getParent.getLanguage	Language	elLanguage
element.getContainingFile	PsiFile	psiFile
paramExprs map { expr => CreateApplicationControllerQuickFix.paramToText(expr) match { case (name, tpe) => s"$name: $tpe" } }	IndexedSeq[String]	parameters
new ParentsIterator(element)	ParentsIterator	it
element.getContainingFile.getViewProvider	FileViewProvider	viewProvider
psiFile.getVirtualFile	VirtualFile	virtualFile
InjectedLanguageUtil getShreds injected	Place	shreds
psiFile.parents	Iterator[PsiElement]	psiParents
TokenSet.create(Play2TemplateElementTypes.SCALA_PLAY_EXPRESSION_START)	TokenSet	MARKED_SET
createMethodFromText(s"def $methodName(${parameters.mkString(",")}) = play.mvc.Results.TODO")	ScFunction	method
expectedParam match { case scalaParam: ScParameter => scalaParam.expectedParamType getOrElse { scalaParam.`type`().getOrElse(bottomType) } case javaParam => javaParam.getType.toScType() }	ScType	methodParamType
classOf[Play2TemplateFileViewProvider]	Class[Play2TemplateFileViewProvider]	VIEW_PROVIDER_CLASS
scalaClass.extendsBlock	ScExtendsBlock	extendsBlock
rootPath.addPath(urlPathParts/*path.getText.split('/')*/, methodName.getText)	ArrayBuffer[RoutingURLClashInspection.PathsTree]	clashes
mutable.ArrayBuffer[PathsTree]()	ArrayBuffer[RoutingURLClashInspection.PathsTree]	children
root startsWith ":"	Boolean	isDynamic
Option(paramExpr findFirstChildByType ScalaElementType.SIMPLE_TYPE) getOrElse paramExpr.leftExpression	PsiElement	problemElement
root startsWith "*"	Boolean	isVarLength
paramExprs map { expr => CreateApplicationControllerQuickFix.paramToText(expr, forJava = true) match { case (name, tpe) => s"$tpe $name" } }	IndexedSeq[String]	parameters
root startsWith "$"	Boolean	isRegExp
ref.multiResolveScala(incomplete = false)	Array[ScalaResolveResult]	multiResolve
!isDynamic && !isVarLength && !isRegExp	Boolean	isPlain
new PathsTree(element, Some(this), isLeaf, method)	RoutingURLClashInspection.PathsTree	newTree
mutable.ArrayBuffer[PathsTree]()	ArrayBuffer[RoutingURLClashInspection.PathsTree]	clashes
funDef.parameters	Seq[PsiParameter]	params
method.args	ScArgumentExprList	args
false	Boolean	isEnabled
expr.`type`().toOption .map(_.presentableText)	Option[String]	maybeTypeText
None	Option[Option[ScType]]	myResultType
Option(classRef.getLastChild) map (_.getText)	Option[Nothing]	name
new Key[String]("PLAY_2_SBT_CREATED_MODULE")	Key[String]	MODULE_TO_PROCESS
argExpr.`type`().toOption.map(_.presentableText)	Option[String]	maybeTypeText
replaceLiteral(argExpr.getParent, maybeTypeText.getOrElse(""), argExpr.getText)	PsiElement	replacement
clazz.name	String	cname
createExpressionFromText("{val a = play.api.mvc.Result(null, null); a}")	ScExpression	expr
new NotNullLazyValue[util.Collection[_ <: GotoRelatedItem]] { def compute(): util.Collection[_ <: GotoRelatedItem] = { collectUsages(wrapper).flatMap { case (clazz, methods) => val cname = clazz.name methods.map(new GotoRelatedItem(_, cname)) }.asJavaCollection } }	NotNullLazyValue[Any] { def compute(): Any }	myLazy
getDescriptionsOuter(getRepoUrl(scalaVersion)) flatMap parseDescription	Option[Seq[String]]	maybeStrings
None	Option[String]	result
Play2ProjectSettings getInstance project	Play2ProjectSettings	settings
funDef.containingClass	ScTemplateDefinition	containing
s"${containing.qualifiedName}.${funDef.name}"	String	methodFqn
ProjectFileIndex.SERVICE.getInstance(project)	ProjectFileIndex	index
ProjectFileIndex.SERVICE getInstance project getModuleForFile element.getContainingFile.getVirtualFile	Module	module
ModulePackageIndex.getInstance(module).getDirectoriesByPackageName(dirName, false)	Array[VirtualFile]	allDirectories
RunManagerEx.getInstanceEx(module.getProject)	RunManagerEx	runManagerEx
(value.getParent match { case methodCall: ScMethodCall => methodCall.getParent case p => p }).asInstanceOf[Play2ScalaPsiStub].findFirstChildByType(Play2ASTTokens.PLAY_2_ROUTING_PATH)	PsiElement	uri
content.indexOf("<body>")	Int	startBody
content.indexOf("</body>")	Int	endBody
PsiManager getInstance project findFile (dir findChild fileName)	PsiFile	file
new RelatedItemLineMarkerInfo[PsiElement](element, element.getTextRange, Play2Icons get MY_ICON, Pass.LINE_MARKERS, new ConstantFunction[PsiElement, String](s"Go To ${file.getName}"), new GutterIconNavigationHandler[PsiElement] { def navigate(e: MouseEvent, elt: PsiElement) { PsiElementListNavigator.openTargets(e, Array[NavigatablePsiElement](file), "GoTo Template", "GoTo Template" , JListCompatibility.getGotoFileCellRenderer(5)) } }, GutterIconRenderer.Alignment.RIGHT, util.Arrays.asList(new GotoRelatedItem(file)))	RelatedItemLineMarkerInfo[PsiElement]	markerInfo
"""logs |project/project |project/target |target |tmp |.history |dist |/.idea |/*.iml |/out |/.idea_modules |/.classpath |/.project |/RUNNING_PID |/.settings""".replace("\r", "").stripMargin	String	gitignore
Play2Util.stringVersionToTuple(play2Version)	Play2Util.Play2TupleVersion	version
List( "conf/application.conf", "conf/logback.xml", "public/images/favicon.png", "public/images/external.png", "public/images/header-pattern.png", "public/javascripts/hello.js", "public/stylesheets/main.css" )	List[Nothing]	conf
List( "controllers/AsyncController", "controllers/CountController", "controllers/HomeController", "filters/ExampleFilter", "services/ApplicationTimer", "services/Counter", "Module" )	List[Nothing]	baseSpecificResources
List( "views/index.scala.html", "views/main.scala.html", "views/welcome.scala.html" )	List[Nothing]	templates
List( "services/AtomicCounter.java", "Filters.java" )	List[Nothing]	javaSpecificResources
pack.getDirectories.filter(isWritable)	Array[PsiDirectory]	dirs
ElementScope(param)	ElementScope	elementScope
genericCall.getChildren	Array[PsiElement]	ch
new RelatedItemLineMarkerInfo[PsiElement](element, element.getTextRange, Play2Icons get MY_ICON, Pass.LINE_MARKERS, new ConstantFunction[PsiElement, String]("Usages in controllers..."), new GutterIconNavigationHandler[PsiElement] { def navigate(e: MouseEvent, elt: PsiElement) { val i = myLazy.getValue.iterator() val l = new util.ArrayList[NavigatablePsiElement]() while (i.hasNext) l.add(i.next().getElement.asInstanceOf[NavigatablePsiElement]) Play2Template2ControllerAnnotator.createMultiLevelPopup ( wrapper, l.toArray(Array.empty[NavigatablePsiElement]), "Usages in the controllers..." ) foreach (_ show new RelativePoint(e)) } }, GutterIconRenderer.Alignment.RIGHT, myLazy)	RelatedItemLineMarkerInfo[PsiElement]	marker
JavaPsiFacade.getInstance(wrapper.getProject).findPackage("controllers")	PsiPackage	controllersPackage
mutable.HashMap[ScTemplateDefinition, Array[PsiMethod]]()	mutable.HashMap[ScTemplateDefinition, Array[PsiMethod]]	classToMethod
refsFound(0)	ScReferenceExpression	value
typedExpr.typeElement.map { case javaTpe if forJava => getJavaTypeText(javaTpe.`type`()) case scalaTpe => scalaTpe.getText }	Option[String]	maybeTxt
sourceRoot.getFile.getChildren	Array[VirtualFile]	children
ch.getChildren	Array[VirtualFile]	sub
if (refsFound.length == 0) "No usages found" else { val value = refsFound(0) s"${getUriText(value)} at ${value.getContainingFile.getName} ${if (refsFound.length > 1) s"(and ${refsFound.length - 1} more usages)" else ""}" }	String	tooltipText
modelsProvider.getLibraryByName(data.getInternalName)	Library	lib
modelsProvider.getModifiableRootModel(module)	ModifiableRootModel	model
LocalFileSystem.getInstance().findFileByIoFile(new File(paths.iterator().next()))	VirtualFile	file
modelsProvider.getModifiableLibraryModel(lib)	Library.ModifiableModel	model
Array[(Play2TupleVersion, BuilderFactory)]( Play2TupleVersion(3, 5) -> {(name, tpe, _, pv) => new OldBuilder(name, tpe, pv)}, Play2TupleVersion(4, 0) -> {(name, tpe, sv, pv) => new PlayPrevReleaseBuilder(name, tpe, sv, pv)}, Play2TupleVersion(5, 1) -> {(name, tpe, sv, pv) => new PlayReleaseBuilder(name, tpe, sv, pv)}, Play2TupleVersion(6, 0, MilestoneVersion(1)) -> { (name, tpe, sv, pv) => new PlayReleaseBuilder25(name, tpe, sv, pv)}, Play2TupleVersion(6, 99) -> {(name, tpe, sv, pv) => new PlayReleaseBuilder26(name, tpe, sv, pv)} )	Array[(Play2Util.Play2TupleVersion, Play2DescriptorBuilders.BuilderFactory)]	versionToBuilder
Set("httpclient-4.0.1.jar", "httpcore-4.0.1.jar")	Set[Nothing]	names
versionToBuilder.last._2	Play2DescriptorBuilders.BuilderFactory	default
mutable.HashSet[String]()	mutable.HashSet[String]	allModuleNames
clazz.getMethods.collect { case ScFunctionWrapper(delegate) => delegate case method => method }.filter { method => method.isPhysical && method.getTextRange != null && !method.getTextRange.isEmpty && contains(wrapper)(method) }	IndexedSeq[PsiMethod]	found
new FindProcessor[PsiReference] { override def accept(t: PsiReference): Boolean = t.resolve() match { case templateDec: ScTemplateDefinition if templateDec == target => true case funDef: ScFunctionDefinition if funDef.name == "apply" && funDef.containingClass == target => true case _ => false } }	CommonProcessors.FindProcessor[PsiReference] { def accept(t: PsiReference): Boolean }	processor
if (otherTargetUrl endsWith "-2.11") replaceEnd(otherTargetUrl, "1", "0") else if (otherTargetUrl endsWith "-2.10") replaceEnd(otherTargetUrl, "0", "1") else return	String	newTargetUrl
VfsUtil.findFileByURL(new URL(newTargetUrl))	VirtualFile	virtualFile
createMarkerAnnotation("action", tooltipText, refsFound, new MyBaseListPopupStep("Route definitions", refsFound.map(_.asInstanceOf[NavigatablePsiElement])) { override def getTextFor(value: NavigatablePsiElement): String = s"${convertText(getUriText(value))} at ${value.getContainingFile.getName}" } )	RelatedItemLineMarkerInfo[_ <: PsiElement]	myMarker
DataManager.getInstance().getDataContext(WindowManager.getInstance().asInstanceOf[WindowManagerEx].getFocusedComponent(project))	DataContext	dataContext
elems groupBy (e => e.asInstanceOf[PsiMethod].getContainingClass)	Map[PsiClass, Array[NavigatablePsiElement]]	method2Class
Play2SbtStructureSettings.getInstance(project)	Play2SbtStructureSettings	mySettings
Play2CompilerSettings getInstance project	Play2CompilerSettings	settings
Play2ProjectSettings getInstance project	Play2ProjectSettings	prSetting
ProjectLanguageImportsUtil.getInstance(project)	ProjectLanguageImportsUtil	importsUtil
DownloadableFileService.getInstance()	DownloadableFileService	service
true	Boolean	haveToDeleteArchiveAfter
null	String	myGroupId
getStatusType(element.getManager)	ScType	statusTpe
new MyWebDialog /*DownloadWebLibraryDialog*/(project, versionDescriptions)	MyWebDialog	myDialog
new BaseListPopupStep[Either[PsiClass, String]](title, (method2Class.keySet.map(c => Left[PsiClass, String](c): Either[PsiClass, String]) + Right("")).toArray: _*) { override def getIconFor(aValue: Either[PsiClass, String]): Icon = aValue match { case Left(_) => Icons.OBJECT case Right(_) => null } override def getTextFor(value: Either[PsiClass, String]): String = value match { case Left(typeDef) => typeDef match { case obj: ScObject => obj.qualifiedName case PsiClassWrapper(definition) => definition.qualifiedName case other => other.getQualifiedName } case Right(_) => "Find all usages..." } override def onChosen(selectedValue: Either[PsiClass, String], finalChoice: Boolean): PopupStep[_] = selectedValue match { case Left(clazz) => new AnnotatorUtil.MyBaseListPopupStep("Methods", method2Class(clazz).sortBy(_.getName)) case Right(_) => doFinalStep(new Runnable { def run() { FindManager.getInstance(template.getProject).findUsages(template, true) } }) } }	BaseListPopupStep[Either[PsiClass, String]] { def getTextFor(value: Either[PsiClass, String]): String def getIconFor(aValue: Either[PsiClass, String]): Any def onChosen(selectedValue: Either[PsiClass, String], finalChoice: Boolean): PopupStep[_] }	listStep
Play2SbtProjectBuilder.Play2ScalaTemplate	Play2SbtProjectBuilder.TemplateType	myGroup
service.createDownloader(description)	FileDownloader	downloader
downloader.download()	Array[VirtualFile]	files
if (module.hasScala) Play2SbtProjectBuilder.Play2ScalaTemplate else Play2SbtProjectBuilder.Play2JavaTemplate	Play2SbtProjectBuilder.TemplateType	lang
new Play2SbtProjectBuilder(lang)	Play2SbtProjectBuilder	myBuilder
fun match { case fun: ScFunctionDefinition => fun.returnType.getOrElse(return) case pt: ScPatternDefinition => pt.`type`().getOrElse(return) }	ScType	gotTpe
18	Int	IN_TEXT_SIGNATURE_LENGTH
Map[String, Icon]( "action" -> Play2Icons.WEB_ICON, "template" -> Play2Icons.TEMPLATE_ICON, "result" -> Play2Icons.WEB_SOME_ICON )	Map[String, Any]	TYPE_TO_ICON
ServiceKt.getStateStore(impl)	IComponentStore	stateStore
new PressConsoleShortcutAction(descriptor)	PressConsoleShortcutAction	action
module.getProject.modifiableModel	ModifiableModuleModel	modifiableModel
myBuilder.getExternalProjectSettings	SbtProjectSettings	settings
Play2ProjectSettings.getInstance(project)	Play2ProjectSettings	settings
true	Boolean	removeDuplicateHack
_	String	prevLine
EditorColorsManager.getInstance.getGlobalScheme	EditorColorsScheme	scheme
new Play2RunSettings(conf)	Play2RunSettings	form
false	Boolean	play2IsNonDefaultInstallDirUsed
true	Boolean	play2NeedOpenInBrowser
false	Boolean	enableSbtGlobalPlugins
false	Boolean	play2isAutoReloadEnabled
9999	Int	play2JpdaPort
Array[ConfigurationFactory](new Play2RunConfigurationFactory(this))	Array[ConfigurationFactory]	MY_CONFIGURATION_FACTORY
Map( "--- (Running the application, auto-reloading is enabled) ---" -> Color.MAGENTA, "--- (RELOAD) ---" -> Color.MAGENTA, "(Server started, use Ctrl+D to stop and go back to the console...)" -> Color.GREEN, "Server started, use Cmd+P to stop" -> Color.GREEN, "Server started, use Alt+D to stop" -> Color.GREEN )	Map[Nothing, Nothing]	PREDEFINED_STRINGS
state.execute(env.getExecutor, this)	ExecutionResult	executionResult
new RunContentBuilder(executionResult, RunContentBuilder.fix(env, this))	RunContentBuilder	contentBuilder
state match { case myState: Play2RunConfiguration.Play2RunProfileState => if (myState.isDebug) { myState setDebug true attachVirtualMachine(state, env, new RemoteConnection(true, "127.0.0.1", myState.getConfiguration.play2JpdaPort + "", false), true) } else { super.createContentDescriptor(state, env) } case _ => super.createContentDescriptor(state, env) }	RunContentDescriptor	descriptor
contentBuilder showRunContent env.getContentToReuse	RunContentDescriptor	descriptor
Option(env) flatMap (en => Option(en.getRunnerAndConfigurationSettings)) map (_.getConfiguration) getOrElse { (Option(env) flatMap (en => Option(en.getRunProfile))).orNull }	RunProfile	play2Config
0	Int	prevStart
new Play2SbtCompilerMessageProcessor	Play2SbtCompilerMessageProcessor	myProcessor
immutable.HashMap ( "-Dfile.encoding" -> "UTF8", "-Dsbt.log.noformat" -> "true", "-Djline.terminal" -> "none" )	HashMap[Nothing, Nothing]	commonEnvVars
service.createFileSetVersions(myGroupId, localDescriptor)	DownloadableFileSetVersions[DownloadableFileSetDescription]	setVersions
(playHome: String) => immutable.HashMap ( "-Dsbt.ivy.home" -> (playHome + File.separatorChar + "repository"), "-Dsbt.boot.properties" -> ("file:///" + playHome.replace('\\', '/') + "/framework/sbt/sbt.boot.properties"), "-Dplay.version" -> s"$playVersion", "-Dplay.home" -> (playHome + File.separator + "framework") )	String => HashMap[Nothing, Nothing]	standalonePlayEnvVars
new JavaParameters	JavaParameters	javaParameters
javaParameters.getVMParametersList	ParametersList	vmParameters
getModule.modifiableModel	ModifiableRootModel	moduleModel
Play2DescriptorBuilders.createBuilder(PROJECT_NAME, templateType, scalaVersion, play2Version)	Play2DescriptorBuilders.Play2DescriptorBuilder	builder
SbtSettings.getInstance(project).getState	SbtSettings.State	settings
new CreateApplicationControllerQuickFix(null).getName	String	fixName
ref.getContainingFile	PsiFile	file
getProject	Project	project
new ProblemsHolder(InspectionManager getInstance project, file, false)	ProblemsHolder	holder
new RoutingBadHandlerInspection().buildVisitor(holder, isOnTheFly = false)	PsiElementVisitor	visitor
new Result(entireLength - line.length, entireLength - line.length + ERROR_PREFIX.length, null, new TextAttributes(Color.RED, null, null, EffectType.BOXED, Font.PLAIN))	Filter.Result	prefixResult
Set( "tips", "user1", "userActivity", "userActivityByFeature", "friends", "index", "update", "updateHelp", "makeFriend", "unfriend", "explore", "exploreFeature", "myBadges" )	Set[Nothing]	appMethodsUsedInRoutes
base	PsiElement	lastElement
mutable.HashMap.empty[String, String] ++= commonEnvVars ++= additionalEnvVariables.map {case (k,v) => s"-D$k" -> v }	mutable.HashMap[String, String]	mergedEnvVariables
l.getReferences	Array[PsiReference]	refs
ModuleManager getInstance project getModules()	Array[Module]	allModules
false	Boolean	debug
new CantRunException("Cannot find Play 2 install dir")	CantRunException	cannotFindInstallDirException
p.getPsiElement	PsiElement	e
getChildren(lastElement).find { case named: PsiNamedElement => named.getName == pathElement case _ => false }	Option[PsiElement]	nextElement
1	Int	a
myFixture findClass myTestObjectFqn	PsiClass	testClass
refs filter (_.isInstanceOf[FileReference])	Array[PsiReference]	fileReferences
lastElement.asInstanceOf[PsiClass].getAllMethods.toSet	Set[PsiMethod]	actualMembers
findFile(filePath)	VirtualFile	file
ManifestHandler(sbtLauncher)	ManifestHandler	manifestHandler
javaParameters.getClassPath	PathsList	javaClassPath
getPsiManager.findFile(file)	PsiFile	psiFile
javaParameters.getProgramParametersList	ParametersList	programParametersList
scalaFile.findReferenceAt(i + 3).asInstanceOf[ScReferenceExpression]	ScReferenceExpression	reference
psiFile.getViewProvider.getPsi(ScalaLanguage.INSTANCE).findElementAt(i + Play2ResolveAssetsTest.MY_REF_PREFIX.length + 12)	PsiElement	e
reference.getElement	ScReference	element
findRoutesFile(fileName)	VirtualFile	virtualFile
getPsiManager.findFile(virtualFile)	PsiFile	psiFile
psiFile.asInstanceOf[Play2HtmlRoutingPsiFile]	Play2HtmlRoutingPsiFile	file
file.getAllMethodControllerRefs.filter(_.getText == refName)	List[ScReferenceExpression]	refs
findClass(className) match { case PsiClassWrapper(definition) => definition case c => c }	PsiClass	clazz
ModuleRootManager.getInstance(module).getSdk	Sdk	sdk
env.getProject	Project	project
findFile(s"app/views/$fileName.scala.html")	VirtualFile	file
TestUtil.createPseudoPhysicalFile(getProject, "dummy.scala.html", before)	PsiFile	testFile
PsiDocumentManager.getInstance(getProject)	PsiDocumentManager	manager
manager.getDocument(testFile)	Document	document
testFile.getTextRange	TextRange	myTextRange
info.getElement	PsiElement	e
new EmptyDirHolder	SbtLauncherCommandLineBuilder.EmptyDirHolder	emptyPluginsDir
None	Option[Any]	tempDir
s"app/views/$name.scala.html"	String	path
findFile(path)	VirtualFile	virtualFile
getPsiManager findFile virtualFile	PsiFile	psiFile
expectedMethods .map(className + "." + _) .toSet[String]	Set[String]	expected
getPsi(templateFileName)	PsiFile	templatePsi
getPsi(templateFileName + "Check")	PsiFile	templateCheck
if (config.play2IsNonDefaultInstallDirUsed) { val play2Home = new File(config.play2NonDefaultInstallDir) if (play2Home.exists()) Some(play2Home.getCanonicalPath) else None } else if (Play2Util.guessPlay2Home(module.getProject).isDefined) None else Play2Util guessPlay2StandaloneHome module	Option[String]	finalPlay2Home
GlobalSearchScope.projectScope(element.getProject)	GlobalSearchScope	scope
ConfigurationTypeUtil findConfigurationType classOf[Play2RunConfigurationType] match { case tpe: Play2RunConfigurationType => tpe case _ => new Play2RunConfigurationType }	Play2RunConfigurationType	configType
Set("routes", "sub.routes")	Set[Nothing]	names
Option(Play2CompilerSettings.getInstance(project).PROJECT_PLAY_MODULE).flatMap( name => Option(ModuleManager.getInstance(project).findModuleByName(name)) ).flatMap(a => findUri(a.getName))	Option[Any]	play2BaseModuleDir
play2BaseModuleDir orElse findUri(sbtModuleName) orElse Play2Util.findExternalLinkedModule(project).flatMap( m => findUri(m.getName)).orElse(findUri(project.getName))	Option[Any]	workDir
List[String]("project " + sbtModuleName, runCommand)	List[String]	commands
123	Int	foo
123	Int	jjj
Seq("-Xms512M", "-Xmx1024M", "-Xss1M", "-XX:+CMSClassUnloadingEnabled", "-XX:MaxPermSize=256M", "-Dfile.encoding=UTF-8", "-Dsbt.log.noformat=true")	Seq[Nothing]	DEFAULT_VM_OPTIONS
None	Option[String]	fileWithErrorName
mutable.HashMap[JpsProject, CompilationInfo]()	mutable.HashMap[JpsProject, Play2JPSUtil.CompilationInfo]	compilationInfos
None	Option[Int]	errorLine
mutable.MutableList[Int]()	mutable.MutableList[Int]	lineOffsetsList
None	Option[Int]	errorColumn
-1L	Long	timestamp
false	Boolean	needShowError
false	Boolean	ready
-1	Int	linesRemaining
None	Option[String]	lastKind
runManagerEx.createConfiguration("Play2Run", new Play2RunConfigurationFactory(configType))	RunnerAndConfigurationSettings	play2Config
computeCompilationUri()	Option[(String, JpsModule)]	moduleForCompilation
None	Option[BuildMessage.Kind]	messageType
if (messageType exists (_ != mTpe)) getCurrentMessage else null	CompilerMessage	oldMessage
computePlay2Home()	Option[String]	play2Home
getExternalProjectSettings	SbtProjectSettings	settings
getModuleType	ModuleType[_ <: ModuleBuilder]	moduleType
if (mTpe == BuildMessage.Kind.ERROR) linesRemaining match { case -1 => if (!isErrorSummaryMessage(stripedMessage)) extractMessageInfo(stripedMessage) match { case (a, b, c, d, e) => fileWithErrorName = a errorLine = b errorColumn = c messageBody = d linesRemaining = e } if (linesRemaining == 0) { ready = true Some(getCurrentMessage) } else None case 1 => linesRemaining = 0 ready = true errorColumn = extractMessageColumn(stripedMessage) messageBody += ("\n" + stripedMessage) Some(getCurrentMessage) case _ => linesRemaining -= 1 messageBody = (if (!messageBody.startsWith("\n")) "\n" + messageBody else messageBody) + "\n" + stripedMessage None } else { ready = true messageBody = stripedMessage Some(getCurrentMessage) }	Option[CompilerMessage]	newMessage
':'	Char	semicolon
moduleModel.newModule(path, moduleType.getId)	Module	module
myJdkComboBox.getSelectedJdk	Sdk	selectedJdk
s"META-INF/MANIFEST.MF"	String	MANIFEST_ENTRY_NAME
stripedMessage.indexOf(semicolon, 4)	Int	nameInd
None	Option[List[(String, Iterable[String])]]	vrs
false	Boolean	tableStart
{ var vrs: Option[List[(String, Iterable[String])]] = None ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable { override def run() { try { vrs = Some(scalaVersionsList.map ( v => (v, Play2RepositoryUtil.getVersionList(v).map(_.reverse).getOrElse(List(Play2RepositoryUtil.PLAY_2_DEFAULT_VERSION))) )) } catch { case _: Exception => //ignore } } }, "Downloading versions list...", false, null) vrs getOrElse scalaVersionsList.zip(Stream.continually(List(Play2RepositoryUtil.PLAY_2_DEFAULT_VERSION))) }	List[(String, Iterable[String])]	scala2PlayVersions
Option(XmlSerializer.deserialize(componentTag, classOf[Play2TemplateOuterCompilerSettingsImpl])) getOrElse { new Play2TemplateOuterCompilerSettingsImpl() }	Play2TemplateOuterCompilerSettingsImpl	state
settingsStep.getContext	WizardContext	context
stripedMessage.indexOf(semicolon, nameInd + 1)	Int	lineInd
if (fileName endsWith "routes") 1 else 2	Int	addLines
Play2DescriptorBuilders.createBuilder(name, langType, getFullVersion(scalaVersion), play2Version)	Play2DescriptorBuilders.Play2DescriptorBuilder	myDescriptorBuilder
Option(XmlSerializer.deserialize(componentTag, classOf[Play2AdditionalCompilerSettings])) getOrElse { new Play2AdditionalCompilerSettings() }	Play2AdditionalCompilerSettings	state
JpsElementChildRoleBase.create("play2 exclude compilation settings")	JpsElementChildRoleBase[Play2TemplateOuterCompilerSettings]	PROJECT_SETTINGS_ROLE
JpsElementChildRoleBase.create("play2 additional compilation settings")	JpsElementChildRoleBase[Play2AdditionalCompilerSettings]	ADDITIONAL_SETTINGS_ROLE
file.getLines()	Iterator[String]	i
null	String	line
mutable.MutableList[Int](0)	mutable.MutableList[Int]	lineNumberOffsetsList
if (relUrl.endsWith("251.scala_")) relUrl.stripSuffix("251.scala_") + ".scala" else relUrl	String	f
{ val file = new File(translatedTemplatePath) if (file.exists()) Some(file) else None }	Option[Any]	translatedTemplate
JpsElementChildRoleBase.create[Play2TemplateOuterCompilerSettings]("Play2 template external make settings")	JpsElementChildRoleBase[Play2TemplateOuterCompilerSettings]	COMPILER_SETTINGS
{ using(new JarFile(jarFile)) { handler => Option(handler.getEntry(MANIFEST_ENTRY_NAME)) map (e => new Manifest(handler.getInputStream(e))) } }	Option[Manifest]	manifest
new Play2SbtCompilerMessageProcessor	Play2SbtCompilerMessageProcessor	errorAssembler
new GeneralCommandLine	GeneralCommandLine	cmd
ManifestHandler(file)	Play2JPSUtil.ManifestHandler	handler
List("2.12", "2.11", "2.10")	List[Nothing]	scalaVersionsList
Play2SerializerService.getProjectSettings(project)	Play2TemplateOuterCompilerSettings	settings
module.getProject	JpsProject	project
new BaseOSProcessHandler(process, null, null) { override def executeOnPooledThread(task: Runnable) = SharedThreadPool.getInstance() executeOnPooledThread task }	BaseOSProcessHandler { def executeOnPooledThread(task: Any): Nothing }	handler
compilationInfos.get(project)	Option[Play2JPSUtil.CompilationInfo]	info
new CompilationInfo(Play2SerializerService getProjectSettings project, Play2SerializerService getAdditionalSettings project, project)	Play2JPSUtil.CompilationInfo	i
Play2SerializerService.getAdditionalSettings(project)	Play2AdditionalCompilerSettings	additionalSettings
compilationInfos.get(project) match { case Some(i) => i.play2Home case None => val i = new CompilationInfo(Play2SerializerService getProjectSettings project, Play2SerializerService getAdditionalSettings project, project) compilationInfos.put(project, i) i.play2Home }	Option[String]	hh
s => new FilenameFilter { def accept(dir: File, name: String): Boolean = name == s }	String => Any	exactMatchFilter
settingKey[File]("Path to packaged, but not yet compressed plugin")	SettingKey[sbt.File]	packagedPluginDir
mutable.HashMap[String, String]()	mutable.HashMap[String, String]	versionsCache
taskKey[Classpath]("scalaUltimate module's fullClasspath in Compile and Test scopes")	TaskKey[Keys.Classpath]	ultimateFullClasspath
index + versionNameLength	String	startOffset
new String(contents.substring(startOffset, startOffset + quoteIndex))	String	version
2	Int	maxUrlRetries
ManifestHandler(sbtLauncher).getMainClass getOrElse "xsbt.boot.Boot"	String	mainClass
taskKey[Unit]("Stashes all compilation results for hoarder ")	TaskKey[Unit]	stashAll
taskKey[Unit]("Restores cached compilation from cache")	TaskKey[Unit]	unstashAll
ParametersListUtil.parseToArray(settings)	Array[Nothing]	userParameters
{ sourceRoots collectFirst { case root if translatedTemplatePath startsWith root.getFile.getCanonicalPath => root.getFile } match { case Some(rootFile) => rootFile listFiles Play2JPSUtil.exactMatchFilter("views") find (f => f.listFiles(Play2JPSUtil.exactMatchFilter("html")).length > 0) match { case Some(viewsFile) => val relativePath = translatedTemplatePath stripPrefix (viewsFile.getAbsolutePath + File.separator + "html"+ File.separator) stripSuffix ".template.scala" sourceRoots collectFirst { case root if constructRelativeFile(root, relativePath, ".scala.html").exists() => constructRelativeFile(root, relativePath, ".scala.html") } case n@None => n } case _ => None } }	Option[Any]	sourceTemplate
FileIndexHolder lineToOffset sourceLine getOrElse 0	Int	sourceLineOffset
ArgParser.Opts( buildTypeId = "Scala_Idea15NewBuild_Release_Package", confluecePage = "Test page", pivotBuild = "8975371", artifact = "a.zip", channel = "test", username = "Mikhail.Mutcianko@jetbrains.com", password = "" )	ArtifactPublisher.ArgParser.Opts	opts
ArgParser.parse(args)	ArtifactPublisher.ArgParser.Opts	opts
PluginRepository.uploadPlugin(opts.username, opts.password, opts.artifact, opts.channel).location .flatMap(PluginRepository.extractUpdateId)	Option[String]	updId
TeamcityUtil.getBuildsBetweenPinned(opts.buildTypeId, opts.pivotBuild)	Seq[ArtifactPublisher.TeamcityBuild]	builds
TeamcityUtil.collectIssues(builds)	Seq[ArtifactPublisher.TeamcityRelatedIssue]	issues
Confluence.postReleaseNotes(builds.head, issues, opts.confluecePage, updId)	String	code
JavaCoverageEnabledConfiguration.getFrom(configuration)	JavaCoverageEnabledConfiguration	coverageEnabledConfiguration
configuration.getTestClassPath	String	testClass
configuration.getTestPackagePath	String	testPackage
{ val settings = Play2SerializerService.getAdditionalSettings(context.getProjectDescriptor.getProject).SBT_OPTIONS if (settings == null) DEFAULT_VM_OPTIONS else { val userParameters = ParametersListUtil.parseToArray(settings) mergeSettings(DEFAULT_VM_OPTIONS, userParameters) } }	Seq[Any]	vmOptions
unit.defined.mapValues { project => if (project.id == "scalaCommunity" || project.id == "scalap") applyUltimateSettings(project) else if (project.id == "idea-runner") project.settings(products := Seq.empty) else project }	Map[String, Project]	defined
datakey(classOf[SbtBuildModuleDataBsp])	Key[SbtBuildModuleDataBsp]	Key
build.units.mapValues { unit => val defined = unit.defined.mapValues { project => if (project.id == "scalaCommunity" || project.id == "scalap") applyUltimateSettings(project) else if (project.id == "idea-runner") project.settings(products := Seq.empty) else project } new PartBuildUnit(unit.unit, defined, unit.rootProjects, unit.buildSettings) }	Map[Any, PartBuildUnit]	units
"ijplatform_master_Idea_Installers" :: "ijplatform_master_Idea_InstallersForEapRelease" :: "ijplatform_IjPlatform183_Idea_InstallersForEapRelease" :: "ijplatform_IjPlatform191_Idea_InstallersForEapRelease" :: "ijplatform_IjPlatform192_Idea_InstallersForEapRelease" :: "IDEA_Trunk_Installers" :: Nil	List[B]	BuildTypes
new BaseOSProcessHandler(process, null, Charset.defaultCharset())	BaseOSProcessHandler	handler
datakey(classOf[ScalaSdkData])	Key[ScalaSdkData]	Key
"scala-sdk"	String	LibraryName
datakey(classOf[BspMetadata])	Key[BspMetadata]	Key
ProjectDataManager.getInstance()	ProjectDataManager	dataManager
new Gson()	Gson	gson
TestMode.ALL_IN_PROJECT	BspTestConfigurationForm.TestMode	testMode
getModifiableRootModel(module)	ModifiableRootModel	model
Option(model.getSdk)	Option[Sdk]	moduleSdk
BuildRef(file(".").toURI)	BuildRef	thisBuild
buildResponse(buildType, "number", ideaVersion)	Elem	response
response \ "build" \ "@id"	NodeSeq	nodes
url(s"$BaseUrl/?locator=buildType:(id:$buildType),branch:(default:any),$key:$value")	sbt.URL	from
IO.readLinesURL(from).mkString	String	string
s"https://www.jetbrains.com/intellij-repository/$repo/com/jetbrains/intellij/idea"	String	baseUrl
SdkUtils.javaLanguageLevelFrom(javacOptions) .orElse(moduleSdk.flatMap(SdkUtils.defaultJavaLanguageLevelIn))	Option[LanguageLevel]	languageLevel
targets().map(uri => new BuildTargetIdentifier(uri.toString))	IndexedSeq[BuildTargetIdentifier]	targetIds
new TestParams(targetIds.toList.asJava)	TestParams	params
for { projectInfo <- Option(dataManager.getExternalProjectData(project, BSP.ProjectSystemId, project.getBasePath)) projectStructure <- Option(projectInfo.getExternalProjectStructure) moduleDataNode <- Option(ES.find(projectStructure, ProjectKeys.MODULE, predicate)) metadata <- Option(ES.find(moduleDataNode, BspMetadata.Key)) } yield { metadata.getData }	Option[BspMetadata]	metadata
m .map { case (uri, classes) => new ScalaTestClassesItem(new BuildTargetIdentifier(uri.toString), classes.asJava) } .toList	List[ScalaTestClassesItem]	scalaTestClasses
new ScalaTestParams	ScalaTestParams	p
x.getDataKind	String	kind
None	Option[Any]	stream
url(s"$baseUrl/ideaIC/$build/ideaIC-$build-sources.jar")	sbt.URL	result
mutable.Map()	mutable.Map[String, Long]	startTime
(packageOutputDir in ThisProject).value	sbt.File	pluginDir
getBuildId(build.buildNumber)	String	buildId
proc	ProcessHandler	pr
new MProcHandler	BspTestRunner.this.MProcHandler	procHandler
sc.parts	Seq[String]	parts
SMTestRunnerConnectionUtil.createAndAttachConsole("BSP", procHandler, new SMTRunnerConsoleProperties( project, rc, "BSP", ex))	BaseTestsOutputConsoleView	console
new NotificationData("bsp Import", message, NotificationCategory.WARNING, NotificationSource.PROJECT_SYNC)	NotificationData	notification
Inactive	BspProjectResolver.ImportState	importState
new ExternalSystemTaskNotificationEvent(id, msg)	ExternalSystemTaskNotificationEvent	ev
new BuildEventMessage(id, kind, "BSP", msg)	BuildEventMessage	buildEvent
new ExternalSystemBuildEvent(id, buildEvent)	ExternalSystemBuildEvent	event
BspCommunicationService.getInstance.communicate(project)	BspCommunication	bspCommunication
dirs.map(_.toPath)	IndexedSeq[Any]	paths
dataT.map(it => (it \\ itemName).toStream.map(builder).iterator).getOrElse(Iterator.empty)	Iterator[T]	iterator
Try(XML.load(url))	Try[Elem]	dataT
dataT.get	Elem	data
Seq(data)	Seq[Elem]	state
(data \ "@id").text	String	id
SbtBuildModuleDataBsp( target.getAutoImports, buildFor.asJava )	SbtBuildModuleDataBsp	sbtBuildModuleData
state.getRootModel.getModule	Module	module
getScalaSdkData(target.getScalaBuildTarget, scalacOptionsItem)	ScalaSdkData	scalaSdkData
BuildMessages.randomEventId	BuildMessages.EventId	bspTaskId
new BuildToolWindowReporter(project, bspTaskId, "bsp build")	BuildToolWindowReporter	report
buildTargets.map(t => (t.getId, t)).toMap	Map[BuildTargetIdentifier, BuildTarget]	idToTarget
calculateModuleDescriptions( targets, scalacOptions, sources, resources, depSources )	BspResolverDescriptors.ProjectModules	descriptions
mutable.Map.empty	mutable.Map[Any, List[Diagnostic]]	diagnostics
new IndicatorReporter(indicator)	IndicatorReporter	reportIndicator
scalacOptionsItems.map(item => (item.getTarget, item)).toMap	Map[BuildTargetIdentifier, ScalacOptionsItem]	idToScalacOptions
new ScalaTestClassesParams(targets.asJava)	ScalaTestClassesParams	p
{ val p = new ScalaTestClassesParams(targets.asJava) p.setOriginId(UUID.randomUUID().toString) p }	ScalaTestClassesParams	testClassesParams
task.getModule	Module	module
targets.groupBy(_.workspace)	Map[Any, Iterable[BspTask.BspTarget]]	targetByWorkspace
targetsToClean.groupBy(_.workspace)	Map[Any, Iterable[BspTask.BspTarget]]	targetToCleanByWorkspace
ModuleType.get(module)	ModuleType[_ <: ModuleBuilder]	moduleType
BspCommunication.forWorkspace(new File(workspaceCreationPath))	BspCommunication	communication
targetToCleanByWorkspace.getOrElse(workspace, List.empty)	Iterable[BspTask.BspTarget]	targetsToClean
(start +: transitiveDependencies(start)).map(_.getId)	IndexedSeq[BuildTargetIdentifier]	transitiveDeps
{ case BspNotifications.LogMessage(params) => // TODO use params.id for tree structure statusUpdate(params.getMessage) case _ => }	BspSession.NotificationCallback	notifications
BspCommunication.forWorkspace(workspace.toFile)	BspCommunication	communication
{ msg => listener.onTaskOutput(id, msg, true) }	BspSession.ProcessLogger	processLogger
dependencySourcesItems .map(item => (item.getTarget, item.getSources.asScala.map(_.toURI.toFile))) .toMap	Map[BuildTargetIdentifier, Any]	idToDepSources
Promise[(T,A)]	Promise[(T, A)]	promise
default	A	a
None	Option[Any]	runningTask
BspCommunicationService.getInstance .communicate(proj) .run(bsp => bsp.buildTargetScalaTestClasses(testClassesParams).catchBspErrors, _ => {}, _ => {})	BspJob[Nothing]	task
(data \ "tags" \\ "tag" \\ "@name").map(_.text.toLowerCase()).toSet	Set[Any]	tags
resourcesItems .map(item => (item.getTarget, item.getResources.asScala.map(sourceDirectory(_)))) .toMap	Map[BuildTargetIdentifier, Any]	idToResources
(data \ "@number").text	String	buildNumber
communication.run(requests(_), notifications, processLogger)	BspJob[Nothing]	projectJob
ListBuffer.empty[Cancelable]	ListBuffer[Cancelable]	toCancel
Cancelable(() => ())	Cancelable	empty
Map("Minor" -> 0, "Normal" -> 1, "Major" -> 2, "Critical" -> 3, "Show-stopper" -> 4)	Map[Nothing, Nothing]	lookup
ListBuffer.empty[Throwable]	ListBuffer[Throwable]	errors
sourcesItems .map(item => (item.getTarget, sourceDirectories(item))) .toMap	Map[BuildTargetIdentifier, Seq[BspResolverDescriptors.SourceDirectory]]	idToSources
new BuildClientCapabilities(capabilities.languageIds.asJava)	BuildClientCapabilities	buildClientCapabilities
sharedSourceDirs(idToSources)	Map[BspResolverDescriptors.SourceDirectory, Seq[BuildTargetIdentifier]]	sharedSources
target.getId	BuildTargetIdentifier	id
Seq(super.hashCode(), id)	Seq[Any]	state
idToScalacOptions.get(id)	Option[ScalacOptionsItem]	scalacOptions
new BuildIterator(buildTypeId)	ArtifactPublisher.BuildIterator	iterator
idToSources .getOrElse(id, Seq.empty) .filterNot(sharedSources.contains)	Seq[BspResolverDescriptors.SourceDirectory]	sources
metadata.getData	BspMetadata	data
transitiveDependencyOutputs(target)	Seq[Any]	dependencyOutputs
ScalaPluginVersionVerifier.getPluginVersion.map(_.presentation).getOrElse("N/A")	String	pluginVersion
new JsonObject()	JsonObject	dataJson
new InitializeBuildParams("IntelliJ-BSP", pluginVersion, "2.0", rootUri.toString, buildClientCapabilities)	InitializeBuildParams	initializeBuildParams
for { projectPath <- Option(ES.getExternalProjectPath(task.getModule)) projectData <- Option(ES.findProjectData(project, BSP.ProjectSystemId, projectPath)) moduleDataNode <- Option(ES.find( projectData, ProjectKeys.MODULE, (node: DataNode[ModuleData]) => node.getData.getId == moduleId)) metadata <- Option(ES.find(moduleDataNode, BspMetadata.Key)) } yield { val data = metadata.getData val workspaceUri = Paths.get(projectPath).toUri data.targetIds.asScala.map(id => BspTarget(workspaceUri, id)).toList }	Option[Any]	targetIds
Logger.getInstance(classOf[BloopConnector])	Logger	logger
false	Boolean	verbose
waitForProjectCancelable(projectJob)	Try[DataNode[ProjectData]]	result
CompilerPaths.getOutputPaths(modules)	Array[Nothing]	outputRoots
initialJob	jobs.BspSessionJob[_, _]	currentJob
false	Boolean	retry
0	Long	lastProcessOutput
0	Long	lastActivity
startServerConnection	BspSession.ServerConnection	serverConnection
Promise[Unit]	Promise[Unit]	sessionShutdown
builds flatMap { _.relatedIssues }	Seq[ArtifactPublisher.TeamcityRelatedIssue]	unsorted
new BspTask(project, targets, targetsToClean, Option(projectTaskNotification), onComplete)	BspTask[Nothing]	bspTask
10.millis	FiniteDuration	queuePause
ProjectDataManager.getInstance().getExternalProjectData(project, BSP.ProjectSystemId, project.getBasePath)	ExternalProjectInfo	info
Await.result(projectJob.future, 300.millis)	DataNode[ProjectData]	res
1.second	FiniteDuration	queueTimeout
() => { process.destroy() }	() => Any	cleanup
connectUnixSocket(socketFile)	Either[BspErrorMessage, (Process, UnixDomainSocket)]	procAndSocketResult
() => { socket.close() socket.shutdownInput() socket.shutdownOutput() if (socketFile.isFile) socketFile.delete() proc.destroy() }	() => Unit	cleanup
BspServerConnector.createInitializeBuildParams(rootUri, compilerOutputUri, capabilities)	InitializeBuildParams	initializeBuildParams
targetByWorkspace.map { case (workspace, targets) => val targetsToClean = targetToCleanByWorkspace.getOrElse(workspace, List.empty) val communication: BspCommunication = BspCommunication.forWorkspace(workspace.toFile) communication.run( buildRequests(targets, targetsToClean)(_), BuildMessages.empty, notifications(report), processLog(report)) }	IndexedSeq[BspJob[(Nothing, BuildMessages)]]	buildJobs
20.seconds	FiniteDuration	sessionTimeout
issues.map(i => s"""<li> <a href=\"${i.url}\">${i.id}</a>${i.summary}</li>""").mkString	String	issuesFmt
buildJobs.map(waitForJobCancelable(_, indicator))	IndexedSeq[(Nothing, BuildMessages)]	compileResults
updId.orElse(build.updateId())	Option[String]	updateId
connectTcp(host, uri)	Either[BspError, Any]	socketResult
methods.collectFirst { case UnixLocalBsp(socketFile) => val procAndSocketResult = connectUnixSocket(socketFile) procAndSocketResult.map { case (proc, socket) => val cleanup: ()=>Unit = () => { socket.close() socket.shutdownInput() socket.shutdownOutput() if (socketFile.isFile) socketFile.delete() proc.destroy() } (socket, cleanup) } case TcpBsp(host, uri) => val socketResult = connectTcp(host, uri) socketResult.map { socket => (socket, ()=>()) } }	Option[Either[BspError, (Any, () => Unit)]]	socketAndCleanupOpt
try { val res = Await.result(projectJob.future, 300.millis) Success(res) } catch { case to: TimeoutException => retry = true // hack around tail call optimization not working in catch Failure(to) case NonFatal(x) => Failure(x) }	Success[DataNode[ProjectData]]	res
updateId.map(u => s"https://plugins.jetbrains.com/plugin/download?pr=idea&amp;updateId=$u") .getOrElse("https://plugins.jetbrains.com/plugin/1347")	String	dlUrl
Success(new SourcesResult(Collections.emptyList()))	Success[SourcesResult]	emptySources
socketAndCleanupOpt.getOrElse(Left(BspErrorMessage("could not find supported connection method for bloop")))	Either[BspError, (Any, () => Unit)]	socketAndCleanupEither
compileResults.map(r => messagesWithStatus(report, reportIndicator, r._1, r._2))	IndexedSeq[BuildMessages]	updatedMessages
Success(new ResourcesResult(Collections.emptyList()))	Success[ResourcesResult]	emptyResources
Success(new DependencySourcesResult(Collections.emptyList()))	Success[DependencySourcesResult]	emptyDepSources
Success(new ScalacOptionsResult(Collections.emptyList()))	Success[ScalacOptionsResult]	emptyScalacOpts
updatedMessages.fold(BuildMessages.empty){ (m1, m2) => m1.combine(m2) }	BuildMessages	combinedMessages
buildTargets.flatMap { target: BuildTarget => val id = target.getId val scalacOptions = idToScalacOptions.get(id) val depSources = idToDepSources.getOrElse(id, List.empty) val sources = idToSources .getOrElse(id, Seq.empty) .filterNot(sharedSources.contains) val resources = idToResources.getOrElse(id, List.empty) val dependencyOutputs = transitiveDependencyOutputs(target) implicit val gson: Gson = new Gson() moduleDescriptionForTarget(target, scalacOptions, depSources, sources, resources, dependencyOutputs) }	IndexedSeq[BspResolverDescriptors.ModuleDescription]	moduleDescriptions
s"bsp --protocol local --socket $socketFile $verboseParam"	String	bloopParams
Some(pageContent.indexOf(marker)).map(i => if (i != -1) i else 0).get	Int	index
ApplicationManager.getApplication	Application	app
ApplicationManager.getApplication.getMessageBus.connect()	MessageBusConnection	bus
combinedMessages.toTaskResult	ProjectTaskResult	result
BspConnectionError("bsp server is not responding", to)	BspConnectionError	error
getPage(pageName)	String	locatorData
new JSONObject(getContent(id))	JSONObject	pageParsed
None	Option[BspSession]	session
new SourcesParams(targets)	SourcesParams	sourcesParams
prepareSession(base, executionSettings)	Either[BspError, BspSession.Builder]	sessionBuilder
new DependencySourcesParams(targets)	DependencySourcesParams	depSourcesParams
new ResourcesParams(targets)	ResourcesParams	resourcesParams
10.minutes	FiniteDuration	timeout
new ScalacOptionsParams(targets)	ScalacOptionsParams	scalacOptionsParams
(for { m <- moduleDescriptions t <- m.data.targets } yield (t.getId, m)).toMap	Map[BuildTargetIdentifier, BspResolverDescriptors.ModuleDescription]	idToModule
10.seconds	FiniteDuration	cleanerPause
s"problem connecting to bsp server: ${error.getMessage}. See IDE log for details."	String	msg
mutable.Map[URI, BspCommunication]()	mutable.Map[Any, BspCommunication]	comms
BspException(msg, error)	BspException	bspError
new BspCommunication(base, executionSettings(base))	BspCommunication	comm
currentJob.future .recover { case NonFatal(_) => () } .andThen { case _ => lastActivity = System.currentTimeMillis()}	Future[Any]	currentIgnoringErrors
Serialization.formats(NoTypeHints)	Any with Formats { val dateFormat : DateFormat val typeHints : TypeHints }	formats
BspException("problem executing bsp job", error)	BspException	bspError
false	Boolean	buildOnSave
new BspProjectSettings	BspProjectSettings	result
s"bsp connection failed: ${error.getMessage}"	String	procLogMsg
newSessionBuilder.create	BspSession	newSession
getFillLineConstraints(1)	GridBag	fillLineConstraints
getInitialSettings	BspProjectSettings	initial
jobs.create(task, default, aggregator, processLogger)	jobs.BspSessionJob[Nothing, A]	job
new UnixDomainSocket(socketFile.getCanonicalPath)	UnixDomainSocket	socket
false	Boolean	sockfileCreated
12000	Int	timeout
10	Int	wait
(a: Unit, n: BspNotification) => notifications(n)	(Unit, BspNotifications.BspNotification) => Unit	callback
s"bsp --protocol tcp --host ${host.toString} --port $port $verboseParam"	String	bloopParams
new CompileResult(StatusCode.CANCELLED)	CompileResult	res
run(bspSessionTask, (), callback, processLogger)	BspJob[(Nothing, Unit)]	job
List("scala","java")	List[Nothing]	supportedLanguages
getContent((locatorData \ "results" \ "id").values.toString)	String	data
new BspProjectSettingsListenerAdapter(listener)	BspProjectSettingsListenerAdapter	adapter
new BspSettings.State	BspSettings.State	state
targetsToClean.map(target => new bsp4j.BuildTargetIdentifier(target.target.toString))	IndexedSeq[BuildTargetIdentifier]	targetIds
new BspSessionClient	BspSession.this.BspSessionClient	localClient
new bsp4j.CleanCacheParams(targetIds.toList.asJava)	CleanCacheParams	params
new ProjectSystemId("BSP", Name)	ProjectSystemId	ProjectSystemId
NotificationGroup.balloonGroup("bsp")	NotificationGroup	balloonNotification
XML.load(xmlUrl)	Elem	d
targets.map(target => new bsp4j.BuildTargetIdentifier(target.target.toString))	IndexedSeq[BuildTargetIdentifier]	targetIds
new bsp4j.CompileParams(targetIds.toList.asJava)	CompileParams	params
new TextCollector	BspTask.TextCollector	textNoAnsiAcceptor
textNoAnsiAcceptor.result	String	textNoAnsi
BspCapabilities(supportedLanguages)	BspServerConnector.BspCapabilities	capabilities
new BspSystemSettings.State	BspSystemSettings.State	myState
"bloop"	String	bloopPath
((d \\ "idea-plugin").filter(p => (p \ "version").text == build.buildNumber) \ "download-url").text	String	url
false	Boolean	traceBsp
commonBase(idToSources.values.flatten.map(_.directory)).map(_.toPath)	Option[Any]	allSourcesBase
BspSystemSettings.getInstance	BspSystemSettings	systemSettings
diagnostics.getOrElse(uri, List.empty)	List[Diagnostic]	previousDiagnostics
TcpBsp(new URI("localhost"), findFreePort(5001))	BspServerConnector.TcpBsp	tcpMethod
targetIds.map(idToTarget)	IndexedSeq[BuildTarget]	targets
Some(new FilePosition(uri.toFile, start.getLine, start.getCharacter, end.getLine, end.getCharacter))	Some[FilePosition]	position
targetIds.map(idToModule)	IndexedSeq[BspResolverDescriptors.ModuleDescription]	sharingModules
-1	Int	lastPercent
s"${diagnostic.getMessage} [${start.getLine + 1}:${start.getCharacter + 1}]"	String	text
params.getTaskId	TaskId	taskId
if (SystemInfo.isWindows) WindowsLocalBsp(id) else if (SystemInfo.isUnix) { val tempDir = Files.createTempDirectory("bsp-") val socketFilePath = tempDir.resolve(s"$id.socket") val socketFile = socketFilePath.toFile socketFile.deleteOnExit() UnixLocalBsp(socketFile) } else tcpMethod	BspServerConnector.BspConnectionMethod with Product with Serializable	platformMethod
new BspSystemSettingsPane	BspSystemSettingsPane	pane
parseOpts(args)	BSPCli.Opts	opts
settings.getSystemSettings	BspSystemSettings	systemSettings
findBspConfigs(base)	List[BspConnectionDetails]	connectionDetails
EventId(taskId.getId)	BuildMessages.EventId	id
s"${bloopExecutable.getCanonicalPath} $params"	String	command
sharedSources.map { case (src, targetIds) => val targets = targetIds.map(idToTarget) val sharingModules = targetIds.map(idToModule) createSyntheticModuleDescription(allSourcesBase, targets, Seq(src), sharingModules) }	IndexedSeq[BspResolverDescriptors.ModuleDescription]	syntheticModules
connectionDetails.map(ProcessBsp)	IndexedSeq[BspServerConnector.ProcessBsp]	configuredMethods
new bsp.settings.BspSystemSettings.State()	BspSystemSettings.State	st
{ val st = new bsp.settings.BspSystemSettings.State() st.traceBsp = opts.tracePath.isDefined st.bloopPath = opts.bloopExec st }	BspSystemSettings.State	bspSettingsState
new BspSystemSettings	BspSystemSettings	set
new MockApplication(() => {}) { val bspSettingsState: BspSystemSettings.State = { val st = new bsp.settings.BspSystemSettings.State() st.traceBsp = opts.tracePath.isDefined st.bloopPath = opts.bloopExec st } override def isUnitTestMode: Boolean = false override def getComponent[T](interfaceClass: Class[T]): T = { if (interfaceClass == classOf[VirtualFileManager]) new VirtualFileManagerImpl(Collections.singletonList(new MockLocalFileSystem())){ override def findFileByUrl(url: String): VirtualFile = null }.asInstanceOf[T] else if (interfaceClass == classOf[BspCommunicationService]) (new BspCommunicationService).asInstanceOf[T] else if (interfaceClass == classOf[BspSystemSettings]) { val set = new BspSystemSettings set.loadState(bspSettingsState) set.asInstanceOf[T] } else super.getComponent(interfaceClass) } }	MockApplication	application
try { System.setProperty("java.awt.headless", "true") val opts = parseOpts(args) opts.tracePath.fold({})(p => sys.props += ("BSP_TRACE_PATH" -> p)) val application: MockApplication = new MockApplication(() => {}) { val bspSettingsState: BspSystemSettings.State = { val st = new bsp.settings.BspSystemSettings.State() st.traceBsp = opts.tracePath.isDefined st.bloopPath = opts.bloopExec st } override def isUnitTestMode: Boolean = false override def getComponent[T](interfaceClass: Class[T]): T = { if (interfaceClass == classOf[VirtualFileManager]) new VirtualFileManagerImpl(Collections.singletonList(new MockLocalFileSystem())){ override def findFileByUrl(url: String): VirtualFile = null }.asInstanceOf[T] else if (interfaceClass == classOf[BspCommunicationService]) (new BspCommunicationService).asInstanceOf[T] else if (interfaceClass == classOf[BspSystemSettings]) { val set = new BspSystemSettings set.loadState(bspSettingsState) set.asInstanceOf[T] } else super.getComponent(interfaceClass) } } ApplicationManager.setApplication(application, () => {}) opts } catch { case e: IllegalArgumentException => System.err.println(Console.RED + "Error: " + e.getMessage) println("Usage: --bloop <path> --project <path> [--log <path>]") System.exit(1) throw e case b: Throwable => throw b }	BSPCli.Opts	opts
true	Boolean	running
new BspExecutionSettings(new File(opts.projectPath), new File(opts.bloopExec), true)	BspExecutionSettings	bspExecSettings
VirtualFileManager.getInstance()	VirtualFileManager	vfm
project.getMessageBus.connect(project)	MessageBusConnection	busConnection
withBase.groupBy(_.data.basePath).values.map(mergeModules)	IndexedSeq[BspResolverDescriptors.ModuleDescription]	mergedBase
BspCommunication.forWorkspace(new File(opts.projectPath))	BspCommunication	bspComm
new BspProjectResolver()	BspProjectResolver	resolver
((lenWritten.toDouble / f.length()) * 100).toInt	Int	percent
ProjectRootManager.getInstance(project).getFileIndex	ProjectFileIndex	fileIndex
noBase ++ mergedBase	IndexedSeq[BspResolverDescriptors.ModuleDescription]	modules
ProjectTaskManager.getInstance(project)	ProjectTaskManager	taskManager
FileTypeManager.getInstance()	FileTypeManager	fileTypes
new Launcher.Builder[BspServer]() .setRemoteInterface(classOf[BspServer]) .setExecutorService(AppExecutorUtil.getAppExecutorService) .setInput(bspIn) .setOutput(bspOut) .setLocalService(localClient) .traceMessages(bspTraceLogger) .create()	Launcher[BspSession.BspServer]	launcher
new BuildTarget( new BuildTargetIdentifier("ePzqj://jqke:540/n/ius7/jDa/t/z78"), List("bla").asJava, null, List.empty.asJava, new BuildTargetCapabilities(true,true,true) )	BuildTarget	target
launcher.getRemoteProxy	BspSession.BspServer	bspServer
new BspProcessMessageHandler(bspErr)	BspSession.this.BspProcessMessageHandler	messageHandler
new GsonBuilder().setPrettyPrinting().create()	Gson	gson
for { (id, sources) <- idToSources.toSeq dir <- sources } yield (id, dir)	IndexedSeq[(BuildTargetIdentifier, BspResolverDescriptors.SourceDirectory)]	idToSrc
params.getStatus match { case StatusCode.OK => new SuccessResultImpl() case StatusCode.CANCELLED => new SkippedResultImpl case StatusCode.ERROR => new FailureResultImpl(params.getMessage, null) case otherCode => new FailureResultImpl(s"unknown status code $otherCode", null) }	EventResult	result
sourcesItem.getSources.asScala.distinct	Seq[SourceItem]	sourceItems
StringBuilder.newBuilder	mutable.StringBuilder	builder
Arbitrary(genPath.map(_.toFile))	Arbitrary[Any]	arbFile
Arbitrary(genModuleKind)	Arbitrary[BspResolverDescriptors.ModuleKind]	arbModuleKind
Arbitrary(genModuleDescription)	Arbitrary[BspResolverDescriptors.ModuleDescription]	arbModuleDescription
30 * 1000000	Int	checkDelay
Arbitrary(genVersion)	Arbitrary[String]	arbVersion
Arbitrary(genPath)	Arbitrary[Any]	arbPath
scala.collection.mutable.HashSet[Module]()	mutable.HashSet[Module]	modulesToCompile
false	Boolean	changesSinceCompile
0	Long	lastChangeTimestamp
Arbitrary(genSourceDirectory)	Arbitrary[BspResolverDescriptors.SourceDirectory]	arbSourceDirectory
for { projectDir <- Option(vfm.findFileByUrl(base.toPath.toUri.toString)) // path.toUri is rendered with :// separator which findFileByUrl needs project <- Option(ProjectUtil.guessProjectForFile(projectDir)) cpe = CompilerProjectExtension.getInstance(project) output <- Option(cpe.getCompilerOutput) } yield new File(output.getCanonicalPath)	Option[Any]	compilerOutputDirFromConfig
nextOpt(Map(), argsArr.toList)	OptMap	args
fileIndex.getModuleForFile(file)	Module	module
new ProjectTaskNotification { override def finished(projectTaskResult: ProjectTaskResult): Unit = { if (projectTaskResult.isAborted || projectTaskResult.getErrors > 0) { // modules stay queued for recompile on next try // TODO only re-queue failed modules? requires information to be available in ProjectTaskResult } else { modulesToCompile.clear() } } }	ProjectTaskNotification { def finished(projectTaskResult: ProjectTaskResult): Unit }	notification
if (connectionDetails.nonEmpty) new GenericConnector(base, compilerOutputDir, capabilities) else if (bloopConfigDir.exists()) new BloopConnector(bspExecutionSettings.bloopExecutable, base, compilerOutputDir, capabilities) else new DummyConnector(base.toURI)	BspServerConnector	connector
new bsp4j.CompileParams(targets)	CompileParams	params
new bsp4j.TestParams(targets)	TestParams	params
new bsp4j.ScalaTestClassesParams(targets)	ScalaTestClassesParams	params
BspResolverLogic.calculateModuleDescriptions(List(target), List(), List(), List(), List())	BspResolverDescriptors.ProjectModules	descriptions
descriptions.modules.head	BspResolverDescriptors.ModuleDescription	rootModule
Cancelable { () => Cancelable.cancelAll( List( Cancelable(() => bspIn.close()), Cancelable(() => bspOut.close()), Cancelable(() => listening.cancel(true)), Cancelable(() => messageHandlerRunning.cancel(true)), Cancelable(() => cleanup()) ) ) }	Cancelable	cancelable
serverConnection.server	BspSession.BspServer	bspServer
if (isAlive) { job } else { new FailedBspSessionJob[T, A](BspException("BSP session is not available", deathReason.orNull)) }	jobs.BspSessionJob[T, A]	resultJob
sessionShutdown.future.value.flatMap { case Success(_) => None case Failure(exception) => Some(exception) }	Option[Throwable]	sessionError
Try(queueProcessor.get()) match { case Success(_) => None case Failure(exception) => Some(exception) }	Option[Throwable]	queueError
new UastSpecialExpressionKind("match")	UastSpecialExpressionKind	Match
new UastSpecialExpressionKind("case_clause")	UastSpecialExpressionKind	CaseClause
new UastSpecialExpressionKind("imports_list")	UastSpecialExpressionKind	ImportsList
filterRoots(sourceDirs)	Seq[BspResolverDescriptors.SourceDirectory]	sourceRoots
new UastSpecialExpressionKind("empty_list")	UastSpecialExpressionKind	EmptyList
filterRoots(resourceDirs)	Seq[BspResolverDescriptors.SourceDirectory]	resourceRoots
s"$msg (code ${errorObject.getCode}). Data: ${errorObject.getData}"	String	fullMessage
Option(target.getBaseDirectory) .map(_.toURI.toFile)	Option[Any]	moduleBase
scalacOptions.map(_.getClassDirectory.toURI.toFile)	Option[Any]	outputPath
scalacOptions.map(_.getClasspath.asScala.map(_.toURI.toFile))	Option[Any]	classPath
listFiles(List(workspaceConfigDir))	List[Any]	workspaceConfigs
Try(whenDone.get(sessionTimeout.toMillis, TimeUnit.MILLISECONDS))	Try[Nothing]	result
systemDependentConnectionFiles	List[Any]	systemConfigs
ShowMessage(params)	BspNotifications.ShowMessage	event
new LazyUElementImpl(() => null)	LazyUElement	Empty
LogMessage(params)	BspNotifications.LogMessage	event
thunk()	UElement	force
PublishDiagnostics(params)	BspNotifications.PublishDiagnostics	event
tryReadingConnectionFiles(workspaceConfigs ++ systemConfigs)	Seq[Try[BspConnectionDetails]]	potentialConfigs
ScUVariable.createLightVariable( isField = false, name = funDef.name, psiType = funDef.uastType(), isVal = true, containingTypeDef, modifiersList = None )	PsiLocalVariable	_lightVariable
Option(target.getData).map(_.asInstanceOf[JsonElement])	Option[JsonElement]	targetData
TaskStart(params)	BspNotifications.TaskStart	event
Option((sourcePsi match { // ========================= DECLARATIONS =============================== case file: ScalaFile => (_: LazyUElement) => new ScUFile( file, UastFacade.INSTANCE.findPlugin(file).asInstanceOf[ScalaUastLanguagePlugin] ) case e: ScImportStmt => new ScUImportStatement(e, _) case e: ScTypeDefinition => new ScUClass(e, _) case ScUVariable(parent2UField) => parent2UField(_) case e: ScMethodLike if !e.isLocal => new ScUMethod(e, _) case e: ScPrimaryConstructorWrapper => new ScUMethod(e.delegate, _) case e: ScFunctionWrapper => new ScUMethod(e.delegate, _) case e: ScParameter => new ScUParameter(e, _) case e: ScValueOrVariable => new ScUDeclarationsExpression(e, _) case e: ScFunctionDefinition if e.isLocal => ScULocalFunction .findContainingTypeDef(e) .map( tpDef => new ScULocalFunctionDeclarationExpression( e, tpDef, _: LazyUElement ) ) .orNull case e: ScTemplateBody => //noinspection ScalaUnusedSymbol (for { eb @ (_x: ScExtendsBlock) <- Option(e.getParent) nt @ (_x: ScNewTemplateDefinition) <- Option(eb.getParent) } yield new ScUAnonymousClass(nt, _: LazyUElement)).orNull case e: ScNewTemplateDefinition if e.extendsBlock.isAnonymousClass => new ScUObjectLiteralExpression(e, _) /** * [[UAnnotationUtils]]#getAnnotationEntry wants to be able * to convert constructor invocation into [[UAnnotation]] */ case ScUAnnotation.fromConstructorInvocation(scAnnotation) if requiredType == classOf[UAnnotation] => new ScUAnnotation(scAnnotation, _) case e: ScAnnotation => new ScUAnnotation(e, _) // ========================= LAMBDAS ==================================== case lambdaExpr: ScFunctionExpr => new ScULambdaExpression(lambdaExpr, _) case block: ScBlock if block.isAnonymousFunction => new ScUPartialLambdaExpression(block, _) case us: ScUnderscoreSection if us.bindingExpr.collect { case ScReference(_: PsiMethod) => }.isDefined => us.bindingExpr match { case Some(binding: ScReference) => new ScUCallableReferenceExpression(binding, _) case _ => null } case us: ScExpression if ScUnderScoreSectionUtil.isUnderscoreFunction(us) && convertLambdas => new ScUUnderscoreLambdaExpression(us, _) case mv @ MethodValue(_) if convertLambdas => mv match { case ref: ScReference => new ScUCallableReferenceExpression(ref, _) case _ => new ScUMethodValueLambdaExpression(mv, _) } // ========================= CONTROL STRUCTURES ========================= case e: ScIf => new ScUIfExpression(e, _) case e: ScWhile => new ScUWhileExpression(e, _) case e: ScDo => new ScUDoWhileExpression(e, _) case e: ScTry => new ScUTryExpression(e, _) case e: ScThrow => new ScUThrowExpression(e, _) case e: ScReturn => new ScUReturnExpression(e, _) case e: ScMatch => new ScUSwitchExpression(e, _) case e: ScCaseClauses => e.getParent match { case bl: ScBlock if bl.isInCatchBlock => null case _ => new ScUCaseClausesList(e, _) } case e: ScCaseClause => if (isInsideCatchBlock(e)) new ScUCatchExpression(e, _) else new ScUCaseClause(e, _) case e: ScBlock if e.getParent.isInstanceOf[ScCaseClause] => e.getParent match { case clause: ScCaseClause if !isInsideCatchBlock(clause) => new ScUCaseClauseBodyList(e, _) case _ => new ScUBlockExpression(e, _) } // ========================= EXPRESSION GROUPS ========================== case e: ScBlock => new ScUBlockExpression(e, _) case e: ScInfixExpr => new ScUBinaryExpression(e, _) case e: ScTypedExpression => new ScUBinaryExpressionWithType(e, _) case e: ScPostfixExpr => new ScUPostfixExpression(e, _) case e: ScPrefixExpr => new ScUPrefixExpression(e, _) case e: ScParenthesisedExpr => new ScUParenthesizedExpression(e, _) case e: ScAssignment => if (e.isNamedParameter) new ScUNamedExpression(e, _) else new ScUAssignment(e, _) // ======================== CALLS ======================================= //region Special section that converts PSI call elements to // UAST call expressions if the required type is a call expression. // Otherwise PSI visitor won't be able to find some UAST calls // because they will be converted to UQualifiedExpression's case e: ScMethodCall if requiredType == classOf[UCallExpression] => new ScUMethodCallExpression(e, _, getSourcePsi = e) case e: ScGenericCall if !e.getParent.isInstanceOf[ScMethodCall] && requiredType == classOf[UCallExpression] => new ScUGenericCallExpression(e, _, getSourcePsi = e) case funRef @ ScReferenceExpression( _: PsiMethod | _: ScSyntheticFunction ) if !funRef.getParent.isInstanceOf[ScMethodCall] && !funRef.getParent.isInstanceOf[ScGenericCall] && requiredType == classOf[UCallExpression] => new ScUReferenceCallExpression(funRef, _, getSourcePsi = funRef) //endregion case e: ScNewTemplateDefinition => //noinspection ScalaUnnecessaryParentheses e.constructorInvocation .map(c => new ScUConstructorCallExpression(c, _: LazyUElement)) .getOrElse(null) case e: ScMethodCall => e.getInvokedExpr match { case ref: ScReferenceExpression if ref.isQualified => new ScUQualifiedReferenceExpression(ref, sourcePsi = e, _) case gc: ScGenericCall => gc.referencedExpr match { case ref: ScReferenceExpression if ref.isQualified => new ScUQualifiedReferenceExpression(ref, sourcePsi = e, _) case _ => new ScUMethodCallExpression(e, _) } case _ => new ScUMethodCallExpression(e, _) } case e: ScGenericCall if !e.getParent.isInstanceOf[ScMethodCall] => e.referencedExpr match { case ref: ScReferenceExpression if ref.isQualified => new ScUQualifiedReferenceExpression(ref, sourcePsi = e, _) case _ => new ScUGenericCallExpression(e, _) } // ========================= REFERENCES ================================= case e: ScReferenceExpression if e.isQualified => e.getParent match { case mc: ScMethodCall => new ScUQualifiedReferenceExpression(e, sourcePsi = mc, _) case gc: ScGenericCall => gc.getParent match { case mc: ScMethodCall => new ScUQualifiedReferenceExpression(e, sourcePsi = mc, _) case _ => new ScUQualifiedReferenceExpression(e, sourcePsi = gc, _) } case _ => new ScUQualifiedReferenceExpression(e, _) } case funRef @ ScReferenceExpression( _: PsiMethod | _: ScSyntheticFunction ) if { funRef.getParent match { case _: ScMethodCall => false case _: ScGenericCall => false case _: ScUnderscoreSection => false case _ => true } } => new ScUReferenceCallExpression(funRef, _) case ScUReferenceExpression(parent2ScURef) => parent2ScURef(_) case e: ScTypeElement if e.getFirstChild.isInstanceOf[ScReference] => new ScUTypeReferenceExpression( e.getFirstChild.asInstanceOf[ScReference], typeProvider = Some(e), sourcePsi = e, _ ) case e: ScThisReference => new ScUThisExpression(e, _) case e: ScSuperReference => new ScUSuperExpression(e, _) // ========================= LEAF ELEMENTS ============================== case e: ScLiteral => new ScULiteral(e, _) case e: ScUnderscoreSection if e.bindingExpr.isEmpty => new ScUUnderscoreExpression(e, _) /** * Some 3-rd party UAST based inspections try to * convert [[LeafPsiElement]] representing identifier to [[UIdentifier]] */ case e: LeafPsiElement if e.getElementType == ScalaTokenTypes.tIDENTIFIER => (_: LazyUElement) => new LazyAnyUParentUIdentifier(e) // ========================= UNSUPPORTED ================================ case e: ScFor => new ScUEmptyExpressionWithGivenType(e, _) case _ => null }): LazyUElement => UElement) .map(Free.fromLazyConstructor[UElement](_))	Option[Free[UElement]]	elementOpt
free.standalone	UElement	detachedUElement
segments.mkString("/")	String	combined
TaskProgress(params)	BspNotifications.TaskProgress	event
250 - root.toString.length	Int	toTruncate
TaskFinish(params)	BspNotifications.TaskFinish	event
DidChangeBuildTarget(didChange)	BspNotifications.DidChangeBuildTarget	event
firstConvertibleAncestor(sourcePsi)	Option[UElement]	firstPossibleParent
Source.fromInputStream(input).getLines()	Iterator[String]	lines
Nil	List[BspSession.NotificationCallback]	notificationCallbacks
DummyJob	jobs.BspSessionJob[_, _]	initialJob
() => false	() => Boolean	traceLogPredicate
targetData.flatMap { data => target.getDataKind match { case BuildTargetDataKind.SCALA => targetData.flatMap(extractScalaSdkData) .map(target => getScalaSdkData(target, scalacOptions)) .map(ScalaModule) case BuildTargetDataKind.SBT => // TODO there's some disagreement on responsibility of handling sbt build data. // specifically with bloop, the main workspace is not sbt-aware, and IntelliJ would need to start separate bloop // servers for the build modules. targetData.flatMap(extractSbtData) .map { data => val (sbtModuleData, scalaSdkData) = getSbtData(data, scalacOptions) SbtModule(scalaSdkData, sbtModuleData) } case _ => Some(UnspecifiedModule()) } }	Option[BspResolverDescriptors.ModuleKind with Product with Serializable]	moduleKind
paths.map(_.toFile)	IndexedSeq[Any]	files
commonBase(files)	Option[Any]	base
5001	Int	port
files.nonEmpty ==> base.isDefined	Prop	findsBase
createModuleDescriptionData( Seq(target), tags, moduleBase, outputPath, sourceRoots, resourceRoots, classPathWithoutDependencyOutputs, dependencySourceDirs)	BspResolverDescriptors.ModuleDescriptionData	moduleDescriptionData
targets.headOption	Option[BuildTarget]	primaryTarget
content.map(_.convertToUExpressionOrEmpty(this))	IndexedSeq[UExpression]	convertedContent
null	ScUImplicitReturnExpression.this.PsiFacade	scElement
returnedElement.convertToUExpressionOrEmpty(parent = this, convertLambdas)	UExpression	getReturnExpression
lastStatement.map { it => if (ScUBlockExpression.isFunctionLastStatementWithoutReturn(it)) ScUImplicitReturnExpression .convertAndWrapIntoReturn(it, LazyUElement.just(this)) else it.convertToUExpressionOrEmpty(this) }	IndexedSeq[UExpression]	convertedLastStatement
null	ScUImplicitBlockExpression.this.PsiFacade	scElement
psiElement	PsiElement	scElement
Option(ref).collect { case it: ScReferenceExpression => it }	Option[Typeable]	typeProvider
_lightVariable	ScULocalFunction.this.PsiFacade	scElement
scExpression .`type`() .toOption match { case Some(PartialFunctionType(_, paramType)) => paramType.toPsiType case _ => createUErrorType() }	PsiType	paramPsiType
(files.size > 1) ==> files.forall { f => FileUtil.isAncestor(base.get, f, false) }	Prop	baseIsAncestor
getScalaSdkData(scalaBuildTarget, Some(scalacOptionsItem))	ScalaSdkData	data
Option((source, element, estimatedParent.orNull) match { // skips reference for methods leaving UIdentifier only // because otherwise they would have the same source psi case (_, _: UIdentifier, uParent: USimpleNameReferenceExpression) => uParent.getUastParent match { case mc: UCallExpression => mc case _ => uParent } // selects method call as a parent for method identifier case (_, _: UIdentifier, uParent: UQualifiedReferenceExpression) => uParent.getSelector // if the expression is functional its parent is // lambda of this expression case (e: ScExpression, uElement, _) if SAMUtil.isFunctionalExpression(e) && !uElement.isInstanceOf[UCallableReferenceExpression] && !uElement.isInstanceOf[ULambdaExpression] => convertWithParentTo[ULambdaExpression](e).orNull // selects method call as a parent for method arguments case (arg, _: UExpression, uParent: UQualifiedReferenceExpression) if arg.getParent.isInstanceOf[ScArgumentExprList] => uParent.getSelector // skips block for call expressions with braced arguments case (_, _: ULambdaExpression, uParent: UBlockExpression) => uParent.getUastParent match { case call: UCallExpression => call case _ => uParent } // skips catch block as a parent for catch clause case (_, _: UCatchClause, uParent: UBlockExpression) => uParent.getUastParent /** Wraps unnamed annotation args into [[ScUUnnamedExpression]] */ case (scExpr: ScExpression, uElement, uParent: UAnnotation) if !uElement.isInstanceOf[UNamedExpression] => new ScUUnnamedExpression(scExpr, LazyUElement.just(uParent)) // skips constructor invocation as an ancestor inside annotation case (_, _, constructorCall: UCallExpression) if constructorCall.getUastParent.isInstanceOf[UAnnotation] => constructorCall.getUastParent // skips type reference as an ancestor inside constructor invocation case (_, _, typeRef: UTypeReferenceExpression) if typeRef.getUastParent.isInstanceOf[UCallExpression] => typeRef.getUastParent // skips type reference as an ancestor inside annotation case (_, _, typeRef: UTypeReferenceExpression) if typeRef.getUastParent.isInstanceOf[UAnnotation] => typeRef.getUastParent // skips primary constructor as a parent for the "field" case (_, _: UField, primaryConstructor: UMethod) => primaryConstructor.getUastParent /** * As a parent for variable declaration returns * - containing class for "fields" skipping declaration expr * - containing declaration expr for local variables */ case (_: ScReferencePattern, _, declsExpr: UDeclarationsExpression) => declsExpr.getUastParent match { case cls: UClass => cls case _ => declsExpr } /** * As a parent for initializer expression returns __first__ variable * inside Scala multiple variable declaration list, e.g. * `a` in `val a, b, c = 1`. * Applies for both "fields" and local variables. * * There is a special case for local functions * @see [[ScULocalFunctionDeclarationExpression]] */ case (_, _, declsExpr: UDeclarationsExpression) => val decls = declsExpr.getDeclarations val first = if (!decls.isEmpty) decls.get(0) else null first match { case uVar: UVariable => uVar.getSourcePsi match { case fun: ScFunctionDefinition if fun.isLocal => uVar.getUastInitializer case _ => uVar } case _ => declsExpr } // skips parent when PSI parent converts to the same physical UAST element case (_, uElement, uParent) if uElement == uParent && uElement.getSourcePsi != null => uParent.getUastParent case _ => estimatedParent.orNull })	Option[UElement]	clarifiedParent
Option(sourcePsi) .flatMap(e => makeUParent(e, Free.ignoringParent[UElement](this))) .orNull	UElement	getUastParent
ModuleDescriptionData( moduleId, moduleName, targets, Seq.empty, Seq.empty, moduleBase, None, None, Seq.empty, Seq.empty, Seq.empty, Seq.empty, Seq.empty, Seq.empty, Seq.empty, Seq.empty)	BspResolverDescriptors.ModuleDescriptionData	dataBasic
calculateModuleDescriptions(buildTargets, optionsItems, sourcesItems, resourcesItems, dependencySourcesItems)	BspResolverDescriptors.ProjectModules	descriptions
for { elem <- scElement.declaredElements refPattern <- Option(elem.nameId.getParent) // does not specify parent as `this` here to allow `UField` // to skip this uDeclaration as a parent and return `UClass` instead valOrVar <- refPattern.convertWithParentTo[UDeclaration]() } yield valOrVar	IndexedSeq[UDeclaration]	declarations
for { e <- getReferencedExpr qualifiedRef <- e.convertTo[UReferenceExpression](this) } yield qualifiedRef	Option[UReferenceExpression]	receiverOpt
scElement.constructorInvocation.map( new ScUConstructorCallExpression(_, LazyUElement.Empty) )	Option[ScUConstructorCallExpression]	uConstructor
(descriptions.modules ++ descriptions.synthetic).map(_.data.id)	IndexedSeq[String]	moduleIds
parent.force	UElement	getUastParent
scExpression	ScUExpression.this.PsiFacade	scElement
(buildTargets.nonEmpty && buildTargets.exists(_.getBaseDirectory != null)) ==> descriptions.modules.nonEmpty	Prop	moduleForEveryTarget
moduleIds.size == moduleIds.distinct.size	Boolean	noDuplicateIds
element.getChildren.toSeq .filter(_.isInstanceOf[PsiComment]) .map(_.asInstanceOf[PsiComment])	IndexedSeq[PsiComment]	childrenComments
scElement	ScNamedElement	namedElement
new LightParameter(name, psiType, declarationScope)	LightParameter	tmp
psiParameter	ScULambdaParameter.this.PsiFacade	scElement
scElement.getImportStatements	Seq[ScImportStmt]	fileImports
ArrayBuffer.empty[UField]	ArrayBuffer[UField]	uFields
scElement.firstPackaging.map(_.getImportStatements).getOrElse(Seq())	Seq[ScImportStmt]	fstPackageImports
moduleDescriptionForTarget(target, scalacOptions, depSources, sources, resources, dependencyOutputs)	Option[BspResolverDescriptors.ModuleDescription]	description
ArrayBuffer.empty[UComment]	ArrayBuffer[UComment]	buf
this match { case _: UExpression => nearestCommentSibling(element)(_.getNextSibling) ++ nearestCommentSibling(element)(_.getPrevSibling) case _ => Seq.empty }	Seq[PsiComment]	nearestComments
if(tags.contains(TEST)) dataBasic.copy( targetTestDependencies = targetDeps, testOutput = outputPath, testSourceDirs = sourceRoots, testResourceDirs = resourceRoots, testClasspath = classPath, testClasspathSources = dependencySources ) else dataBasic.copy( targetDependencies = targetDeps, output = outputPath, sourceDirs = sourceRoots, resourceDirs = resourceRoots, classpath = classPath, classpathSources = dependencySources )	BspResolverDescriptors.ModuleDescriptionData	data
mergeModules(ancestors)	BspResolverDescriptors.ModuleDescription	merged
target.getBaseDirectory != null ==> description.isDefined :| "base dir defined, but not created"	Prop	definedForBaseDir
lightVariable	ScUField.this.PsiFacade	scElement
lightVariable	ScULocalVariable.this.PsiFacade	scElement
findElementByText[UAnnotation](file, "@java.lang.Deprecated")	UAnnotation	uAnnotation
new ExtensionFileNameMatcher(ScalaFileType.INSTANCE.getDefaultExtension)	ExtensionFileNameMatcher	fileNameMatcher
mutable.ArrayBuffer.empty[String]	ArrayBuffer[String]	javaModifiers
description.isDefined ==> description.get.moduleKindData.isInstanceOf[ScalaModule]	Prop	hasScalaModule
findElementByTextFromPsi[ULiteralExpression](file, "\"abc\"")	ULiteralExpression	literal1
findElementByTextFromPsi[ULiteralExpression](file, "123")	ULiteralExpression	literal2
myFixture.configureByFile(testFile.getPath)	PsiFile	psiFile
mutable.ArrayBuffer.empty[T]	ArrayBuffer[T]	matchingElements
str.lastIndexOf(delimiter)	Int	index
scElement	ScTemplateDefinition	scTemplate
psiElem.findElementAt(psiElem.getText.indexOf(refText))	PsiElement	elementAtStart
scAnonDefinition	ScTemplateDefinition	scTemplate
this	ScUAnonymousClass.this.PsiFacade	scElement
createModuleDescriptionData(Seq(target), tags, moduleBase, outputPath, sourceRoots, resourceRoots, classpath, dependencySources)	BspResolverDescriptors.ModuleDescriptionData	description
for { callExpression <- convertWithParentTo[UCallExpression](element) constructorMethod <- constructorCall.reference.map( _.resolveTo[PsiMethod] ) containingClass <- Option(constructorMethod.getContainingClass) if containingClass.getQualifiedName == fqName } yield new ResolvedConstructor( callExpression, constructorMethod, containingClass )	Option[UastLanguagePlugin#ResolvedConstructor]	resolvedConstructor
Stream .iterate(elementAtStart)( it => if (it.isInstanceOf[PsiFile]) null else it.getParent ) .takeWhile(_ != null)	Stream[PsiElement]	nonStrictParentElements
(tags.contains(BuildTargetTag.LIBRARY) || tags.contains(BuildTargetTag.APPLICATION)) ==> (description.output == outputPath && description.targetDependencies == target.getDependencies.asScala && description.classpathSources == dependencySources && description.sourceDirs == sourceRoots && description.classpath == classpath) :| s"data not correctly set for library or application tags. Result data was: $description"	Prop	p2
Option(getParentOfType(namePattern, classOf[ScMethodLike])) .forall { containingMethod => findCommonParent(containingTypeDef, containingMethod) == containingMethod }	Boolean	isField
tags.contains(BuildTargetTag.TEST) ==> (description.testOutput == outputPath && description.targetTestDependencies == target.getDependencies.asScala && description.testClasspathSources == dependencySources && description.testSourceDirs == sourceRoots && description.testClasspath == classpath) :| s"data not correctly set for test tag. Result data was: $description"	Prop	p3
description1.data	BspResolverDescriptors.ModuleDescriptionData	data1
description2.data	BspResolverDescriptors.ModuleDescriptionData	data2
c	c.type	x
mergeModules(List(description1, description2))	BspResolverDescriptors.ModuleDescription	merged
merged.data	BspResolverDescriptors.ModuleDescriptionData	data
createLightVariable( isField, namePattern.name, variableType, namePattern.isVal, containingTypeDef, Some(declarationExpr.getModifierList) )	PsiField with PsiLocalVariable	lightVariable
if (strict) nonStrictParentElements.dropWhile(!_.getText.contains(refText)) else nonStrictParentElements	Stream[PsiElement]	parentElements
ProjectModules(moduleDescriptions, Seq.empty)	BspResolverDescriptors.ProjectModules	projectModules
projectNode(projectRootPath, moduleFilesDir.toString, projectModules)	DataNode[ProjectData]	node
parentElements .flatMap(_.convertWithParentTo[T]()) .headOption .getOrElse( throw new AssertionError( s"requested text '$refText' not found as ${implicitly[ClassTag[T]]}" ) )	T	uElemContainingText
uElemContainingText.getSourcePsi	PsiElement	uElemSourcePsi
file("community")	sbt.File	scalaCommunityBase
createLightVariable( isField = true, classParam.name, fieldType, isVal = classParam.isVal, classParam.containingClass, Some(classParam.getModifierList) )	PsiField with PsiLocalVariable	lightField
q"_root_.org.jetbrains.plugins.scala.util.UIFreezingGuard"	c.universe.Tree	fqName
c	c.type	context
hasReturnStatements(c)(computation)	Boolean	needLocalFunction
false	Boolean	result
merged.data.copy( id = id, name = id, targets = targets, sourceDirs = sourceRoots, testSourceDirs = Seq.empty )	BspResolverDescriptors.ModuleDescriptionData	inheritorData
new c.universe.Traverser { override def traverse(tree: c.universe.Tree): Unit = tree match { case c.universe.Return(_) => result = true //skip local functions and classes case c.universe.DefDef(_, _, _, _, _, _) => case c.universe.ClassDef(_, _, _, _) => case c.universe.ModuleDef(_, _, _) => case _ => super.traverse(tree) } }	c.universe.Traverser { def traverse(tree: c.universe.Tree): Unit }	traverser
Value("getModificationCount")	ModCount.ModCount	getModificationCount
Value("getBlockModificationCount")	ModCount.ModCount	getBlockModificationCount
Value("anyScalaPsiModificationCount")	ModCount.ModCount	anyScalaPsiModificationCount
combined.data	BspResolverDescriptors.ModuleDescriptionData	dataCombined
next.data	BspResolverDescriptors.ModuleDescriptionData	dataNext
stringLiteral(c.freshName(name))	c.universe.Tree	uniqueId
q"_root_.org.jetbrains.plugins.scala.util.TracingLogger()"	c.universe.Tree	tracingLogger
withClassName(name)	c.universe.Tree	cacheName
paramss.flatten	List[c.universe.ValDef]	flatParams
(dataCombined.targets ++ dataNext.targets).sortBy(_.getId.getUri).distinct	IndexedSeq[BuildTarget]	targets
CachedMacroUtil.withClassName(name)(c)	c.universe.Tree	methodCallString
params(0).asInstanceOf[c.universe.Tree]	c.universe.Tree	depItem
params(1).asInstanceOf[c.universe.Tree]	c.universe.Tree	psiElement
q""" val _tracer_ = $internalTracer($uniqueId, $cacheName) _tracer_.invocation() _tracer_.calculationStart() try { $rhs } finally _tracer_.calculationEnd() """	c.universe.Tree	updatedBody
BuildRef(scalaCommunityBase.toURI)	BuildRef	communityBuild
q"""s" (" + (this.hashCode) + ")""""	c.universe.Tree	instanceMarker
modCountParamToModTracker(c)(depItem, psiElement)	c.universe.Tree	modTracker
flatParams.map(_.tpt)	IndexedSeq[c.universe.Tree]	parameterTypes
mergeBTIs(dataCombined.targetDependencies, dataNext.targetDependencies)	IndexedSeq[BuildTargetIdentifier]	targetDependencies
q"""" (" + __threadName__ + ")""""	c.universe.Tree	threadMarker
mergeBTIs(dataCombined.targetTestDependencies, dataNext.targetTestDependencies)	IndexedSeq[BuildTargetIdentifier]	targetTestDependencies
flatParams.map(_.name)	List[c.universe.TermName]	parameterNames
flatParams.nonEmpty	Boolean	hasParams
dataCombined.output.orElse(dataNext.output)	Option[Any]	output
dataCombined.testOutput.orElse(dataNext.testOutput)	Option[Any]	testOutput
q"""$methodCallString + $instanceMarker + $threadMarker"""	c.universe.Tree	methodCallMarker
q""" val __start__ = System.nanoTime() val __logger__ = $tracingLogger val __threadName__ = Thread.currentThread.getName() var __exception__ = false __logger__.log($methodCallMarker) try { $rhs } catch { case ex: Throwable => __exception__ = true throw ex } finally { val end = System.nanoTime() val tookMs = (end - __start__) / 1000 / 1000 __logger__.log($methodCallMarker + " (end)" + " (took: " + tookMs + "ms)" + (if ( __exception__ ) " (exception)" else "")) } """	c.universe.Tree	updatedBody
if (hasParams) tq"(..$parameterTypes)" else tq"Unit"	c.universe.Tree	dataType
box(c)(retTp)	c.universe.Tree	resultType
mergeSourceDirs(dataCombined.sourceDirs, dataNext.sourceDirs)	IndexedSeq[BspResolverDescriptors.SourceDirectory]	sourceDirs
DefDef(mods, name, tpParams, paramss, retTp, updatedBody)	c.universe.DefDef	updatedDef
psiElementType	c.universe.Tree	elementType
mergeSourceDirs(dataCombined.resourceDirs, dataNext.resourceDirs)	IndexedSeq[BspResolverDescriptors.SourceDirectory]	resourceDirs
mergeSourceDirs(dataCombined.testResourceDirs, dataNext.testResourceDirs)	IndexedSeq[BspResolverDescriptors.SourceDirectory]	testResourceDirs
ProjectRef(scalaCommunityBase, "scalaCommunity")	ProjectRef	scalaCommunity
mergeSourceDirs(dataCombined.testSourceDirs, dataNext.testSourceDirs)	IndexedSeq[BspResolverDescriptors.SourceDirectory]	testSourceDirs
generateTermName(name.toString, "$cachedFun")	c.universe.TermName	cachedFunName
mergeFiles(dataCombined.classpath, dataNext.classpath)	IndexedSeq[Any]	classPath
mergeFiles(dataCombined.classpathSources, dataNext.classpathSources)	IndexedSeq[Any]	classPathSources
mergeFiles(dataCombined.testClasspath, dataNext.testClasspath)	IndexedSeq[Any]	testClassPath
mergeFiles(dataCombined.testClasspathSources, dataNext.testClasspathSources)	IndexedSeq[Any]	testClassPathSources
UastContextKt.toUElement(node.getSourcePsi)	UElement	uElement
declaration.getUastAnchor	UElement	uastAnchor
valueWrapperParam(params.head)	ValueWrapper.ValueWrapper	valueWrapper
ProjectRef(scalaCommunityBase, "compiler-shared")	ProjectRef	compilerShared
params.drop(1)	List[c.universe.Tree]	buffers
ModuleDescriptionData( dataCombined.id, dataCombined.name, targets, targetDependencies, targetTestDependencies, dataCombined.basePath, output, testOutput, sourceDirs, testSourceDirs, resourceDirs, testResourceDirs, classPath, classPathSources, testClassPath, testClassPathSources)	BspResolverDescriptors.ModuleDescriptionData	newData
new ProjectData(BSP.ProjectSystemId, projectRoot.getName, projectRootPath, projectRootPath)	ProjectData	projectData
c.freshName(name)	c.universe.TermName	cacheVarName
new DataNode[ProjectData](ProjectKeys.PROJECT, projectData, null)	DataNode[ProjectData]	projectNode
generateTermName(name.toString, "$tracer")	c.universe.TermName	tracerName
new ModuleData(name, BSP.ProjectSystemId, BspSyntheticModuleType.Id, name, moduleFilesDirectoryPath, projectRootPath)	ModuleData	moduleData
new DataNode[ModuleData](ProjectKeys.MODULE, moduleData, projectNode)	DataNode[ModuleData]	moduleNode
new ContentRootData(BSP.ProjectSystemId, projectRoot.getCanonicalPath)	ContentRootData	contentRootData
ProjectRef(scalaCommunityBase, "codeInsight")	ProjectRef	codeInsight
new DataNode[ContentRootData](ProjectKeys.CONTENT_ROOT, contentRootData, moduleNode)	DataNode[ContentRootData]	contentRootDataNode
if (projectModules.modules.exists (_.data.basePath.exists(_ == projectRoot))) None else { val name = projectRoot.getName + "-root" val moduleData = new ModuleData(name, BSP.ProjectSystemId, BspSyntheticModuleType.Id, name, moduleFilesDirectoryPath, projectRootPath) val moduleNode = new DataNode[ModuleData](ProjectKeys.MODULE, moduleData, projectNode) val contentRootData = new ContentRootData(BSP.ProjectSystemId, projectRoot.getCanonicalPath) val contentRootDataNode = new DataNode[ContentRootData](ProjectKeys.CONTENT_ROOT, contentRootData, moduleNode) moduleNode.addChild(contentRootDataNode) Some(moduleNode) }	Option[DataNode[ModuleData]]	rootModule
ModuleDescriptionData(id, name, targets, targetDependencies, targetTestDependencies, basePath.map(_.toFile), output, testOutput, sourceDirs, testSourceDirs, resourceDirs, testResourceDirs, classPath, classPathSources, testClassPath, testClassPathSources)	BspResolverDescriptors.ModuleDescriptionData	data
m.data.targets.map(t => TargetId(t.getId.getUri))	IndexedSeq[BspResolverLogic.TargetId]	targetIds
toModuleNode(m)	DataNode[ModuleData]	node
projectModules.modules.map { m => val targetIds = m.data.targets.map(t => TargetId(t.getId.getUri)) val node = toModuleNode(m) targetIds -> node }	Seq[(Seq[BspResolverLogic.TargetId], DataNode[ModuleData])]	idsToTargetModule
ProjectRef(scalaCommunityBase, "scala-impl")	ProjectRef	scalaImpl
newProject("scalaUltimate", file(".")) .dependsOn( scalaCommunity % "test->test;compile->compile", SSP % "test->test;compile->compile", akka % "test->test;compile->compile", scalaJS % "test->test;compile->compile", scalaJPA % "test->test;compile->compile", scalaPlay % "test->test;compile->compile", scalaLift % "test->test;compile->compile", scalaSpring % "test->test;compile->compile", scalaCoverage % "test->test;compile->compile", scalaPlay2Jps % "test->test;compile->compile", scalaPerformanceTests % "test->test;compile->compile", scalaDuplicateDetector % "test->test;compile->compile" ) .settings( sourcesInBase := false, javacOptions ++= Seq("-source", "1.8"), packageArtifactZipFile := target.value / s"scala-intellij-bin-$pluginVersion.zip", ideExcludedDirectories := Seq(baseDirectory.value / "target"), packageLibraryMappings ++= Seq( Dependencies.nailgun -> Some("lib/jps/nailgun.jar"), Dependencies.scalaLibrary -> Some("lib/scala-library.jar") ), packageFileMappings += patchPluginXML(baseDirectory.value / "resources" / "META-INF" / "plugin.xml") -> "lib/scalaUltimate.jar!/META-INF/plugin.xml", packageMethod := PackagingMethod.Standalone(), baseDirectory in Test := baseDirectory.value / "community", definedTests in Test := { definedTests.all(ScopeFilter(inDependencies(scalaUltimate, includeRoot = false), inConfigurations(Test)) ).value.flatten } )	Project	scalaUltimate
outer.notifier	Notifier	notifier
new NotifierReporter { val notifier = outer.notifier override def export(implicit arguments: Arguments): ExecutingSpecification => ExecutedSpecification = (spec: ExecutingSpecification) => { super.export(arguments)(spec) //TODO !!! Worked in Specs2 2.9.2 - 1.12.2 // exportToOthers(arguments)(spec) spec.executed } }	Reporter	reporter
rootModule.toSeq.map(m => SynthId(m.getData.getId) -> m)	IndexedSeq[(BspResolverLogic.SynthId, DataNode[ModuleData])]	idToRootModule
generateTermName(name.toString, "map")	c.universe.TermName	mapName
generateTermName(name.toString, "element")	c.universe.TermName	elemName
projectModules.synthetic.map { m => SynthId(m.data.id) -> toModuleNode(m) }	IndexedSeq[(BspResolverLogic.SynthId, DataNode[ModuleData])]	idToSyntheticModule
generateTermName(name.toString, "guard")	c.universe.TermName	guard
generateTermName(name.toString, "$mapAndCounter")	c.universe.TermName	mapAndCounterRef
ScStubFileElementType(WorksheetLanguage.INSTANCE)	ScStubFileElementType	FileNodeType
idsToTargetModule.flatMap { case (ids,m) => ids.map(_ -> m)}	IndexedSeq[(BspResolverLogic.TargetId, DataNode[ModuleData])]	idToTargetModule
WorksheetFileType	WorksheetFileType.type	fileType
(idToRootModule ++ idToTargetModule ++ idToSyntheticModule).toMap	Map[BspResolverLogic.DependencyId, DataNode[ModuleData]]	idToModuleMap
generateTermName(name.toString, "data")	c.universe.TermName	dataName
_	Boolean	excludeInDialectSources
calculateModuleDependencies(projectModules)	Seq[BspResolverLogic.ModuleDep]	moduleDeps
getScalaSettings	ScalaCodeStyleSettings	settings
generateTermName(name.toString, "defaultValue")	c.universe.TermName	defValueName
generateTermName(name.toString, "computedValue")	c.universe.TermName	computedValue
generateTermName(name.toString, "$valueAndCounter")	c.universe.TermName	timestampedDataRef
0	Int	PRE_TEST_LOOP
1	Int	POST_TEST_LOOP
generateTermName(name.toString, "key")	c.universe.TermName	keyVarName
newProjectWithIdea("play", file("play")) .dependsOn(scalaPlay2Jps, scalaImpl % "compile->compile;test->test;test->compile") .settings( ideaInternalPlugins ++= Seq("JavaScriptLanguage", "CSS"), addCompilerPlugin(Dependencies.macroParadise) )	Project	scalaPlay
newProjectWithIdea("scala-play-2-jps", file("play/scala-play-2-jps")) .dependsOn(compilerShared) .settings(packageMethod := PackagingMethod.Standalone("lib/scala-play-2-jps-plugin.jar"))	Project	scalaPlay2Jps
Comments()	IntermediateNode.Comments	comments
newProjectWithIdea("coverage", file("coverage")) .dependsOn(scalaImpl)	Project	scalaCoverage
new ArrayBuffer[IntermediateNode]()	ArrayBuffer[IntermediateNode]	children
new ArrayBuffer[IntermediateNode]	ArrayBuffer[IntermediateNode]	beforeStatements
inProject	ProjectContext	ctx
newProjectWithIdea("performanceTests", file("performanceTests")) .dependsOn(scalaImpl) .settings(ideaInternalPlugins ++= Seq("performanceTesting"))	Project	scalaPerformanceTests
newProjectWithIdea("duplicateDetector", file("duplicateDetector")) .dependsOn(scalaImpl)	Project	scalaDuplicateDetector
newProjectWithIdea("jpa", file("jpa")) .dependsOn(scalaImpl)	Project	scalaJPA
defaultFileName(WorksheetFileType)	String	fileName
newProjectWithIdea("lift", file("lift")) .dependsOn(scalaImpl)	Project	scalaLift
flatParams.map(_.name)	IndexedSeq[c.universe.TermName]	paramNames
flatParams.nonEmpty	Boolean	hasParameters
newProjectWithIdea("spring", file("spring")) .dependsOn(scalaImpl)	Project	scalaSpring
new ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	result
mutable.ArrayBuffer.empty[(IntermediateNode, Option[String])]	ArrayBuffer[(IntermediateNode, Option[String])]	buffer
element.getFirstChild	PsiElement	child
element.getLastChild	PsiElement	child
element.getPrevSibling	PsiElement	prev
new ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	resultComments
element.getNextSibling	PsiElement	next
generateTermName(name.toString, "holder")	c.universe.TermName	holderName
Seq(ModifierType.PUBLIC, ModifierType.PRIVATE, ModifierType.PROTECTED, ModifierType.PACKAGE_LOCAL)	Seq[ModifierType.Value]	accessModifiers
newProjectWithIdea("akka", file("akka")) .dependsOn( codeInsight % "compile->compile;test->test", scalaImpl % "test;compile;test->test" )	Project	akka
new ArrayBuffer[ModifierType]()	ArrayBuffer[ModifierType.ModifierType]	withoutList
LocalFileSystem.getInstance.refreshAndFindFileByPath(file.getCanonicalPath)	VirtualFile	fileOnFilesystem
collectCommentsAndSpacesBefore(element).reverse	ArrayBuffer[PsiElement]	innerComments
newProjectWithIdea("ssp", file("ssp")) .dependsOn(scalaImpl % "test;compile;test->test")	Project	SSP
collectCommentsAtStart(element)	ArrayBuffer[PsiElement]	result
make()	Seq[String]	messages
new ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	buffer
calculateSyntheticDependencies(moduleDeps, projectModules)	IndexedSeq[BspResolverLogic.ModuleDep]	synthDeps
"WorksheetLibrary"	String	name
idToModuleMap.values.toSet	Set[DataNode[ModuleData]]	modules
tq"$concurrentMapTypeFqn[(..${flatParams.map(_.tpt)}), _root_.scala.Some[$retTp]]"	c.universe.Tree	mapType
getParts(inType.toScType(paramTopLevel = true), buffer)	IntermediateNode	result
TypeConstruction(ctx.typeSystem.presentableText(des, withPrefix = textMode))	IntermediateNode	typeConstruction
collectCommentsAndSpacesAfter(element, buffer)	ArrayBuffer[PsiElement]	result
VfsUtil.findFileByURL(url)	VirtualFile	rootFile
methodName match { case "this" => methodName case _ => ScalaNamesUtil.escapeKeyword(methodName) }	String	escapedName
generateTermName(name.toString, "result")	c.universe.TermName	resultName
moduleDescription.data	BspResolverDescriptors.ModuleDescriptionData	moduleDescriptionData
LiteralExpression(escapedName)	LiteralExpression	identifier
getAllBeforeComments(element)	ArrayBuffer[LiteralExpression]	before
"org.jetbrains.plugins.scala.worksheet.MacroPrinter"	String	CLASS_NAME
getAllAfterComments(element)	ArrayBuffer[LiteralExpression]	after
newProjectWithIdea("js",file("js")) .dependsOn(scalaImpl % "test;compile;test->test") .settings( ideaInternalPlugins += "JavaScriptLanguage", ideaInternalPlugins += "JavaScriptDebugger")	Project	scalaJS
q""" new _root_.scala.volatile() private val $mapAndCounterRef: $atomicReferenceTypeFQN[$timestampedTypeFQN[$mapType]] = new $atomicReferenceTypeFQN($timestampedFQN(null, -1L)) """	c.universe.Tree	fields
collectCommentsAtTheEnd(element)	ArrayBuffer[PsiElement]	latest
receiver match { case null => identifier case qualifier => QualifiedExpression(qualifier, identifier) }	IntermediateNode with Product with Serializable	method
args.map(getParts(_, buffer))	IndexedSeq[IntermediateNode]	argsOnLevel
TypeConstruction(ctx.typeSystem.presentableText(otherType, withPrefix = textMode))	IntermediateNode	typeConstruction
createRunnerProject(scalaUltimate, "idea-runner-ultimate")	Project	ideaRunnerUltimate
Seq.empty[(IntermediateNode, Option[String])]	Seq[(IntermediateNode, Option[String])]	associationMap
Set( JavaErrorMessages.message("expected.semicolon"), JavaErrorMessages.message("expected.rbrace") )	Set[Nothing]	javaAllowedErrors
Set( ScalaBundle.message("rbrace.expected"), ScalaBundle.message("semi.expected") )	Set[Nothing]	scalaAllowedErrors
valueWrapper match { case ValueWrapper.None => retTp case ValueWrapper.WeakReference => tq"_root_.java.lang.ref.WeakReference[$retTp]" case ValueWrapper.SoftReference => tq"_root_.java.lang.ref.SoftReference[$retTp]" case ValueWrapper.SofterReference => tq"_root_.com.intellij.util.SofterReference[$retTp]" }	c.universe.Tree	wrappedRetTp
q""" def getOrUpdateMap() = { val timestampedMap = $mapAndCounterRef.get if (timestampedMap.modCount < currModCount) { $mapAndCounterRef.compareAndSet(timestampedMap, $timestampedFQN($createNewMap, currModCount)) } $mapAndCounterRef.get.data } """	c.universe.Tree	getOrUpdateMapDef
generateTermName(name.toString, "cachedFun")	c.universe.TermName	cachedFunName
javaFile.getProject	Project	project
new ArrayBuffer[String]	ArrayBuffer[String]	failedToResolveNames
moduleDescriptionData.basePath.map { path => val base = path.getCanonicalPath new ContentRootData(BSP.ProjectSystemId, base) }	Option[ContentRootData]	moduleBase
new ArrayBuffer[String]	ArrayBuffer[String]	alreadyResolvedNames
if (dir.generated) SOURCE_GENERATED else SOURCE	ExternalSystemSourceType	sourceType
moduleDescriptionData.sourceDirs.map { dir => val sourceType = if (dir.generated) SOURCE_GENERATED else SOURCE (sourceType, dir) }	IndexedSeq[(ExternalSystemSourceType, BspResolverDescriptors.SourceDirectory)]	sourceRoots
if (hasParams) q"(..$parameterNames)" else q"()"	c.universe.Tree	dataValue
CopyPasteManager.getInstance	CopyPasteManager	copyPasteManager
moduleDescriptionData.resourceDirs.map { dir => (RESOURCE, dir) }	IndexedSeq[(ExternalSystemSourceType, BspResolverDescriptors.SourceDirectory)]	resourceRoots
if (dir.generated) TEST_GENERATED else TEST	ExternalSystemSourceType	sourceType
'\n'	Char	lineSeparator
buffersToAddTo.map { buffer => q"$buffer += $mapName" }	IndexedSeq[c.universe.Tree]	addToBuffers
moduleDescriptionData.testSourceDirs.map { dir => val sourceType = if (dir.generated) TEST_GENERATED else TEST (sourceType, dir) }	IndexedSeq[(ExternalSystemSourceType, BspResolverDescriptors.SourceDirectory)]	testRoots
moduleDescriptionData.testResourceDirs.map { dir => (TEST_RESOURCE, dir) }	IndexedSeq[(ExternalSystemSourceType, BspResolverDescriptors.SourceDirectory)]	testResourceRoots
new ImportClassFix(reference)	ImportClassFix	importClassFix
q""" new _root_.scala.volatile() private val $timestampedDataRef: $atomicReferenceTypeFQN[$timestampedTypeFQN[$retTp]] = new $atomicReferenceTypeFQN($timestampedFQN(${defaultValue(c)(retTp)}, -1L)) """	c.universe.Tree	fields
(sourceRoots ++ testRoots ++ resourceRoots ++ testResourceRoots).toSet	Set[(ExternalSystemSourceType, BspResolverDescriptors.SourceDirectory)]	allSourceRoots
moduleDescriptionData.name	String	moduleName
new ModuleData(moduleDescriptionData.id, BSP.ProjectSystemId, StdModuleTypes.JAVA.getId, moduleName, moduleFilesDirectoryPath, projectRootPath)	ModuleData	moduleData
new LibraryData(BSP.ProjectSystemId, s"$moduleName dependencies")	LibraryData	libraryData
new LibraryDependencyData(moduleData, libraryData, LibraryLevel.MODULE)	LibraryDependencyData	libraryDependencyData
new LibraryData(BSP.ProjectSystemId, s"$moduleName test dependencies")	LibraryData	libraryTestData
new LibraryDependencyData(moduleData, libraryTestData, LibraryLevel.MODULE)	LibraryDependencyData	libraryTestDependencyData
new DataNode[LibraryDependencyData](ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData, moduleNode)	DataNode[LibraryDependencyData]	libraryDependencyNode
if (hasParams) q"$cachesUtilFQN.getOrCreateCachedMap[$elemName.type, $dataType, $resultType]($elemName, $keyVarName, () => $modTracker)" else q"$cachesUtilFQN.getOrCreateCachedRef[$elemName.type, $resultType]($elemName, $keyVarName, () => $modTracker)"	c.universe.Tree	getOrCreateCachedHolder
new DataNode[LibraryDependencyData](ProjectKeys.LIBRARY_DEPENDENCY, libraryTestDependencyData, moduleNode)	DataNode[LibraryDependencyData]	libraryTestDependencyNode
q""" def $cachedFunName(): $retTp = $rhs val currModCount = $modTracker.getModificationCount() val $tracerName = $internalTracer($keyId, $cacheName) $tracerName.invocation() val timestamped = $timestampedDataRef.get if (timestamped.modCount == currModCount) timestamped.data else { val stackStamp = $recursionManagerFQN.markStack() $tracerName.calculationStart() val computed = try { $cachedFunName } finally { $tracerName.calculationEnd() } if (stackStamp.mayCacheNow()) { $timestampedDataRef.compareAndSet(timestamped, $timestampedFQN(computed, currModCount)) $timestampedDataRef.get.data } else computed } """	c.universe.Tree	updatedRhs
file.depthFirst().instancesOf[PsiErrorElement].toList	List[PsiErrorElement]	errorElements
file match { case _: ScalaFile => scalaAllowedErrors case _ => javaAllowedErrors }	Set[Nothing]	allowedMessages
directory.createFile(fileName).asInstanceOf[ScalaFile]	ScalaFile	file
if (hasParameters) { q""" private val $mapName = new java.util.concurrent.ConcurrentHashMap[(..${flatParams.map(_.tpt)}), $wrappedRetTp]() ..$addToBuffers """ } else { q""" new _root_.scala.volatile() private var $cacheVarName: $wrappedRetTp = null.asInstanceOf[$wrappedRetTp] """ }	c.universe.Tree	fields
PsiDocumentManager.getInstance(project)	PsiDocumentManager	documentManager
if (hasParams) q"$holderName.get($dataName)" else q"$holderName.get()"	c.universe.Tree	getFromHolder
ApplicationManager.getApplication.isUnitTestMode && !TextJavaCopyPastePostProcessor.insideIde || !hasTextBlockTransferableData(content)	Boolean	isPlainTextCopy
new DataNode[ContentRootData](ProjectKeys.CONTENT_ROOT, data, moduleNode)	DataNode[ContentRootData]	contentRootDataNode
ScalaProjectSettings.getInstance(project)	ScalaProjectSettings	settings
file.findElementAt(a)	PsiElement	e
if (hasParams) q"$holderName.putIfAbsent($dataName, $resultName)" else q"$holderName.compareAndSet(null, $resultName)"	c.universe.Tree	updateHolder
moduleDescriptionData.targets.map(_.getId.getUri.toURI)	IndexedSeq[Any]	targetIds
withUIFreezingGuard(c)(rhs, retTp)	c.universe.Tree	actualCalculation
DefDef(mods, name, tpParams, paramss, retTp, updatedRhs)	c.universe.DefDef	updatedDef
startOffsets.zip(endOffsets).forall { case (a, b) => val e = file.findElementAt(a) e.isInstanceOf[PsiElement] && e.getLanguage.isKindOf(ScalaLanguage.INSTANCE) && e.getNode != null && e.getNode.getElementType == ScalaTokenTypes.tSTRING && a > e.getTextRange.getStartOffset && b < e.getTextRange.getEndOffset }	Boolean	literal
valueWrapper match { case ValueWrapper.None => q"$computedValue" case ValueWrapper.WeakReference => q"new _root_.java.lang.ref.WeakReference($computedValue)" case ValueWrapper.SoftReference => q"new _root_.java.lang.ref.SoftReference($computedValue)" case ValueWrapper.SofterReference => q"new _root_.com.intellij.util.SofterReference($computedValue)" }	c.universe.Tree	wrappedResult
editor.getSelectionModel.getSelectionStart	Int	offset
file.findElementAt(offset)	PsiElement	e
if(e.getNode == null) null else e.getNode.getElementType	IElementType	elementType
q""" ..$fields $updatedDef """	c.universe.Tree	res
if (hasReturnStatements(c)(actualCalculation)) q"$cachedFunName()" else q"$actualCalculation"	c.universe.Tree	computation
generateTermName(name.toString, "dataForGuard")	c.universe.TermName	dataForGuardName
BspMetadata(targetIds.asJava)	BspMetadata	metadata
new DataNode[BspMetadata](BspMetadata.Key, metadata, moduleNode)	DataNode[BspMetadata]	metadataNode
if (valueWrapper == ValueWrapper.None) q"$cacheVarName" else { q""" if ($cacheVarName == null) null else $cacheVarName.get() """ }	c.universe.Tree	getFromCache
q""" ..${if (hasParameters) getValuesFromMap else EmptyTree} val $tracerName = $internalTracer($keyId, $cacheName) $tracerName.invocation() val resultFromCache = $getFromCache if (resultFromCache == null) { $tracerName.calculationStart() val $computedValue = try { $rhs } finally { $tracerName.calculationEnd() } assert($computedValue != null, "Cached function should never return null") $storeValue $computedValue } else resultFromCache """	c.universe.Tree	functionContents
moduleDescription.data.targetDependencies.map((_, DependencyScope.COMPILE))	IndexedSeq[(BuildTargetIdentifier, DependencyScope)]	compileDeps
DefDef(mods, name, tpParams, paramss, retTp, functionContents)	c.universe.DefDef	updatedDef
moduleDescription.data.targetTestDependencies.map((_, DependencyScope.TEST))	IndexedSeq[(BuildTargetIdentifier, DependencyScope)]	testDeps
moduleDependencies.groupBy(_.parent)	Map[BspResolverLogic.DependencyId, Seq[BspResolverLogic.ModuleDep]]	dependencyByParent
SynthId(moduleDescription.data.id)	BspResolverLogic.SynthId	synthId
if (hasParams) q"$cachesUtilFQN.getOrCreateCachedMap[$elementType, $dataType, $resultType]($elemName, $keyVarName, () => $modTracker)" else q"$cachesUtilFQN.getOrCreateCachedRef[$elementType, $resultType]($elemName, $keyVarName, () => $modTracker)"	c.universe.Tree	getOrCreateCachedHolder
TargetId(synthParent.getId.getUri)	BspResolverLogic.TargetId	parentId
dependencyByParent.getOrElse(parentId, Seq.empty)	Seq[BspResolverLogic.ModuleDep]	parentDeps
Value("None")	ValueWrapper.ValueWrapper	None
Value("SoftReference")	ValueWrapper.ValueWrapper	SoftReference
Value("WeakReference")	ValueWrapper.ValueWrapper	WeakReference
Value("SofterReference")	ValueWrapper.ValueWrapper	SofterReference
parentDeps.map { d => ModuleDep(synthId, d.child, d.scope, export = false)}	IndexedSeq[BspResolverLogic.ModuleDep]	inheritedDeps
q""" def $cachedFunName(): $retTp = $actualCalculation val $tracerName = $internalTracer($keyId, $cacheName) $tracerName.invocation() val $dataName = $dataValue val $keyVarName = ${getOrCreateKey(c, hasParams)(q"$keyId", dataType, resultType)} val $elemName = $elem val $holderName = $getOrCreateCachedHolder val fromCachedHolder = $getFromHolder if (fromCachedHolder != null) return fromCachedHolder val stackStamp = $recursionManagerFQN.markStack() $tracerName.calculationStart() val $resultName = try { $computation } finally { $tracerName.calculationEnd() } if (stackStamp.mayCacheNow()) { $updateHolder } $resultName """	c.universe.Tree	updatedRhs
ModuleDep(parentId, synthId, DependencyScope.COMPILE, export = true)	BspResolverLogic.ModuleDep	parentSynthDependency
new ModuleDependencyData(parent.getData, child.getData)	ModuleDependencyData	data
new DataNode[ModuleDependencyData](ProjectKeys.MODULE_DEPENDENCY, data, parent)	DataNode[ModuleDependencyData]	node
moduleNode.getData	ModuleData	moduleData
new LibraryData(BSP.ProjectSystemId, ScalaSdkData.LibraryName)	LibraryData	scalaSdkLibrary
new LibraryDependencyData(moduleData, scalaSdkLibrary, LibraryLevel.MODULE)	LibraryDependencyData	scalaSdkLibraryDependencyData
new UpdateHolderGenerator[c.type](c) { override def apply(resultName: c.universe.TermName): c.universe.Tree = if (hasParams) q"$holderName.putIfAbsent($dataName, $resultName)" else q"$holderName.compareAndSet(null, $resultName)" }	CachedMacroUtil.UpdateHolderGenerator[c.type] { def apply(resultName: this.c.universe.TermName): this.c.universe.Tree }	updateHolder
new DataNode[LibraryDependencyData](ProjectKeys.LIBRARY_DEPENDENCY, scalaSdkLibraryDependencyData, moduleNode)	DataNode[LibraryDependencyData]	scalaSdkLibraryNode
new DataNode[ScalaSdkData](ScalaSdkData.Key, scalaSdkData, moduleNode)	DataNode[ScalaSdkData]	scalaSdkNode
new DataNode[SbtBuildModuleDataBsp](SbtBuildModuleDataBsp.Key, sbtData, moduleNode)	DataNode[SbtBuildModuleDataBsp]	sbtNode
if (hasParams) tq"($elementType, $dataType)" else tq"$elementType"	c.universe.Tree	dataForGuardType
convert(javaFile, javaCodeWithContext.context, project)	String	convertedText
javaFile.getTextLength	Int	javaFileLen
mutable.HashSet.empty[LiteralExpression]	mutable.HashSet[LiteralExpression]	printedComments
new PrintWithComments()	PrintWithComments	visitor
getMarginChar(literal)	Char	marginChar
if (hasParams) q"($elemName, $dataName)" else q"$elemName"	c.universe.Tree	dataForRecursionGuard
withUIFreezingGuard(c)(rhs, retTp)	c.universe.Tree	guardedCalculation
handleProbablyRecursiveException(c)(elemName, dataName, keyVarName, guardedCalculation)	c.universe.Tree	withProbablyRecursiveException
file.findElementAt(offset1)	PsiElement	possibleComment
doCaching(c)(withProbablyRecursiveException, resultName, guard, dataForGuardName, updateHolder)	c.universe.Tree	withCaching
!literal.textContains('\n')	Boolean	isOneLine
doPreventingRecursion(c)(withCaching, guard, dataForGuardName, retTp)	c.universe.Tree	cachedCalculationWithAllTheChecks
getMarginChar(element)	Char	marginChar
mutable.StringBuilder.newBuilder	mutable.StringBuilder	printer
correspondedConstructorParams	Seq[PsiParameter]	params
mutable.HashMap.empty.withDefaultValue(TextRange.create(0, 0))	mutable.Map[IntermediateNode, TextRange]	nodesToRanges
new mutable.HashSet[PsiElement]()	mutable.HashSet[PsiElement]	dropElements
collectTopElements( begin, end, javaFile ).filterNot(el => el.isInstanceOf[PsiImportList] || el.isInstanceOf[PsiPackageStatement])	Array[PsiElement]	elementsToConvert
startOffsets.zip(endOffsets).map { case (startOffset, endOffset) => TextRange.create(startOffset, endOffset) }	IndexedSeq[TextRange]	ranges
startOffsets.headOption.getOrElse(0)	Int	shift
mutable.ArrayBuffer.empty[Part]	ArrayBuffer[ConverterUtil.Part]	buffer
attributes.iterator	Iterator[(Option[IntermediateNode], Option[IntermediateNode])]	iterator
file.findElementAt(offset)	PsiElement	elem
referenceProcessor.collectTransferableData(file, editor, startOffsets, endOffsets) match { case dataList if dataList.isEmpty => Seq.empty case dataList => val shift = startOffsets.headOption.getOrElse(0) dataList.get(0).getData.map { it => new ReferenceData( it.startOffset + shift, it.endOffset + shift, it.qClassName, it.staticMemberName ) } }	Seq[ReferenceData]	data
findElem(startOffset)	PsiElement	elem
new RestoreReferencesDialog(project, bindingsToRestore.map(_.path.toOption.getOrElse("")).sorted.toArray)	RestoreReferencesDialog	dialog
primaryConstructor.get.asInstanceOf[PrimaryConstruction]	PrimaryConstruction	pc
usage.getParent match { case ae: PsiAssignmentExpression if (ae.getOperationSign.getTokenType == JavaTokenType.EQ) && ae.getRExpression.isInstanceOf[PsiReferenceExpression] => Option(ae.getRExpression.asInstanceOf[PsiReferenceExpression]).flatMap(e => Option(e.resolve())) case _ => None }	Option[PsiElement]	rightPart
dialog.getSelectedElements	Array[Nothing]	selectedPaths
mutable.ListBuffer.empty[AssociationHelper]	ListBuffer[JavaToScala.AssociationHelper]	associationsHelper
element.hasModifierProperty(PsiModifier.FINAL)	Boolean	possibleVal
text.indexOf('\n') >= 0	Boolean	isPastedTextMultiline
JavaToScala.convertPsisToText(elementsToConvert, textMode = true)	String	scalaFileText
element.hasModifierProperty(PsiModifier.PUBLIC) || element.hasModifierProperty(PsiModifier.PROTECTED)	Boolean	possibleVar
new MainConstruction	MainConstruction	resultNode
CodeWithContext(text, FileContext())	TextJavaCopyPastePostProcessor.this.CodeWithContext	asFile
members.collect { case el: EnumConstruction => el }	IndexedSeq[EnumConstruction]	enumConstants
CodeWithContext(text, ClassContext())	TextJavaCopyPastePostProcessor.this.CodeWithContext	asClass
Seq("eq", "ne")	Seq[Nothing]	specialOperations
params.asInstanceOf[ParameterListConstruction].list.collect { case p: ParameterConstruction => p }.map(_.name)	Seq[IntermediateNode]	pNames
LangDataKeys.PSI_ELEMENT_ARRAY.getData(e.getDataContext)	Array[PsiElement]	elements
findVariableUsage(element, parent).filter((el: PsiReferenceExpression) => PsiUtil.isAccessedForWriting(el))	Seq[PsiReferenceExpression]	references
CodeWithContext(text, BlockContext())	TextJavaCopyPastePostProcessor.this.CodeWithContext	asBlock
CommonDataKeys.PSI_FILE.getData(e.getDataContext)	PsiFile	file
CodeWithContext(text, ExpressionContext())	TextJavaCopyPastePostProcessor.this.CodeWithContext	asExpression
true	Boolean	insideIde
!startsWithChar(text.trim, marginChar)	Boolean	marginIsMissing
marginIsMissing && startsFromNewLine	Boolean	needMargin
if (needMargin) marginChar else ""	Char	marginPrefix
j.getContainingDirectory	PsiDirectory	dir
q""" val $elemName = $element val $dataName = $dataValue val $dataForGuardName = $dataForRecursionGuard val $keyVarName = ${getOrCreateKey(c, hasParams)(q"$keyId", dataType, resultType)} def $defValueName: $resultType = $defaultValue val $tracerName = $internalTracer($keyId, $cacheName) $tracerName.invocation() val $holderName = $getOrCreateCachedHolder val fromCachedHolder = $getFromHolder if (fromCachedHolder != null) return fromCachedHolder val $guard = $recursionGuardFQN[$dataForGuardType, $resultType]($keyVarName.toString) if ($guard.checkReentrancy($dataForGuardName)) return $cachesUtilFQN.handleRecursiveCall($elemName, $dataName, $keyVarName, $defValueName) $tracerName.calculationStart() try { val ($resultName, shouldCacheLocally) = $cachedCalculationWithAllTheChecks if (shouldCacheLocally) { $guard.cacheInLocalCache($dataForGuardName, $resultName) } $resultName } finally { $tracerName.calculationEnd() } """	c.universe.Tree	updatedRhs
for { f <- Option(file) if requiresMarginProcess(f) offset = editor.getCaretModel.getOffset element = file.findElementAt(offset) literal <- findMultilineStringParent(element) selection = editor.getSelectionModel if literal.contentRange.containsRange(selection.getSelectionStart, selection.getSelectionEnd) } yield { val isOneLine = !literal.textContains('\n') if (isOneLine && settings(file).MULTILINE_STRING_INSERT_MARGIN_ON_ENTER) { val marginChar = getMarginChar(element) val isPastedTextMultiline = text.indexOf('\n') >= 0 if(isPastedTextMultiline){ ensureLiteralHasStripMargin(editor, literal, marginChar) addMargins(text, marginChar) } else { text } } else if (MultilineStringUtil.looksLikeUsesMargins(literal)) { val marginChar = getMarginChar(element) val marginIsMissing = !startsWithChar(text.trim, marginChar) val startsFromNewLine = StringUtil.isEmptyOrSpaces(linePrefix(editor.getDocument, offset)) val needMargin = marginIsMissing && startsFromNewLine val marginPrefix = if (needMargin) marginChar else "" marginPrefix + addMargins(text, marginChar) } else { text } }	Option[String]	result
if (marginChar == '|') "" else s"('$marginChar')"	String	stripMarginParams
document.getLineStartOffset(document.getLineNumber(offset))	Int	lineStartOffset
new TextRange(lineStartOffset, offset)	TextRange	range
shiftedElement(elem, dropElements, endOffset)	PsiElement	shifted
convertPsiToIntermediate(element, null)(associationsHelper, data, dropElements, textMode = false)	IntermediateNode	result
modifiers.collect { case m: Modifier if !modifiersConstruction.accessModifiers.contains(m.modificator) => m } ++ modifiers.collect { case m: Modifier if modifiersConstruction.accessModifiers.contains(m.modificator) => m }	IndexedSeq[IntermediateNode with Modifier]	sortModifiers
jFile.getContainingDirectory	PsiDirectory	dir
jFile.getContainingDirectory	PsiDirectory	directory
name + ".scala"	String	nameWithExtension
visitors.PrintWithComments(resultNode)	PrintWithComments	visitor
TypeConstruction.createIntermediateTypePresentation(t, project)	IntermediateNode	iNode
directory.getVirtualFile.findChild(nameWithExtension)	VirtualFile	existingFile
disjunctionTypeConstructions.parts.iterator	Iterator[IntermediateNode]	iterator
directory.createFile(name + ".scala")	PsiFile	file
MainConstruction()	MainConstruction	m
Seq(JavaTokenType.PUBLIC_KEYWORD, JavaTokenType.PROTECTED_KEYWORD, JavaTokenType.PRIVATE_KEYWORD, JavaTokenType.STATIC_KEYWORD, JavaTokenType.ABSTRACT_KEYWORD, JavaTokenType.FINAL_KEYWORD, JavaTokenType.NATIVE_KEYWORD, JavaTokenType.SYNCHRONIZED_KEYWORD, JavaTokenType.STRICTFP_KEYWORD, JavaTokenType.TRANSIENT_KEYWORD, JavaTokenType.VOLATILE_KEYWORD, JavaTokenType.DEFAULT_KEYWORD)	Seq[IElementType]	drop
inElem	PsiElement	elem
escapeKeyword(name)	String	cname
nameOpt .map { case n@("this" | "super") => n case b => escapeKeyword(b) } .getOrElse("")	String	escapedName
seq.iterator	Iterator[IntermediateNode]	it
".java"	String	fromLangExtension
".scala"	String	fromLangExtension
_	ScalaCodeStyleSettings	oldSettings
Option(s.getLockExpression).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	lock
Option(s.getBody).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	body
Option(i.getCondition).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	condition
".txt"	String	fromLangExtension
Option(i.getThenBranch).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	thenBranch
s""" |import java.io.File; | |${Start}public class AnonymousClass { | File file = new File("super"); |}$End """.stripMargin	String	fromText
s"${Start}new double[]{1.0, 2, 3};$End"	String	fromText
Option(i.getElseBranch).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	elseBranch
s""" |import java.io.File; | |${Start}public class Test { | File[] array = new File[23]; |}$End """.stripMargin	String	fromText
Option(javaFile.findElementAt(startOffset)) .map(e => Iterator(e) ++ e.parentsInFile) .getOrElse(Iterator.empty) .dropWhile(parentIsValid)	Iterator[PsiElement]	parentAtOffset
parentAtOffset.next()	PsiElement	elem
Option(c.getCondition).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	condition
s""" |${Start}assert true : "Invocation of 'paste' operation for specific caret is not supported";$End """.stripMargin	String	fromText
Option(c.getThenExpression).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	thenBranch
s"""assert(true, "Invocation of 'paste' operation for specific caret is not supported")""".stripMargin	String	expected
s""" |import java.util.ArrayList; |import java.util.List; | |${Start}public class Test { | List<Integer> list = new ArrayList<Integer>(); |}$End """.stripMargin	String	fromText
Option(c.getElseExpression).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	elseBranch
s""" |${Start}public void doExecute() { | assert true : "Invocation of 'paste' operation for specific caret is not supported"; |}$End """.stripMargin	String	fromText
s"""object Test { | val x = 1$Start;$End |}""".stripMargin	String	from
s"""$Start//comment before |package qwert; | |import java.util.ArrayList; |import java.util.HashSet; |import java.util.List; |import java.util.Set; | | |public class Test { | List<Integer> list = new ArrayList<Integer>(); | | private static class Inner { | void foo() { | Set<String> st = new HashSet<>(); | } | } |}$End""".stripMargin	String	fromText
Option(w.getCondition).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	condition
s"""object Test2 { | 1$Caret |}""".stripMargin	String	to
s""" |${Start}int i = 6; |boolean a = false; |String s = "false";$End """.stripMargin	String	fromText
Option(w.getBody).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	body
s"""public class Test { | public static int number = 42; | | public static int number2 = ${Start}Test.number$End; |} |""".stripMargin	String	fromText
PsiDocumentManager.getInstance(file.getProject).getDocument(file)	Document	document
s"(${Start}1, 2, 3$End)"	String	from
CodeStyleManager.getInstance(file.getProject)	CodeStyleManager	manager
s""" |${Start}import java.io.File; |public class Main { | int func() { | int qwe = 34; | Boolean b = true; | File f = new File("sdf"); | return 21; | } |}$End """.stripMargin	String	fromText
s""" |abstract class ScalaClass { | if (true) { | $Caret | } else { | | } |}""".stripMargin	String	toText
CodeStyle.getSettings(file.getProject).getCommonSettings(ScalaLanguage.INSTANCE)	CommonCodeStyleSettings	settings
settings.KEEP_BLANK_LINES_IN_CODE	Int	keep_blank_lines_in_code
settings.KEEP_BLANK_LINES_IN_DECLARATIONS	Int	keep_blank_lines_in_declarations
settings.KEEP_BLANK_LINES_BEFORE_RBRACE	Int	keep_blank_lines_before_rbrace
s""" |${Start}class Test { | public static void main(String[] args) { | System.out.println("hello") | System.out.println(" how are you?"); | } |}$End """.stripMargin	String	fromText
CodeInsightSettings.getInstance	CodeInsightSettings	settings
s""" |abstract class ScalaClass { | if (true) { | Test.number | } else { | | } |}""".stripMargin	String	expected
settings.REFORMAT_ON_PASTE	Int	oldReformat
s"""object Test { | ($Caret) |}""".stripMargin	String	to
CountingLoop.from(f)	CountingLoop	countingLoop
elem.withNextSiblings .takeWhile(elem => elem != null && elem.getTextRange.getEndOffset < endOffset) .map(_.getNextSibling) .filter(el => el != null && el.isValid) .toArray	Array[PsiElement]	topElements
s"""${Start}Arrays.asList("peter", "anna", "mike", "xenia");$End""".stripMargin	String	fromText
s"""public class Test { | ${Start}public static int number = 42;$End | | public static int number2 = Test.number; |} |""".stripMargin	String	fromText
s"""'''${Start}first line | second line | third line | $End'''.stripMargin |""".stripMargin	String	from
Option(f.getBody).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	body
s""" |abstract class ScalaClass { | "$Caret" |}""".stripMargin	String	toText
s""" |class Test { | ${Start}public static void main(String[] args) { | System.out.println("hello"); | System.out.println(" how are you?"); $End |} """.stripMargin	String	fromText
convertPsiToIntermediate(countingLoop.getCounter.getNameIdentifier, externalProperties)	IntermediateNode	name
s"""'''${Start}first line | second line | third line$End | '''.stripMargin |""".stripMargin	String	from
s""" |abstract class ScalaClass { | "public static int number = 42;" |}""".stripMargin	String	expected
s""" |${Start}public class Salary extends Employee { | private double salary; |}$End |""".stripMargin	String	fromText
s"""'''${Start}first line | | second line | | third line | |$End'''.stripMargin |""".stripMargin	String	from
s"""public class Test { | ${Start}public static int number = 42; |$End | public static int number2 = Test.number; |} |""".stripMargin	String	fromText
s""" |abstract class Employee { | private String name; |} | |$Caret""".stripMargin	String	toText
RangeExpression( convertPsiToIntermediate(countingLoop.getInitializer, externalProperties), convertPsiToIntermediate(countingLoop.getBound, externalProperties), countingLoop.isIncluding, countingLoop.isDescending)	RangeExpression	iteratedValue
s"""'''${Start}first line | | second line | | third line$End | |'''.stripMargin |""".stripMargin	String	from
problem.getFixes.collect { case f: LocalQuickFixOnPsiElement => f }	IndexedSeq[LocalQuickFixOnPsiElement]	fixes
s""" |abstract class ScalaClass { | $qqq$Caret$qqq |}""".stripMargin	String	toText
Option(f.getInitialization).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	initialization
new ProblemsHolder(InspectionManager.getInstance(project), file, false)	ProblemsHolder	holder
s"""s'''${Start}first line | | second line | | third line | |$End'''.stripMargin |""".stripMargin	String	from
associationsHelper.collect { case AssociationHelper(itype: TypedElement, path) => Association(path, visitor(itype.getType)) } ++ associationsHelper.collect { case AssociationHelper(itype, path) => Association(path, visitor(itype)) }	IndexedSeq[Association]	updatedAssociations
visitor()	String	text
s""" |abstract class ScalaClass { | ${qqq}public static int number = 42; | |$qqq.stripMargin |}""".stripMargin	String	expected
Some(f.getCondition match { case _: PsiEmptyStatement => LiteralExpression("true") case null => LiteralExpression("true") case _ => convertPsiToIntermediate(f.getCondition, externalProperties) })	Some[IntermediateNode]	condition
settings.ScalaProjectSettings.getInstance(getProjectAdapter)	ScalaProjectSettings	projectSettings
s"""s'''${Start}first line | | second line | | third line$End | |'''.stripMargin |""".stripMargin	String	from
projectSettings.isAddOverrideToImplementInConverter	Boolean	oldValue
Option(f.getUpdate).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	update
s"""'''${Start}first line | | second line$End | | third line | |'''.stripMargin |""".stripMargin	String	from
LanguageLevelProjectExtension.getInstance(getProject)	LanguageLevelProjectExtension	projectExtension
projectExtension.getLanguageLevel	LanguageLevel	oldLevel
getTextBetweenOffsets(file, startOffsets, endOffsets)	String	oldText
Option(a.getAssertCondition).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	condition
(new RemoveRedundantReturnInspection).buildVisitor(holder, isOnTheFly = false)	PsiElementVisitor	removeReturnVisitor
s"""'''green yellow | | red blue $Caret | | orange | |'''.stripMargin |""".stripMargin	String	to
Option(a.getAssertDescription).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	description
s"""'''green yellow | | red blue first line | | second line | | orange | |'''.stripMargin |""".stripMargin	String	after
scalaSig.get(index)	Entry	entry
(new ScalaUnnecessaryParenthesesInspection).buildVisitor(holder, isOnTheFly = false)	PsiElementVisitor	parenthesisedExpr
s"""s'''${Start}first line | | second line$End | | third line | |'''.stripMargin |""".stripMargin	String	from
ConvertedCode( updatedAssociations.toArray, text, compareTextNEq(oldText, text) )	ConverterUtil.ConvertedCode	result
folderPath + getTestName(false) + ".java"	String	filePath
(new ScalaUnnecessarySemicolonInspection).buildVisitor(holder, isOnTheFly = false)	PsiElementVisitor	removeSemicolon
s"""s'''green yellow | | red blue $Caret | | orange | |'''.stripMargin |""".stripMargin	String	to
s"Error parsing scala signature of $fileName"	String	message
false	Boolean	initialized
(new ReferenceMustBePrefixedInspection).buildVisitor(holder, isOnTheFly = false)	PsiElementVisitor	addPrefix
s"""s'''green yellow | | red blue first line | | second line | | orange | |'''.stripMargin |""".stripMargin	String	after
createIndex()	Array[Int]	index
ArrayBuffer.empty[ClassSymbol]	ArrayBuffer[ClassSymbol]	classes
ArrayBuffer.empty[ObjectSymbol]	ArrayBuffer[ObjectSymbol]	objects
new Array[Entry](index.length)	Array[Entry]	entries
new ScalaSig(entries)	ScalaSig	scalaSig
ArrayBuffer.empty[SymAnnot]	ArrayBuffer[SymAnnot]	symAnnots
readByte()	Int	tag
readIndex	Int	savedIdx
readNat()	Int	ref
mutable.HashMap.empty[Int, ArrayBuffer[Symbol]]	mutable.HashMap[Int, ArrayBuffer[Symbol]]	parentToChildren
objectSymbol.symbolInfo.owner.get	Symbol	owner
readNameRef()	Ref[Name]	name
readSymbolRef()	Ref[Symbol]	owner
readNat()	Int	flags
objectSymbol.name	String	name
symAnnots.filter(sameSymbol)	ArrayBuffer[SymAnnot]	forSameSymbol
if (s.isDefaultCase) Seq(LiteralExpression("_")) else Option(s.getCaseValues) .map(it => it.getExpressions.toSeq.map(convertPsiToIntermediate(_, externalProperties))) .getOrElse(Seq.empty)	Seq[IntermediateNode]	caseValues
LocalFileSystem.getInstance.findFileByPath(filePath.replace(File.separatorChar, '/'))	VirtualFile	file
s match { case rs: PsiSwitchLabeledRuleStatement => Option(rs.getBody) case _ => None }	Option[PsiStatement]	body
startOffsets.zip(endOffsets).sortWith(_._1 < _._1)	IndexedSeq[(Int, Int)]	textGaps
bounds.getStartOffset	Int	start
bounds.getEndOffset	Int	end
Option(s.getExpression).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	expr
s"""'''green yellow | red blue $Caret | orange | '''.stripMargin |""".stripMargin	String	to
hasQuoteAt(start - 1) && hasQuoteAt(end)	Boolean	isInsideStringLiteral
tryReadRef(isSymbolTag, Ref.to[Symbol], end)	Option[Ref[Symbol]]	privateWithin
readTypeRef()	Ref[Type]	typeInfo
readEnd()	Int	end
forSameSymbol.map(ann => ann.typeRef -> ann).toMap.values	Iterable[SymAnnot]	distinctTypes
s"""'''green yellow | red blue first line | second line | third line | orange | '''.stripMargin |""".stripMargin	String	after
Option(f.getIteratedValue).flatMap((e: PsiExpression) => Option(e.getType))	Option[PsiType]	tp
parentToChildren.getOrElseUpdate(ref.index, ArrayBuffer.empty)	ArrayBuffer[Symbol]	children
getFileAdapter	PsiFile	javaFile
52	Int	SUPERtpe2
if (tp.isEmpty) true else !tp.get.isInstanceOf[PsiArrayType]	Boolean	isJavaCollection
ClassSymbol(readSymbolInfo(end), tryReadTypeRef(end))	ClassSymbol	clazz
javaFile.findElementAt(javaFile.getText.length - 1)	PsiElement	lastPsi
Option(f.getIteratedValue).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	iteratedValue
ObjectSymbol(readSymbolInfo(end))	ObjectSymbol	obj
37	Int	LITERALsymbol
parent match { case Some(NoSymbol) | None => name case Some(sym) => s"${sym.path}.$name" }	String	path
symbolInfo.name.get.value.trim	String	name
s"""'''green yellow | red blue first line | second line | third line | | orange | '''.stripMargin |""".stripMargin	String	after
nameRef.value	String	name
ConverterUtil.collectTopElements(startOffset, endOffset, javaFile)	Array[PsiElement]	buf
convertPsiToIntermediate(f.getIterationParameter.getNameIdentifier, externalProperties)	IntermediateNode	name
s"wrong type of reference at index $index, expected: $expName, actual: $actName"	String	message
0	Int	readIndex
bytes(readIndex).toInt	Int	x
0L	Long	b
0L	Long	x
Option(r.getParameterList).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	args
if (textMode && r.getQualifier == null) r.resolve() match { case clazz: PsiClass => ScalaPsiUtil.nameWithPrefixIfNeeded(clazz) case _ => r.getReferenceName } else r.getReferenceName	String	nameWithPrefix
if (externalProperties.isInstanceOf[WithReferenceExpression]) { fieldParameterMap.getOrElse(r.getReferenceName, nameWithPrefix) } else { nameWithPrefix }	String	name
JavaToScala.convertPsisToText(buf, getUsedComments(offset, endOffset, lastPsi, javaFile))	String	res
{ val nameWithPrefix: String = if (textMode && r.getQualifier == null) r.resolve() match { case clazz: PsiClass => ScalaPsiUtil.nameWithPrefixIfNeeded(clazz) case _ => r.getReferenceName } else r.getReferenceName val name: String = if (externalProperties.isInstanceOf[WithReferenceExpression]) { fieldParameterMap.getOrElse(r.getReferenceName, nameWithPrefix) } else { nameWithPrefix } Option(name) }	Option[String]	refName
s"""s'''${Start}first line | second line | third line$End | '''.stripMargin |""".stripMargin	String	from
tag match { case TYPEsym => TypeSymbol(readSymbolInfo(end)) case ALIASsym => AliasSymbol(readSymbolInfo(end)) case CLASSsym => val clazz = ClassSymbol(readSymbolInfo(end), tryReadTypeRef(end)) scalaSig.addClass(clazz) clazz case MODULEsym => val obj = ObjectSymbol(readSymbolInfo(end)) scalaSig.addObject(obj) obj case VALsym => MethodSymbol(readSymbolInfo(end), tryReadSymbolRef(end)) case _ => errorBadSignature("bad symbol tag: " + tag) }	SymbolInfoSymbol with Product with Serializable	symbol
64 - (len << 3)	Int	leading
tryReadSymbolRef(end)	Option[Ref[Symbol]]	owner
readIndex	Int	savedIndex
readIndex	Int	startIdx
op()	T	result
tag == EXTMODCLASSref	Boolean	isObject
readNat()	Int	size
readNat()	Int	len
readSymbolRef()	Ref[Symbol]	sym
readTypeRef()	Ref[Type]	info
new Array[Int](size)	Array[Int]	index
readNat()	Int	major
readNat()	Int	minor
JavaCodeReferenceStatement(None, args, refName)	JavaCodeReferenceStatement	iResult
s"""'''green yellow | | red blue first line | | second line | | third line | | orange | |'''.stripMargin |""".stripMargin	String	after
Option(r.getQualifierExpression).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	t
"Lscala/reflect/ScalaSignature;"	String	SCALA_SIG_ANNOTATION
"Lscala/reflect/ScalaLongSignature;"	String	SCALA_LONG_SIG_ANNOTATION
Set.empty	Set[TypeBoundsType]	visitedTypeBoundsType
new mutable.HashMap[Symbol, String]()	mutable.HashMap[Symbol, String]	currentTypeParameters
s"${t.name}_$$_$index"	String	nameWithIndex
s"""'''green yellow | | red blue | | orange | | $Caret'''.stripMargin |""".stripMargin	String	to
mutable.HashSet.empty[PsiElement]	mutable.HashSet[PsiElement]	usedComments
javaFile.findElementAt(startOffset)	PsiElement	startComment
javaFile.findElementAt(endOffset)	PsiElement	endComment
Logger.getInstance("#org.jetbrains.plugins.scala.decompiler.DecompilerUtil")	Logger	Log
s"""'''green yellow | | red blue | | orange | | first line | | second line | | third line'''.stripMargin |""".stripMargin	String	after
verbosity match { case ShowAll => true case HideClassPrivate => !isClassPrivate case HideInstancePrivate => !isInstancePrivate }	Boolean	accessibilityOk
!filterFirstCons	Boolean	firstConsFiltered
{ symbol match { case sym: SymbolInfoSymbol => sym.symbolInfo.privateWithin match { case Some(t: Ref[Symbol]) => Some("[" + processName(t.get.name) + "]") case _ => None } case _ => None } }	Option[String]	privateWithin
(startOffsets, endOffsets).zipped.map((a, b) => charSequence.substring(a, b))	IndexedSeq[Any]	selections
if (!c.isTrait) getPrinterByConstructor(c) else ""	String	defaultConstructor
until(end, () => tryReadRef(isConstAnnotArgTag, Ref.to[ConstAnnotArg], end)).flatten	List[Ref[ConstAnnotArg]]	args
c.infoType	Type	it
new ScalaSigPrinter(new StringBuilder(), verbosity)	ScalaSigPrinter	printer
f.containingClass	PsiClass	clazz
until(end, () => (readNameRef(), readConstantAnnotArgRef()))	List[(Ref[Name], Ref[ConstAnnotArg])]	namedArgs
s"""class A { | '''green yellow | | red blue | orange | $Caret'''.stripMargin |} |""".stripMargin	String	to
printer.result	String	res
o.symbolInfo.owner.get.name	String	poName
s"""class A { | '''green yellow | | red blue | orange | |first line | | second line | | third line'''.stripMargin |} |""".stripMargin	String	after
Option(clazz.getNameIdentifier).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	name
new ClassParser(new ByteArrayInputStream(bytes), fileName).parse()	JavaClass	parsed
selections.zipWithIndex.map(p => new Attachment("Selection-%d.java".format(p._2 + 1), p._1))	IndexedSeq[Attachment]	attachments
s"""class A { | '''green yellow | | red blue | | orange | $Caret''' |} |""".stripMargin	String	to
Option(p.getQualifier).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	qualifier
s"""class A { | '''green yellow | | red blue | | orange | |first line | | second line | | third line''' |} |""".stripMargin	String	after
SbtProcessManager.forProject(project).acquireShellRunner()	SbtShellRunner	shell
SymAnnot(sym, info, args, namedArgs)	SymAnnot	annot
Option(p.getParameterList).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	args
until(end, readConstantAnnotArgRef _)	List[Ref[ConstAnnotArg]]	args
Array.concat(strings: _*)	Array[Byte]	bytes
readNat()	Int	pflagsHi
readNat()	Int	pflagsLo
new ScalaSigPrinter(new StringBuilder, false)	ScalaSigPrinter	printer
(pflagsHi.toLong << 32) + pflagsLo	Long	pflags
symbol.path	String	path
s"""s'''green yellow | | red blue | | orange | | $Caret'''.stripMargin |""".stripMargin	String	to
scala.reflect.internal.Flags.pickledToRawFlags(pflags)	Long	flags
readNameRef()	Ref[Name]	privateWithin
s"""s'''green yellow | | red blue | | orange | | first line | | second line | | third line'''.stripMargin |""".stripMargin	String	after
s"""object Main extends App { | val js = | s''' | function myFunc() { |$Start debugger; |$End } | ''' |}""".stripMargin	String	from
processName(ms.name) + " : " + toString(ms.infoType)(TypeFlags(true))	String	nameAndType
msymb.name	String	methodName
s"""object Main extends App { | val js = | s''' | function myFunc() { | debugger; |$Caret | } | ''' |}""".stripMargin	String	to
c.children.filter { case ms: MethodSymbol if ms.isParamAccessor && ms.name.startsWith(methodName) => true case _ => false }	Seq[Symbol]	paramAccessors
s"""object Main extends App { | val js = | s''' | function myFunc() { | debugger; | debugger; | | } | ''' |}""".stripMargin	String	after
scalaSig.topLevelClasses ++ scalaSig.topLevelObjects	IndexedSeq[SymbolInfoSymbol with Product with Serializable]	symbols
0	Int	wordStartIdx
0	Int	innerIdx
s"""s'''${Start}first line | second line$End | '''.stripMargin |""".stripMargin	String	from
s"""s'''${Start}green yellow$End | | $Caret'''.stripMargin |""".stripMargin	String	to
SbtShellCommunication.forProject(e.getProject)	SbtShellCommunication	comms
s"""s'''first line | | second line$Caret | | '''.stripMargin |""".stripMargin	String	after
new CustomShortcutSet(end)	CustomShortcutSet	shortcuts
associations.toSeq.zipMapped { dependency => editor.getDocument.createRangeMarker(dependency.range.shiftRight(bounds.getStartOffset)) }	Seq[(Association, RangeMarker)]	markedAssociations
externalData.name	String	keyPart
Option(PsiTreeUtil.getParentOfType(l, classOf[PsiCodeBlock], classOf[PsiBlockStatement]))	Option[Nothing]	parent
getTemplatePresentation	Presentation	templatePresentation
if (parent.isEmpty) false else isVar(l, parent)	Boolean	needVar
new CustomShortcutSet(ctrlD)	CustomShortcutSet	shortcuts
s"""s''$Start'green yellow$End | | $Caret'''.stripMargin |""".stripMargin	String	to
association.copy(range = new TextRange(marker.getStartOffset - bounds.getStartOffset, marker.getEndOffset - bounds.getStartOffset))	Association	movedAssociation
Option(l.getInitializer).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	initalizer
convertPsiToIntermediate(l.getNameIdentifier, externalProperties)	IntermediateNode	name
inWriteAction { performePaste(editor, bounds, text, project) val markedAssociations = associations.toSeq.zipMapped { dependency => editor.getDocument.createRangeMarker(dependency.range.shiftRight(bounds.getStartOffset)) } CodeStyleManager.getInstance(project) .reformatText(file, bounds.getStartOffset, bounds.getStartOffset + text.length) markedAssociations.map { case (association, marker) => val movedAssociation = association.copy(range = new TextRange(marker.getStartOffset - bounds.getStartOffset, marker.getEndOffset - bounds.getStartOffset)) marker.dispose() movedAssociation } }	IndexedSeq[Association]	shiftedAssociations
s"""s''first line | second line$Caret | | '''.stripMargin |""".stripMargin	String	after
new RemoteConfigurationType	RemoteConfigurationType	configType
isSelected(e)	Boolean	active
s"""s$Start'''first line | | second line | |'''.stripMargin$End |""".stripMargin	String	from
s"""s'''green yellow | | $Caret'''.stripMargin |""".stripMargin	String	to
s"""s'''green yellow | | \\\"\\\"\\\"first line | | | second line | | |\\\"\\\"\\\".stripMargin$Caret'''.stripMargin |""".stripMargin	String	after
paramAccessors.exists(acc => isSetterFor(acc.name, methodName))	Boolean	isMutable
handleModifierList(f)	IntermediateNode	modifiers
paramAccessors.find(m => !m.isPrivate || !m.isLocal)	Option[Symbol]	toPrint
RunManager.getInstance(project)	RunManager	runManager
isVar(f, Option(f.getContainingClass))	Boolean	needVar
s"""s'''green yellow | $Caret''' |""".stripMargin	String	to
toolWindow.getContentManager	ContentManager	twContentManager
s"""s'''green yellow | \\\"\\\"\\\"first line | | second line | |\\\"\\\"\\\".stripMargin$Caret''' |""".stripMargin	String	after
runManager.createConfiguration(configName, configType)	RunnerAndConfigurationSettings	rc
processName(methodName) + " : " + toString(msymb.infoType)(TypeFlags(true))	String	nameAndType
Option(f.getInitializer).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	initalizer
findRunConfig .getOrElse { val rc = runManager.createConfiguration(configName, configType) rc.setTemporary(true) rc.setActivateToolWindowBeforeRun(false) rc.getConfiguration.setAllowRunningInParallel(false) runManager.setTemporaryConfiguration(rc) rc }	RunnerAndConfigurationSettings	runConfig
convertPsiToIntermediate(f.getNameIdentifier, externalProperties)	IntermediateNode	name
s"""${Start}first line | second line$End |""".stripMargin	String	from
runConfig.getConfiguration.asInstanceOf[RemoteConfiguration]	RemoteConfiguration	settings
Seq( "compile", "test", "console", "clean", "update", "updateClassifiers", "updateSbtClassifiers", "products", "publish", "publishLocal", "consoleProject")	Seq[Nothing]	tasks
Seq("libraryDependencies", "baseDirectory", "sourceDirectory", "unmanagedBase", "target")	Seq[Nothing]	settings
convertPsiToIntermediate(m.getNameIdentifier, externalProperties)	IntermediateNode	name
s"""'''$Caret''' |""".stripMargin	String	to
Seq("run", "runMain", "testOnly")	Seq[Nothing]	inputs
Seq("help", "reload", "plugins", "settings", "project", "projects")	Seq[Nothing]	commands
TokenSet.create(TokenType.WHITE_SPACE)	TokenSet	WhiteSpaces
mt.paramSymbols.map({ case ms: MethodSymbol => pe(ms) case _ => "^___^" })	IndexedSeq[String]	paramEntries
new IFileElementType("sbt shell file", SbtShellLanguage)	IFileElementType	File
s"""'''first line | second line$Caret''' |""".stripMargin	String	after
Option(p.getExpression).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	expr
pt.paramSymbols	Seq[Symbol]	typeParams
ExecutionEnvironmentBuilder.create(DefaultDebugExecutor.getDebugExecutorInstance, runConfig)	ExecutionEnvironmentBuilder	environmentBuilder
m.name	String	n
ExecutionManager.getInstance(project)	ExecutionManager	executionManager
method.getReturnType	PsiType	returnType
processName(name)	String	nn
annot.getParameterList.getAttributes	Array[PsiNameValuePair]	attributes
m.isFinal && keywords.startsWith("val")	Boolean	isConstantValueDefinition
tasks ++ settings ++ inputs ++ commands	IndexedSeq[Nothing]	all
!m.isDeferred && (m.parent match { case Some(c: ClassSymbol) if refinementClass(c) => false case _ => true })	Boolean	printBody
s"""'''first line | | second line$Caret'''.stripMargin |""".stripMargin	String	after
mutable.ArrayBuffer[(Option[IntermediateNode], Option[IntermediateNode])]()	ArrayBuffer[(Option[IntermediateNode], Option[IntermediateNode])]	attrResult
toString(attrib.typeRef, "@")	String	prefix
s"""'''$Caret'''.stripMargin |""".stripMargin	String	to
attrib.args.map(annotArgText)	IndexedSeq[String]	argTexts
SbtProcessManager.forProject(project)	SbtProcessManager	process
s"""'''$Caret |''' |""".stripMargin	String	to
s"""'''first line | second line$Caret |''' |""".stripMargin	String	after
new SbtShellExecuteActionHandler(getProcessHandler)	SbtShellRunner.this.SbtShellExecuteActionHandler	myConsoleExecuteActionHandler
None	Option[SbtProcessManager.ProcessData]	processData
attrib.namedArgs.map { case (name, value) => s"${processName(name)} = ${annotArgText(value)}" }	IndexedSeq[String]	namedArgsText
new ProjectTaskResult(false, 0, 0)	ProjectTaskResult	defaultResult
SbtProcessManager.forProject(project) .acquireShellProcessHandler()	ColoredProcessHandler	myProcessHandler
super.createConsoleActions()	Array[AnAction]	defaultActions
thisSymbol.name match { case "package" => thisSymbol.symbolInfo.owner match { case Ref(ex: ExternalSymbol) => processName(ex.name) case _ => "this" } case name if thisSymbol.isModule => processName(name) case name => processName(name) + ".this" }	String	thisSymbolName
s"""'''$Caret |'''.stripMargin |""".stripMargin	String	to
BuildInfo.sbtStructureVersion	String	sbtStructureVersion
Option(attribute.getValue) match { case Some(v: PsiAnnotationMemberValue) if isArrayAnnotationParameter(attribute) => ArrayInitializer(Seq(convertPsiToIntermediate(v, externalProperties))) case Some(_) => convertPsiToIntermediate(attribute.getValue, externalProperties) case _ => null }	IntermediateNode	value
s"""'''first line | | second line$Caret |'''.stripMargin |""".stripMargin	String	after
BuildInfo.sbtIdeaShellVersion	String	sbtIdeaShellVersion
s"""s'''$Caret''' |""".stripMargin	String	to
toString(typeRef, level)	String	typeRefString
SettingQueryHandler.bufferedListener(this)	((ProjectTaskResult, SbtShellCommunication.ShellEvent) => ProjectTaskResult) { val successPrefix : Nothing var strings : ListBuffer[String] def apply(res: ProjectTaskResult, se: SbtShellCommunication.ShellEvent): ProjectTaskResult var collectInfo : Boolean val filterPrefix : Nothing def getBufferedOutput: String }	listener
(sbtProjectUri, sbtProjectName) match { case (Some(uri), Some(project)) => def quoted(s: String): String = '"' + s + '"' s"$settingName.in(ProjectRef(uri(${quoted(uri)}), ${quoted(project)}))${taskName.map(" in " + _).getOrElse("")}" case (None, Some(project)) => s"$settingName in $project${taskName.map(" in " + _).getOrElse("")}" case _ => settingName }	String	settingIn
SettingQueryHandler.getProjectIdPrefix(sbtProjectUri, sbtProjectName) + taskName.map(_ + ":").getOrElse("*:") + settingName	String	settingColon
s"""s'''first line | second line$Caret''' |""".stripMargin	String	after
List(SettingQueryHandler.getProjectIdPrefix(None, sbtProjectName) + taskName.map(_ + ":").getOrElse("") + settingName, SettingQueryHandler.getProjectIdPrefix(None, sbtProjectName) + "*" + taskName.map(_ + ":").getOrElse("") + settingName)	Seq[String]	settingValuePrefixes
new CommandListener(default, eventHandler)	CommandListener[A]	listener
new EventAggregator[ProjectTaskResult]() { override def apply(v1: ProjectTaskResult, v2: ShellEvent): ProjectTaskResult = v1 }	((ProjectTaskResult, SbtShellCommunication.ShellEvent) => ProjectTaskResult) { def apply(v1: ProjectTaskResult, v2: SbtShellCommunication.ShellEvent): ProjectTaskResult }	emptyListener
SbtShellConsoleView(project, debugConnection)	SbtShellConsoleView	cv
ListBuffer[String]()	ListBuffer[String]	strings
true	Boolean	collectInfo
getConsoleView	SbtShellConsoleView	consoleView
new StringBuilder()	StringBuilder	res
consoleView.getHistoryViewer	EditorEx	editor
Option(annot.getNameReferenceElement).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	name
CompilerIndicesSettings(project).isBytecodeIndexingActive	Boolean	compilerIndicesEnabled
handleModifierList(p)	IntermediateNode	modifiers
convertPsiToIntermediate(p.getNameIdentifier, externalProperties)	IntermediateNode	name
s"""s'''first line | | second line$Caret'''.stripMargin |""".stripMargin	String	after
BuildInfo.sbtIdeaCompilerIndicesVersion	String	pluginVersion
process.acquireShellProcessHandler()	ColoredProcessHandler	handler
new SbtShellReadyListener( whenReady = shellQueueReady.release(), whenWorking = () )	SbtShellReadyListener	stateChanger
createToolWindowContent(consoleView)	Content	content
convertTypePsiToIntermediate(p.getType, p.getTypeElement, p.getProject)	IntermediateNode	`type`
(builder, e) => e match { case TaskStart | TaskComplete | ErrorWaitForInput => builder case Output(text) => builder.append("\n").append(text) }	SbtShellCommunication.EventAggregator[StringBuilder]	messageAggregator
s"""s'''$Caret'''.stripMargin |""".stripMargin	String	to
RunnerLayoutUi.Factory.getInstance(project)	RunnerLayoutUi.Factory	factory
convertTypePsiToIntermediate(n.getType, n.getClassReference, n.getProject)	IntermediateNode	iType
if (n.getArgumentList != null) { if (n.getArgumentList.getExpressions.isEmpty) { n.getParent match { case r: PsiJavaCodeReferenceElement if n == r.getQualifier => Seq(LiteralExpression("()")) case _ => null } } else { Seq(convertPsiToIntermediate(n.getArgumentList, externalProperties)) } } else null	Seq[IntermediateNode]	argList
Promise[A]()	Promise[A]	promise
factory.create("sbt-shell-toolwindow-runner", "", "session", project)	RunnerLayoutUi	layoutUi
new DefaultActionGroup	DefaultActionGroup	group
mutable.ArrayBuffer[(String, IntermediateNode)]()	ArrayBuffer[(String, IntermediateNode)]	resourcesVariables
defaultActions.find(_.isInstanceOf[ToggleUseSoftWrapsToolbarAction]) .getOrElse(throw new RuntimeException("action of type `ToggleUseSoftWrapsToolbarAction` couldn't be found"))	AnAction	toggleSoftWrapsAction
false	Boolean	readyState
s"""s'''$Caret | ''' |""".stripMargin	String	to
defaultActions.find(_.isInstanceOf[ClearConsoleAction]) .getOrElse(throw new RuntimeException("action of type `ClearConsoleAction` couldn't be found"))	AnAction	clearAllAction
new StartAction(project)	StartAction	startAction
s"""s'''first line | second line$Caret | ''' |""".stripMargin	String	after
new StopAction(project)	StopAction	stopAction
new DebugShellAction(project, debugConnection)	DebugShellAction	debugShellAction
new SbtShellScrollToTheEndToolbarAction(getEditor)	SbtShellScrollToTheEndToolbarAction	scrollToTheEndToolbarAction
promptReady(line) || (readyState && debuggerMessage(line))	Boolean	sbtReady
new EOFAction(project)	EOFAction	eofAction
new StringBuilder	StringBuilder	builder
new SigIntAction(project)	SigIntAction	sigIntAction
resourceList.iterator	Iterator[Char]	it
s"""s'''$Caret | '''.stripMargin |""".stripMargin	String	to
it.next()	Char	next
s"""s'''first line | | second line$Caret | '''.stripMargin |""".stripMargin	String	after
Array( startAction, stopAction, debugShellAction, scrollToTheEndToolbarAction, toggleSoftWrapsAction, clearAllAction, eofAction, sigIntAction )	Array[AnAction]	allActions
new SbtShellConsoleView(project, debugConnection)	SbtShellConsoleView	cv
s"""'''abc $Caret''' |""".stripMargin	String	to
s"""'''abc first line | second line$Caret''' |""".stripMargin	String	after
new PatternHyperlinkFormat(fileWithLinePattern, false, false, null, PATH, LINE)	PatternHyperlinkFormat	fileWithLineFormat
new PatternHyperlinkFormat(fileOnlyPattern, false, false, null, PATH)	PatternHyperlinkFormat	fileOnlyFormat
new PatternBasedFileHyperlinkRawDataFinder(Array(fileWithLineFormat, fileOnlyFormat))	PatternBasedFileHyperlinkRawDataFinder	dataFinder
Option(t.getTryBlock) .map((f: PsiCodeBlock) => f.getStatements.map(convertPsiToIntermediate(_, externalProperties)).toSeq) .getOrElse(Seq.empty)	Seq[IntermediateNode]	tryBlock
s"""'''abc first line | | second line$Caret'''.stripMargin |""".stripMargin	String	after
IdeFocusManager.getInstance(cv.getProject)	IdeFocusManager	focusManager
ContentFactory.SERVICE.getInstance.createContent(layoutComponent, "sbt-shell-toolwindow-content", true)	Content	content
s"""'''abc $Caret'''.stripMargin |""".stripMargin	String	to
new ConsoleHistoryController(SbtShellRootType, null, getConsoleView)	ConsoleHistoryController	historyController
t.getCatchSections.map((cb: PsiCatchSection) => (convertPsiToIntermediate(cb.getParameter, externalProperties), convertPsiToIntermediate(cb.getCatchBlock, externalProperties)))	IndexedSeq[(IntermediateNode, IntermediateNode)]	catches
builder.result().trimRight	String	line
builder.result()	String	lineSoFar
task.getModule.getProject	Project	project
compilerIndicesEnabled.seq { val pluginVersion = BuildInfo.sbtIdeaCompilerIndicesVersion s"""addSbtPlugin("org.jetbrains" % "sbt-idea-compiler-indices" % "$pluginVersion")""" }	Seq[String]	compilerIndicesPlugin
buildLine(text)	Option[String]	ready
Option(t.getFinallyBlock).map((f: PsiCodeBlock) => f.getStatements.map(convertPsiToIntermediate(_, externalProperties)).toSeq)	Option[Seq[IntermediateNode]]	finallys
s"""s'''abc $Caret''' |""".stripMargin	String	to
s"""s'''abc first line | second line$Caret''' |""".stripMargin	String	after
SbtSettings.getInstance(project).getLinkedProjectSettings(module)	Option[SbtProjectSettings]	projectSettings
Option(s.getStatement).map(convertPsiToIntermediate(_, externalProperties))	Option[IntermediateNode]	statements
element match { case f: PsiFile => val m = MainConstruction() m.addChildren(f.getChildren.map(convertPsiToIntermediate(_, externalProperties))) m case e: PsiExpressionStatement => convertPsiToIntermediate(e.getExpression, externalProperties) case l: PsiLiteralExpression => LiteralExpression(l.getText) case n: PsiIdentifier => NameIdentifier(n.getText) case t: PsiTypeElement => convertTypePsiToIntermediate(t.getType, t, t.getProject) case w: PsiWhiteSpace => LiteralExpression(w.getText) case r: PsiReturnStatement => ReturnStatement(convertPsiToIntermediate(r.getReturnValue, externalProperties)) case t: PsiThrowStatement => ThrowStatement(convertPsiToIntermediate(t.getException, externalProperties)) case i: PsiImportStatement => handleImport(i) case i: PsiImportStaticStatement => handleImport(i) case i: PsiImportList => ImportStatementList(i.getAllImportStatements.map(handleImport).distinct) case a: PsiAssignmentExpression => BinaryExpressionConstruction(convertPsiToIntermediate(a.getLExpression, externalProperties), convertPsiToIntermediate(a.getRExpression, externalProperties), a.getOperationSign.getText, inExpression = false) case e: PsiExpressionListStatement => ExpressionListStatement(e.getExpressionList.getExpressions.map(convertPsiToIntermediate(_, externalProperties))) case d: PsiDeclarationStatement => ExpressionListStatement(d.getDeclaredElements.map(convertPsiToIntermediate(_, externalProperties))) case b: PsiBlockStatement => convertPsiToIntermediate(b.getCodeBlock, externalProperties) case s: PsiSynchronizedStatement => val lock = Option(s.getLockExpression).map(convertPsiToIntermediate(_, externalProperties)) val body = Option(s.getBody).map(convertPsiToIntermediate(_, externalProperties)) SynchronizedStatement(lock, body) case b: PsiCodeBlock => BlockConstruction(b.getStatements.map(convertPsiToIntermediate(_, externalProperties))) case t: PsiTypeParameter => TypeParameterConstruction(convertPsiToIntermediate(t.getNameIdentifier, externalProperties), t.getExtendsList.getReferenceElements.map(convertPsiToIntermediate(_, externalProperties))) case i: PsiIfStatement => val condition = Option(i.getCondition).map(convertPsiToIntermediate(_, externalProperties)) val thenBranch = Option(i.getThenBranch).map(convertPsiToIntermediate(_, externalProperties)) val elseBranch = Option(i.getElseBranch).map(convertPsiToIntermediate(_, externalProperties)) IfStatement(condition, thenBranch, elseBranch) case c: PsiConditionalExpression => val condition = Option(c.getCondition).map(convertPsiToIntermediate(_, externalProperties)) val thenBranch = Option(c.getThenExpression).map(convertPsiToIntermediate(_, externalProperties)) val elseBranch = Option(c.getElseExpression).map(convertPsiToIntermediate(_, externalProperties)) IfStatement(condition, thenBranch, elseBranch) case w: PsiWhileStatement => val condition = Option(w.getCondition).map(convertPsiToIntermediate(_, externalProperties)) val body = Option(w.getBody).map(convertPsiToIntermediate(_, externalProperties)) WhileStatement(None, condition, body, None, WhileStatement.PRE_TEST_LOOP) case w: PsiDoWhileStatement => val condition = Option(w.getCondition).map(convertPsiToIntermediate(_, externalProperties)) val body = Option(w.getBody).map(convertPsiToIntermediate(_, externalProperties)) WhileStatement(None, condition, body, None, WhileStatement.POST_TEST_LOOP) case f: PsiForStatement => val countingLoop = CountingLoop.from(f) val body = Option(f.getBody).map(convertPsiToIntermediate(_, externalProperties)) if (countingLoop != null) { val name = convertPsiToIntermediate(countingLoop.getCounter.getNameIdentifier, externalProperties) val iteratedValue = RangeExpression( convertPsiToIntermediate(countingLoop.getInitializer, externalProperties), convertPsiToIntermediate(countingLoop.getBound, externalProperties), countingLoop.isIncluding, countingLoop.isDescending) ForeachStatement(name, Some(iteratedValue), body, isJavaCollection = false) } else { val initialization = Option(f.getInitialization).map(convertPsiToIntermediate(_, externalProperties)) val condition = Some(f.getCondition match { case _: PsiEmptyStatement => LiteralExpression("true") case null => LiteralExpression("true") case _ => convertPsiToIntermediate(f.getCondition, externalProperties) }) val update = Option(f.getUpdate).map(convertPsiToIntermediate(_, externalProperties)) WhileStatement(initialization, condition, body, update, WhileStatement.PRE_TEST_LOOP) } case a: PsiAssertStatement => val condition = Option(a.getAssertCondition).map(convertPsiToIntermediate(_, externalProperties)) val description = Option(a.getAssertDescription).map(convertPsiToIntermediate(_, externalProperties)) AssertStatement(condition, description) case s: PsiSwitchLabelStatementBase => val caseValues = if (s.isDefaultCase) Seq(LiteralExpression("_")) else Option(s.getCaseValues) .map(it => it.getExpressions.toSeq.map(convertPsiToIntermediate(_, externalProperties))) .getOrElse(Seq.empty) val body : Option[PsiStatement] = s match { case rs: PsiSwitchLabeledRuleStatement => Option(rs.getBody) case _ => None } SwitchLabelStatement(caseValues, ScalaPsiUtil.functionArrow(s.getProject), body.map(convertPsiToIntermediate(_, externalProperties))) case s: PsiSwitchBlock => def statements = Option(s.getBody).map(_.getStatements) def defaultStatement = SwitchLabelStatement(Seq(LiteralExpression("_")), ScalaPsiUtil.functionArrow(s.getProject)) val expr = Option(s.getExpression).map(convertPsiToIntermediate(_, externalProperties)) val body = Option(s.getBody).map(convertPsiToIntermediate(_, externalProperties)) if (statements.exists(_.length == 0)) SwitchBlock(expr, Some(defaultStatement)) else SwitchBlock(expr, body) case p: PsiPackageStatement => PackageStatement(convertPsiToIntermediate(p.getPackageReference, externalProperties)) case f: PsiForeachStatement => val tp = Option(f.getIteratedValue).flatMap((e: PsiExpression) => Option(e.getType)) val isJavaCollection = if (tp.isEmpty) true else !tp.get.isInstanceOf[PsiArrayType] val iteratedValue = Option(f.getIteratedValue).map(convertPsiToIntermediate(_, externalProperties)) val body = Option(f.getBody).map(convertPsiToIntermediate(_, externalProperties)) val name = convertPsiToIntermediate(f.getIterationParameter.getNameIdentifier, externalProperties) ForeachStatement(name, iteratedValue, body, isJavaCollection) case r: PsiReferenceExpression => val args = Option(r.getParameterList).map(convertPsiToIntermediate(_, externalProperties)) val refName: Option[String] = { val nameWithPrefix: String = if (textMode && r.getQualifier == null) r.resolve() match { case clazz: PsiClass => ScalaPsiUtil.nameWithPrefixIfNeeded(clazz) case _ => r.getReferenceName } else r.getReferenceName val name: String = if (externalProperties.isInstanceOf[WithReferenceExpression]) { fieldParameterMap.getOrElse(r.getReferenceName, nameWithPrefix) } else { nameWithPrefix } Option(name) } var iResult = JavaCodeReferenceStatement(None, args, refName) if (r.getQualifierExpression != null) { val t = Option(r.getQualifierExpression).map(convertPsiToIntermediate(_, externalProperties)) iResult = JavaCodeReferenceStatement(t, args, refName) } else { r.resolve() match { case f: PsiMember if f.hasModifierProperty("static") => val clazz = f.containingClass if (clazz != null && context.get().contains((false, clazz.qualifiedName))) { val name = Option(clazz.getNameIdentifier).map(convertPsiToIntermediate(_, externalProperties)) iResult = JavaCodeReferenceStatement(name, args, refName) } case _ => } } handleAssociations(r, iResult) iResult case p: PsiJavaCodeReferenceElement => val qualifier = Option(p.getQualifier).map(convertPsiToIntermediate(_, externalProperties)) val args = Option(p.getParameterList).map(convertPsiToIntermediate(_, externalProperties)) JavaCodeReferenceStatement(qualifier, args, Option(p.getReferenceName)) case be: PsiBinaryExpression => def isOk: Boolean = { if (be.getLOperand.getType.isInstanceOf[PsiPrimitiveType]) return false be.getROperand match { case l: PsiLiteralExpression if l.getText == "null" => return false case _ => } true } def inExpression: Boolean = Option(be.getParent) match { case Some(_: PsiExpression) => true case _ => false } val operation = be.getOperationSign.getText match { case "==" if isOk => "eq" case "!=" if isOk => "ne" case x => x } BinaryExpressionConstruction( convertPsiToIntermediate(be.getLOperand, externalProperties), convertPsiToIntermediate(be.getROperand, externalProperties), operation, inExpression) case c: PsiTypeCastExpression => ClassCast( convertPsiToIntermediate(c.getOperand, externalProperties), convertPsiToIntermediate(c.getCastType, externalProperties), c.getCastType.getType.isInstanceOf[PsiPrimitiveType] && c.getOperand.getType.isInstanceOf[PsiPrimitiveType]) case a: PsiArrayAccessExpression => ArrayAccess( convertPsiToIntermediate(a.getArrayExpression, externalProperties), convertPsiToIntermediate(a.getIndexExpression, externalProperties)) case a: PsiArrayInitializerExpression => ArrayInitializer(a.getInitializers.map(convertPsiToIntermediate(_, externalProperties))) case c: PsiClassObjectAccessExpression => ClassObjectAccess(convertPsiToIntermediate(c.getOperand, externalProperties)) case i: PsiInstanceOfExpression => InstanceOfConstruction( convertPsiToIntermediate(i.getOperand, externalProperties), convertPsiToIntermediate(i.getCheckType, externalProperties)) case m: PsiMethodCallExpression => def isSuper: Boolean = m.getMethodExpression.getQualifierExpression.isInstanceOf[PsiSuperExpression] m.getMethodExpression.resolve() match { case method: PsiMethod if method.getName == "parseInt" && m.getArgumentList.getExpressions.length == 1 && method.getContainingClass != null && method.getContainingClass.qualifiedName == "java.lang.Integer" => ClassCast(convertPsiToIntermediate(m.getArgumentList.getExpressions.apply(0), externalProperties), TypeConstruction("Int"), isPrimitive = true) case method: PsiMethod if method.getName == "parseDouble" && m.getArgumentList.getExpressions.length == 1 && method.getContainingClass != null && method.getContainingClass.qualifiedName == "java.lang.Double" => ClassCast(convertPsiToIntermediate(m.getArgumentList.getExpressions.apply(0), externalProperties), TypeConstruction("Double"), isPrimitive = true) case method: PsiMethod if method.getName == "round" && m.getArgumentList.getExpressions.length == 1 && method.getContainingClass != null && method.getContainingClass.qualifiedName == "java.lang.Math" => MethodCallExpression.build( convertPsiToIntermediate(m.getArgumentList.getExpressions.apply(0), externalProperties), ".round", null) case method: PsiMethod if method.getName == "equals" && m.getTypeArguments.isEmpty && !isSuper && m.getArgumentList.getExpressions.length == 1 => MethodCallExpression.build( Option(m.getMethodExpression.getQualifierExpression).map(convertPsiToIntermediate(_, externalProperties)) .getOrElse(LiteralExpression("this")), " == ", convertPsiToIntermediate(m.getArgumentList.getExpressions.apply(0), externalProperties)) case _ => MethodCallExpression(m.getMethodExpression.getQualifiedName, convertPsiToIntermediate(m.getMethodExpression, externalProperties), convertPsiToIntermediate(m.getArgumentList, externalProperties), (m.getType == PsiType.VOID) && m.getArgumentList.getExpressions.isEmpty) } case t: PsiThisExpression => ThisExpression(Option(t.getQualifier).map(convertPsiToIntermediate(_, externalProperties))) case s: PsiSuperExpression => SuperExpression(Option(s.getQualifier).map(convertPsiToIntermediate(_, externalProperties))) case e: PsiExpressionList => ExpressionList(e.getExpressions.map(convertPsiToIntermediate(_, externalProperties))) case lambda: PsiLambdaExpression => FunctionalExpression( convertPsiToIntermediate(lambda.getParameterList, externalProperties), convertPsiToIntermediate(lambda.getBody, externalProperties)) case l: PsiLocalVariable => val parent = Option(PsiTreeUtil.getParentOfType(l, classOf[PsiCodeBlock], classOf[PsiBlockStatement])) val needVar = if (parent.isEmpty) false else isVar(l, parent) val initalizer = Option(l.getInitializer).map(convertPsiToIntermediate(_, externalProperties)) val name = convertPsiToIntermediate(l.getNameIdentifier, externalProperties) LocalVariable(handleModifierList(l), name, convertTypePsiToIntermediate(l.getType, l.getTypeElement, l.getProject), needVar, initalizer) case enumConstant: PsiEnumConstant => EnumConstruction(convertPsiToIntermediate(enumConstant.getNameIdentifier, externalProperties)) case f: PsiField => val modifiers = handleModifierList(f) val needVar = isVar(f, Option(f.getContainingClass)) val initalizer = Option(f.getInitializer).map(convertPsiToIntermediate(_, externalProperties)) val name = convertPsiToIntermediate(f.getNameIdentifier, externalProperties) FieldConstruction(modifiers, name, convertTypePsiToIntermediate(f.getType, f.getTypeElement, f.getProject), needVar, initalizer) case p: PsiParameterList => ParameterListConstruction(p.getParameters.map(convertPsiToIntermediate(_, externalProperties))) case m: PsiMethod => def body: Option[IntermediateNode] = { if (m.isConstructor) { getFirstStatement(m).map(_.getExpression).flatMap { case mc: PsiMethodCallExpression if mc.getMethodExpression.getQualifiedName == "this" => Some(convertPsiToIntermediate(m.getBody, externalProperties)) case _ => getStatements(m).map(statements => BlockConstruction(LiteralExpression("this()") +: statements.map(convertPsiToIntermediate(_, externalProperties)))) } } else { Option(m.getBody).map(convertPsiToIntermediate(_, externalProperties)) } } def convertMethodReturnType = if (m.getReturnType != PsiType.VOID || ScalaCodeStyleSettings.getInstance(m.getProject).ENFORCE_FUNCTIONAL_SYNTAX_FOR_UNIT) Some(convertPsiToIntermediate(m.getReturnTypeElement, externalProperties)) else None if (m.isConstructor) { ConstructorSimply(handleModifierList(m), m.getTypeParameters.map(convertPsiToIntermediate(_, externalProperties)), m.parameters.map(convertPsiToIntermediate(_, externalProperties)), body) } else { val name = convertPsiToIntermediate(m.getNameIdentifier, externalProperties) MethodConstruction(handleModifierList(m), name, m.getTypeParameters.map(convertPsiToIntermediate(_, externalProperties)), m.parameters.map(convertPsiToIntermediate(_, externalProperties)), body, convertMethodReturnType) } case c: PsiClass => createClass(c, externalProperties) case p: PsiParenthesizedExpression => val expr = Option(p.getExpression).map(convertPsiToIntermediate(_, externalProperties)) ParenthesizedExpression(expr) case v: PsiArrayInitializerMemberValue => ArrayInitializer(v.getInitializers.map(convertPsiToIntermediate(_, externalProperties)).toSeq) case annot: PsiAnnotation => def isArrayAnnotationParameter(pair: PsiNameValuePair): Boolean = { AnnotationUtil.getAnnotationMethod(pair) match { case method: PsiMethod => val returnType = method.getReturnType returnType != null && returnType.isInstanceOf[PsiArrayType] case _ => false } } val attributes = annot.getParameterList.getAttributes val attrResult = mutable.ArrayBuffer[(Option[IntermediateNode], Option[IntermediateNode])]() for (attribute <- attributes) { val value = Option(attribute.getValue) match { case Some(v: PsiAnnotationMemberValue) if isArrayAnnotationParameter(attribute) => ArrayInitializer(Seq(convertPsiToIntermediate(v, externalProperties))) case Some(_) => convertPsiToIntermediate(attribute.getValue, externalProperties) case _ => null } attrResult += ((Option(attribute.getNameIdentifier).map(convertPsiToIntermediate(_, externalProperties)), Option(value))) } val inAnnotation = PsiTreeUtil.getParentOfType(annot, classOf[PsiAnnotation]) != null val name = Option(annot.getNameReferenceElement).map(convertPsiToIntermediate(_, externalProperties)) AnnotaionConstruction(inAnnotation, attrResult, name) case p: PsiParameter => val modifiers = handleModifierList(p) val name = convertPsiToIntermediate(p.getNameIdentifier, externalProperties) val `type` = convertTypePsiToIntermediate(p.getType, p.getTypeElement, p.getProject) if (p.isVarArgs) { p.getType match { case at: PsiArrayType => ParameterConstruction(modifiers, name, convertTypePsiToIntermediate(at.getComponentType, p.getTypeElement.getInnermostComponentReferenceElement, p.getProject), None, isArray = true) case t => ParameterConstruction(modifiers, name, `type`, None, isArray = false) // should not happen } } else ParameterConstruction(modifiers, name, `type`, None, isArray = false) case n: PsiNewExpression => if (n.getAnonymousClass != null) { return AnonymousClassExpression(convertPsiToIntermediate(n.getAnonymousClass, externalProperties)) } val iType = convertTypePsiToIntermediate(n.getType, n.getClassReference, n.getProject) if (n.getArrayInitializer != null) { NewExpression(iType, n.getArrayInitializer.getInitializers.map(convertPsiToIntermediate(_, externalProperties))) } else if (n.getArrayDimensions.nonEmpty) { NewExpression(iType, n.getArrayDimensions.map(convertPsiToIntermediate(_, externalProperties)), withArrayInitalizer = false) } else { val argList: Seq[IntermediateNode] = if (n.getArgumentList != null) { if (n.getArgumentList.getExpressions.isEmpty) { n.getParent match { case r: PsiJavaCodeReferenceElement if n == r.getQualifier => Seq(LiteralExpression("()")) case _ => null } } else { Seq(convertPsiToIntermediate(n.getArgumentList, externalProperties)) } } else null NewExpression(iType, argList, withArrayInitalizer = false) } case t: PsiTryStatement => val resourcesVariables = mutable.ArrayBuffer[(String, IntermediateNode)]() Option(t.getResourceList).foreach { resourceList => val it = resourceList.iterator while (it.hasNext) { val next = it.next() next match { case varible: PsiResourceVariable => resourcesVariables += ((varible.getName, convertPsiToIntermediate(varible, externalProperties))) case _ => } } } val tryBlock = Option(t.getTryBlock) .map((f: PsiCodeBlock) => f.getStatements.map(convertPsiToIntermediate(_, externalProperties)).toSeq) .getOrElse(Seq.empty) val catches = t.getCatchSections.map((cb: PsiCatchSection) => (convertPsiToIntermediate(cb.getParameter, externalProperties), convertPsiToIntermediate(cb.getCatchBlock, externalProperties))) val finallys = Option(t.getFinallyBlock).map((f: PsiCodeBlock) => f.getStatements.map(convertPsiToIntermediate(_, externalProperties)).toSeq) TryCatchStatement(resourcesVariables, tryBlock, catches, finallys, ScalaPsiUtil.functionArrow(t.getProject)) case p: PsiPrefixExpression => PrefixExpression(convertPsiToIntermediate(p.getOperand, externalProperties), p.getOperationSign.getText, ExpressionUtils.isVoidContext(p)) case p: PsiPostfixExpression => PostfixExpression(convertPsiToIntermediate(p.getOperand, externalProperties), p.getOperationSign.getText, ExpressionUtils.isVoidContext(p)) case p: PsiPolyadicExpression => val tokenValue = if (p.getOperands.nonEmpty) { p.getTokenBeforeOperand(p.getOperands.apply(1)).getText } else "" PolyadicExpression(p.getOperands.map(convertPsiToIntermediate(_, externalProperties)), tokenValue) case r: PsiReferenceParameterList => TypeParameters(r.getTypeParameterElements.map(convertPsiToIntermediate(_, externalProperties))) case b: PsiBreakStatement => if (isBreakRemovable(b)) EmptyConstruction() else if (b.getLabelIdentifier != null) NotSupported(None, "break " + b.getLabelIdentifier.getText + "// todo: label break is not supported") else NotSupported(None, "break //todo: break is not supported") case y: PsiYieldStatement => if (isYieldRemovable(y)) convertPsiToIntermediate(y.getExpression, externalProperties) else NotSupported(None, "`yield` " + Option(y.getExpression).map(_.getText).mkString + "// todo: Java's yield is not supported") case c: PsiContinueStatement => if (c.getLabelIdentifier != null) NotSupported(None, "continue " + c.getLabelIdentifier.getText + " //todo: continue is not supported") else NotSupported(None, "continue //todo: continue is not supported") case s: PsiLabeledStatement => val statements = Option(s.getStatement).map(convertPsiToIntermediate(_, externalProperties)) NotSupported(statements, s.getLabelIdentifier.getText + " //todo: labels are not supported") case _: PsiEmptyStatement => EmptyConstruction() case _: PsiErrorElement => EmptyConstruction() case e => LiteralExpression(e.getText) }	IntermediateNode	result
s"""s'''abc first line | | second line$Caret'''.stripMargin |""".stripMargin	String	after
result match { case parametrizedConstruction: ParametrizedConstruction => parametrizedConstruction.associationMap case arrayConstruction: ArrayConstruction => arrayConstruction.associationMap case _ => Seq.empty }	Seq[(IntermediateNode, Option[String])]	associationMap
mutable.HashMap.empty[String, String]	mutable.HashMap[String, String]	fieldParameterMap
processName(symbol.name)	String	name
mutable.ArrayBuffer[(PsiClassType, PsiJavaCodeReferenceElement)]()	ArrayBuffer[(PsiClassType, PsiJavaCodeReferenceElement)]	typez
s"""s'''abc $Caret'''.stripMargin |""".stripMargin	String	to
mutable.ArrayBuffer[PsiMember]()	ArrayBuffer[PsiMember]	forClass
getSbtSettings(workingDirPath)	SbtExecutionSettings	sbtSettings
mutable.ArrayBuffer[PsiMember]()	ArrayBuffer[PsiMember]	forObject
if (name == "_") { symbol.get match { case ts: TypeSymbol => ts.infoType match { case t: TypeBoundsType => if (visitedTypeBoundsType.contains(t)) "" else { visitedTypeBoundsType += t try { toString(t, level) } finally { visitedTypeBoundsType -= t } } case _ => "" } case _ => "" } } else ""	String	typeBounds
BuildInfo.sbtStructureVersion	String	runid
selectSdkOrWarn(sbtSettings)	Sdk	sdk
s"""${Start}first line$End |""".stripMargin	String	from
serialVersion(inClass)	Option[PsiField]	serialVersionUID
toString(lower, level)	String	lb
if (sbtSettings.shellDebugMode) Option(addDebugParameters(javaParameters)) else None	Option[RemoteConnection]	debugConnection
s"""'''first line$Caret''' |""".stripMargin	String	after
convertPsiToIntermediate(inClass.getNameIdentifier, externalProperties)	IntermediateNode	name
s"""'''abc $Caret def''' |""".stripMargin	String	to
toString(upper, level)	String	ub
s"""'''abc first line$Caret def''' |""".stripMargin	String	after
objectMembers.filter(!_.isInstanceOf[PsiEnumConstant]).map(convertPsiToIntermediate(_, externalProperties))	IndexedSeq[IntermediateNode]	membersOut
NotificationGroup.balloonGroup("Sbt Shell")	NotificationGroup	notificationGroup
getClassString(level + 1, classSym)	String	text
{ val text = getClassString(level + 1, classSym) if (text.trim.stripPrefix("{").stripSuffix("}").trim.isEmpty) "" else text }	String	classStr
inClass.getInitializers.map((x: PsiClassInitializer) => convertPsiToIntermediate(x.getBody, externalProperties))	IndexedSeq[IntermediateNode]	initializers
None	None.type	primaryConstructor
None	None.type	typeParams
EmptyConstruction()	EmptyConstruction	companionObject
handleModifierList(inClass)	IntermediateNode	modifiers
new shell.SbtShellToolWindowFactory.TraversalPolicy(project, defaultFocusPolicy)	SbtShellToolWindowFactory.TraversalPolicy	focusPolicy
Version(detectSbtVersion(workingDir, launcher))	Version	projectSbtVersion
modifiers.asInstanceOf[ModifiersConstruction].without(ModifierType.ABSTRACT)	IntermediateNode	updatedModifiers
KeymapManager.getInstance()	KeymapManager	keymapManager
SbtUtil.latestCompatibleVersion(projectSbtVersion)	Version	latestCompatibleSbtVersion
keymapManager.getKeymap("$default")	Keymap	defaultKeymap
new KeyboardShortcut(KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.SHIFT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK), null)	KeyboardShortcut	defaultShortcut
keymapManager.getKeymap("NetBeans 6.5")	Keymap	netbeansKeymap
symbols.map(_.get).map(toString).filter(!_.startsWith("_")).map("type " + _)	IndexedSeq[Any]	refs
convertTypePsiToIntermediate(clazz.getBaseClassType, clazz.getBaseClassReference, clazz.getProject)	IntermediateNode	tp
convertPsiToIntermediate(clazz.getArgumentList, externalProperties)	IntermediateNode	argList
new ScalaDocumentationProvider	ScalaDocumentationProvider	scalaDocProvider
PsiTreeUtil.findChildrenOfType(keyDefinition, classOf[ScMethodCall]).asScala	Iterable[ScMethodCall]	methodCalls
targetMap.get(left)	Option[PsiMethod]	rightFromMap
targetMap.get(right)	Option[PsiMethod]	leftFromMap
(for (a <- symbol.attributes) yield toString(a)).mkString(" ")	String	attrs
sbtSettings.allowSbtVersionOverride && projectSbtVersion >= mayUpgradeSbtVersion && projectSbtVersion < latestCompatibleSbtVersion	Boolean	shouldUpgradeSbtVersion
if (shouldUpgradeSbtVersion) latestCompatibleSbtVersion else projectSbtVersion	Version	upgradedSbtVersion
for { manager <- Option(ToolWindowManager.getInstance(project)) window <- Option(manager.getToolWindow(ID)) } yield window	Option[ToolWindow]	result
SbtProcessManager.forProject(project)	SbtProcessManager	sbtManager
Option(callback)	Option[ProjectTaskNotification]	callbackOpt
new ProjectTaskResult(false, 0, 0)	ProjectTaskResult	taskResult
new CommandTask(project, modules.toArray, command, callbackOpt)	CommandTask	task
for { shellRunner <- sbtManager.shellRunner if sbtManager.isAlive view <- Option(shellRunner.getConsoleView) editor <- Option(view.getConsoleEditor) } yield editor.getContentComponent	Option[Nothing]	shellComponent
upgradedSbtVersion >= SbtProjectResolver.sinceSbtVersionShell	Boolean	autoPluginsSupported
Set("SettingKey", "TaskKey", "InputKey", "AttributeKey").map(_.toLowerCase)	IndexedSeq[Any]	SbtKeyTypes
upgradedSbtVersion >= addPluginCommandVersion_1 || upgradedSbtVersion.inRange(addPluginCommandVersion_013, Version("1.0.0"))	Boolean	addPluginCommandSupported
javaParameters.getVMParametersList	ParametersList	vmParams
javaParameters.toCommandLine	GeneralCommandLine	commandLine
symbol.infoType match { case PolyType(typeRef, symbols) => PolyTypeWithCons(typeRef, symbols, "") case tp => tp }	Type	symbolType
currentTypeParameters.getOrElse(symbol, symbol.name)	String	name
binaryVersion(upgradedSbtVersion)	Version	sbtMajorVersion
SbtUtil.makeSbtProjectId(sbtModuleData)	String	scope
new ExternalSystemTaskExecutionSettings	ExternalSystemTaskExecutionSettings	taskSettings
typeRef.symbol.get.path	String	ref
typeRef.typeArgs	Seq[Ref[Type]]	args
{ case null => "scala.Null" case _: Unit => "scala.Unit" case _: Short => "scala.Short" //there are no literals for shorts and bytes case _: Byte => "scala.Byte" case Ref(typeRef: TypeRefType) => s"java.lang.Class[${classTypeText(typeRef)}]" case Ref(ExternalSymbol(_, Some(Ref(parent)), _)) => parent.path //enum type }	PartialFunction[Any, String]	nonLiteralTypeText
buildConstructorTargetMap(inClass.getConstructors.sortBy(_.getTextOffset))	mutable.HashMap[PsiMethod, PsiMethod]	constructorsCallMap
{ case Ref(ScalaSymbol(value)) => "\'" + value }	PartialFunction[Any, String]	symbolLiteralText
{ case Ref(sym: ExternalSymbol) => sym.path //enum value case Ref(typeRef: TypeRefType) => s"scala.Predef.classOf[${classTypeText(typeRef)}]" //class literal // java numeric constants with special `toString` // Double and Float infinities are equal, so we should check type first case d: Double if d == java.lang.Double.POSITIVE_INFINITY => "java.lang.Double.POSITIVE_INFINITY" case d: Double if d == java.lang.Double.NEGATIVE_INFINITY => "java.lang.Double.NEGATIVE_INFINITY" case f: Float if f == java.lang.Float.POSITIVE_INFINITY => "java.lang.Float.POSITIVE_INFINITY" case f: Float if f == java.lang.Float.NEGATIVE_INFINITY => "java.lang.Float.NEGATIVE_INFINITY" // NaNs cannot be compared directly case d: Double if java.lang.Double.isNaN(d) => "java.lang.Double.NaN" case f: Float if java.lang.Float.isNaN(f) => "java.lang.Float.NaN" }	PartialFunction[Any, String]	constantDefinitionExpr
sortMembers()	Seq[PsiMember]	sortedMembers
""	String	tasks
"-Xms512M -Xmx1024M -Xss1M -XX:+CMSClassUnloadingEnabled"	String	vmparams
{ case null => "null" case value: String => quote(value, canUseMultiline = false) case Ref(Name(value)) => quote(value, canUseMultiline = false) case value: Char => "\'" + value + "\'" case value: Long => value + "L" case value: Float => value + "f" case value@(_: Boolean | _: Int | _: Double) => value.toString }	PartialFunction[Any, String]	literalText
defaultWorkingDirectory	String	workingDir
true	Boolean	useSbtShell
dropMembers.map(el => sortedMembers.filter(!el.contains(_))).getOrElse(sortedMembers)	Seq[PsiMember]	updatedMembers
Set("true", "false", "null", "abstract", "case", "catch", "class", "def", "do", "else", "extends", "final", "finally", "for", "forSome", "if", "implicit", "import", "lazy", "match", "new", "object", "override", "package", "private", "protected", "return", "sealed", "super", "this", "throw", "trait", "try", "type", "val", "var", "while", "with", "yield")	Set[Nothing]	keywordList
SbtProcessManager.forProject(project).acquireShellRunner()	SbtShellRunner	shellRunner
new SbtRunConfigurationFactory(this)	SbtRunConfigurationFactory	confFactory
name.stripPrivatePrefix.split('.')	Array[String]	parts
0	Int	idx
setterName.length == methodName.length + setterSuffix.length	Boolean	correctLength
injectedPlugins(sbtMajorVersion.presentation)	Seq[String]	plugins
new IndicatorReporter(indicator)	IndicatorReporter	report
SbtShellCommunication.forProject(project)	SbtShellCommunication	shell
str.lastIndexOf("$$")	Int	i
plugins.exists(_.contains("sbt-idea-compiler-indices"))	Boolean	compilerIndicesPluginLoaded
new MyTrojanRemoteState(environment.getProject, connection)	SbtDebugProgramRunner.this.MyTrojanRemoteState	state
ReflectExpansionsCollector.getInstance(project)	ReflectExpansionsCollector	collector
str.indexOf(defaultParamMarker)	Int	idx
inClass.getTypeParameters.map(convertPsiToIntermediate(_, externalProperties))	IndexedSeq[IntermediateNode]	typeParams
SbtShellCommunication.forProject(env.getProject)	SbtShellCommunication	sc
idx + defaultParamMarker.length	Int	afterMarker
state.processedCommands	String	commands
if (inClass.isInterface) INTERFACE else CLASS	ClassConstruction.ClassType.Value	classType
-1	Int	idx
SbtCompilationSupervisor().actualPort	Option[Int]	ideaPort
lastIdentifierCharIdx(id)	Int	lastIdCharIdx
ideaPort.fold("")(port => s"; set ideaPort in Global := $port ;")	String	ideaPortSetting
if (compilerIndicesPluginLoaded) s"$ideaPortSetting idea-shell" else "idea-shell"	String	commands
createPtyCommandLine(commandLine)	PtyCommandLine	pty
new ColoredProcessHandler(pty)	ColoredProcessHandler	cpty
attachVirtualMachine(state, environment, connection, true)	RunContentDescriptor	attach
s"Started sbt shell with sbt version ${upgradedSbtVersion.presentation} instead of ${projectSbtVersion} configured by project."	String	message
None	Option[ExecutionResult]	execResult
super.execute(executor, runner)	ExecutionResult	er
updateMembersAndConvert(dropMembers)	Seq[IntermediateNode]	members
new SbtRunConfigurationForm(project, configuration)	SbtRunConfigurationForm	form
handleObject(objectMembers)	IntermediateNode	companionObject
if (text startsWith ERROR_PREFIX) { val msg = text.stripPrefix(ERROR_PREFIX) // only report first error until we can get a good mapping message -> error if (messages.errors.isEmpty) { showShell() report.error("errors in build", None) } messages.addError(msg) } else if (text startsWith WARN_PREFIX) { val msg = text.stripPrefix(WARN_PREFIX) // only report first warning if (messages.warnings.isEmpty) { report.warning("warnings in build", None) } messages.addWarning(msg) } else messages	BuildMessages	messagesWithErrors
{ (messages,event) => event match { case TaskStart => // handled for main task messages case TaskComplete => // handled for main task messages case ErrorWaitForInput => // can only actually happen during reload, but handle it here to be sure showShell() report.error("build interrupted", None) messages.addError("ERROR: build interrupted") messages case Output(raw) => val text = raw.trim val messagesWithErrors = if (text startsWith ERROR_PREFIX) { val msg = text.stripPrefix(ERROR_PREFIX) // only report first error until we can get a good mapping message -> error if (messages.errors.isEmpty) { showShell() report.error("errors in build", None) } messages.addError(msg) } else if (text startsWith WARN_PREFIX) { val msg = text.stripPrefix(WARN_PREFIX) // only report first warning if (messages.warnings.isEmpty) { report.warning("warnings in build", None) } messages.addWarning(msg) } else messages collector.processCompilerMessage(text) report.log(text) messagesWithErrors } }	(BuildMessages, SbtShellCommunication.ShellEvent) => BuildMessages	resultAggregator
new mutable.HashMap[PsiMethod, PsiMethod]()	mutable.HashMap[PsiMethod, PsiMethod]	toTargetConstructorMap
shell.command(command, BuildMessages.empty, resultAggregator, showShell = true)	Future[BuildMessages]	commandFuture
getFirstStatement(constructor).map(_.getExpression).flatMap { case mc: PsiMethodCallExpression if mc.getMethodExpression.getQualifiedName == "this" => Some(mc.getMethodExpression) case _ => None }	Option[PsiReferenceExpression]	refExpr
Await.ready(commandFuture, Duration.Inf).value.get	Try[BuildMessages]	buildMessages
toTargetConstructorMap.getOrElse(m, m)	PsiMethod	finalTarget
mutable.ArrayBuffer[PsiField]()	ArrayBuffer[PsiField]	dropFields
getFirstStatement(constructor)	Option[PsiExpressionStatement]	firstStatement
messages.toTaskResult	ProjectTaskResult	taskResult
Option(ProjectRootManager.getInstance(project).getProjectSdk)	Option[Sdk]	existingJdk
new ProjectTaskResult(true, 1, 0)	ProjectTaskResult	failedResult
firstStatement.map(_.getExpression).flatMap { case mc: PsiMethodCallExpression if mc.getMethodExpression.getQualifiedName == "super" => Some(mc) case _ => None }	Option[PsiMethodCallExpression]	maybeSuperCall
DebuggerManagerEx.getInstanceEx(project).getContext.getDebuggerSession	DebuggerSession	debuggerSession
DebuggerSettings.getInstance	DebuggerSettings	debuggerSettings
mutable.ArrayBuffer[(PsiField, PsiExpressionStatement)]()	ArrayBuffer[(PsiField, PsiExpressionStatement)]	dropInfo
Vector.empty[Node[_]]	Vector[Node[_]]	children
new DataNode[T](key, data, parent.orNull)	DataNode[T]	node
ProjectDataManager.getInstance().getExternalProjectData(project,SbtProjectSystem.Id, project.getBasePath)	ExternalProjectInfo	info
Option(usage.getParent)	Option[PsiElement]	parent
Option(data.jdk) .flatMap(SdkUtils.findProjectSdk) .orElse(existingJdk) .orElse(SdkUtils.mostRecentJdk)	Option[Sdk]	projectJdk
parent.flatMap { case ae: PsiAssignmentExpression if (ae.getOperationSign.getTokenType == JavaTokenType.EQ) && ae.getLExpression.isInstanceOf[PsiReferenceExpression] => ae.getLExpression.asInstanceOf[PsiReferenceExpression].resolve() match { case f: PsiField if f.getContainingClass == constructor.getContainingClass && f.getInitializer == null => Some(f) case _ => None } case _ => None }	Option[PsiField]	field
parent .flatMap(p => Option(p.getParent)) .collect { case p: PsiExpressionStatement => p }	Option[PsiExpressionStatement]	statement
new CollectProcessor[Library] { override def accept(library: Library): Boolean = library.hasRuntimeLibrary }	CommonProcessors.CollectProcessor[Library] { def accept(library: Library): Boolean }	delegate
Option(ProjectRootManager.getInstance(project).getProjectSdk)	Option[Sdk]	projectJdk
VfsUtil.findFileByIoFile(propertiesFile, true)	VirtualFile	vFile
datakey(classOf[SbtBuildModuleData])	Key[SbtBuildModuleData]	Key
constructor.parameters	Seq[PsiParameter]	params
datakey(classOf[SbtModuleData])	Key[SbtModuleData]	Key
SdkUtils.javaLanguageLevelFrom(data.javacOptions.asScala) .orElse(projectJdk.flatMap(SdkUtils.defaultJavaLanguageLevelIn))	Option[LanguageLevel]	javaLanguageLevel
mutable.ArrayBuffer[IntermediateNode]()	ArrayBuffer[IntermediateNode]	updatedParams
datakey(classOf[SbtProjectData])	Key[SbtProjectData]	Key
super.execute(executor, runner)	ExecutionResult	r
mutable.ArrayBuffer[PsiExpressionStatement]()	ArrayBuffer[PsiExpressionStatement]	dropStatements
LanguageLevelProjectExtension.getInstance(project)	LanguageLevelProjectExtension	extension
datakey(classOf[SbtSettingData])	Key[SbtSettingData]	Key
datakey(classOf[SbtTaskData])	Key[SbtTaskData]	Key
getCorrespondedFieldInfo(param)	Seq[(PsiField, PsiExpressionStatement)]	fieldInfo
datakey(classOf[SbtCommandData])	Key[SbtCommandData]	Key
(s: StringBuilder, event: ShellEvent) => { event match { case Output(line) => l(line) s.append("\n").append(line) case _ => s } }	(StringBuilder, SbtShellCommunication.ShellEvent) => Any	agg
datakey(classOf[ModuleExtData], ProjectKeys.LIBRARY_DEPENDENCY.getProcessingWeight + 1)	Key[ModuleExtData]	Key
convertPsiToIntermediate(param, null).asInstanceOf[ParameterConstruction]	ParameterConstruction	p
datakey(classOf[Play2ProjectData], ProjectKeys.PROJECT.getProcessingWeight + 1)	Key[Play2ProjectData]	Key
convertPsiToIntermediate(fieldInfo.head._1, WithReferenceExpression(true)).asInstanceOf[FieldConstruction]	FieldConstruction	fieldConverted
sbtSettings.jdk.map(JdkByName).flatMap(SdkUtils.findProjectSdk)	Option[Sdk]	configuredSdk
ProjectRootManager.getInstance(project).getProjectSdk	Sdk	projectSdk
new JavaParameters	JavaParameters	params
ParameterConstruction(EmptyConstruction(), fieldConverted.name, fieldConverted.ftype, Some(fieldConverted.isVar), isArray = false)	ParameterConstruction	param
JavaParametersUtil.createProjectJdk(configuration.getProject, null)	Sdk	jdk
datakey(classOf[AndroidFacetData], ProjectKeys.LIBRARY_DEPENDENCY.getProcessingWeight +100500)	Key[AndroidFacetData]	Key
if (fieldInfo.isEmpty) { val p = convertPsiToIntermediate(param, null).asInstanceOf[ParameterConstruction] p.isVar = Some(false) p } else { fieldInfo.foreach { case (field, statement) => dropFields += field dropStatements += statement } val fieldConverted = convertPsiToIntermediate(fieldInfo.head._1, WithReferenceExpression(true)).asInstanceOf[FieldConstruction] val param = ParameterConstruction(EmptyConstruction(), fieldConverted.name, fieldConverted.ftype, Some(fieldConverted.isVar), isArray = false) param.setComments(fieldConverted.comments) param }	ParameterConstruction	updatedField
SbtShellNotifications.notificationGroup .createNotification(message, NotificationType.ERROR)	Notification	noProjectSdkNotification
SbtSettings.getInstance(configuration.getProject).getState	SbtSettings.State	sbtSystemSettings
getSuperCall(dropStatements)	IntermediateNode	superCall
new RemoteConnection(true, host, port, false)	RemoteConnection	remoteConnection
JavacConfiguration.getOptions(project, classOf[JavacConfiguration])	JpsJavaCompilerOptions	settings
buildConstructorTargetMap(constructors)	mutable.HashMap[PsiMethod, PsiMethod]	possibleConstructors
s"-agentlib:jdwp=transport=dt_socket,address=$host:$port,suspend=n,server=y"	String	shellDebugProperties
new PtyCommandLine()	PtyCommandLine	pty
CompilerConfiguration.getInstance(project).asInstanceOf[CompilerConfigurationImpl]	CompilerConfigurationImpl	compilerSettings
constructors.filter(!possibleConstructors.contains(_))	Seq[PsiMethod]	candidates
constructors.filter(_.getParameterList.getParametersCount == 0)	Seq[PsiMethod]	emptyParamsConstructors
settings.mkString("scala.collection.Seq(\n",",\n","\n)")	String	settingsString
Class.forName("org.jetbrains.sbt.project.module.SbtModuleType").newInstance.asInstanceOf[SbtModuleType]	SbtModuleType	instance
createPrimaryConstructor(constructors.head)	PrimaryConstruction	updatedConstructor
GetComplexPrimaryConstructor()	PsiMethod	pc
createPrimaryConstructor(pc)	PrimaryConstruction	updatedConstructor
additionalOptionsFrom(options)	Seq[String]	customOptions
Map( (PsiModifier.VOLATILE, ModifierType.VOLATILE), (PsiModifier.PRIVATE, ModifierType.PRIVATE), (PsiModifier.PROTECTED, ModifierType.PROTECTED), (PsiModifier.TRANSIENT, ModifierType.TRANSIENT), (PsiModifier.NATIVE, ModifierType.NATIVE) )	Map[String, ModifierType.Value]	SIMPLE_MODIFIERS_MAP
new NotificationData( SbtBundle("sbt.notificationGroupTitle"), SbtBundle("sbt.dataService.scalaLibraryIsNotFound", version, module), NotificationCategory.WARNING, NotificationSource.PROJECT_SYNC )	NotificationData	notificationData
Set("-g:none", "-nowarn", "-Xlint:none", "-deprecation", "-Xlint:deprecation")	Set[Nothing]	handledOptions
if (guardSettings) s"""if (java.lang.System.getProperty("idea.runid", "false") == "$runid") $settingsString else scala.collection.Seq.empty""" else settingsString	String	guardedSettings
acquireShellRunner()	SbtShellRunner	runner
mutable.ArrayBuffer[IntermediateNode]()	ArrayBuffer[IntermediateNode]	modifiers
createProcessData()	SbtProcessManager.ProcessData	pd
new SbtShellRunner(project, title, debugConnection)	SbtShellRunner	runner
options.indexOf(name)	Int	index
resolvers.map(_.toString) .mkString(Delimiter)	String	newResolvers
new SbtModuleState()	SbtModuleState	myState
""	String	imports
""	String	resolvers
""	String	buildForURI
new SbtModuleSettingsForm	SbtModuleSettingsForm	myForm
new JListCompatibility.CollectionListModelWrapper(new CollectionListModel[String](Collections.emptyList[String]))	JListCompatibility.CollectionListModelWrapper	modelWrapper
Resolvers(getModel.getModule).toSeq	Seq[SbtResolver]	resolvers
myForm.resolversTable.getSelectedRows.map(resolvers(_))	Seq[SbtResolver]	resolversToUpdate
getModel.getModule	Module	module
SbtSettings.getInstance(state.getProject).getLinkedProjectSettings(module)	Option[SbtProjectSettings]	moduleSettings
SIMPLE_MODIFIERS_MAP.filter { case (psiType, _) => owner.hasModifierProperty(psiType) }.values	Iterable[ModifierType.Value]	simpleList
Class.forName("org.jetbrains.sbt.project.sources.SharedSourcesModuleType").newInstance.asInstanceOf[SharedSourcesModuleType]	SharedSourcesModuleType	instance
method.getThrowsList.getReferenceElements	Array[PsiJavaCodeReferenceElement]	references
owner.getContainingFile.asInstanceOf[PsiClassOwner].getPackageName	String	packageName
ModifiersConstruction(handleAnnotations, handleModifiers)	ModifiersConstruction	ml
Version("1.2.0")	Version	addPluginCommandVersion_1
Version("0.13.18")	Version	addPluginCommandVersion_013
Version("0.13.0")	Version	mayUpgradeSbtVersion
new BuildFileChangeBrowser(project, swappedChanges, canExcludeChanges, fileStatusMap)	BuildFileChangeBrowser	changesBrowser
List("-Dsbt.supershell=false")	List[Nothing]	hardcoded
ScalaCodeFragment(text)	ScalaCodeFragment	file
c.findFieldByName("serialVersionUID", false)	PsiField	serialField
module.getProject	Project	project
BuildFileElementType("LIBRARY_DEPENDENCY")	BuildFileElementType	libraryDependencyElementId
BuildFileElementType("RESOLVER")	BuildFileElementType	resolverElementId
BuildFileElementType("SCALAC_OPTIONS")	BuildFileElementType	scalacOptionsElementId
false	Boolean	res
PsiTreeUtil.getNextSiblingOfType(statement, classOf[PsiStatement]) == null	Boolean	noNextStatement
hardcoded ++ SbtOpts.loadFrom(workingDir) ++ JvmOpts.loadFrom(workingDir) ++ sbtSettings.vmOptions	IndexedSeq[String]	opts
Some(List())	Option[List[VirtualFile]]	empty
buildFileLocationProviders.toStream	Stream[BuildFileModificationLocationProvider]	locationProvidersStream
mutable.Map[VirtualFile, LightVirtualFile]()	mutable.Map[VirtualFile, LightVirtualFile]	vfsFileToCopy
List(BuildFileElementType.libraryDependencyElementId, BuildFileElementType.resolverElementId, BuildFileElementType.scalacOptionsElementId)	List[BuildFileElementType]	supportedElementTypes
BuildFileChange.swap(myChange.asInstanceOf[BuildFileChange])	BuildFileChange	changeSwapped
false	Boolean	sbtSupportSuggested
new SbtLocalSettingsState	SbtLocalSettingsState	state
mutable.Map[VirtualFile, (BuildFileModifiedStatus, Long)]()	mutable.Map[VirtualFile, (BuildFileModifiedStatus, Long)]	fileStatusMap
FileDocumentManager.getInstance()	FileDocumentManager	documentManager
null	String	jdk
true	Boolean	resolveClassifiers
new SimpleContentRevision(VfsUtilCore.loadText(original), VcsUtil getFilePath original, "original")	SimpleContentRevision	originalRevision
false	Boolean	resolveSbtClassifiers
false	Boolean	resolveJavadocs
false	Boolean	useSbtShellForImport
false	Boolean	useSbtShellForBuild
new CurrentContentRevision(VcsUtil getFilePath copy) { override def getVirtualFile: LightVirtualFile = copy }	CurrentContentRevision { def getVirtualFile: LightVirtualFile }	copyRevision
false	Boolean	enableDebugSbtShell
true	Boolean	allowSbtVersionOverride
FileDocumentManager.getInstance().getDocument(changeSwapped.getVirtualFile) .getModificationStamp	Long	newModificationStamp
_	String	sbtVersion
new SbtProjectSettings()	SbtProjectSettings	result
changes.contains(copy)	Boolean	isModified
if (isModified) BuildFileModifiedStatus.MODIFIED_AUTOMATICALLY else BuildFileModifiedStatus.DETECTED	BuildFileModifiedStatus	buildFileStatus
SbtSettings.getInstance(project)	SbtSettings	settings
documentManager.getDocument(copy).getModificationStamp	Long	buildFileModificationStamp
parent.getChildren	Array[PsiElement]	children
parent.getContainingFile	PsiFile	psiFile
psiFile.getVirtualFile	VirtualFile	res
modifiedStatus.changeAfterManualModification()	BuildFileModifiedStatus	newStatus
new ShowDiffContext()	ShowDiffContext	context
for (change <- changesArray) yield BuildFileChange.swap(change.asInstanceOf[BuildFileChange])	Array[Change]	changesArraySwapped
element.getContainingFile	PsiFile	res
12	Int	temp
filesToWorkingCopies.toSeq.map{case (original, copy) => val originalRevision = new SimpleContentRevision(VfsUtilCore.loadText(original), VcsUtil getFilePath original, "original") val copyRevision = new CurrentContentRevision(VcsUtil getFilePath copy) { override def getVirtualFile: LightVirtualFile = copy } val isModified = changes.contains(copy) assert(!fileStatusMap.contains(copy)) val buildFileStatus = if (isModified) BuildFileModifiedStatus.MODIFIED_AUTOMATICALLY else BuildFileModifiedStatus.DETECTED val buildFileModificationStamp = documentManager.getDocument(copy).getModificationStamp fileStatusMap.put(copy, (buildFileStatus, buildFileModificationStamp)) new BuildFileChange(originalRevision, copyRevision, buildFileStatus) }	IndexedSeq[BuildFileChange]	vcsChanges
new ProjectSdksModel()	ProjectSdksModel	model
items.sortBy(a => a.displayName)	Array[IndexEntry]	indexedItems
new JdkComboBox(model)	JdkComboBox	result
Seq( SbtBundle("sbt.settings.resolvers.name"), SbtBundle("sbt.settings.resolvers.url"), SbtBundle("sbt.settings.resolvers.updated") )	Seq[String]	columns
(vcsChanges zip changes).toMap	Map[BuildFileChange, VirtualFile]	changesToWorkingCopies
ExternalSystemApiUtil.getSettings(project, SbtProjectSystem.Id). asInstanceOf[AbstractExternalSystemSettings[_ <: AbstractExternalSystemSettings[_, SbtProjectSettings, _], SbtProjectSettings, _ <: ExternalSystemSettingsListener[SbtProjectSettings]]]	AbstractExternalSystemSettings[_ <: AbstractExternalSystemSettings[_, SbtProjectSettings, _], SbtProjectSettings, _ <: ExternalSystemSettingsListener[SbtProjectSettings]]	settings
new Runnable { override def run(): Unit = { val settings = ExternalSystemApiUtil.getSettings(project, SbtProjectSystem.Id). asInstanceOf[AbstractExternalSystemSettings[_ <: AbstractExternalSystemSettings[_, SbtProjectSettings, _], SbtProjectSettings, _ <: ExternalSystemSettingsListener[SbtProjectSettings]]] getExternalProjectSettings setExternalProjectPath getContentEntryPath settings linkProject getExternalProjectSettings ExternalSystemUtil.refreshProject(project, SbtProjectSystem.Id, getContentEntryPath, false, ProgressExecutionMode.IN_BACKGROUND_ASYNC) } }	{ def run(): Unit }	runnable
ProjectJdkTable.getInstance()	ProjectJdkTable	table
new Condition[Sdk] { override def value(sdk: Sdk): Boolean = { inWriteAction { val table = ProjectJdkTable.getInstance() if (!table.getAllJdks.contains(sdk)) table.addJdk(sdk) } false } }	Condition[Sdk] { def value(sdk: Sdk): Boolean }	addToTable
{ val model = new ProjectSdksModel() model.reset(null) val result = new JdkComboBox(model) val button = new JButton("Ne\u001Bw...") val addToTable = new Condition[Sdk] { override def value(sdk: Sdk): Boolean = { inWriteAction { val table = ProjectJdkTable.getInstance() if (!table.getAllJdks.contains(sdk)) table.addJdk(sdk) } false } } result.setSetupButton(button, null, model, new JdkComboBox.NoneJdkComboBoxItem, addToTable, false) result }	JdkComboBox	jdkComboBox
ChangesConfirmationDialog(project, vcsChanges.toList, fileStatusMap)	ChangesConfirmationDialog	dialog
dialog.showAndGet()	Boolean	isOk
dialog.selectedChanges	List[BuildFileChange]	selectedChanges
FileDocumentManager.getInstance()	FileDocumentManager	manager
"${content-length}"	String	CONTENT_LENGTH_TEMPLATE
FileUtil.createParentDirs(outputFile)	Boolean	parentDirExists
manager.getDocument(changedFile)	Document	changedDocument
index.getUpdateTimeStamp	Long	ts
progress.map(_.getText).getOrElse("")	String	originalText
request.getConnection.getContentLength	Int	contentLength
getLabelConstraints(indentLevel)	GridBag	labelConstraints
getFillLineConstraints(indentLevel)	GridBag	fillLineConstraints
HttpConfigurable.getInstance()	HttpConfigurable	conf
columnIndex match { case 0 => resolvers.lift(rowIndex).map(_.name) case 1 => resolvers.lift(rowIndex).map(_.root) case 2 => for { resolver <- resolvers.lift(rowIndex) index <- resolver.getIndex(project) } yield { val ts = index.getUpdateTimeStamp if (ts == ResolverIndex.NO_TIMESTAMP) SbtBundle("sbt.settings.resolvers.neverUpdated") else if (ts == ResolverIndex.MAVEN_UNAVALIABLE) SbtBundle("sbt.settings.resolvers.mavenUnavailable") else DateFormatUtil.formatDate(ts) } }	Option[String]	valueOpt
getInitialSettings	SbtProjectSettings	settings
opts.exists(_.startsWith("-Xmx"))	Boolean	hasXmx
text indexOf CONTENT_LENGTH_TEMPLATE	Int	ind
formatContentLength(contentLengthInBytes)	String	mes
text.substring(0, ind) + mes + text.substring(ind + CONTENT_LENGTH_TEMPLATE.length)	String	newText
1024	Int	kilo
Map.empty	Map[String, IndexEntry]	allTemplates
{ downloadTemplateList() new TechHubTemplateList(allTemplates.values.toArray) }	TechHubTemplateList	settingsComponents
s"https://example.lightbend.com/$API_VERSION/api"	String	API_URI
settingsComponents.getSelectedTemplate	IndexEntry	info
settingsComponents.getSelectedTemplate	IndexEntry	selected
settings.jdkName.flatMap(name => Option(ProjectJdkTable.getInstance.findJdk(name)))	Option[Nothing]	jdk
IndexEntry("","","","","","","",Array.empty, Array.empty, EntryFeatured(0))	IndexEntry	dummyEntry
settings.useSbtShellForBuild != useSbtShellForBuildCheckBox.isSelected	Boolean	useSbtShellForBuildSettingChanged
TechHubDownloadUtil.downloadString(s"$API_URI/$TEMPLATES_ENDPOINT")	Try[String]	jsonTry
new Gson	Gson	gson
if (settings.useSbtShellForBuild) CompilerMode.SBT else CompilerMode.JPS	CompilerMode with Product with Serializable	newMode
Selections( null, null, null, resolveClassifiers = true, resolveSbtClassifiers = false )	SbtModuleBuilder.Selections	selections
Map( "-sbt-boot" -> "-Dsbt.boot.directory=", "-sbt-dir" -> "-Dsbt.global.base=", "-ivy" -> "-Dsbt.ivy.home=", "-jvm-debug" -> debuggerOpts )	Map[String, String]	sbtToJdkOpts
ScalaKind()	Versions	scalaVersions
SbtKind()	Versions	sbtVersions
elem.label	String	keyName
s"${entry.downloadUrl}?name=$name&_rawArchive_=true"	String	url
elem.child.filterNot(_.text.forall(c => c == '\n' || c == ' '))	Seq[Node]	children
outputType match { case ProcessOutputTypes.STDOUT => Some(OutputType.StdOut) case ProcessOutputTypes.STDERR => Some(OutputType.StdErr) case _ => None }	Option[OutputType]	textType
taskId.findProject()	Project	project
children.flatMap{ case _: Text => None case projectKey => Some((projectKey.label, (projectKey \ ENTRY_SEQ_NAME).map(_.text).toJavaList)) }.toMap	Map[String, Any]	values
mutable.HashMap[String, Map[String, ParsedValue[_]]]()	mutable.HashMap[String, Map[String, Play2Keys.AllKeys.ParsedValue[_]]]	map
new StringParsedKey("playVersion")	AllKeys.StringParsedKey	PLAY_VERSION
new StringParsedKey("uri")	AllKeys.StringParsedKey	PROJECT_URI
new SeqStringParsedKey("twirlTemplatesImports")	AllKeys.SeqStringParsedKey	TEMPLATES_IMPORT
new SeqStringParsedKey("playRoutesImports")	AllKeys.SeqStringParsedKey	ROUTES_IMPORT
new StringParsedKey("testOptions")	AllKeys.StringParsedKey	TEST_OPTIONS
new StringParsedKey("playConf")	AllKeys.StringParsedKey	PLAY_CONF_DIR
SbtLocalSettings.getInstance(project)	SbtLocalSettings	sbtSettings
new StringParsedKey("sourceDirectory")	AllKeys.StringParsedKey	SOURCE_DIR
for { contentPath <- Option(contentEntryPath) if contentPath.nonEmpty contentRootDir = new File(contentPath) if FileUtilRt.createDirectory(contentRootDir) vContentRootDir <- Option(LocalFileSystem.getInstance.refreshAndFindFileByIoFile(contentRootDir)) } yield { doSetupRootModel(model, projectSettings, contentRootDir, vContentRootDir) true }	Option[Boolean]	attempt
model.getModule	Module	module
newData.flatMap { case (id, baseDir, data) => extractProjectKeyValue(id, baseDir, data) }	IndexedSeq[(Play2OldStructureAdapter.ProjectId, String, Play2Keys.AllKeys.ParsedValue[_])]	projectKeyValueTriples
new ModuleData("N/A", SbtProjectSystem.Id, "N/A", module.getName, rootPath, rootPath)	ModuleData	dummyModuleData
new ProjectData(SbtProjectSystem.Id, module.getProject.getName, rootPath, rootPath)	ProjectData	dummyProjectData
ModuleManager.getInstance(project).getModules.toSeq	Seq[Module]	modules
options.mkString(" ")	String	optString
s"""set _root_.org.jetbrains.sbt.StructureKeys.sbtStructureOptions in Global := "$optString""""	String	setCmd
projectKeyValueTriples.groupBy(_._2).map { case (string, triples) => (string, triples.map(t => (t._1, t._3))) }	IndexedSeq[(String, IndexedSeq[(Play2OldStructureAdapter.ProjectId, Play2Keys.AllKeys.ParsedValue[_])])]	oldData
if (CompilerIndicesSettings(project).isBytecodeIndexingActive) { val ideaPort = SbtCompilationSupervisor().actualPort ideaPort.fold("")(port => s"; set ideaPort in Global := $port") } else ""	String	ideaPortSetting
s";reload; $setCmd ;*/*:dumpStructureTo $structureFilePath; session clear-all $ideaPortSetting"	String	cmd
ExternalSystemModulePropertyManager.getInstance(module)	ExternalSystemModulePropertyManager	esProperty
new TaskOperationDescriptorImpl("dump project structure from sbt shell", System.currentTimeMillis(), "project-structure-dump")	TaskOperationDescriptorImpl	taskDescriptor
model.getProject	Project	project
ExternalSystemApiUtil.getSettings(project, SbtProjectSystem.Id) .asInstanceOf[AbstractExternalSystemSettings[_, SbtProjectSettings, _]]	AbstractExternalSystemSettings[_, SbtProjectSettings, _]	settings
new ProjectSystemId("SBT", Sbt.Name)	ProjectSystemId	Id
dumpMessageAggregator(taskId, s"dump:${UUID.randomUUID()}", taskDescriptor, shell, notifications, viewManager)	SbtShellCommunication.EventAggregator[SbtStructureDump.ImportMessages]	aggregator
modules.exists(_.getModuleFilePath.contains(".idea_modules"))	Boolean	fromGenIdea
data.playVersion.map(v => (PLAY_VERSION, new StringParsedValue(v))).toSeq	Seq[(Play2Keys.AllKeys.StringParsedKey, Play2Keys.AllKeys.StringParsedValue)]	playVersion
NotificationUtil.builder(project, Message).setNotificationType(NotificationType.WARNING)	NotificationUtil.NotificationBuilder	builder
options.mkString(", ")	String	optString
ActionManager.getInstance	ActionManager	manager
ExtensionPointName.create("org.intellij.sbt.sbtOptionsProvider")	ExtensionPointName[SbtOptionsProvider]	ExtensionPoint
data.confDirectory.map(d => (PLAY_CONF_DIR, new StringParsedValue(d.getCanonicalPath))).toSeq	Seq[(Play2Keys.AllKeys.StringParsedKey, Play2Keys.AllKeys.StringParsedValue)]	confDirectory
Option(taskId.findProject()).map(ServiceManager.getService(_, classOf[SyncViewManager]))	Option[Any]	viewManager
s"""<a href="$ImportDescription">Import sbt project</a>"""	String	message
new SbtProjectImportProvider()	SbtProjectImportProvider	sbtProjectImportProvider
configPath.find("build.sbt")	Option[VirtualFile]	buildSbt
new AddModuleWizard(project, project.getBasePath, sbtProjectImportProvider)	AddModuleWizard	wizard
NotificationGroup.balloonGroup(Sbt.Name)	NotificationGroup	sbtNotificationGroup
List(SbtTaskData.Key, SbtSettingData.Key, SbtCommandData.Key)	List[Key[_]]	keys
Seq( """historyPath := None""", s"""shellPrompt := { _ => "" }""", s"""SettingKey[_root_.scala.Option[_root_.sbt.File]]("sbtStructureOutputFile") in _root_.sbt.Global := _root_.scala.Some(_root_.sbt.file("$structureFilePath"))""", s"""SettingKey[_root_.java.lang.String]("sbtStructureOptions") in _root_.sbt.Global := "$optString"""" ).mkString("set _root_.scala.collection.Seq(", ",", ")")	String	setCommands
playVersion ++ confDirectory ++ Seq( (TEMPLATES_IMPORT, new SeqStringParsedValue(data.templatesImports.toJavaList)), (ROUTES_IMPORT, new SeqStringParsedValue(data.routesImports.toJavaList)), (SOURCE_DIR, new StringParsedValue(data.sourceDirectory.getCanonicalPath)), (PROJECT_URI, new StringParsedValue(baseDir.getCanonicalFile.toURI.toString)) )	IndexedSeq[(Play2Keys.AllKeys.ParsedKey[_ >: Seq[String] with String], Play2Keys.AllKeys.ParsedValue[_ >: String] with Product)]	keyValues
applyTo(new SComboBox())( _.setItems(sbtVersions.versions), _.setSelectedItem(selections.sbtVersion) )	SComboBox	sbtVersionComboBox
configPath.find("project").flatMap(_.find("Build.scala"))	Option[VirtualFile]	buildScala
applyTo(new SComboBox())( setupScalaVersionItems )	SComboBox	scalaVersionComboBox
m.mapValues(_.toMap)	Map[K, Map[A, B]]	withMapsValues
dataNode.asInstanceOf[DataNode[SbtTaskData]]	DataNode[SbtTaskData]	typedNode
None	Option[SbtStructureDump]	activeProcessDumper
Seq( setCommands, s"""apply -cp "${normalizePath(sbtStructureJar)}" org.jetbrains.sbt.CreateTasks""", s"*/*:dumpStructure" ).mkString(";", ";", "")	String	sbtCommands
dataNode.asInstanceOf[DataNode[SbtSettingData]]	DataNode[SbtSettingData]	typedNode
dataNode.asInstanceOf[DataNode[SbtCommandData]]	DataNode[SbtCommandData]	typedNode
sdkSettingsStep(settingsStep)	SdkSettingsStep { def validateLanguageLevel(languageLevel: ScalaLanguageLevel, sdk: Sdk): Unit def updateDataModel(): Unit def validate(): Boolean }	step
new SbtTasksGroupNode(externalProjectsView)	SbtViewContributor.SbtTasksGroupNode	tasksNode
new SbtSettingsGroupNode(externalProjectsView)	SbtViewContributor.SbtSettingsGroupNode	settingsNode
new SbtCommandsGroupNode(externalProjectsView)	SbtViewContributor.SbtCommandsGroupNode	commandsNode
if (file.isDirectory && file.getName != Sbt.ProjectDirectory) file else file.getParent	VirtualFile	root
SbtOpts.loadFrom(directory) ++ JvmOpts.loadFrom(directory) ++ vmOptions	IndexedSeq[String]	jvmOptions
dataNode.getData()	SbtCommandData	data
SbtProjectImportProvider.projectRootPath(file)	String	path
new AddModuleWizard(null, path, new SbtProjectImportProvider(getBuilder))	AddModuleWizard	dialog
scalaVersions.versions	Array[String]	versions
parameters.getClassPath	PathsList	classpath
projectToModuleNode.keys.toSeq	Seq[ProjectData]	projects
normalizePath(vmExecutable) +: "-Djline.terminal=jline.UnsupportedTerminal" +: "-Dsbt.log.noformat=true" +: "-Dfile.encoding=UTF-8" +: jvmOptions :+ "-jar" :+ normalizePath(sbtLauncher)	IndexedSeq[String]	processCommandsRaw
sharedAndExternalRootsIn(projects)	Seq[ExternalSourceRootResolution.this.SharedRoot]	sharedRoots
settings.getState	SbtSettings.State	settingsState
groupSharedRoots(sharedRoots)	Seq[ExternalSourceRootResolution.this.RootGroup]	grouped
processCommandsRaw.filterNot(_.isEmpty)	IndexedSeq[String]	processCommands
new TaskOperationDescriptorImpl("dump project structure from sbt", System.currentTimeMillis(), "project-structure-dump")	TaskOperationDescriptorImpl	taskDescriptor
rootGroup.projects	Seq[ProjectData]	projects
Option(settings.getLinkedProjectSettings(path)).getOrElse(SbtProjectSettings.default)	SbtProjectSettings	projectSettings
s"dump:${UUID.randomUUID()}"	String	dumpTaskId
new ExternalSystemStartEventImpl[TaskOperationDescriptor](dumpTaskId, null, taskDescriptor)	ExternalSystemStartEventImpl[TaskOperationDescriptor]	startEvent
new ExternalSystemTaskExecutionEvent(taskId, startEvent)	ExternalSystemTaskExecutionEvent	taskStartEvent
createSourceModule(rootGroup, moduleFilesDirectory)	ModuleNode	moduleNode
apply(kind) match { case null => val Versions(defaultVersion, versionsArray) = versions versionsArray.headOption.getOrElse(defaultVersion) case value => value }	String	version
detectSbtVersion(projectRoot, sbtLauncher)	String	sbtVersion
using(new PrintWriter(new BufferedWriter(new OutputStreamWriter(process.getOutputStream, "UTF-8")))) { writer => writer.println(sbtCommands) // exit needs to be in a separate command, otherwise it will never execute when a previous command in the chain errors writer.println("exit") writer.flush() handle(process, taskId, dumpTaskId, taskDescriptor, viewManager, notifications) }	Try[SbtStructureDump.ImportMessages]	result
s"import:${UUID.randomUUID()}"	String	importTaskId
new TaskOperationDescriptorImpl("import to IntelliJ project model", System.currentTimeMillis(), "project-model-import")	TaskOperationDescriptorImpl	importTaskDescriptor
settingsState.customLauncherEnabled.option(settingsState.getCustomLauncherPath).map(_.toFile)	Option[Any]	customLauncher
settingsState.customSbtStructurePath.nonEmpty.option(settingsState.customSbtStructurePath.toFile)	Option[Any]	customSbtStructureFile
Option(projectSettings.getExternalProjectPath).getOrElse(path)	String	realProjectPath
sbtFilePattern && infixExpressionChildPattern	ElementPattern[_ <: PsiElement]	afterInfixOperator
parameters.getPosition.getProject	ProjectContext	project
dumpStructure(projectRoot, sbtLauncher, Version(sbtVersion), settings, taskId, notifications)	Try[(Elem, SbtStructureDump.ImportMessages)]	structureDump
bootstrapJdk(project, projectSettings)	Option[String]	projectJdkName
representativeProjectIn(rootGroup.projects)	ProjectData	representativeProject
representativeProject.dependencies.modules	Seq[ModuleDependencyData]	moduleDependencies
representativeProject.dependencies.projects	Seq[ProjectDependencyData]	projectDependencies
positionFromParameters(parameters)	PsiElement	place
place.getContext.getContext.asInstanceOf[ScInfixExpr]	ScInfixExpr	infixExpr
infixExpr.operation	ScReferenceExpression	operator
infixExpr.right match { case ref: ScReferenceExpression => ref case _ => return }	ScReferenceExpression	parentRef
Seq("scala.collection.Seq", "scala.collection.immutable.Set")	Seq[Nothing]	collectionTypeNames
new ScalaRecursiveElementVisitor { override def visitMethodCallExpression(call: ScMethodCall): Unit = call match { case ScMethodCall(expr, Seq(_: ScLiteral, pathElt)) if expr.getText == "Project" => result = extractPathFromFileParam(pathElt) case ScMethodCall(expr, Seq(pathElt)) if expr.getText.matches("^project.+?in$") => result = extractPathFromFileParam(pathElt) case ScMethodCall(expr, _) if expr.getText.startsWith("project") => result = Some(element.getText) super.visitMethodCallExpression(call) case _ => super.visitMethodCallExpression(call) } }	ScalaRecursiveElementVisitor { def visitMethodCallExpression(call: ScMethodCall): Unit }	visitor
Try { val processBuilder = new ProcessBuilder(processCommands.asJava) processBuilder.directory(directory) processBuilder.environment().putAll(environment.asJava) val process = processBuilder.start() val result = using(new PrintWriter(new BufferedWriter(new OutputStreamWriter(process.getOutputStream, "UTF-8")))) { writer => writer.println(sbtCommands) // exit needs to be in a separate command, otherwise it will never execute when a previous command in the chain errors writer.println("exit") writer.flush() handle(process, taskId, dumpTaskId, taskDescriptor, viewManager, notifications) } result.getOrElse(ImportMessages.empty.addError("no output from sbt shell process available")) } .recoverWith { case fail => Failure(ImportCancelledException(fail)) }	Try[SbtStructureDump.ImportMessages]	result
new ExternalSystemStartEventImpl(importTaskId, null, importTaskDescriptor)	ExternalSystemStartEventImpl[Nothing]	convertStartEvent
projectToModuleNode.values.find(_.getId == ModuleNode.combinedId(dependencyId.project, dependencyId.buildURI)).getOrElse( throw new ExternalSystemException("Cannot find project dependency: " + dependencyId.project))	ModuleNode	dependency
new ExternalSystemTaskExecutionEvent(taskId, convertStartEvent)	ExternalSystemTaskExecutionEvent	event
new ModuleDependencyNode(moduleNode, dependency)	ModuleDependencyNode	dependencyNode
new ModuleDependencyNode(moduleNode, reprProjectModule)	ModuleDependencyNode	node
{ val moduleNode = createSourceModule(rootGroup, moduleFilesDirectory) // Select a single project and clone its module / project dependencies. // It seems that dependencies of any single project should be enough to highlight files in the shared source module. // Please note that we mix source modules into other modules on compilation, // so source module dependencies are not relevant for compilation, only for highlighting. val representativeProject = representativeProjectIn(rootGroup.projects) //add library dependencies of the representative project val moduleDependencies = representativeProject.dependencies.modules moduleNode.addAll(createLibraryDependencies(moduleDependencies)(moduleNode, libraryNodes.map(_.data))) //add library dependencies of the representative project val projectDependencies = representativeProject.dependencies.projects projectDependencies.foreach { dependencyId => val dependency = projectToModuleNode.values.find(_.getId == ModuleNode.combinedId(dependencyId.project, dependencyId.buildURI)).getOrElse( throw new ExternalSystemException("Cannot find project dependency: " + dependencyId.project)) val dependencyNode = new ModuleDependencyNode(moduleNode, dependency) dependencyNode.setScope(scopeFor(dependencyId.configuration)) moduleNode.add(dependencyNode) } projectToModuleNode.get(representativeProject).foreach { reprProjectModule => //add representative project itself as a dependency for shared source module val node = new ModuleDependencyNode(moduleNode, reprProjectModule) node.setExported(true) moduleNode.add(node) //put source module to the same module group moduleNode.setIdeModuleGroup(reprProjectModule.getIdeModuleGroup) } moduleNode }	ModuleNode	sourceModuleNode
new ModuleDependencyNode(ownerModule, sourceModuleNode)	ModuleDependencyNode	node
(title: String) => title.endsWith("js") || title.endsWith("native")	String => Boolean	isNonJvmTitle
(project: ProjectData) => isNonJvmTitle(project.id.toLowerCase) || isNonJvmTitle(project.name.toLowerCase)	ProjectData => Boolean	isNonJvmProject
new ModuleNode(SharedSourcesModuleType.instance.getId, group.name, null, group.name, moduleFilesDirectory.path, group.base.canonicalPath)	ModuleNode	moduleNode
new ContentRootNode(group.base.path)	ContentRootNode	node
{ val node = new ContentRootNode(group.base.path) group.roots.foreach { root => node.storePath(scopeAndKindToSourceType(root.scope, root.kind), root.directory.path) } node }	ContentRootNode	contentRootNode
messages.errors.map(msg => new FailureImpl(msg, msg, Collections.emptyList()))	IndexedSeq[FailureImpl]	fails
true	Boolean	allowsForwardReferences
new FailureImpl(x.getMessage, x.getClass.getName, Collections.emptyList())	FailureImpl	fail
ScalaPsiManager.instance(getProject)	ScalaPsiManager	manager
getVmOptions(settingsState, jreHome)	Seq[String]	vmOptions
result match { case Success(messages) => if (messages.errors.isEmpty) new SuccessResultImpl(startTime, endTime, true) else { val fails = messages.errors.map(msg => new FailureImpl(msg, msg, Collections.emptyList())) new FailureResultImpl(startTime, endTime, fails.asJava) } case Failure(x) => val fail = new FailureImpl(x.getMessage, x.getClass.getName, Collections.emptyList()) new FailureResultImpl(startTime, endTime, Collections.singletonList(fail)) }	DefaultOperationResult	operationResult
new ExternalSystemFinishEventImpl[TaskOperationDescriptor]( dumpTaskId, null, taskDescriptor, operationResult )	ExternalSystemFinishEventImpl[TaskOperationDescriptor]	finishEvent
parentRef.expectedType() .filterNot(_.isInstanceOf[NonValueType])	Option[ScType]	refType
new ExternalSystemTaskExecutionEvent(taskId, finishEvent)	ExternalSystemTaskExecutionEvent	taskFinishEvent
ImportMessages.empty	SbtStructureDump.ImportMessages	messages
Map.empty ++ getAndroidEnvironmentVariables(projectJdkName)	Map[String, String]	environment
Option(ProjectRootManager.getInstance(project).getProjectSdk).map(_.getName)	Option[Nothing]	jdkInProject
importSettings.jdkName	Option[String]	jdkInImportSettings
elem.deserialize[sbtStructure.StructureData].right.get	StructureData	data
JavaAwareProjectJdkTableImpl.getInstanceEx.getInternalJdk	Sdk	internalSdk
sbtFilePattern && ( infixExpressionChildPattern && psiElement.withChild(psiElement.withText(string.oneOf("%", "%%"))) || psiElement.inside( instanceOf(classOf[ScInfixExpr]) && psiElement.withChild(psiElement.withText("libraryDependencies")) ) )	ElementPattern[_ <: PsiElement]	pattern
if (internalSdk == null) IdeaTestUtil.getMockJdk17 else internalSdk	Sdk	sdk
projects.flatMap(project => sourceRootsIn(project).map(ProjectRoot(project,_)))	IndexedSeq[ExternalSourceRootResolution.this.ProjectRoot]	projectRoots
sdk.getSdkType.asInstanceOf[JavaSdkType]	JavaSdkType	sdkType
settings.getCustomVMPath	String	customPath
positionFromParameters(params)	PsiElement	place
importsFor(targetModule).map { // TODO this is a workaround, we need to find out why references stopped resolving via the chained imports case "Keys._" => "sbt.Keys._" case "Build._" => "sbt.Build._" // TODO: this is a workaround. `processDeclarations` does not resolve "Play.autoImport -> PlayImport" // However, when object with implicit imports is located in the same file where plugin object resides // everything is resolved, but PlayImport and Play are in different files. case "_root_.play.Play.autoImport._" => "_root_.play.PlayImport._" case importText => importText }	IndexedSeq[String]	imports
place.getProject	Project	p
ModuleManager.getInstance(getProject)	ModuleManager	manager
Seq( refType, extractSeqType, getScopeType ).flatten	Seq[ScType]	expectedTypes
if (settings.customVMEnabled && JdkUtil.checkForJre(customPath)) { val javaExe = if (SystemInfo.isWindows) "java.exe" else "java" Some(new File(customPath) / "bin" / javaExe) } else None	Option[Nothing]	customVmExecutable
expectedTypes match { case Seq(t, rest @ _*) => t case _ => return }	ScType	expectedType
projectRoots.filter(_.isInternal).map(_.root.directory)	IndexedSeq[Any]	internalSourceDirectories
new SharedSourceRootNameProvider()	ExternalSourceRootResolution.this.SharedSourceRootNameProvider	nameProvider
JavaSdk.getInstance()	JavaSdk	jdkType
SbtResolverUtils.projectResolvers(place)	Set[SbtResolver]	resolvers
if (oper.getText == "%%") s"_${place.scalaLanguageLevelOrDefault.getVersion}" else ""	String	versionSuffix
nameProvider.nameFor(base)	String	name
if (loper.getText == "%%") s"_${place.scalaLanguageLevelOrDefault.getVersion}" else ""	String	versionSuffix
sharedRoots.flatMap(_.projects).distinct	IndexedSeq[ProjectData]	projects
Set("compile", "test", "it")	Set[Nothing]	relevantScopes
for { SbtModuleData(_, buildURI) <- SbtUtil.getSbtModuleData(module) module <- manager.getModules.find { module => Build(module) == buildURI } } yield module	Option[Module]	moduleByUri
false	Boolean	customLauncherEnabled
""	String	customLauncherPath
defaultMaxHeapSize	String	maximumHeapSize
""	String	vmParameters
false	Boolean	customVMEnabled
buildEvent(text, SbtProcessBuildWarning(taskId, _), SbtProcessBuildError(taskId, _))	Option[MessageEvent]	buildEv
""	String	customVMPath
""	String	customSbtStructurePath
new SbtSettings.State	SbtSettings.State	state
new ExternalSystemStatusEventImpl[TaskOperationDescriptor]( dumpTaskId, null, taskDescriptor, 1, -1, "events")	ExternalSystemStatusEventImpl[TaskOperationDescriptor]	progressEvent
new ExternalSystemTaskExecutionEvent(taskId, progressEvent)	ExternalSystemTaskExecutionEvent	statusEvent
module.getModuleScope	GlobalSearchScope	moduleScope
new SbtProjectSettingsListenerAdapter(listener)	SbtProjectSettingsListenerAdapter	adapter
""	String	defaultMaxHeapSize
JvmMemorySize.Megabytes(1536)	JvmMemorySize	hiddenDefaultMaxHeapSize
{ case (OutputType.StdOut, text) => if (text.contains("(q)uit")) { val writer = new PrintWriter(process.getOutputStream) writer.println("q") writer.close() } else { update(text) } case (OutputType.StdErr, text) => update(text) }	(OutputType, String) => Unit	processListener
new OSProcessHandler(process, "sbt import", Charset.forName("UTF-8"))	OSProcessHandler	handler
false	Boolean	processEnded
100	Int	SBT_PROCESS_CHECK_TIMEOUT_MSEC
ProjectManager.getInstance().getOpenProjects.find(p => FileUtil.pathsEqual(p.getBasePath, projectRoot.getCanonicalPath))	Option[Project]	projectOpt
new ScalaResolveResult(element) .getLookupElement(isClassName = true, shouldImport = true) .head	ScalaLookupItem	lookup
project.configurations.filter(it => relevantScopes.contains(it.id))	Seq[ConfigurationData]	relevantConfigurations
variantObj match { case el: ScalaLookupItem => el case ch: ScalaChainLookupElement => ch.element case _ => return }	ScalaLookupItem	variant
if (configuration.id == "compile") Root.Scope.Compile else Root.Scope.Test	ExternalSourceRootResolution.this.Root.Scope with Product with Serializable	scope
structureDump .map { case (elem, _) => val data = elem.deserialize[sbtStructure.StructureData].right.get convert(normalizePath(projectRoot), data, settings.jdk).toDataNode } .recoverWith { case ImportCancelledException(cause) => val causeMessage = if (cause != null) cause.getMessage else "unknown cause" // notify user if project exists already val projectOpt = ProjectManager.getInstance().getOpenProjects.find(p => FileUtil.pathsEqual(p.getBasePath, projectRoot.getCanonicalPath)) projectOpt.foreach { p => val notification = SbtNotifications.notificationGroup.createNotification(s"sbt import cancelled: $causeMessage", NotificationType.INFORMATION) notification.notify(p) } log.info("sbt import cancelled", cause) // sorry, ExternalSystem expects a null when resolving is not possible Success(null) case x: Exception => Failure(new ExternalSystemException(x)) }	Try[DataNode[ProjectData]]	conversionResult
new ScalaResolveResult(field) .getLookupElement(isClassName = true, shouldImport = true) .head	ScalaLookupItem	lookup
new ExternalSystemFinishEventImpl[TaskOperationDescriptor]( importTaskId, null, importTaskDescriptor, result )	ExternalSystemFinishEventImpl[TaskOperationDescriptor]	convertFinishedEvent
new ExternalSystemTaskExecutionEvent(taskId, convertFinishedEvent)	ExternalSystemTaskExecutionEvent	event
settings.useShellForImport && shellImportSupported(sbtVersion) && project != null	Boolean	useShellImport
dumpOptions(settings)	Seq[String]	options
s"sbt launcher not found at ${sbtLauncher.getCanonicalPath}"	String	error
roots.map { root => root.base.getOrElse(root.directory) .getCanonicalFile.toPath.normalize }	IndexedSeq[Any]	paths
SbtProcessBuildWarning(taskId, "error during import")	SbtStructureDump.SbtProcessBuildWarning	reportedWarning
s"sbt $sinceSbtVersion+ required. Please update project build.properties."	String	message
SbtProcessBuildError(taskId, "error during import")	SbtStructureDump.SbtProcessBuildError	reportedError
new ExternalSystemTaskExecutionEvent(id, startEvent)	ExternalSystemTaskExecutionEvent	statusEvent
Seq(Seq("src", "main"), Seq("src", "test"))	Seq[Seq[Nothing]]	DefaultPaths
Set.empty[String]	Set[String]	usedNames
1	Int	counter
messages.errors.map { msg => new FailureImpl(msg, msg, Collections.emptyList()) }	IndexedSeq[FailureImpl]	fails
s"<b>${unindexedRepos.length} Unindexed maven repositories found</b>"	String	title
if (messages.errors.isEmpty) new SuccessResultImpl(taskDescriptor.getEventTime, System.currentTimeMillis(), true) else { val fails = messages.errors.map { msg => new FailureImpl(msg, msg, Collections.emptyList()) } new FailureResultImpl(taskDescriptor.getEventTime, System.currentTimeMillis(), fails.asJava) }	DefaultOperationResult	result
new ExternalSystemFinishEventImpl[TaskOperationDescriptor](dumpTaskId, null, taskDescriptor, result)	ExternalSystemFinishEventImpl[TaskOperationDescriptor]	finishEvent
new ExternalSystemTaskExecutionEvent(id, finishEvent)	ExternalSystemTaskExecutionEvent	statusEvent
new ExternalSystemException(msg)	ExternalSystemException	ex
s""" |If you want to use dependency completion, click |<b><a href="#open">here</a></b>, select required repositories and press "Update" button. <a href="#disable">Disable...</a> """.stripMargin	String	message
new FailureImpl(msg, "error during sbt import", Collections.emptyList())	FailureImpl	failure
proxyOptions { optName => !userOptions.exists(_.startsWith(optName)) }	Seq[String]	ideaProxyOptions
createIndexerNotification(title, message)	NotificationData	notificationData
new ExternalSystemFinishEventImpl[TaskOperationDescriptor]( dumpTaskId, null, taskDescriptor, new FailureResultImpl(taskDescriptor.getEventTime, timestamp, Collections.singletonList(failure)) )	ExternalSystemFinishEventImpl[TaskOperationDescriptor]	finishEvent
new Consumer[util.List[MavenIndex]] { override def consume(mavenIndexes: util.List[MavenIndex]): Unit = { if (project.isDisposed) return val sbtRepos = (new SbtMavenRepositoryProvider) .getRemoteRepositories(project) .asScala .map(_.getUrl) .toSet val unindexedRepos = mavenIndexes .asScala .filter(idx => idx.getUpdateTimestamp == -1 && sbtRepos.contains(idx.getRepositoryPathOrUrl)) if (unindexedRepos.isEmpty) return val title = s"<b>${unindexedRepos.length} Unindexed maven repositories found</b>" val message = s""" |If you want to use dependency completion, click |<b><a href="#open">here</a></b>, select required repositories and press "Update" button. <a href="#disable">Disable...</a> """.stripMargin val notificationData = createIndexerNotification(title, message) ExternalSystemNotificationManager.getInstance(project).showNotification(SbtProjectSystem.Id, notificationData) } }	Consumer[Any]	unindexedNotifier
for { fqn <- Sbt.DefinitionHolderClasses aClass <- manager.getCachedClasses(moduleWithDependenciesAndLibrariesScope, fqn) inheritor <- searches.ClassInheritorsSearch .search(aClass, moduleScope, true) .findAll .asScala } yield s"${inheritor.qualifiedName}._"	IndexedSeq[Nothing]	localObjectsWithDefinitions
SbtShellBuildError(dumpTaskId, msg)	SbtShellBuildError	buildEvent
normalizePath(structureFile)	String	structureFilePath
SbtProjectSystem.Id + ExternalSystemConstants.USE_IN_PROCESS_COMMUNICATION_REGISTRY_KEY_SUFFIX	String	key
new SbtStructureDump()	SbtStructureDump	dumper
dumper.dumpFromShell(taskId, projectRoot, structureFilePath, options, notifications)	Future[SbtStructureDump.ImportMessages]	messagesF
new SbtSettingsPane(settings.getProject)	SbtSettingsPane	pane
Seq("sbt.Plugin", "sbt.Build")	Seq[Nothing]	DefinitionHolderClasses
Seq("sbt._", "Process._", "Keys._", "dsl._")	Seq[Nothing]	DefaultImplicitImports
Version(BuildInfo.sbtLatestVersion)	Version	LatestVersion
Version(BuildInfo.sbtLatest_1_0)	Version	Latest_1_0
Version(BuildInfo.sbtLatest_0_12)	Version	Latest_0_12
SbtResolverUtils.projectResolvers(project) .flatMap(_.getIndex(project)) .filter { case index: IvyIndex => index.getUpdateTimeStamp == -1 case _ => false }	IndexedSeq[ResolverIndex]	outdatedIvyIndexes
Version(BuildInfo.sbtLatest_0_13)	Version	Latest_0_13
s"<b>${outdatedIvyIndexes.size} Unindexed Ivy repositories found</b>"	String	title
s""" |Update repositories <b><a href="#open">here</a></b> to use dependency completion. |Enable Maven plugin to use extra indexes.<a href="#disable">Disable...</a> """.stripMargin	String	message
new NotificationData( title, message, NotificationCategory.WARNING, NotificationSource.PROJECT_SYNC)	NotificationData	notificationData
ProjectStructureConfigurable.getInstance(project)	ProjectStructureConfigurable	ui
new SingleConfigurableEditor(project, ui)	SingleConfigurableEditor	editor
buildEvent(text, SbtProcessBuildWarning(dumpTaskId, _), SbtShellBuildError(dumpTaskId, _))	Option[MessageEvent]	buildEv
new ExternalSystemStatusEventImpl[TaskOperationDescriptor]( dumpTaskId, null, taskDescriptor, 1, -1, "events" )	ExternalSystemStatusEventImpl[TaskOperationDescriptor]	progressEvent
new ExternalSystemTaskExecutionEvent(id, progressEvent)	ExternalSystemTaskExecutionEvent	event
new SbtPossiblePlacesPanel(project, wizard, fileLines)	SbtPossiblePlacesPanel	panel
ui.getModulesConfig.getModules.find(ModuleType.get(_).isInstanceOf[SbtModuleType])	Option[Module]	module
Messages.showYesNoDialog(project, s"""Notification will be disabled for all projects Settings | Appearance & Behavior | Notifications | $SBT_MAVEN_NOTIFICATION_GROUP can be used to configure the notification.""".stripMargin, "Unindexed Maven Repositories sbt Detection", "Disable Notification", CommonBundle.getCancelButtonText, Messages.getWarningIcon)	Int	result
JvmMemorySize.parse(maxHeapSizeString + "M") .orElse(JvmMemorySize.parse(maxHeapSizeString)) .map(_.toString) .getOrElse(maxHeapSizeString + "M")	String	maxHeapSize
if (maxHeapSizeString.nonEmpty) { val maxHeapSize = JvmMemorySize.parse(maxHeapSizeString + "M") .orElse(JvmMemorySize.parse(maxHeapSizeString)) .map(_.toString) .getOrElse(maxHeapSizeString + "M") Seq(s"-Xmx$maxHeapSize") } else Seq.empty	Seq[String]	maxHeapOptions
{ if (useShellImport) { val messagesF = dumper.dumpFromShell(taskId, projectRoot, structureFilePath, options, notifications) Try(Await.result(messagesF, Duration.Inf)) // TODO some kind of timeout / cancel mechanism } else { val sbtStructureJar = settings .customSbtStructureFile .orElse(SbtUtil.getSbtStructureJar(sbtVersion)) .getOrElse(throw new ExternalSystemException(s"Could not find sbt-structure-extractor for sbt version $sbtVersion")) val structureFilePath = normalizePath(structureFile) // TODO add error/warning messages during dump, report directly dumper.dumpFromProcess( projectRoot, structureFilePath, options, settings.vmExecutable, settings.vmOptions, settings.environment, sbtLauncher, sbtStructureJar, taskId, notifications) } }	Try[SbtStructureDump.ImportMessages]	messageResult
maxHeapOptions ++ ideaProxyOptions ++ userOptions	IndexedSeq[String]	allOptions
HttpConfigurable.getInstance	HttpConfigurable	http
new SbtArtifactChooseDependencyStep(this, artifactInfoSet)	SbtArtifactChooseDependencyStep	sbtArtifactSearchStep
new SbtPossiblePlacesStep(this, project, fileLines)	SbtPossiblePlacesStep	sbtPossiblePlacesStep
new JBList[ArtifactInfo]()	JBList[ArtifactInfo]	myResultList
_	Option[ArtifactInfo]	resultArtifact
_	Option[DependencyPlaceInfo]	resultFileLine
new JBList[DependencyPlaceInfo]()	JBList[DependencyPlaceInfo]	myResultList
createEditor()	Editor	myCurEditor
7	Int	EDITOR_TOP_MARGIN
if (!StringUtil.isEmpty(http.PROXY_EXCEPTIONS)) { val hosts = http.PROXY_EXCEPTIONS.split(",") if (hosts.nonEmpty) { val hostString = hosts.map(_.trim).mkString("|") Seq(("http.nonProxyHosts", hostString)) } else Seq.empty } else Seq.empty	Seq[(Nothing, Any)]	nonProxyHosts
new SbtArtifactSearchPanel(wizard, artifactInfoSet)	SbtArtifactSearchPanel	panel
"libraryDependencies"	String	LIBRARY_DEPENDENCIES
"settings"	String	SETTINGS
"Seq"	String	SEQ
Set(":=", "+=", "++=")	Set[Nothing]	InfixOpsSet
XML.load(structureFile.toURI.toURL)	Elem	elem
List()	Seq[PsiElement]	res
artifactInfoSet .toSeq .sortWith((a, b) => a.groupId >= b.groupId && a.artifactId >= b.artifactId && compare(a.version, b.version) >= 0 )	Seq[ArtifactInfo]	artifacts
List()	Seq[ScPatternDefinition]	res
parameterized.typeArguments	Seq[ScType]	args
List()	Seq[ScInfixExpr]	res
StringUtil.offsetToLineNumber(psiFile.charSequence, psiFile.getTextLength) + 1	Int	line
infix.getContainingFile	PsiFile	psiFile
infix.right	ScExpression	dependency
patternDefinition.`type`().toOption .map(_.canonicalText)	Option[String]	maybeTypeName
generateSeqPsiMethodCall(info)(project)	ScMethodCall	seqCall
ref.resolve()	PsiElement	element
infix.right	ScExpression	dependencies
getScPatternDefinition(element)	ScPatternDefinition	patternDefinition
List()	Seq[ScMethodCall]	res
element.getProject	Project	p
refElement match { case ValidSmartPointer(element) => element.getManager.isInProject(scalaFile) case _ => false }	Boolean	isInProject
Option(ScalaPsiUtil.getModule(element))	Option[Module]	module
refElement.getElement	ScReference	element
SbtResolverUtils.projectResolvers(element)	Set[SbtResolver]	resolversToUse
-1	Int	NO_TIMESTAMP
project.baseDir	VirtualFile	baseDir
-2	Int	MAVEN_UNAVALIABLE
getModuleFromEnumerator(enumerator).fold(false)(_ != library.getOwnerModule)	Boolean	isTransitive
sbtVersionFor(file)	Version	sbtVersion
sbtVersion < Version("0.13.6")	Boolean	less_13_6
createPersistentMap(indexDir / Paths.ARTIFACT_TO_GROUP_FILE)	PersistentHashMap[String, Set[String]]	artifactToGroupMap
createPersistentMap(indexDir / Paths.GROUP_TO_ARTIFACT_FILE)	PersistentHashMap[String, Set[String]]	groupToArtifactMap
generateArtifactPsiExpression(info)(project)	ScExpression	addedExpr
createPersistentMap(indexDir / Paths.GROUP_ARTIFACT_TO_VERSION_FILE)	PersistentHashMap[String, Set[String]]	groupArtifactToVersionMap
1000	Int	MAX_RESULTS
createPersistentMap(indexDir / Paths.FQ_NAME_TO_GROUP_ARTIFACT_VERSION_FILE)	PersistentHashMap[String, Set[String]]	fqNameToGroupArtifactVersionMap
s.split(":")	Array[String]	info
resolversToUse.flatMap(_.getIndex(p))	IndexedSeq[ResolverIndex]	indexes
Option(PsiTreeUtil.getParentOfType(seqCall, classOf[ScInfixExpr]))	Option[Nothing]	parentDef
mutable.HashMap.empty[String, mutable.Set[String]]	mutable.HashMap[String, mutable.Set[String]]	agMap
mutable.HashMap.empty[String, mutable.Set[String]]	mutable.HashMap[String, mutable.Set[String]]	gaMap
if (sbtVersion < Version("0.13.0")) "Seq[Project.Setting[_]]" :: "Project.Setting[_]" :: Nil else if (less_13_6) "Seq[Def.SettingsDefinition]" :: "Def.SettingsDefinition" :: Nil else if (sbtVersion < Version("1.0.0")) "sbt.internals.DslEntry" :: Nil else "sbt.internal.DslEntry" :: Nil	List[B]	allowedTypes
file.getChildren	Array[PsiElement]	children
parentDef match { case Some(expr) if isValid(expr) && expr.left.textMatches(LIBRARY_DEPENDENCIES) => generateArtifactPsiExpression(info) case _ => generateLibraryDependency(info) }	ScExpression	addedExpr
{ if (isDynamicVersion(info.version)) indexes.exists(_.searchVersion(info.group, info.artifact).nonEmpty) else indexes.exists(_.searchVersion(info.group, info.artifact).contains(info.version)) }	Boolean	isInRepo
mutable.HashMap.empty[String, mutable.Set[String]]	mutable.HashMap[String, mutable.Set[String]]	gavMap
mutable.HashMap.empty[String, mutable.Set[String]]	mutable.HashMap[String, mutable.Set[String]]	fqNameGavMap
generateLibraryDependency(info)(project)	ScInfixExpr	addedExpr
null	PsiElement	addedExpr
projectName + "_" + Random.nextInt(10000)	String	projectTmpName
fqNameArtifacts._1	String	fqName
settings.args.exprsArray	Array[ScExpression]	args
elem match { case call: ScMethodCall => call.getEffectiveInvokedExpr match { case expr: ScReferenceExpression => expr.nameId.getTextOffset case _ => elem.getTextOffset } case _ => elem.getTextOffset }	Int	offset
StringUtil.offsetToLineNumber(elem.getContainingFile.charSequence, offset) + 1	Int	line
FileDocumentManager.getInstance.getDocument(project.baseDir.findFileByRelativePath(myCurFileLine.path))	Document	document
baseDir.findChild(Sbt.BuildFile) match { case buildFile if buildFile != null && buildFile.exists() => Some(buildFile) case _ => baseDir.getChildren.find(language.SbtFileType.isMyFileType) }	Option[VirtualFile]	sbtFileOpt
SbtResolver.localCacheResolver(None)	SbtResolver	resolver
findBuildModule(module)	Option[Module]	sbtModule
ScalaPsiElementFactory.createScalaFileFromText(document.getText)(project)	ScalaFile	tmpFile
tmpFile.findElementAt(myCurFileLine.element.getTextOffset)	PsiElement	tmpElement
extensions.inReadAction(getReferenceText)	String	fqName
ConfigurationData("compile", Seq(DirectoryData(sourceDir, managed = false)), Seq.empty, Seq.empty, classDir)	ConfigurationData	dummyConfigurationData
findProjectModule(module).flatMap(_.scalaLanguageLevel).map(_.getVersion)	Option[Nothing]	scalaVersion
for { typeName <- allowedTypes typeElement = ScalaPsiElementFactory.createTypeElementFromText(typeName, expression.getContext, expression) expectedType <- typeElement.`type`().toOption } yield expectedType	IndexedSeq[ScType]	maybeExpectedType
JavaData(None, Seq.empty)	JavaData	dummyJavaData
for { resultArtifact <- wizard.resultArtifact dependency <- AddSbtDependencyUtils.addDependency(tmpElement, resultArtifact)(project) } yield dependency	Option[PsiElement]	dep
myCurEditor.getScrollingModel	ScrollingModel	scrollingModel
myCurEditor.offsetToLogicalPosition(myCurFileLine.offset)	LogicalPosition	oldPos
myCurEditor.getColorsScheme.getAttributes(CodeInsightColors.MATCHED_BRACE_ATTRIBUTES)	TextAttributes	attributes
DependencyData(Seq.empty, Seq.empty, Seq.empty)	DependencyData	dummyDependencyData
new FilenameFilter { override def accept(dir: File, name: String): Boolean = name.endsWith(".xml") }	{ def accept(dir: Any, name: String): Boolean }	ivyFileFilter
EditorFactory.getInstance.createViewer(EditorFactory.getInstance().createDocument(""))	Editor	viewer
fqNameArtifacts._2.map(a => a.groupId + ":" + a.artifactId + ":" + a.version)	IndexedSeq[String]	artifacts
new SbtIvyCacheEnumerator(new File(root), progressIndicator)	IvyIndex.this.SbtIvyCacheEnumerator	ivyCacheEnumerator
XML.loadFile(ivyFile)	Elem	xml
for { home <- jreHome if ! hasOption(maxPermSize.key) jreVersion <- Option(JdkVersionDetector.getInstance().detectJdkVersionInfo(home.getAbsolutePath)) if jreVersion.version.feature >= 8 } yield options	Option[Seq[String]]	withoutPermSize
JvmOption("-Dfile.encoding", "UTF-8")	DefaultOptions.JvmOption	fileEncoding
JvmOption("-XX:MaxPermSize", "256M")	DefaultOptions.JvmOption	maxPermSize
JvmOption("-Didea.managed", "true")	DefaultOptions.JvmOption	ideaManaged
(xml \\ "ivy-module" \\ "info" \\ "@organisation").text	String	group
new mutable.HashMap[String, ResolverIndex]()	mutable.HashMap[String, ResolverIndex]	indexes
(xml \\ "ivy-module" \\ "info" \\ "@module").text	String	artifact
EditorHighlighterFactory.getInstance.createEditorHighlighter(project, ScalaFileType.INSTANCE)	EditorHighlighter	editorHighlighter
(xml \\ "ivy-module" \\ "info" \\ "@revision").text	String	version
Option(map.get(element._1)).getOrElse(Set.empty)	Set[String]	existingValue
ScalaProjectSettings.getInstance(project.project).getIvy2IndexingMode.toString	String	newMode
f(x)	A	v
false	Boolean	eof
false	Boolean	updateScheduled
scala.collection.immutable.HashSet[String]()	HashSet[String]	buffer
1L	Long	i
None	Option[ScMethodCall]	placeToFix
getIvyIndex(resolver.name, resolver.root)	ResolverIndex	idx
mutable.Map.empty	mutable.Map[String, mutable.Set[ArtifactInfo]]	fqNameToArtifacts
Option(parameters.getPropertyValue(CommandLineOptions.globalPlugins)).map(new File(_))	Option[Any]	customGlobalPlugins
new ScalaRecursiveElementVisitor { override def visitMethodCallExpression(call: ScMethodCall): Unit = call match { case ScMethodCall(expr, Seq(ScLiteral(name), _)) if expr.getText == "Project" && name == projectName => placeToFix = Some(call) case _ => super.visitMethodCallExpression(call) } }	ScalaRecursiveElementVisitor { def visitMethodCallExpression(call: ScMethodCall): Unit }	visitor
ProjectData( projectTmpName, projectRoot.toURI, projectTmpName, s"org.$projectName", "0.0", projectRoot, Seq.empty, new File(projectRoot, "target"), Seq(dummyConfigurationData), Option(dummyJavaData), None, None, dummyDependencyData, Set.empty, None, Seq.empty, Seq.empty, Seq.empty )	ProjectData	dummyRootProject
ScalaProjectSettings.getInstance(project.project).getIvy2IndexingMode == Ivy2IndexingMode.Classes	Boolean	enableFQNameIndex
Seq(dummyRootProject)	Seq[ProjectData]	projects
Option(parameters.getPropertyValue(CommandLineOptions.globalBase)).map(new File(_))	Option[Any]	customGlobalBase
new ProjectNode(projectName, projectPath, projectPath)	ProjectNode	projectNode
Iterator.fill(powK)(1024L).product	Long	byteMultiplier
new FileFilter { override def accept(file: File): Boolean = file.name.endsWith(".xml") }	{ def accept(file: Any): Boolean }	ivyFileFilter
Seq(Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes)	Seq[JvmMemorySize.Factory]	units
customGlobalBase.map(new File(_, "plugins"))	Option[Any]	pluginsUnderCustomGlobalBase
Seq.empty[LibraryNode]	Seq[LibraryNode]	libraryNodes
units.map(unit => unit.unitSuffix -> unit.byteMultiplier).toMap	Map[String, Long]	unitMultiplierMapping
sbtVersion.major(1).presentation	String	major
raw"(\d+)([a-zA-Z]*)".r	Regex	sizeWithUnit
NotificationGroup.balloonGroup("sbt")	NotificationGroup	notificationGroup
readSectionFromBootPropertiesOf(jar, sectionName = "app")	Map[String, String]	appProperties
createModules(projects, libraryNodes, moduleFilesDirectory)	Map[ProjectData, ModuleNode]	projectToModule
mutable.HashMap.empty[ArtifactInfo, Set[String]]	mutable.HashMap[ArtifactInfo, Set[String]]	artifactToFqNames
false	Boolean	isList
if (fqName.endsWith("._")) { // search wildcard imports by containing package doSearch(fqName.replaceAll("_$", "")) match { case set if set.isEmpty => doSearch(fqName.replaceAll("._$", "")) // not a package, try searching for a class case result => result } } else { doSearch(fqName) match { case set if set.isEmpty && fqName.contains(".") => // imported name is not a class -> search for enclosing package doSearch(fqName.substring(0, fqName.lastIndexOf(".") + 1)) case result => result } }	Set[ArtifactInfo]	artifacts
false	Boolean	isDone
fetchProject(dataContext)	Project	project
t.artifactId + "-" + t.version + ".jar"	String	fname
None	Option[ScTypeElement]	_analog
scala.io.Source.fromInputStream(jar.getInputStream(entry)).getLines()	Iterator[String]	lines
Option(getNextSibling).map(_.getNode)	Option[ASTNode]	nextNode
SbtProjectData(Seq.empty, settings.jdk.map(JdkByName), Seq.empty, sbtVersion, projectPath)	SbtProjectData	dummySbtProjectData
extensions.inReadAction( for { sbtFile <- sbtFileOpt psiSbtFile = PsiManager.getInstance(project).findFile(sbtFile).asInstanceOf[ScalaFile] depPlaces = getDependencyPlaces(project, psiSbtFile) } yield depPlaces )	Option[Seq[DependencyPlaceInfo]]	depPlaces
nextNode .exists(n => n.getElementType == ScalaTokenTypes.tIDENTIFIER && n.getText == "*")	Boolean	isAsterisk
getContext match { case typeElement: ScParameterizedTypeElement => typeElement case _ => this }	ScTypeElement	constrInvocationTypeElement
getDeps	Set[ArtifactInfo]	deps
components.map(_.getText)	IndexedSeq[Nothing]	componentsTexts
listFqNames(dir, artifactsHere)	mutable.Map[ArtifactInfo, Set[String]]	artifactToFqNames
BuildData(projectRoot.toURI, Seq.empty, Seq.empty, Seq.empty, Seq.empty)	BuildData	dummyBuildData
getPlaces	Seq[DependencyPlaceInfo]	places
new ui.SbtArtifactSearchWizard(project, deps, places)	SbtArtifactSearchWizard	wizard
List()	List[DependencyPlaceInfo]	res
(for { node <- nextNode next <- Option(node.getTreeNext) } yield next.getElementType != ScalaTokenTypes.tIDENTIFIER).getOrElse(true)	Boolean	notAnInfixType
getTopLevelLibraryDependencies(psiSbtFile)	Seq[ScInfixExpr]	libDeps
ModuleManager.getInstance(project).getModules.toList	List[Module]	modules
getTopLevelSbtProjects(psiSbtFile)	Seq[ScPatternDefinition]	sbtProjects
createBuildModule(dummyBuildData, projects, moduleFilesDirectory, None)	ModuleNode	buildModule
ModuleManager.getInstance(project).getModules	Array[Module]	modules
data.projects	Seq[ProjectData]	projects
SbtUtil.getSbtModuleData(project, moduleId)	Option[SbtModuleData]	maybeModuleData
projects.find(p => FileUtil.filesEqual(p.base, new File(root))) .orElse(projects.headOption) .getOrElse(throw new RuntimeException("No root project found"))	ProjectData	rootProject
new ProjectNode(rootProject.name, root, root)	ProjectNode	projectNode
projects.flatMap(_.basePackages).distinct	IndexedSeq[String]	basePackages
SbtUtil.getModuleData(project, moduleId, SbtTaskData.Key).toList	List[SbtTaskData]	moduleTasks
getNode.getChildren(TokenSet.create(ScalaTokenTypes.tFUNTYPE, ScalaTokenTypes.tFUNTYPE_ASCII))	Array[ASTNode]	result
SbtUtil.getModuleData(project, moduleId, SbtSettingData.Key).toList	List[SbtSettingData]	moduleSettings
rootProject.java.map(_.options).getOrElse(Seq.empty)	Seq[String]	javacOptions
Key.create[ScType]("scala.type.without.implicits")	Key[ScType]	TypeKey
chooseJdk(rootProject, settingsJdk)	Option[SdkReference]	projectJdk
(paramTypeElement match { case tuple: ScTupleTypeElement => tuple.components case parenthesised: ScParenthesisedTypeElement => parenthesised.innerElement.toSeq case other => Seq(other) }).map(_.getParamTypeText) ++ Seq(returnTypeElement.map(_.getText).getOrElse("Any"))	IndexedSeq[String]	paramTypes
containingClass	ScTemplateDefinition	ccontainingClass
sbtProjects.map(proj => proj -> modules.map(_.getName).filter(containsModuleName(proj, _))).toMap	Map[ScPatternDefinition, IndexedSeq[Nothing]]	projToAffectedModules
getLastChild	PsiElement	child
ccontainingClass.getOriginalElement.asInstanceOf[PsiClass]	PsiClass	originalClass
originalClass.asInstanceOf[ScTypeDefinition]	ScTypeDefinition	c
collection.mutable.Map[PsiElement, Seq[String]]()	mutable.Map[PsiElement, Seq[String]]	elemToAffectedProjects
projects.flatMap(p => p.play2.map(d => (p.id, p.base, d)))	IndexedSeq[(String, Any, Play2Data)]	newPlay2Data
c.members.iterator	Iterator[ScMember]	membersIterator
membersIterator.next()	ScMember	member
getPossiblePlacesToAddFromProjectDefinition(proj)	Seq[PsiElement]	places
member.asInstanceOf[ScDeclaredElementsHolder]	ScDeclaredElementsHolder	d
list.patterns.map(_.`type`().getOrAny)	IndexedSeq[ScType]	types
createLibraries(data, projects)	Seq[LibraryNode]	libraryNodes
nameId.getTextRange.getStartOffset - getTextRange.getStartOffset	Int	start
getTextLength	Int	len
d.declaredElements.iterator	Iterator[PsiNamedElement]	elemsIterator
elemsIterator.next()	PsiNamedElement	nextElem
moduleSettings ++ moduleTasks	IndexedSeq[SbtEntityData with SbtNamedKey with SbtRankedKey with Serializable]	moduleKeys
getAnnotations	Array[ScAnnotation]	annotations
createSharedSourceModules(projectToModule, libraryNodes, moduleFilesDirectory)	Seq[ModuleNode]	sharedSourceModules
a.annotationExpr.constructorInvocation	ScConstructorInvocation	constr
createBuildModule(_, projects, moduleFilesDirectory, data.localCachePath.map(_.getCanonicalPath))	BuildData => ModuleNode	buildModuleForProject
data.builds.map(buildModuleForProject)	IndexedSeq[ModuleNode]	buildModules
moduleKeys.filter { td => td.name.contains(commandString) }	IndexedSeq[SbtEntityData with SbtNamedKey with SbtRankedKey with Serializable]	relevantEntries
lines .dropWhile(_.trim != s"[$sectionName]").drop(1) .takeWhile(!_.trim.startsWith("["))	Iterator[String]	sectionLines
clause.getTextByStub	String	paramClauseText
project.android.map(android => AndroidJdk(android.targetVersion))	Option[AndroidJdk]	androidSdk
parameterList.clauses match { case Seq() => Seq(emptyParameterList) case Seq(clause) if clause.isImplicit => Seq(emptyParameterList, clause) case clauses => clauses }	Seq[ScParameterClause]	clausesWithInitialEmpty
parameterList	ScParameters	parameters
parameters.clauses	Seq[ScParameterClause]	clauses
findChildByClassScala(classOf[ScConstructorInvocation])	Null	constrInvocation
getParent.asInstanceOf[ScTypeDefinition]	ScTypeDefinition	clazz
clazz.typeParameters	Seq[ScTypeParam]	typeParameters
new BooleanFunction[DataNode[ModuleData]] { override def fun(s: DataNode[ModuleData]): Boolean = s.getData.getId == moduleId }	BooleanFunction[DataNode[ModuleData]] { def fun(s: DataNode[ModuleData]): Boolean }	predicate
defaultJdk.map(JdkByName)	Option[JdkByName]	default
modules.flatMap { module => val moduleId = ExternalSystemApiUtil.getExternalProjectId(module) val maybeModuleData = SbtUtil.getSbtModuleData(project, moduleId) // suggest settings and tasks scoped to project maybeModuleData.flatMap { moduleData => val moduleTasks = SbtUtil.getModuleData(project, moduleId, SbtTaskData.Key).toList val moduleSettings = SbtUtil.getModuleData(project, moduleId, SbtSettingData.Key).toList val moduleKeys = moduleSettings ++ moduleTasks val relevantEntries = moduleKeys.filter { td => td.name.contains(commandString) } if (moduleData.id.contains(projectString)) Some((moduleData, relevantEntries)) else None } }	IndexedSeq[(SbtModuleData, IndexedSeq[SbtEntityData with SbtNamedKey with SbtRankedKey with Serializable])]	moduleDataAndKeys
SbtUtil.makeSbtProjectId(moduleData)	String	projectId
projectToModule.values .find(_.getId == ModuleNode.combinedId(dependencyId.project, dependencyId.buildURI)) .getOrElse(throw new ExternalSystemException("Cannot find project dependency: " + dependencyId.project))	ModuleNode	dependency
ScalaPsiUtil.getPlaceTd(clazz)	ScTemplateDefinition	parentClazz
new ModuleDependencyNode(moduleNode, dependency)	ModuleDependencyNode	data
if (parentClazz != null) ScProjectionType(ScThisType(parentClazz), clazz) else ScDesignatorType(clazz)	ScType	designatorType
ScalaPsiManager.instance	ScalaPsiManager	psiManager
result.getOrElse({ val clazz = getParent.asInstanceOf[ScTypeDefinition] val typeParameters = clazz.typeParameters val parentClazz = ScalaPsiUtil.getPlaceTd(clazz) val designatorType: ScType = if (parentClazz != null) ScProjectionType(ScThisType(parentClazz), clazz) else ScDesignatorType(clazz) if (typeParameters.isEmpty) designatorType else { ScParameterizedType(designatorType, typeParameters.map(TypeParameterType(_))) } })	ScType	returnType
findChildByClassScala(classOf[ScAnnotations])	Null	container
constr.args.patterns.indexWhere(_ == pattern)	Int	thisIndex
if (infix.left == pattern) 0 else if (pattern.isInstanceOf[ScTuplePattern]) return None //pattern is handled elsewhere in pattern function else 1	Int	i
for { projectInfo <- Option(dataManager.getExternalProjectData(project, SbtProjectSystem.Id, project.getBasePath)) projectStructure <- Option(projectInfo.getExternalProjectStructure) moduleDataNode <- Option(ExternalSystemApiUtil.find(projectStructure, ProjectKeys.MODULE, predicate)) dataNodes <- Option(ExternalSystemApiUtil.findAll(moduleDataNode, key)) } yield { dataNodes.asScala.map { node => dataManager.ensureTheDataIsReadyToUse(node) node.getData } }	Option[Any]	maybeNodes
data.id	String	id
binaryVersion(sbtVersion)	Version	binVersion
SbtShellTask(projectId, commandString)	SbtRunAnythingProvider.SbtShellTask	basicSuggestion
tuple.patternList match { case Some(patterns: ScPatterns) => patterns.patterns.indexWhere(_ == pattern) case _ => return None }	Int	i
if (binVersion ~= Version("0.13")) Some(BuildInfo.sbtStructurePath_0_13) else if (binVersion ~= Version("1.0")) Some(BuildInfo.sbtStructurePath_1_0) else None	Option[String]	structurePath
libraryNodes.map(_.data).find(_.getExternalName == Sbt.UnmanagedSourcesAndDocsName)	Option[LibraryData]	unmanagedSourcesAndDocsLibrary
tuple.patternList match { case Some(pat) => pat.patterns.length case _ => -1 //is it possible to get here? }	Int	patternLength
version.major(2)	Version	major
projects.groupBy(_.name)	Map[String, Seq[ProjectData]]	nameToProjects
if (major.inRange(Version("0.12"), Version("0.13"))) Sbt.Latest_0_12 else if (major.inRange(Version("0.13"), Version("1.0"))) Sbt.Latest_0_13 else if (major.inRange(Version("1.0"), Version("2.0"))) Sbt.Latest_1_0 else Sbt.LatestVersion	Version	latestInSeries
nameToProjects.size == projects.size	Boolean	namesAreUnique
if (file.getName == "classes") 1 else 2	Int	deep
psiManager.getCachedClass(elementScope.scope, "scala.xml.Node")	Option[PsiClass]	nodeClass
nameId.getNode	ASTNode	id
if (namesAreUnique) project.name else project.id	String	moduleName
id.getTreeParent	ASTNode	parent
if (nameToProjects(project.name).size > 1) Array(project.name) else null	Array[String]	groupName
keys.sortBy(_.rank).map { key => SbtShellTask(projectId, key.name) }	IndexedSeq[SbtRunAnythingProvider.SbtShellTask]	taskSuggestions
clauses.foldRight[ScType](returnType){(clause: ScParameterClause, tp: ScType) => ScMethodType(tp, clause.getSmartParameters, clause.isImplicit) }	ScType	res
psiManager.getCachedClass(elementScope.scope, "java.lang.Throwable")	Option[PsiClass]	thr
mutable.ArrayBuffer.empty[ScPrimaryConstructorWrapper]	ArrayBuffer[ScPrimaryConstructorWrapper]	buffer
multiResolveScala(false).iterator	Iterator[ScalaResolveResult]	iterator
createModule(project, moduleFilesDirectory, moduleName)	ModuleNode	moduleNode
iterator.next()	ScalaResolveResult	resolved
element.getOriginalElement	PsiElement	originalElement
createContentRoot(project)	ContentRootNode	contentRootNode
qualName.split('.')	Array[String]	parts
new LibraryDependencyNode(moduleNode, lib, LibraryLevel.MODULE)	LibraryDependencyNode	dependency
parts.last	String	last
referenceCreator(last, true)	T	anotherRef
projects.map { project => val moduleName = if (namesAreUnique) project.name else project.id val groupName = if (nameToProjects(project.name).size > 1) Array(project.name) else null val moduleNode = createModule(project, moduleFilesDirectory, moduleName) moduleNode.setIdeModuleGroup(groupName) val contentRootNode = createContentRoot(project) project.android.foreach(a => a.apklibs.foreach(addApklibDirs(contentRootNode, _))) moduleNode.add(contentRootNode) moduleNode.addAll(createLibraryDependencies(project.dependencies.modules)(moduleNode, libraryNodes.map(_.data))) moduleNode.add(createModuleExtData(project)) moduleNode.add(new SbtModuleNode(SbtModuleData(project.id, project.buildURI))) moduleNode.addAll(createTaskData(project)) moduleNode.addAll(createSettingData(project)) moduleNode.addAll(createCommandData(project)) moduleNode.addAll(project.android.map(createFacet(project, _)).toSeq) moduleNode.addAll(createUnmanagedDependencies(project.dependencies.jars)(moduleNode)) unmanagedSourcesAndDocsLibrary foreach { lib => val dependency = new LibraryDependencyNode(moduleNode, lib, LibraryLevel.MODULE) dependency.setScope(DependencyScope.COMPILE) moduleNode.add(dependency) } (project,moduleNode) }	IndexedSeq[(ProjectData, ModuleNode)]	projectToModule
anotherRef.multiResolveScala(false)	Array[ScalaResolveResult]	resolve
projectToModule.toMap	Map[ProjectData, ModuleNode]	projectToModuleMap
getParent	PsiElement	oldParent
data.repository.map(_.modules).getOrElse(Seq.empty)	Seq[ModuleData]	repositoryModules
findChildByClassScala(classOf[ScCaseClauses])	Null	caseClauses
resolve.exists(_.importsUsed.nonEmpty)	Boolean	hasUsedImports
caseClauses.caseClauses	Seq[ScCaseClause]	clauses
ArrayBuffer[ScType]()	ArrayBuffer[ScType]	clausesTypes
clauses.iterator	Iterator[ScCaseClause]	iterator
getNode.findChildByType(ScalaTokenTypes.tIDENTIFIER)	ASTNode	node
resolve.map(_.name).toSet	Set[String]	usedNames
false	Boolean	reject
ref match { case refImpl: ScStableCodeReferenceImpl => refImpl.doResolve(new ExpandedExtractorResolveProcessor(ref, ref.refName, ref.getKinds(incomplete = false), ref.getContext match { case inf: ScInfixPattern => inf.expectedType case constr: ScConstructorPattern => constr.expectedType case _ => None })) }	Array[ScalaResolveResult]	resolve
ref.bind() match { case Some(ScalaResolveResult(_: ScBindingPattern | _: ScParameter, _)) => val resolve = ref match { case refImpl: ScStableCodeReferenceImpl => refImpl.doResolve(new ExpandedExtractorResolveProcessor(ref, ref.refName, ref.getKinds(incomplete = false), ref.getContext match { case inf: ScInfixPattern => inf.expectedType case constr: ScConstructorPattern => constr.expectedType case _ => None })) } resolve match { case Array(r) => Some(r) case _ => None } case m => m }	Option[ScalaResolveResult]	bind
if (ScalaPsiUtil.needParentheses(this, expr)) { impl.ScalaPsiElementFactory.createExpressionFromText(expr.getText.parenthesize()) } else expr	ScExpression	newExpr
projects.flatMap(_.dependencies.modules.map(_.id)).toSet -- repositoryModules.map(_.id).toSet	Set[ModuleIdentifier]	otherModuleIds
oldParent.getNode	ASTNode	parentNode
newExpr.copy.getNode	ASTNode	newNode
None	Option[(ScExpression, ScType)]	additionalExpression
ScUnderScoreSectionUtil.underscores(expr)	Seq[ScUnderscoreSection]	unders
Option(pointer.getElement).map(_.name)	Option[String]	maybeName
ScalaCodeStyleSettings.getInstance(getProject).hasImportWithPrefix(qualName)	Boolean	prefixImport
"ValueRead"	String	name
`type` match { case ScExistentialType(quantified, _) => quantified case _ => `type` }	ScType	tp
if (ScalaCodeStyleSettings.getInstance(getProject).isImportShortestPathForAmbiguousReferences) parts.length - 2 else 0	Int	index
"ValueWrite"	String	name
SmartPointerManager.createPointer(_e)	SmartPsiElementPointer[PsiElement]	pointer
substitutor(functionType)	ScType	substitutedFunctionType
getContainingClassLoose	ScTemplateDefinition	found
ScalaCodeStyleSettings.getInstance(pointer.getProject)	ScalaCodeStyleSettings	settings
if (clausesTypes.isEmpty) Nothing else clausesTypes.lub(checkWeak = true)	ScType	clausesLubType
importExpr.getOrElse(return None)	ScImportExpr	expr
parts.take(index + 1).mkString(".")	String	packagePart
pattern.getParent.asInstanceOf[ScalaPsiElement] .findChildrenByType(ScalaTokenTypes.tINTERPOLATED_STRING) .map(_.getText)	IndexedSeq[Nothing]	parts
false	Boolean	flag
this.resolveScope	GlobalSearchScope	resolveScope
qualifiedName	String	qualName
modulesWithBinaries.map(createResolvedLibrary) ++ otherModuleIds.map(createUnresolvedLibrary)	IndexedSeq[LibraryNode]	libs
ScalaPsiManager.instance	ScalaPsiManager	manager
pattern.getContext.getContext match { case _: ScInterpolationPattern => val parts = pattern.getParent.asInstanceOf[ScalaPsiElement] .findChildrenByType(ScalaTokenTypes.tINTERPOLATED_STRING) .map(_.getText) if (argIndex < parts.length && parts(argIndex).endsWith("...")) ScalaPsiElementFactory.createTypeElementFromText("Seq[Seq[scala.reflect.api.Trees#Tree]]") if (argIndex < parts.length && parts(argIndex).endsWith("..")) ScalaPsiElementFactory.createTypeElementFromText("Seq[scala.reflect.api.Trees#Tree]") else ScalaPsiElementFactory.createTypeElementFromText("scala.reflect.api.Trees#Tree") }	ScTypeElement	tpe
modulesWithoutBinaries.filter(m => m.docs.nonEmpty || m.sources.nonEmpty)	Seq[ModuleData]	modulesWithDocumentation
new LibraryNode(Sbt.UnmanagedSourcesAndDocsName, true)	LibraryNode	unmanagedSourceLibrary
manager.getCachedClasses(resolveScope, PartialFunctionType.TypeName)	Array[PsiClass]	funs
pattern.getParent.getParent.asInstanceOf[ScInterpolationPatternImpl]	ScInterpolationPatternImpl	interpolationPattern
ScMember.containingClass(this, found)	ScTemplateDefinition	clazz
getContext	PsiElement	context
found.extendsBlock	ScExtendsBlock	extendsBlock
u.getNonValueType(ignoreBaseType).getOrAny.inferValueType.unpackedType	ScType	tpe
parts.drop(index).mkString(".")	String	toReplace
referenceCreator(toReplace, true)	T	ref
ref	T	qual
qual.multiResolveScala(false)	Array[ScalaResolveResult]	resolve
resolve(0)	ScalaResolveResult	result
funs.find(_.isInstanceOf[ScTrait]).getOrElse(return Failure("Cannot find PartialFunction class"))	PsiClass	fun
QuasiquoteInferUtil.getMetaQQPatternTypes(interpolationPattern)	Seq[String]	patterns
unders.zipWithIndex.map { case (u, index) => val tpe = u.getNonValueType(ignoreBaseType).getOrAny.inferValueType.unpackedType Parameter(tpe, isRepeated = false, index = index) }	IndexedSeq[Parameter]	params
manager.getCachedClass(resolveScope, "java.lang.Throwable").orNull	PsiClass	throwable
patterns(argIndex)	String	clazz
context != null && (context == extendsBlock || extendsBlock.templateBody.contains(context) || extendsBlock.earlyDefinitions.contains(context) || found.physicalExtendsBlock.templateBody.contains(context))	Boolean	isCorrect
ScalaPsiElementFactory.createTypeElementFromText(clazz)	ScTypeElement	tpe
qualName.lastIndexOf('.')	Int	index
ScalaAddImportAction.getImportHolder(this, getProject)	ScImportsHolder	holder
true	Boolean	res
fun.typeParameters	Seq[ScTypeParam]	funTypeParams
referenceCreator(toReplace, false)	T	ref
referenceCreator("_root_." + qualName, false)	T	ref
new ArrayBuffer[ScMember]	ArrayBuffer[ScMember]	buf
ScalaAddImportAction.getImportHolder(ref = this, project = getProject)	ScImportsHolder	importHolder
android.map(_.targetVersion).map(AndroidJdk) .orElse(java.flatMap(_.home).map(JdkByHome))	Option[AndroidJdk]	sdk
buf.filter(isSimilarMemberForNavigation(_, isStrict = true))	ArrayBuffer[ScMember]	filter
this.expectedType(fromUnderscore = false) .getOrElse(return Failure("Cannot infer type without expected type"))	ScType	et
Key.create[PsiElement]("ScMember.syntheticNavigationElement")	Key[PsiElement]	syntheticNavigationElementKey
Key.create[ScTypeDefinition]("ScMember.syntheticContainingClass")	Key[ScTypeDefinition]	syntheticContainingClassKey
ScMethodType(expr.getTypeAfterImplicitConversion(ignoreBaseTypes = ignoreBaseType, fromUnderscore = true).tr.getOrAny, params, isImplicit = false)	ScMethodType	methType
expectedOption.orElse { expectedType(fromUnderscore = fromUnderscore) }	Option[ScType]	expected
importHolder.getAllImportUsed.exists { case ImportExprUsed(expr) => expr.reference.exists { ref => ref.multiResolveScala(false).exists(rr => rr.getElement match { case p: ScPackage => p.getQualifiedName == qualifiedName case p: PsiPackage => p.getQualifiedName == qualifiedName case _ => false }) } case _ => false }	Boolean	imported
extendsBlock	ScExtendsBlock	eb
eb.templateParents	Option[ScTemplateParents]	tp
resultExpression match { case None => ScalaPsiUtil.fileContext(this) match { case scalaFile: ScalaFile if scalaFile.isCompiled => Nothing case _ => Unit } case Some(e) => e.`type`().getOrAny }	ScType	inner
ElementScope(getProject)	ElementScope	elementScope
getTypeWithoutImplicits(ignoreBaseTypes, fromUnderscore)	result.TypeResult	tr
qualifiedName	String	qual
member.projectContext	ProjectContext	projectContext
node.getLastChildNode	ASTNode	last
ModuleExtData( scala.map(_.version), scala.fold(Seq.empty[File])(_.jars), scala.fold(Seq.empty[String])(_.options), sdk, java.fold(Seq.empty[String])(_.options) )	ModuleExtData	data
anchor.map { _.getNode }.getOrElse { val last = node.getLastChildNode last.getTreePrev match { case result if isLineTerminator(result.getPsi) => result case _ => last } }	ASTNode	beforeNode
beforeNode.getPsi	PsiElement	before
tryConvertToSAM(fromUnderscore, expType, tp)	Option[ScExpression.ExpressionTypeResult]	samType
stub.getPsi.asInstanceOf[PsiElement]	PsiElement	psi
tp.lowerBound.getOrNothing.typeDepth.max(tp.upperBound.getOrAny.typeDepth)	Int	boundsDepth
f.returnType.getOrAny.typeDepth	Int	returnTypeDepth
sbtStructure.ModuleData(moduleId, Set.empty, Set.empty, Set.empty)	ModuleData	module
new LibraryNode(nameFor(module.id), resolved)	LibraryNode	result
FunctionType(expType, Seq(tp))	ValueType	functionType
new ImplicitCollector(expr, functionType, functionType, None, isImplicitConversion = true)	ImplicitCollector	implicitCollector
if (id.classifier.isEmpty) None else Some(id.classifier)	Option[String]	classifierOption
ScSubstitutor.bind(funTypeParams)(UndefinedType(_))	ScSubstitutor	undefSubst
ModuleNode.combinedId(project.id, Option(project.buildURI))	String	projectId
new ModuleNode(StdModuleTypes.JAVA.getId, projectId, project.buildURI, moduleName, moduleFilesDirectory.path, project.base.canonicalPath)	ModuleNode	result
st.getStub.asInstanceOf[StubElement[_]]	StubElement[_]	stub
validRootPathsIn(project, "compile")(_.sources)	Seq[DirectoryData]	productionSources
createNewLineNode()	ASTNode	newLineNode
extendsBlock.getNode	ASTNode	node
validRootPathsIn(project, "compile")(_.resources)	Seq[DirectoryData]	productionResources
ta.aliasedType.getOrAny.typeDepth	Int	aliasedDepth
Key.create("ScTemplateDefinition.originalElem")	Key[ScTemplateDefinition]	originalElemKey
validRootPathsIn(project, "test")(_.sources) ++ validRootPathsIn(project, "it")(_.sources)	IndexedSeq[DirectoryData]	testSources
SbtShellCommandString(commandString)	SbtRunAnythingProvider.SbtShellCommandString	defaultSuggestion
validRootPathsIn(project, "test")(_.resources) ++ validRootPathsIn(project, "it")(_.resources)	IndexedSeq[DirectoryData]	testResources
new ContentRootNode(project.base.path)	ContentRootNode	result
SbtShellCommunication.forProject(project)	SbtShellCommunication	com
ta.lowerBound.getOrNothing.typeDepth.max(ta.upperBound.getOrAny.typeDepth)	Int	boundsDepth
project.configurations.flatMap(_.excludes)	IndexedSeq[Any]	extractedExcludes
ScalaPsiUtil.getContextOfType(pattern, true, classOf[ScTemplateDefinition])	PsiElement	clazz
createIdentifier(name)	ASTNode	newId
nameContext.getParent match { case _: ScTemplateBody | _: ScEarlyDefinitions => PsiTreeUtil.getParentOfType(this, classOf[ScTemplateDefinition], true) case _ if this.isInstanceOf[ScClassParameter] => PsiTreeUtil.getParentOfType(this, classOf[ScTemplateDefinition], true) case _ => null }	ScTemplateDefinition	clazz
PsiTreeUtil.getParentOfType(this, classOf[ScMember], false)	ScMember	parentMember
ContainerUtil.createConcurrentLongObjectMap()	ConcurrentLongObjectMap[String]	idToName
clazz match { case clazz: ScTemplateDefinition => undefSubst.followed(ScSubstitutor(ScThisType(clazz))) case _ => undefSubst }	ScSubstitutor	withThisType
project.configurations .flatMap(configuration => configuration.sources ++ configuration.resources) .filter(_.managed) .map(_.file)	IndexedSeq[Any]	managedDirectories
ContainerUtil.createConcurrentLongObjectMap()	ConcurrentLongObjectMap[String]	reusableIdToName
this.stubOrPsiChild(ScalaElementType.MODIFIERS)	Option[ScModifierList]	child
Set("main", "test")	Set[Nothing]	defaultNames
Long.MaxValue / 2	Long	nameBasedIdBaseline
elementQual(typeParameter)	String	qualifier
psiTypeParameter => psiTypeParameter match { case sc: ScTypeParam => sc.typeParamId case null => -1 case p => cachedId(p, p.name) }	params.TypeParamId[PsiTypeParameter]	psi
t => psi.typeParamId(t.psiTypeParameter)	params.TypeParamId[TypeParameter]	typeParam
t => psi.typeParamId(t.psiTypeParameter)	params.TypeParamId[TypeParameterType]	typeParamType
identity(_)	params.TypeParamId[Long]	long
name => nameBasedIdBaseline + name.hashCode	params.TypeParamId[String]	nameBased
getParent	PsiElement	parent
function.body match { case Some(value) => value case None => return Set.empty }	ScExpression	body
fun.parameters.head.`type`() match { case Right(tp) => tp case _ => return None }	ScType	firstParameterType
withThisType(firstParameterType)	ScType	funType
c.aliases.iterator	Iterator[ScTypeAlias]	aliasesIterator
None	Option[ScType]	result
aliasesIterator.next()	ScTypeAlias	alias
{ body.depthFirst(!_.isInstanceOf[ScFunction]) .collect { case statement: ScReturn => statement } .toSet }	Set[ScReturn]	allReturnStatements
implicitCollector.collect() match { case Seq(res) => extractImplicitParameterType(res).flatMap { case FunctionType(rt, Seq(_)) => Some(rt) case paramType => expr.elementScope.cachedFunction1Type.flatMap { functionType => paramType.conforms(functionType, ConstraintSystem.empty) match { case ConstraintSystem(substitutor) => Some(substitutor(functionType.typeArguments(1))) case _ => None } }.filterNot { _.isInstanceOf[UndefinedType] } }.map(_ -> res) case _ => None }	Option[(ScType, ScalaResolveResult)]	fromImplicit
clause.parameters.indexOf(this)	Int	i
body.calculateTailReturns	Set[ScExpression]	tailExpressions
body.getContainingFile	PsiFile	file
function.body.map(_.calculateTailReturnsOptimizable).getOrElse(Set())	Set[ScExpression]	returnUsages
this.expectedType(fromUnderscore)	Option[ScType]	expectedType
getActualDefaultExpression	Option[ScExpression]	res
if (funTypeParams.isEmpty) substitutor else { val undefSubst = ScSubstitutor.bind(funTypeParams)(UndefinedType(_)) val clazz = ScalaPsiUtil.getContextOfType(pattern, true, classOf[ScTemplateDefinition]) val withThisType = clazz match { case clazz: ScTemplateDefinition => undefSubst.followed(ScSubstitutor(ScThisType(clazz))) case _ => undefSubst } val firstParameterType = fun.parameters.head.`type`() match { case Right(tp) => tp case _ => return None } val funType = withThisType(firstParameterType) expected match { case Some(tp) => calculateSubstitutor(tp, funType, substitutor) case _ => substitutor } }	ScSubstitutor	subst
returnUsages.flatMap(expandIncompleteIf)	Set[PsiElement]	returnUsagesExpanded
self	PsiElement	element
possiblyTailRecursiveCallFor(reference)	PsiElement	element
reference.refName	String	refName
expression.projectContext.stdTypes.Unit	ValType	UnitStdType
function.returnTypeElement match { case Some(Typeable(UnitStdType)) => true case _ if !function.hasAssign => true case _ => false }	Boolean	canExpand
containingClass match { case obj: ScObject if obj.isStatic => true case _ => false }	Boolean	isDefinedInObject
p.clauses.indexOf(clause)	Int	j
Seq(GETTER, IS_GETTER, SETTER)	Seq[PropertyMethods.Value]	beanMethods
values.toSeq	Seq[PropertyMethods.DefinitionRole]	allRoles
method.paramClauses.clauses	Seq[ScParameterClause]	clauses
if (variance == Contravariant) substitutor(tp.lowerType) else substitutor(tp.upperType)	ScType	result
clauses.apply(j).parameters	Seq[ScParameter]	parameters
property.nameContext.asInstanceOf[ScMember]	ScMember	member
function.paramClauses.clauses	Seq[ScParameterClause]	clauses
property.isVar	Boolean	isVar
{ val clauses = function.paramClauses.clauses clauses.nonEmpty && clauses.head.parameters.size == 1 && !clauses.head.isImplicit && clauses.drop(1).forall(_.isImplicit) }	Boolean	hasSingleNonImplicitParam
methodName(property.name, role)	String	mName
nonValueType .widenLiteralType(expr, expectedType) .updateWithExpected(expr, expectedType, fromUnderscore) .dropMethodTypeEmptyParams(expr, expectedType) .inferValueType .unpackedType	ScType	valueType
getNode.getLastChildNode	ASTNode	node
ScPattern.unapplySubpatternTypes(subst(rt), pattern, fun)	Seq[ScType]	args
Set(Apply, Update)	Set[String]	GetSet
getNode.getFirstChildNode	ASTNode	node
new ScalaControlFlowBuilder(null, null)	ScalaControlFlowBuilder	builder
Set(Unapply, UnapplySeq)	Set[String]	Unapplies
Set( "scala.reflect.ClassManifest", "scala.reflect.Manifest", "scala.reflect.OptManifest", "scala.reflect.ClassTag", "scala.reflect.api.TypeTags.TypeTag", "scala.reflect.api.TypeTags.WeakTypeTag" )	Set[Nothing]	tagsAndManifists
pte.designator.equiv(ScalaType.designator(cls))	Boolean	refersToClass
Set(Foreach, Map, FlatMap, Filter, WithFilter)	Set[String]	ForComprehensions
ScalaPsiUtil.withEtaExpansion(expr)	Boolean	checkImplicitParameters
if (op.refName == "-") -1 else 1	Int	mult
new collection.mutable.ArrayBuffer[PsiElement]	ArrayBuffer[PsiElement]	buffer
GetSet ++ Unapplies ++ ForComprehensions	Set[String]	Special
expr match { case ScIntegerLiteral(value) => value case ScPrefixExpr(op, ScIntegerLiteral(value)) if Set("+", "-").contains(op.refName) => val mult = if (op.refName == "-") -1 else 1 mult * value case _ => return None }	Int	intLiteralValue
fun.typeParameters	Seq[ScTypeParam]	typeParameters
(pte.typeArguments corresponds typeParameters) { case (tpt: TypeParameterType, tp) if tpt.psiTypeParameter == tp => true case _ => false }	Boolean	typeParamsAppliedInOrder
Key.create[PsiElement]("context.key")	Key[PsiElement]	ContextKey
StdTypes.instance	StdTypes	stdTypes
aliasedType.getOrAny match { case pte: ScParameterizedType => val refersToClass = pte.designator.equiv(ScalaType.designator(cls)) val typeParamsAppliedInOrder = (pte.typeArguments corresponds typeParameters) { case (tpt: TypeParameterType, tp) if tpt.psiTypeParameter == tp => true case _ => false } refersToClass && typeParamsAppliedInOrder case _ => false }	Boolean	typeParamsAreAppliedInOrderToCorrectClass
Key.create[PsiElement]("child.key")	Key[PsiElement]	ChildKey
sc0.asInstanceOf[ScTypeParametersOwner]	ScTypeParametersOwner	sc
new mutable.Stack[ScReference]()	mutable.Stack[ScReference]	referencesStack
Seq.fill(searchLevel)(" ").mkString	String	indent
element	ProjectContext	ctx
substitutor followed ScSubstitutor.bind(typeParameters)(UndefinedType(_))	ScSubstitutor	undefSubst
fun.parameters.head.`type`() match { case Right(tp) => tp case _ => return None }	ScType	firstParameterRetTp
expression match { case ScIf(_, Some(thenBranch), None) => val UnitStdType = expression.projectContext.stdTypes.Unit val canExpand = function.returnTypeElement match { case Some(Typeable(UnitStdType)) => true case _ if !function.hasAssign => true case _ => false } if (canExpand) { thenBranch.calculateTailReturnsOptimizable.flatMap(expandIncompleteIf) } else { Set.empty } case _ => Set.empty }	Iterable[ScExpression] with (Nothing => Any)	extraExpressions
new TailReturnsCollector	statements.TailReturnsCollector	visitor
undefSubst(firstParameterRetTp)	ScType	funType
element match { case file: PsiFileBase => file.getCopyableUserData(key) case _ => element.getUserData(key) }	PsiElement	fromUserData
new TailReturnsOptimizableCollector(expr.projectContext)	statements.TailReturnsOptimizableCollector	visitor
if (typeParameters.isEmpty) substitutor else { val undefSubst = substitutor followed ScSubstitutor.bind(typeParameters)(UndefinedType(_)) val firstParameterRetTp = fun.parameters.head.`type`() match { case Right(tp) => tp case _ => return None } val funType = undefSubst(firstParameterRetTp) expected match { case Some(tp) => calculateSubstitutor(tp, funType, substitutor) case _ => substitutor } }	ScSubstitutor	subst
matchedParameters.collectFirst { case (arg, param) if param.isImplicit => arg }	Option[ScExpression]	implicitArg
mutable.LinkedHashSet.empty[ScExpression]	mutable.LinkedHashSet[ScExpression]	result_
ScPattern.unapplySubpatternTypes(subst(rt), pattern, fun)	Seq[ScType]	subpatternTpes
res	ScType	resInner
if (argIndex < subpatternTpes.length) subpatternTpes(argIndex) else subpatternTpes.last	ScType	tpe
Key.create[Seq[ScalaResolveResult]]("scala.implicit.arguments")	Key[Seq[ScalaResolveResult]]	IMPLICIT_ARGS_KEY
None	Option[Seq[ScalaResolveResult]]	implicitParameters
mt.elementScope	ElementScope	elementScope
first.name	String	firstName
new ModuleNode(SbtModuleType.instance.getId, buildId, build.uri, buildId, moduleFilesDirectory.path, buildRoot.canonicalPath)	ModuleNode	result
t.nameContext	PsiElement	context
params.map(a => a)	Array[PsiTypeParameter]	getTypeParameters
second.name	String	secondName
catchBlock .collect { case ScCatchBlock(clauses) => clauses } .toSeq	Seq[ScCaseClauses]	caseClauses
types.iterator	Iterator[ScTypeAlias]	iterator
t.abstractOrLowerTypeSubstitutor	ScSubstitutor	abstractSubst
iterator.next	ScTypeAlias	elem
project.stdTypes	StdTypes	stdTypes
expression match { case block: ScBlock => block.resultExpression case _ => None }	Option[ScExpression]	maybeLastExpression
projectContext.stdTypes.Boolean	ValType	booleanInstance
holders.iterator.flatMap(_.declaredElements.iterator)	Iterator[PsiNamedElement]	iterator1
iterator1.next	PsiNamedElement	elem
isNarrowing(expected)	Option[result.TypeResult]	narrowing
place.resolveScope	GlobalSearchScope	scope
subst.followed(ScSubstitutor(ScThisType(cl)))	ScSubstitutor	undefSubst
isWidening(valType, expected)	Option[result.TypeResult]	widening
cl.parameters	Seq[ScParameter]	params
typeElement.`type`().getOrAny	ScType	projected
ScPackageImpl(manager.getCachedPackage("").orNull)	ScPackageImpl	top
ScPackageImpl(manager.getCachedPackage("").orNull)	ScPackageImpl	defaultPackage
FunctionType(Unit, params)	ValueType	newTp
processor.getHint(NameHint.KEY) match { case null => null case hint => hint.getName(state) }	Null	name
params.map(_.`type`().getOrAny).map(undefSubst)	IndexedSeq[ScType]	types
declarations.exists(d => !processElement(d, processor, state))	Boolean	stop
processor.candidates.map { r => r.element match { case mem: PsiMember if mem.containingClass != null => new ScalaResolveResult(mem, r.substitutor, r.importsUsed) case _ => r } }	IndexedSeq[ScalaResolveResult]	res
defaultPackage.getSubPackages(scope)	Array[PsiPackage]	packages
InferUtil.updateAccordingToExpectedType(scType, filterTypeParams = false, expectedType = expectedType, expr = expr, canThrowSCE = true)	ScType	updatedWithExpected
expr.scalaLanguageLevelOrDefault	ScalaLanguageLevel	languageLevel
packages.iterator	Iterator[PsiPackage]	iterator
iterator.next()	PsiPackage	pack
Some(refName)	Some[String]	forName
cls match { case sc0@(_: ScClass | _: ScTrait) => val sc = sc0.asInstanceOf[ScTypeParametersOwner] (typeParameters corresponds sc.typeParameters) { case (tp1, tp2) => tp1.variance == tp2.variance && tp1.upperBound == tp2.upperBound && tp1.lowerBound == tp2.lowerBound && tp1.contextBound.isEmpty && tp2.contextBound.isEmpty && tp1.viewBound.isEmpty && tp2.viewBound.isEmpty } case _ => // Java class (typeParameters corresponds cls.getTypeParameters) { case (tp1, tp2) => tp1.variance == Invariant && tp1.upperTypeElement.isEmpty && tp2.getExtendsListTypes.isEmpty && tp1.lowerTypeElement.isEmpty && tp1.contextBound.isEmpty && tp1.viewBound.isEmpty } }	Boolean	varianceAndBoundsMatch
PsiMigrationManager.getInstance(getProject).getCurrentMigration	PsiMigrationImpl	migration
ScalaType.designator(cls)	ScType	clsType
mt.copy(result = tpt.internalType)	ScMethodType	mtWithoutImplicits
ScPackageImpl(manager.getCachedPackageInScope(name, scope).orNull)	PsiPackage	aPackage
!ScUnderScoreSectionUtil.isUnderscore(expr) && expectedType.map(_.removeAbstracts).forall { case FunctionType(_, _) => false case expect if expr.isSAMEnabled => val languageLevel = expr.scalaLanguageLevelOrDefault languageLevel != Scala_2_11 || SAMUtil.toSAMType(expect, expr).isEmpty case _ => true }	Boolean	shouldDrop
if (types.nonEmpty && params.last.isVarArgs) types.dropRight(1) ++ types.last.wrapIntoSeqType else types	IndexedSeq[ScType]	args
processor match { case r: ResolveProcessor => r.checkPredefinedClassesAndPackages() case _ => true }	Boolean	checkPredefinedClassesAndPackages
params.reverse.foldLeft(retType) { case (tp: ScType, param: Parameter) => ScMethodType(tp, Seq(param), isImplicit = true) }	ScType	splitMethodType
new ArrayBuffer[Parameter]()	ArrayBuffer[Parameter]	paramsForInferBuffer
processor match { case r: ResolveProcessor => r.checkWildcardImports() case _ => true }	Boolean	checkWildcardImports
Some(name)	Option[String]	forName
new CompletionProcessor(StdKinds.methodRef, place) { override protected val forName: Option[String] = Some(name) }	CompletionProcessor	cp
mutable.HashSet.empty[String]	mutable.HashSet[String]	attachedQualifiers
components.map(_.`type`().getOrAny)	IndexedSeq[ScType]	componentsTypes
mutable.ArrayBuffer.empty[PsiClass]	ArrayBuffer[PsiClass]	implObjects
implObjects.iterator	Iterator[PsiClass]	implObjIter
new ArrayBuffer[Compatibility.Expression]()	ArrayBuffer[Compatibility.Expression]	exprsBuffer
implObjIter.next()	PsiClass	clazz
mutable.ArrayBuffer.empty[ScType]	ArrayBuffer[ScType]	result
mutable.ArrayBuffer.empty[String]	ArrayBuffer[String]	names
new ArrayBuffer[ScalaResolveResult]()	ArrayBuffer[ScalaResolveResult]	resolveResultsBuffer
t.abstractOrLowerTypeSubstitutor	ScSubstitutor	abstractSubstitutor
c.effectiveParameterClauses	Seq[ScParameterClause]	clauses
Option(isAnonymousExpression(expression)).filter { case (-1, _) => false case _ => true }.map { case (i, expr: ScFunctionExpr) => (i, shapeIgnoringAssign(expr.result)) case (i, _) => (i, None) }	Option[(Int, Option[ScType])]	arityAndResultType
state.withFromType(td.`type`().toOption)	ResolveState	newState
DefaultImplicitlyImportedPackages.iterator	Iterator[Nothing]	iterator
subst(p.`type`().getOrAny)	ScType	paramType
extractPossibleProductParts(tpe, place)	Seq[ScType]	selectors
ScPackageImpl.findPackage(getProject, "scala")	ScPackageImpl	scalaPack
place.scalaSeqFqn	String	seqFqn
Iterator(tpe) ++ BaseTypes.iterator(tpe)	Iterator[ScType]	baseTpes
Set("?", "+?", "-?", "*", "+*", "-*")	Set[Nothing]	inlineSyntaxIds
refinement.map { r => ScCompoundType.fromPsi(componentsTypes, r.holders, r.types) }.getOrElse(ScCompoundType(componentsTypes))	ScCompoundType	compoundType
clause.declarations.filterBy[ScValueDeclaration]	Seq[ScValueDeclaration]	valDeclarations
ApplyBasedExtractor(place)	ScPattern.ApplyBasedExtractor	applyBasedExtractor
if (scalaPack != null) ScalaShortNamesCacheManager.getInstance(getProject).getClassNames(scalaPack, scope) else Set.empty[String]	Set[String]	namesSet
SeqLikeType(place)	ScPattern.SeqLikeType	seqLikeExtractor
contentRange.shiftLeft(getTextRange.getStartOffset)	TextRange	rangeLocal
ByNameExtractor(place)	ScPattern.ByNameExtractor	byNameExtractor
ScSubstitutor.paramToExprType(paramsForInferBuffer, exprsBuffer)	ScSubstitutor	dependentSubst
extractedType(returnTpe, place)	Option[ScType]	extracted
tp match { case ScTypePolymorphicType(i, p) => ScTypePolymorphicType(ScMethodType(i, params.last, isImplicit = true), p) case _ => ScMethodType(tp, params.last, isImplicit = true) }	NonValueType with Product with Serializable	newTp
valDeclarations.find(_.declaredElements.contains(named))	Option[ScValueDeclaration]	valueDeclaration
SyntheticClasses.get(getProject)	SyntheticClasses	classes
tuple.components.map { case parameterized: ScParameterizedTypeElement => convertParameterized(parameterized) case simple: ScSimpleTypeElement => convertSimpleType(simple) case _ => return null //something went terribly wrong }	IndexedSeq[Any]	paramList
valueDeclaration.flatMap(_.typeElement).map(_.`type`().getOrAny)	Option[ScType]	valType
InferUtil.updateTypeWithImplicitParameters(newTp, this, None, withExpected, fullInfo = false)	(ScType, Option[Seq[ScalaResolveResult]])	res
classes.getAll.iterator	Iterator[ScSyntheticClass]	synthIterator
synthIterator.next()	ScSyntheticClass	synth
ScSubstitutor.paramToExprType(paramsForInfer, exprs)	ScSubstitutor	dependentSubst
place.getProject	ProjectContext	project
classes.syntheticObjects.valuesIterator	Iterator[ScObject]	synthObjectsIterator
{ val classes = build.classes.filter(_.exists).map(_.path) val docs = build.docs.filter(_.exists).map(_.path) val sources = build.sources.filter(_.exists).map(_.path) createModuleLevelDependency(Sbt.BuildLibraryName, classes, docs, sources, DependencyScope.COMPILE)(result) }	LibraryDependencyNode	library
synthObjectsIterator.next()	ScObject	synth
ScCompoundType(Seq(tp, Singleton))	ScCompoundType	compound
Set("scala", "java.lang")	Set[Nothing]	DefaultImplicitlyImportedPackages
new ArrayBuffer[Expression]	ArrayBuffer[Compatibility.Expression]	exprs
Set("scala.Predef", "scala" /* package object*/)	Set[Nothing]	DefaultImplicitlyImportedObjects
new ContentRootNode(buildRoot.path)	ContentRootNode	result
s"${named.name}$$type"	String	name
new ArrayBuffer[Parameter]()	ArrayBuffer[Parameter]	paramsForInfer
_place match { case s: ScalaPsiElement => s.getDeepSameElementInContext case _ => _place }	PsiElement	place
scalaFile.getVirtualFile	VirtualFile	file
constr.containingClass	PsiClass	clazz
PsiLiteralExpressionImpl.parseStringCharacters( chars, outChars, null )	Boolean	success
Seq(buildRoot)	Seq[Nothing]	sourceDirs
new ArrayBuffer[ScalaResolveResult]	ArrayBuffer[ScalaResolveResult]	resolveResults
ProjectRootManager.getInstance(place.getProject).getFileIndex	ProjectFileIndex	index
generateName(i)	String	name
params.iterator	Iterator[Parameter]	iterator
iterator.next()	Parameter	param
Seq( buildRoot / Sbt.TargetDirectory, buildRoot / Sbt.ProjectDirectory / Sbt.TargetDirectory)	Seq[Nothing]	excludedDirs
abstractSubstitutor(param.paramType)	ScType	paramType
mutable.ArrayBuffer.empty[ScBindingPattern]	ArrayBuffer[ScBindingPattern]	b
productElementTypes(returnTpe, place, fun)	Seq[ScType]	tpes
mutable.ArrayBuffer.empty[ScTypeVariableTypeElement]	ArrayBuffer[ScTypeVariableTypeElement]	b
c.getConstructorTypeParameters.map(_.typeParameters).getOrElse(Seq.empty)	Seq[ScTypeParam]	params
Option(fun.containingClass).flatMap(_.qualifiedName.toOption)	Option[String]	fqnO
p.bindings.iterator	Iterator[ScBindingPattern]	iterator
iterator.next()	ScBindingPattern	b
startQuote.length	Int	trimLeft
trimLeft	Int	beginIndex
p.typeVariables.iterator	Iterator[ScTypeVariableTypeElement]	typeVariablesIterator
typeVariablesIterator.next()	ScTypeVariableTypeElement	tvar
if (text.endsWith(endQuote)) endQuote.length else 0	Int	trimRight
super.contentRange	TextRange	range
ScSubstitutor.bind(owner.typeParameters, params)(TypeParameterType(_))	ScSubstitutor	subst
findLastChildByType(TokenSets.MEMBERS)	PsiElement	last
_subst followed constrSubst	ScSubstitutor	subst
paramOpt.flatten.mkString(start = "[", sep = ", ", end = "]")	String	paramText
body.mkString(start = "[", sep = ", ", end = "]")	String	bodyText
new StringBuilder	StringBuilder	forSomeBuilder
1	Int	count
ImplicitState(place, paramType, paramType, coreElement, isImplicitConversion = false, searchImplicitsRecursively, None, fullInfo = false, Some(ImplicitsRecursionGuard.currentMap))	ImplicitCollector.ImplicitState	implicitState
s"_$$$count"	String	res
new ImplicitCollector(implicitState)	ImplicitCollector	collector
collector.collect()	Seq[ScalaResolveResult]	results
findChildrenByClassScala[ScPattern](classOf[ScPattern])	mutable.Seq[ScPattern]	children
typeArgList.typeArgs.map { case w: ScWildcardTypeElement => forSomeBuilder.append("type _" + "$" + count + w.lowerTypeElement.fold("")(te => s" >: ${te.getText}") + w.upperTypeElement.fold("")(te => s" <: ${te.getText}")) forSomeBuilder.append("; ") val res = s"_$$$count" count += 1 res case t => t.getText }	IndexedSeq[String]	typeElements
results.headOption .flatMap(extractImplicitParameterType)	Option[ScType]	maybeType
this.getChildren.filter{_.isInstanceOf[ScBlockExpr]}.flatMap{s => s.getChildren.filter(_.isInstanceOf[ScPattern]).map{_.asInstanceOf[ScPattern]}}	mutable.Seq[ScPattern]	grandChildrenInBlockExpr
ScSimpleTypeElementImpl. calculateReferenceType(ref).getOrElse(ScalaType.designator(td))	ScType	refType
parentElement match { case ta: ScTypeAliasDefinition => ta.aliasedType.getOrElse(return Nothing) case _ => parametrise(calculateReferenceType(ref). getOrElse(return Nothing), clazz, subst) }	ScType	tp
subst(tp)	ScType	res
this.kindProjectorPluginEnabled	Boolean	kindProjectorEnabled
typeElement.`type`()	result.TypeResult	tr
tr.getOrElse(return tr)	ScType	res
parentElement match { case _: ScTypeParametersOwner if constrTypParameters.nonEmpty => constrTypParameters.map(TypeParameter(_)) case tp: ScTypeParametersOwner if tp.typeParameters.nonEmpty => tp.typeParameters.map(TypeParameter(_)) case ptp: PsiTypeParameterListOwner if ptp.getTypeParameters.nonEmpty => ptp.getTypeParameters.toSeq.map(TypeParameter(_)) case _ => updateImplicits(tp, withExpected = false, params = params, lastImplicit = lastImplicit) return res }	Seq[TypeParameter]	typeParameters
tp.quantified	ScType	skolem
ScalaMacroEvaluator.getInstance(project)	ScalaMacroEvaluator	evaluator
compilerGeneratedInstance(paramType)	Option[ScalaResolveResult]	compilerGenerated
ScParameterizedType(res, args.map(_.`type`().getOrAny))	ValueType	result
ScSubstitutor.bind(typeParameters, p.typeArgList.typeArgs)(_.calcType)	ScSubstitutor	appSubst
appSubst(res)	ScType	newRes
ScTypePolymorphicType(res, typeParameters)	ScTypePolymorphicType	result
if (results.isEmpty) NotFoundImplicitParameter(paramType) else AmbiguousImplicitParameters(results)	ApplicabilityProblem with Product with Serializable	problem
clazz.typeParameters	Seq[ScTypeParam]	typeParams
pList.getContext	PsiElement	context
constrInvocation.newTemplate match { case Some(n) => ScUnderScoreSectionUtil.underscores(n).nonEmpty case None => false }	Boolean	fromUnderscore
ScParameterizedType(refType, td.getTypeParameters.map(UndefinedType(_)))	ValueType	clazzType
if (arg.lower.equiv(Nothing)) subst(param.lowerBound.getOrNothing) else arg.lower	ScType	lowerBound
constrInvocation.expectedType match { case Some(expected) if withExpected => def updateRes(expected: ScType): ScTypePolymorphicType = { InferUtil.localTypeInference(previous.internalType, Seq(Parameter(expected, isRepeated = false, index = 0)), Seq(new Expression(ScSubstitutor.bind(previous.typeParameters)(UndefinedType(_)).apply(res.inferValueType))), previous.typeParameters, shouldUndefineParameters = false, filterTypeParams = false) //here should work in different way: } val fromUnderscore = constrInvocation.newTemplate match { case Some(n) => ScUnderScoreSectionUtil.underscores(n).nonEmpty case None => false } if (!fromUnderscore) { updateRes(expected) } else { expected match { case FunctionType(retType, _) => updateRes(retType) case _ => previous //do not update res, we haven't expected type } } case _ => previous }	ScTypePolymorphicType	fromExpected
_	Array[Int]	outSourceOffsets
nameFor(dependency.id)	String	name
constrInvocation.arguments.length - 1	Int	lastClauseIdx
if (arg.upper.equiv(Any)) subst(param.upperBound.getOrAny) else arg.upper	ScType	upperBound
clazz.getTypeParameters	Array[PsiTypeParameter]	typeParams
if (offsetInDecoded < outSourceOffsets.length) outSourceOffsets(offsetInDecoded) else -1	Int	result
libraries.find(_.getExternalName == name).getOrElse( throw new ExternalSystemException("Library not found: " + name))	LibraryData	library
new LibraryDependencyNode(moduleData, library, LibraryLevel.PROJECT)	LibraryDependencyNode	data
param.paramInCode.getOrElse { impl.ScalaPsiElementFactory.createParameterFromText { param.name + " : Int" }(place.getManager) }	ScParameter	psiParam
compilerGenerated.getOrElse { if (param.isDefault && param.paramInCode.nonEmpty) { //todo: should be added for infer to //todo: what if paramInCode is null? new ScalaResolveResult(param.paramInCode.get) } else if (canThrowSCE) throw new SafeCheckException else { val problem = if (results.isEmpty) NotFoundImplicitParameter(paramType) else AmbiguousImplicitParameters(results) val psiParam = param.paramInCode.getOrElse { impl.ScalaPsiElementFactory.createParameterFromText { param.name + " : Int" }(place.getManager) } new ScalaResolveResult(psiParam, problems = Seq(problem), implicitSearchState = Some(implicitState)) } }	ScalaResolveResult	result
bind(td.typeParameters)(Function.const(Any))	ScSubstitutor	toAnySubst
this.nextSiblings.find(_.getNode.getElementType == ScalaTokenTypes.tCOMMA).get.getNextSiblingNotWhitespace.getPrevSibling	PsiElement	end
EnumSet.empty[ScalaModifier]	EnumSet.EnumSet[ScalaModifier]	result
getFirstChild	PsiElement	currentChild
scope match { case DependencyScope.COMPILE => Sbt.UnmanagedLibraryName case it => s"${Sbt.UnmanagedLibraryName}-${it.getDisplayName.toLowerCase}" }	String	name
ScalaModifier.byText(name)	ScalaModifier	mod
t match { case ScProjectionType(_, td: ScTypedDefinition) => Some(td) case ScDesignatorType(td: ScTypedDefinition) => Some(td) case _ => None }	Option[ScTypedDefinition]	designator
mod match { case ScalaModifier.Private if accessModifier.exists(_.isPrivate) => accessModifier case ScalaModifier.Protected if accessModifier.exists(_.isProtected) => accessModifier case _ => Option(findChildByType(ScalaModifierTokenType(mod))) }	Option[PsiElement]	elemToRemove
expr	ProjectContext	ctx
ctx.stdTypes.Unit	ValType	Unit
this.prevSiblings.find(_.getNode.getElementType == ScalaTokenTypes.tCOMMA).get.getPrevSiblingNotWhitespace.getNextSibling	PsiElement	start
dependency.map(_.file.path)	IndexedSeq[Any]	files
new LibraryNode(name, resolved = true)	LibraryNode	libraryNode
new LibraryDependencyNode(moduleData, libraryNode, LibraryLevel.MODULE)	LibraryDependencyNode	result
configurations.toSet	Set[Configuration]	ids
Version("0.13.0")	Version	sinceSbtVersion
Version("0.13.5")	Version	sinceSbtVersionShell
{ val clazzType = ScParameterizedType(refType, td.getTypeParameters.map(UndefinedType(_))) val toAnySubst = bind(td.typeParameters)(Function.const(Any)) this.expectedType.flatMap { clazzType.conformanceSubstitutor(_) }.fold(toAnySubst) { _.followed(toAnySubst) } }	ScSubstitutor	newSubst
r.substitutor	ScSubstitutor	substitutor
fun.typeParameters	Seq[ScTypeParam]	typeParams
if (lastClauseIdx >= 0 && lastClauseIdx < params.length) { updateWithClause(fromExpected, lastClauseIdx, canThrowSCE = withExpected) } else fromExpected	ScTypePolymorphicType	withLastClause
withoutLastClause()	ScTypePolymorphicType	withoutLast
findLastChildByType[PsiElement](ScalaTokenTypes.tUPPER_BOUND)	PsiElement	tUpper
try lastClauseAndImplicits(withoutLast, withExpected = true) catch { case _: SafeCheckException => lastClauseAndImplicits(withoutLast, withExpected = false) }	ScTypePolymorphicType	nonValueType
findLastChildByType[PsiElement](ScalaTokenTypes.tLOWER_BOUND)	PsiElement	tLower
arg.lower	ScType	lowerBound
findId	PsiElement	id
findId.getNode	ASTNode	idNode
nonValueType match { case t: ScTypePolymorphicType => t.polymorphicTypeSubstitutor case _ => ScSubstitutor.empty }	ScSubstitutor	pts
param.getExtendsListTypes	Array[PsiClassType]	listTypes
elem match { case ta: ScTypeAliasDefinition => ta.aliasedType.getOrElse(return (Nothing, ScSubstitutor.empty)) case clazz: PsiClass => parametrise(calculateReferenceType(ref). getOrElse(return (Nothing, ScSubstitutor.empty)), clazz, subst) }	ScType	tp
head.getAnnotations	Array[ScAnnotation]	scAnnotations
element match { case td: ScTypeDefinition => td.name case p: PsiPackage => p.name case _ => throw new IncorrectOperationException("cannot bind to anything but type definition or package") }	String	newElementName
ScPackageImpl(JavaPsiFacade.getInstance(getProject).findPackage(qname))	PsiPackage	pack
offsetInDecoded + rangeInsideHost.getStartOffset	Int	offset
elem match { case tp: ScTypeParametersOwner if tp.typeParameters.nonEmpty => tp.typeParameters.map(TypeParameter(_)) case ptp: PsiTypeParameterListOwner if ptp.getTypeParameters.nonEmpty => ptp.getTypeParameters.toSeq.map(TypeParameter(_)) case _ => return (res, ScSubstitutor.empty) }	Seq[TypeParameter]	typeParameters
PsiAnnotation.ARRAY_FACTORY.create(scAnnotations.length)	Array[PsiAnnotation]	result
mutable.ArrayBuffer.empty[Object]	ArrayBuffer[Any]	buffer
for { Typeable(parameterType) <- fun.parameters.headOption functionType = bind(typeParams)(UndefinedType(_)).apply(parameterType) expectedType <- this.expectedType newSubstitutor <- functionType.conformanceSubstitutor(expectedType) } yield newSubstitutor	Option[ScSubstitutor]	maybeSubstitutor
getNode	ASTNode	node
if (typeParams.isEmpty) substitutor else { val maybeSubstitutor = for { Typeable(parameterType) <- fun.parameters.headOption functionType = bind(typeParams)(UndefinedType(_)).apply(parameterType) expectedType <- this.expectedType newSubstitutor <- functionType.conformanceSubstitutor(expectedType) } yield newSubstitutor maybeSubstitutor.fold(substitutor) { _.followed(substitutor) }.followed { bind(typeParams)(_.upperBound.getOrAny) } }	ScSubstitutor	subst
ref.isConstructorReference && !noConstructor	Boolean	constrRef
createModifierFromText(name).getNode	ASTNode	modifierNode
name != ScalaModifier.CASE	Boolean	addAfter
createNewLineNode(" ")	ASTNode	spaceNode
if (arg.upper.equiv(api.Any)) { val listTypes: Array[PsiClassType] = param.getExtendsListTypes if (listTypes.isEmpty) api.Any else subst(listTypes.toSeq.map(_.toScType()).glb(checkWeak = true)) } else arg.upper	ScType	upperBound
getParent.getNode	ASTNode	parentNode
tp.typeElement.`type`().map { case tp: ScExistentialType => val skolem = tp.quantified skolem.extractClassType match { //todo: type aliases? case Some((clazz: ScTypeDefinition, subst)) => val typeParams = clazz.typeParameters skolem match { case ParameterizedType(des, typeArgs) if typeArgs.length == typeParams.length => ScParameterizedType(des, typeArgs.zip(typeParams).map { case (arg: ScExistentialArgument, param: ScTypeParam) => val lowerBound = if (arg.lower.equiv(Nothing)) subst(param.lowerBound.getOrNothing) else arg.lower //todo: lub? val upperBound = if (arg.upper.equiv(Any)) subst(param.upperBound.getOrAny) else arg.upper //todo: glb? ScExistentialArgument(arg.name, arg.typeParameters, lowerBound, upperBound) case (tp: ScType, _: ScTypeParam) => tp }).unpackedType case _ => tp } case Some((clazz: PsiClass, subst)) => val typeParams: Array[PsiTypeParameter] = clazz.getTypeParameters skolem match { case ParameterizedType(des, typeArgs) if typeArgs.length == typeParams.length => ScParameterizedType(des, typeArgs.zip(typeParams).map { case (arg: ScExistentialArgument, param: PsiTypeParameter) => val lowerBound = arg.lower val upperBound = if (arg.upper.equiv(api.Any)) { val listTypes: Array[PsiClassType] = param.getExtendsListTypes if (listTypes.isEmpty) api.Any else subst(listTypes.toSeq.map(_.toScType()).glb(checkWeak = true)) } else arg.upper //todo: glb? ScExistentialArgument(arg.name, arg.typeParameters, lowerBound, upperBound) case (tp: ScType, _) => tp }).unpackedType case _ => tp } case _ => tp } case tp: ScType => tp }	result.TypeResult	typeElementType
getNextSibling	PsiElement	nextSibling
nextSibling.getNode	ASTNode	currentNode
first.getNode	ASTNode	firstNode
e.updatedWithImplicitParameters(tp, checkExpectedType = false)._2.toSeq.flatten	Seq[ScalaResolveResult]	implicitArgs
internal match { case m: ScMethodType => truncateMethodType(m, expr) case _ => internal }	ScType	sameDepth
sameDepth.inferValueType	ValueType	valueType
Parameter("", None, expected, expected)	Parameter	expectedParam
new Expression(ScSubstitutor.bind(typeParams)(UndefinedType(_)).apply(valueType))	Compatibility.Expression	expressionToUpdate
shapeMultiType(i)	Array[result.TypeResult]	seq
firstNode.getTreeNext	ASTNode	next
localTypeInference(internal, Seq(expectedParam), Seq(expressionToUpdate), typeParams, shouldUndefineParameters = false, canThrowSCE = canThrowSCE, filterTypeParams = filterTypeParams)	ScTypePolymorphicType	inferredWithExpected
endQuote	String	quote
ExtensionPointName.create(CLASS_NAME)	ExtensionPointName[InterpolatedStringMacroTypeProvider]	EP_NAME
inferredWithExpected .typeParameters .filter(p => p.lowerType.equiv(p.upperType))	Seq[TypeParameter]	fullyInferedTypeParameters
for { matchedType <- typeOpt unapplyMethod <- resolveUnapplyMethodFromReference(ref) caseClass <- Option(unapplyMethod.syntheticCaseClass) (clazz: ScClass, substitutor) <- matchedType.extractClassType if clazz.isCase && clazz == caseClass constr <- clazz.constructor } yield getTypedParametersOfPrimaryConstructor(constr, substitutor)	Option[Seq[(ScParameter, Option[ScType])]]	typedParamsOpt
if (!filterTypeParams) { val fullyInferedTypeParameters = inferredWithExpected .typeParameters .filter(p => p.lowerType.equiv(p.upperType)) ScSubstitutor.bind(fullyInferedTypeParameters)(_.lowerType) } else ScSubstitutor.empty	ScSubstitutor	subst
subst(inferredWithExpected)	ScType	result
constr.parameterList.clauses.headOption.map(_.parameters).getOrElse(Seq.empty)	Seq[ScParameter]	params
ScalaMacroEvaluator.getInstance(f.getProject)	ScalaMacroEvaluator	macroEvaluator
(_nonValueType, expectedType) match { case (tpt: ScTypePolymorphicType, Some(expected)) if !expected.equiv(Unit) => doLocalTypeInference(tpt, expected) case _ => _nonValueType }	ScType	nonValueType
impl.ScalaPsiElementFactory.createExpressionWithContextFromText( "null", expr.getContext, expr ).asInstanceOf[ScNullLiteral]	ScNullLiteral	nullLiteral
ScalaPsiManager.instance(getProject).getCachedClasses(getResolveScope, s).filter(!_.isInstanceOf[ScObject])	Array[PsiClass]	typez
macroEvaluator.checkMacro(f, MacroContext(ref, None))	Option[ScType]	typeFromMacro
getStringParts.map(quote + _ + quote) .commaSeparated(Model.Parentheses)	String	constructorParameters
new ArrayBuffer[ScPattern]	ArrayBuffer[ScPattern]	pattBuff
r.getActualElement match { case ta: ScTypeAliasDefinition => subst(ta.aliasedType.getOrElse(return FAILURE)) case _ => parameterize(ScSimpleTypeElementImpl.calculateReferenceType(ref, shapesOnly = true). getOrElse(return FAILURE), clazz, subst) }	ScType	tp
getContext match { case contextRef: ScStableCodeReference => //Since scala 2.11 it's possible macro implementations not only as static methods, //but also inside certain classes, so qualifier of a macro impl reference may resolve to a class //see https://docs.scala-lang.org/overviews/macros/bundles.html if (isMacroImplReference(contextRef)) stableQualOrClass else stableQualRef case e: ScImportExpr => if (e.selectorSet.isDefined //import Class._ is not allowed || qualifier.isEmpty || e.isSingleWildcard) stableQualRef else stableImportSelector case ste: ScSimpleTypeElement => if (incomplete) noPackagesClassCompletion // todo use the settings to include packages else if (ste.getLastChild.isInstanceOf[PsiErrorElement]) stableQualRef else if (ste.singleton) stableQualRef else if (ste.annotation) annotCtor else stableClass case _: ScTypeAlias => stableClass case _: ScInterpolationPattern => stableImportSelector case _: ScConstructorPattern => objectOrValue case _: ScInfixPattern => objectOrValue case _: ScThisReference | _: ScSuperReference => stableClassOrObject case _: ScImportSelector => stableImportSelector case _: ScInfixTypeElement => stableClass case _: ScMacroDefinition => methodsOnly //reference in macro definition may be to method only case _: ScDocSyntaxElement => stableImportSelector case _ => stableQualRef }	ResolveTargets.ValueSet	result
getInjections.map(_.getText) .commaSeparated(Model.Parentheses)	String	methodParameters
findChildByType[PsiElement](ScalaTokenTypes.tLPARENTHESIS)	PsiElement	rpar
nullLiteral.getTypeAfterImplicitConversion(expectedOption = Some(expectedRet))	ScExpression.ExpressionTypeResult	updatedResultType
findChildByType[PsiElement](ScalaTokenTypes.tRPARENTHESIS)	PsiElement	rpar
method.methodTypeProvider(elementScope).methodType(Some(tp))	ScType	methodType
SAMUtil.toSAMType(tp, expr)	Option[ScType]	requiredSAMType
createReferenceFromText(text, getContext, ScStableCodeReferenceImpl.this)	ScStableCodeReference	ref
tpt.abstractTypeSubstitutor	ScSubstitutor	subst
PsiTreeUtil.getParentOfType(this, classOf[ScImportSelector])	ScImportSelector	selector
if (rpar != null) PsiTreeUtil.getNextSiblingOfType(rpar, classOf[ScExpression]) else null	Null	c
ScalaPsiElementFactory.createExpressionWithContextFromText( s"$StringContextCanonical$constructorParameters.$referenceText$methodParameters", context, this ).asInstanceOf[ScMethodCall]	ScMethodCall	expression
subst(mt).asInstanceOf[ScMethodType]	ScMethodType	withAbstracts
if (!filterTypeParams) { val subst = tpt.abstractTypeSubstitutor val withAbstracts = subst(mt).asInstanceOf[ScMethodType] withAbstracts.result } else mt.result	ScType	canConform
withoutImplicitClause(tpe)	ScType	withoutImplicits
if (rpar != null) PsiTreeUtil.getPrevSiblingOfType(rpar, classOf[ScExpression]) else null	Null	c
findKElse	PsiElement	kElse
element match { case _: ScObject | _: ScParameter | _: patterns.ScBindingPattern | _: ScFieldId => element.asInstanceOf[Typeable].`type`().toOption case function: ScFunction => functionTypeNoImplicits(function) }	Option[ScType]	maybeType
retType.projectContext	ProjectContext	projectContext
if (kElse != null) PsiTreeUtil.getPrevSiblingOfType(kElse, classOf[ScExpression]) else getLastChild match { case expression: ScExpression => expression case _ => PsiTreeUtil.getPrevSiblingOfType(getLastChild, classOf[ScExpression]) }	ScExpression	t
if (kElse != null) PsiTreeUtil.getNextSiblingOfType(kElse, classOf[ScExpression]) else null	Null	e
catchBlock.flatMap(_.expression)	Option[ScExpression]	maybeExpression
findChildByType[PsiElement](ScalaTokenTypes.tLPARENTHESIS)	PsiElement	leftParenthesis
findChildByType[PsiElement](ScalaTokenTypes.tRPARENTHESIS)	PsiElement	rightParenthesis
typeParams.map(_.typeParamId).toSet	Set[Long]	typeParamIds
if (shouldUndefineParameters) ScSubstitutor.bind(typeParams)(UndefinedType(_)) else ScSubstitutor.empty	ScSubstitutor	s
ScalaPsiManager.instance(getProject).getCachedClass(getResolveScope, "scala.xml.Node").orNull	PsiClass	clazz
ScTypePolymorphicType(retType, typeParams).abstractTypeSubstitutor	ScSubstitutor	abstractSubst
expressions.map(_.`type`().getOrNothing)	IndexedSeq[ScType]	branchesTypes
constr match { case fun: ScMethodLike => fun.nestedMethodType(i, Some(tp), subst).getOrElse(return FAILURE) case method: PsiMethod => if (i > 0) return Failure("Java constructors only have one parameter section") val methodType = method.methodTypeProvider(elementScope).methodType(Some(tp)) subst(methodType) }	ScType	res
r.getActualElement match { case tp: ScTypeParametersOwner if tp.typeParameters.nonEmpty => tp.typeParameters.map(TypeParameter(_)) case ptp: PsiTypeParameterListOwner if ptp.getTypeParameters.nonEmpty => ptp.getTypeParameters.toSeq.map(TypeParameter(_)) case _ => return Right(res) }	Seq[TypeParameter]	typeParameters
branchesTypes.foldLeft(Nothing: ScType)(_.lub(_))	ScType	branchesLub
qualifier.resolve() match { case _: PsiPackage => Option(getContextOfType(resolvedElement, classOf[ScObject])) match { case Some(obj) if obj.isPackageObject => makeProjection(ScDesignatorType(obj)) case _ => fromType match { case Some(designator@ScDesignatorType(obj: ScObject)) if obj.isPackageObject => makeProjection(designator) case _ => ScalaType.designator(resolvedElement) } } case _ => calculateReferenceType(qualifier, shapesOnly) match { case Right(tp) => makeProjection(tp) case failure@Failure(_) => return failure } }	ScType	result
getFirstChild	PsiElement	cur
ScTypePolymorphicType(res, typeParameters)	ScTypePolymorphicType	nonValueType
params.map(p => p.copy(paramType = s(p.paramType), expectedType = abstractSubst(p.paramType), defaultType = p.defaultType.map(s)))	IndexedSeq[Parameter]	paramsWithUndefTypes
matchedParametersByClauses.toArray.apply(i - 1)	Seq[(ScExpression, Parameter)]	paramsByClauses
exprs.map(_.`type`().getOrAny) match { case Seq() => Unit case components => TupleType(components) }	ValueType	result
ScalaPsiUtil.importAliasFor(element, this)	Option[ScReference]	aliasedRef
new CompletionProcessor(getKinds(incomplete = true, completion = false), this)	CompletionProcessor	processor
getKinds(incomplete = false)	Set[ResolveTargets.Value]	suitableKinds
resolvedElement match { case self: ScSelfTypeElement => ScThisType(getContextOfType(self, classOf[ScTemplateDefinition])) case _ => fromType match { case Some(tp) => makeProjection(tp) case _ => ScalaType.designator(resolvedElement) } }	ScType	result
maybeExpression.toSeq.flatMap { expr => expr.`type`().toOption.zip(createProcessor(expr)).flatMap { case (tp, processor) => processor.processType(tp, expr) processor.candidates } }	IndexedSeq[ScalaResolveResult]	candidates
s"${ref.refName}_=(${rightExpression.map(_.getText).getOrElse("")})"	String	text
createReferenceFromText(c.name)	ScStableCodeReference	ref
c.qualifiedName	String	qname
ScalaPsiElementFactory.createExpressionWithContextFromText(text, getContext, this)	ScExpression	mirrorExpr
methodCall.getInvokedExpr	ScExpression	invokedExpr
bounds.substitutor	ScSubstitutor	unSubst
ScalaCodeStyleSettings.getInstance(getProject).hasImportWithPrefix(qname)	Boolean	isPredefined
if (isLower) tp.lowerType else tp.upperType	ScType	bound
unSubst(bound)	ScType	substedBound
findDeclaredAttributeValue(attributeName)	PsiAnnotationMemberValue	value
ScSubstitutor.bind(constr.containingClass.getTypeParameters)(UndefinedType(_))	ScSubstitutor	mySubst
c.getMethods	Array[PsiMethod]	methods
member.containingClass	ScTemplateDefinition	containingClass
if (isLower) lowerMap else upperMap	LongMap[ScType]	boundsMap
s"${invokedExpr.getText}.update(${methodCall.args.exprs.map(_.getText).mkString(",")}," + s" ${rightExpression.map(_.getText).getOrElse("")}"	String	text
new MethodResolveProcessor(ref, ScalaNamesUtil.clean(fun.name) + "_=", rightExpression.map(expr => List(Seq(new Expression(expr)))).getOrElse(Nil), Nil, ref.getPrevTypeInfoParams, isShapeResolve = shapeResolve, kinds = StdKinds.methodsOnly)	MethodResolveProcessor	processor
bindToElement(containingClass)	PsiElement	refToClass
if (isLower) _ lub _ else _ glb _	(ScType, ScType) => ScType	combine
createReferenceFromText(refToClass.getText + "." + binding.name)	ScStableCodeReference	refToMember
paramsByClauses.map(_._2).map( param => Parameter(mySubst(param.paramType), param.isRepeated, param.index) )	IndexedSeq[Parameter]	undefParams
processor.candidatesS	Set[ScalaResolveResult]	candidates
methods.iterator	Iterator[PsiMethod]	iterator
iterator.next()	PsiMethod	method
findDeclaredAttributeValue(attributeName)	PsiAnnotationMemberValue	existing
elem.getPrevSibling	PsiElement	prev
elem.getNextSibling	PsiElement	next
this.withContexts.takeWhile(!_.isInstanceOf[PsiFile]).toList.reverse	List[PsiElement]	contextsFromFile
annotationExpr.constructorInvocation.arguments	Seq[ScArgumentExprList]	args
contextsFromFile.map(_.getNode.getElementType.toString)	IndexedSeq[Nothing]	elementTypes
args.flatMap(arg => arg.exprs)	Seq[ScExpression]	params
contextsElementKinds	String	contextText
params.isEmpty && (PsiAnnotation.DEFAULT_REFERENCED_METHOD_NAME.equals(attributeName) || null == attributeName)	Boolean	allowNoName
null	String	namePrefix
new StableCodeReferenceResolver(ScStableCodeReferenceImpl.this, false, false, false)	StableCodeReferenceResolver	resolver
!substedBound.equiv(fromMap) && !hasRecursiveTypeParams(substedBound)	Boolean	mayCombine
ScSubstitutor.bind(typeParams)(UndefinedType(_))	ScSubstitutor	undefiningSubstitutor
getContext match { // when processing Foo.this.Bar or Foo.super[Bar].Baz, positioned in the extends block, // it is important to skip the contexts up to the actual outer type definition, or else // we may end up with weird self-references if the name is not unique (#SCL-14707, #SCL-14922) case ctx @ (_: ScSuperReference | _: ScThisReference) => ResolveUtils.enclosingTypeDef(ctx).fold(this: PsiElement)(_.getContext) case _ => this }	PsiElement	startingPlace
combineBounds(tp, isLower = true)	ScType	lower
combineBounds(tp, isLower = false)	ScType	upper
gen .nextSiblings .collectFirst { case e@withDesugared(analog) if !e.isInstanceOf[ScGenerator] => analog } .getOrElse(this)	ScEnumerator.DesugaredEnumerator	desugaredMostInnerEnumOfGen
tp.typeParamId	Long	typeParamId
unSubst(tp.lowerType)	ScType	substedLower
unSubst(tp.upperType)	ScType	substedUpper
un	ConstraintSystem	result
createExpressionWithContextFromText(s"""_root_.scala.StringContext("").$refName""", p, this)	ScExpression	expr
None	Option[Array[ScalaResolveResult]]	withDynamicResult
ScalaResolveState.withSubstitutor(substitutor)	ResolveState	state
getContext match { case call: ScMethodCall => call case _ => this }	ScExpression	curr
curr.getContext.isInstanceOf[ScAssignment] && curr.getContext.asInstanceOf[ScAssignment].leftExpression == curr	Boolean	isUpdate
getChildren.reverse	Array[PsiElement]	reverseChildren
literal.getValue	literal.V	value
if (curr == this && !isUpdate) List.empty else { (curr match { case call: ScMethodCall => call.args.exprs case _ => Seq.empty[ScExpression] }) ++ ( if (isUpdate) curr.getContext.asInstanceOf[ScAssignment].rightExpression match { case Some(x) => Seq[ScExpression](x) case None => Seq[ScExpression](createExpressionFromText("{val x: Nothing = null; x}")) //we can't to not add something => add Nothing expression } else Seq.empty) :: Nil }	List[Seq[ScExpression]]	args
substedLower.asOptionOf[TypeParameterType].map(_.typeParamId).filter(typeParamIds.contains)	Option[Long]	lowerTpId
this.arguments	Seq[ScTypeElement]	typeArgs
new MethodResolveProcessor(referencedExpr, methodName, args, typeArgs, Seq.empty /* todo: ? */ , isShapeResolve = isShape, enableTupling = true)	MethodResolveProcessor	processor
Compatibility.checkConformanceExt(false, undefParams, paramsByClauses.map(_._1), false, false)	Compatibility.ConformanceExtResult	extRes
expectedExprTypes(expr, withResolvedFunction = true, fromUnderscore = fromUnderscore)	Array[(ScType, Option[ScTypeElement])]	types
parameters.map(_.`type`().getOrNothing)	IndexedSeq[ScType]	paramTypes
if (reverseChildren.contains(lastParent)) reverseChildren.drop(reverseChildren.indexOf(lastParent) + ( lastParent match { case _: ScGenerator => 1 case _ => 0 } )) else reverseChildren	Array[PsiElement]	children
extRes.constraints match { case ConstraintSystem(substitutor) => Some(substitutor) case _ => None }	Option[ScSubstitutor]	maybeSubstitutor
result.map(_.`type`().getOrAny)	Option[ScType]	maybeResultType
maybeSubstitutor.fold(nonValueType: ScType) { _.apply(nonValueType) }	ScType	result
new ArrayBuffer[TypeResult]	ArrayBuffer[result.TypeResult]	buffer
substedUpper.asOptionOf[TypeParameterType].map(_.typeParamId).filter(typeParamIds.contains)	Option[Long]	upperTpId
referencedExpr.getNonValueType()	result.TypeResult	typeResult
referencedExpr match { case ref: ScReferenceExpression => ref.shapeType case expr => expr.getNonValueType() }	result.TypeResult	typeResult
unSubst(TypeParameterType(tp))	ScType	substedTp
polymorphicLambdaType	result.TypeResult	polyLambdaType
referencedExpr match { case ref: ScReferenceExpression => ref.shapeMultiType case expr => Array(expr.getNonValueType()) }	Array[result.TypeResult]	typeResult
FunctionType(maybeResultType.getOrElse(api.Unit), paramTypes)	ValueType	functionType
typeParams.foldLeft(constraints)(addConstraints)	ConstraintSystem	newConstraints
r.fromType match { case Some(fType) => Right(ScProjectionType(fType, obj)) case _ => td.`type`().map(substitutor) }	Either[Failure, ScType]	fromType
referencedExpr match { case ref: ScReferenceExpression => ref.multiType case expr => Array(expr.getNonValueType()) }	Array[result.TypeResult]	typeResult
state.withFromType(qualType)	ResolveState	stateWithType
ScalaMacroEvaluator.getInstance(fun.getProject)	ScalaMacroEvaluator	macroEvaluator
if (forDisplay) generateDesugaredExprWithMappings(forDisplay = true) else getDesugaredExprWithMappings	Option[(ScExpression, Map[ScPattern, ScPattern], Any)]	result
if (isShape) ref.shapeResolveConstr else ref.resolveAllConstructors	Array[ScalaResolveResult]	resolve
this.enumerators match { case None => return true case Some(x) => x }	ScEnumerators	enumerators
for { (original, element) <- patternToPosition pattern <- findPatternElement(element, original) } yield original -> pattern	Iterator[(ScPattern, ScPattern)]	patternMapping
macroEvaluator.checkMacro(fun, MacroContext(qualifier, None))	Option[ScType]	typeFromMacro
!(forDisplay && this.getText.contains("\n"))	Boolean	forceSingleLine
0	Int	nextNameIdx
ScalaPsiUtil.functionArrow(getProject)	String	`=>`
ScUnderScoreSectionUtil.underscores(this).zipWithIndex.toMap	Map[ScUnderscoreSection, Int]	underscores
newConstraints.isApplicable(tp.typeParamId)	Boolean	removeMe
expr.copy().asInstanceOf[ScExpression]	ScExpression	copyOfExpr
mutable.StringBuilder.newBuilder	mutable.StringBuilder	resultText
mutable.Map.empty[ScPattern, Int]	mutable.Map[ScPattern, Int]	patternMappings
mutable.Map.empty[ScEnumerator, Int]	mutable.Map[ScEnumerator, Int]	enumMappings
s(tp)	ScType	fromType
TypeParameterType(typeParam)	TypeParameterType	tpt
ScalaResolveState.withFromType(fromType)	ResolveState	state
expr.expectedTypesEx(fromUnderscore)	Array[(ScType, Option[ScTypeElement])]	types
updateType(scType, canThrowSCE = true)	ScType	nonValueType
sub(tpt)	ScType	substed
createExpressionWithContextFromText(getText, getContext, this)	ScExpression	expr
getEffectiveInvokedExpr match { case ref: ScReferenceExpression => ref.bind() case _ => None }	Option[ScalaResolveResult]	invokedResolveResult
args.flatMap(_._1)	IndexedSeq[ScPattern]	argPatterns
findChildByType[PsiElement](ScalaTokenTypes.tIDENTIFIER)	PsiElement	id
id.getNode.getTreeNext	ASTNode	next
expr.getContext match { case ref: ScStableCodeReference if ref.pathQualifier.contains(expr) => ScThisType(td) case referenceExpression: ScReferenceExpression if referenceExpression.qualifier.contains(expr) => ScThisType(td) case _ => expr.expectedType() match { case Some(designatorOwner: DesignatorOwner) if designatorOwner.isStable => ScThisType(td) case _ => td.getTypeWithProjections(thisProjections = true).map { case scType => td.selfType.map(scType.glb(_)).getOrElse(scType) } match { case Right(scType) => scType case _ => return Failure("No clazz type found") } } }	ScType	result
this.findPossibleApplyOrUpdateCandidates(nonValueType)	Option[Array[ScalaResolveResult]]	applyOrUpdateCandidates
dynamicResolveProcessor(rExpr, qual, processor)	MethodResolveProcessor	dynamicProcessor
subst(p.getReturnType.toScType())	ScType	paramType
!forDisplay || forceCases || args.size > 1 || argPatterns.exists(needsDeconstruction)	Boolean	needsCase
tpt.typeParameters.isEmpty || substed.isAny || TypeVariableUnification.unifiableKinds(tpt, substed)	Boolean	kindsMatch
args.size > 1 || !needsCase && argPatterns.exists(needsParenthesisAsLambdaArgument)	Boolean	needsParenthesis
appendBody	R	ret
dynamicProcessor.candidates.collect { case r @ ScalaResolveResult(MacroDef(_), _) => r //regular method call cannot be in a type position }	IndexedSeq[ScalaResolveResult]	candidatesWithMacro
updateType(processedType)	ScType	updatedProcessedType
gen.expr.map(normalizeUnderscores)	Option[ScExpression]	rvalue
clazz.getMethods.flatMap { case p: PsiAnnotationMethod => val paramType = subst(p.getReturnType.toScType()) Seq(Parameter(p.getName, None, paramType, paramType, p.getDefaultValue != null, isRepeated = false, isByName = false)) case _ => Seq.empty }	IndexedSeq[Parameter]	params
!restEnums.exists(_.isInstanceOf[ScGenerator])	Boolean	isLastGen
gen.pattern	ScPattern	pattern
AmmoniteUtil.scriptResolveQualifier(this)	Option[PsiFileSystemItem]	fsi
checkApplication(updatedProcessedType, Some(result))	Option[MethodInvocationImpl.RegularCase]	maybeRegularCase
args match { case Some(arguments) => arguments.exprs.map(new Expression(_)) case None => Seq.empty }	Seq[Compatibility.Expression]	expressions
new MethodResolveProcessor(this, "this", List(expressions), Seq.empty, Seq.empty /*todo: ? */ , StdKinds.methodsOnly, constructorResolve = true, isShapeResolve = shapeResolve, enableTupling = true, selfConstructorResolve = true)	MethodResolveProcessor	proc
types.sortBy { case (_: ScAbstractType, _) => 1 case _ => 0 }.distinctBy { case (ScAbstractType(_, lower, upper), _) if lower == upper => lower case (t, _) => t }	Seq[(ScType, Option[ScTypeElement])]	distinct
ScalaPsiManager.instance(getProject).getCachedClasses(getResolveScope, path)	Array[PsiClass]	classes
Seq(Some(pattern) -> pattern.getText)	Seq[(Some[ScPattern], Nothing)]	initialArg
classes.find(!_.isInstanceOf[ScObject])	Option[PsiClass]	clazz
if (problems.isEmpty) { constraints.substitutionBounds(canThrowSCE) match { case Some(bounds@SubstitutionBounds(_, lowerMap, upperMap)) => val unSubst = bounds.substitutor if (!filterTypeParams) { def combineBounds(tp: TypeParameter, isLower: Boolean): ScType = { val bound = if (isLower) tp.lowerType else tp.upperType val substedBound = unSubst(bound) val boundsMap = if (isLower) lowerMap else upperMap val combine: (ScType, ScType) => ScType = if (isLower) _ lub _ else _ glb _ boundsMap.get(tp.typeParamId) match { case Some(fromMap) => val mayCombine = !substedBound.equiv(fromMap) && !hasRecursiveTypeParams(substedBound) if (mayCombine) combine(substedBound, fromMap) else fromMap case _ => substedBound } } val undefiningSubstitutor = ScSubstitutor.bind(typeParams)(UndefinedType(_)) ScTypePolymorphicType(retType, typeParams.map { tp => val lower = combineBounds(tp, isLower = true) val upper = combineBounds(tp, isLower = false) if (canThrowSCE && !undefiningSubstitutor(lower).weakConforms(undefiningSubstitutor(upper))) throw new SafeCheckException TypeParameter(tp.psiTypeParameter, /* doesn't important here */ tp.typeParameters, lower, upper) }) } else { def addConstraints(un: ConstraintSystem, tp: TypeParameter): ConstraintSystem = { val typeParamId = tp.typeParamId val substedLower = unSubst(tp.lowerType) val substedUpper = unSubst(tp.upperType) var result = un if (un.isApplicable(typeParamId) || substedLower != Nothing) { //todo: add only one of them according to variance //add constraints for tp from its' bounds if (!substedLower.isNothing && !hasRecursiveTypeParams(substedLower)) { result = result.withLower(typeParamId, substedLower) .withTypeParamId(typeParamId) } if (!substedUpper.isAny && !hasRecursiveTypeParams(substedUpper)) { result = result.withUpper(typeParamId, substedUpper) .withTypeParamId(typeParamId) } val lowerTpId = substedLower.asOptionOf[TypeParameterType].map(_.typeParamId).filter(typeParamIds.contains) val upperTpId = substedUpper.asOptionOf[TypeParameterType].map(_.typeParamId).filter(typeParamIds.contains) val substedTp = unSubst(TypeParameterType(tp)) //add constraints for tp bounds from tp substitution if (!hasRecursiveTypeParams(substedTp)) { upperTpId.foreach { id => result = result.withLower(id, substedTp) .withTypeParamId(id) } lowerTpId.foreach { id => result = result.withUpper(id, substedTp) .withTypeParamId(id) } } } result } val newConstraints = typeParams.foldLeft(constraints)(addConstraints) import org.jetbrains.plugins.scala.lang.psi.types.recursiveUpdate.SubtypeUpdater._ def updateWithSubst(sub: ScSubstitutor): ScTypePolymorphicType = ScTypePolymorphicType( sub(retType), typeParams.filter { tp => val removeMe = newConstraints.isApplicable(tp.typeParamId) if (removeMe && canThrowSCE) { tp.psiTypeParameter match { case typeParam: ScTypeParam => val tpt = TypeParameterType(typeParam) val substed = sub(tpt) val kindsMatch = tpt.typeParameters.isEmpty || substed.isAny || TypeVariableUnification.unifiableKinds(tpt, substed) if (!kindsMatch) throw new SafeCheckException case _ => () } } !removeMe }.map(_.update(sub)) ) newConstraints match { case ConstraintSystem(substitutor) => updateWithSubst(substitutor) case _ if !canThrowSCE => updateWithSubst(unSubst) case _ => throw new SafeCheckException } } case None => throw new SafeCheckException } } else ScTypePolymorphicType(retType, typeParams)	ScTypePolymorphicType	tpe
function.returnType.toOption	Option[ScType]	retType
ElementScope(function)	ElementScope	scope
expr.getDeepSameElementInContext	PsiElement	sameInContext
ArrayBuffer.empty[Seq[ScType]]	ArrayBuffer[Seq[ScType]]	buffer
invocation.argumentExpressions	Seq[ScExpression]	argExprs
invocation.getEffectiveInvokedExpr	ScExpression	invoked
c.nestedMethodType(i).getOrElse(return Failure("Not enough parameter sections"))	ScType	methodType
clauses.length - 1	Int	idx
this.reference.map(_.resolve()).orNull match { case ScalaConstructor(constr) => constr.effectiveParameterClauses.map(_.effectiveParameters) case JavaConstructor(constr) => Seq(constr.parameters) case _ => Seq.empty }	Seq[Seq[PsiParameter]]	paramClauses
id.getNode.getTreeParent	ASTNode	parent
clauses(idx)	ScParameterClause	cl
cl.parameters	Seq[ScParameter]	parameters
tp.typeParameters.map(TypeParameter(_))	Seq[TypeParameter]	params
findChildByType[PsiElement](ScalaTokenTypes.tLPARENTHESIS)	PsiElement	par
bindInternal(shapeResolve = true)	Option[PsiElement]	option
this.getTextRange.getStartOffset	Int	start
gen.shapeMultiType	Array[result.TypeResult]	multiType
gen.multiType	Array[result.TypeResult]	multiType
parameters.flatMap(_.`type`().toOption)	IndexedSeq[ScType]	paramTypes
maybeRegularCase.getOrElse { RegularCase(updatedProcessedType, Seq(new DoesNotTakeParameters)) }	MethodInvocationImpl.RegularCase	regularCase
par.getNode.getTreeNext	ASTNode	nextNode
exprs.nonEmpty	Boolean	needCommaAndSpace
anchor.getNode.getTreeNext	ASTNode	nextNode
code"($rvalue).foo".getFirstChild.asInstanceOf[ScParenthesisedExpr]	ScParenthesisedExpr	inParenthesis
if (isDynamic) Some("apply") else None	Option[Nothing]	nameArgForDynamic
new MethodResolveProcessor(baseExpr, methodName, argClauses, typeArgs, typeParams, isShapeResolve = isShape, enableTupling = true, nameArgForDynamic = nameArgForDynamic)	MethodResolveProcessor	processor
candidatesNoImplicit(processor)	Set[ScalaResolveResult]	simpleCandidates
simpleCandidates.nonEmpty	Boolean	noImplicitsForArgs
if (simpleCandidates.forall(!_.isApplicable())) { val noImplicitsForArgs = simpleCandidates.nonEmpty candidatesWithConversion(processor, noImplicitsForArgs) } else simpleCandidates	Set[ScalaResolveResult]	candidates
x.getNonValueType()	result.TypeResult	res
baseExprType match { case ScTypePolymorphicType(_: ScMethodType | _: UndefinedType, _) => Set.empty case ScTypePolymorphicType(internal, typeParam) if typeParam.nonEmpty && shouldProcess(internal) => processType(processor, internal) case _ => Set.empty }	Set[_ <: ScalaResolveResult]	fromPolymorphicType
baseExprType.inferValueType	ValueType	baseValueType
false	Boolean	x
if (expr.getTextRange != null) expr.getTextRange.getStartOffset else 0	Int	startOffset
rvalue.exists { rvalue => val inParenthesis = code"($rvalue).foo".getFirstChild.asInstanceOf[ScParenthesisedExpr] ScalaPsiUtil.needParentheses(inParenthesis, inParenthesis.innerElement.get) }	Boolean	generatorNeedsParenthesis
getText	String	refText
rvalue.flatMap(_.`type`().toOption)	Option[ScType]	rvalueType
JavaPsiFacade.getInstance(getProject)	JavaPsiFacade	facade
if (forDisplay && compilerRewritesWithFilterToFilter) { val rvalueType = rvalue.flatMap(_.`type`().toOption) def hasWithFilter = rvalueType.exists(hasMethod(_, "withFilter")) def hasFilter = rvalueType.exists(hasMethod(_, "filter")) // try to use withFilter // if the type does not have a withFilter method use filter except if filter doesn't exist either if (hasWithFilter || !hasFilter) "withFilter" else "filter" } else { "withFilter" }	String	filterFunc
this	PsiElement	e
applyOrUpdateCandidates .getOrElse(Array.empty) .flatMap(_.problems)	IndexedSeq[ApplicabilityProblem]	problems
argumentClauses(call, isDynamic)	List[Seq[Compatibility.Expression]]	argClauses
unders.indexWhere(_.getTextRange.getStartOffset == startOffset)	Int	i
paramClause.find(_.getName == refToParam.refName) .orElse(refToParam.resolve().asOptionOf[ScParameter])	Option[PsiParameter]	param
Option(forBinding.pattern)	Option[ScPattern]	pattern
null	Option[ScType]	result
false	Boolean	forEqualsParamLength
pattern.collect { case pattern: ScBindingPattern => pattern }	Option[ScBindingPattern]	bindingPattern
bindingPattern.isDefined	Boolean	isBinding
manager.getCachedClasses(getResolveScope, refText)	Array[PsiClass]	classes
pattern.exists(_.isInstanceOf[ScWildcardPattern])	Boolean	isWildCard
bindingPattern.fold({ nextNameIdx += 1 s"v$$${if (forDisplay) "" else "forIntellij"}$nextNameIdx" })(_.name)	String	name
call.getInvokedExpr.getNonValueType().toOption.collect { case ScTypePolymorphicType(_, tps) => tps }.getOrElse(Seq.empty)	Seq[TypeParameter]	typeParams
None	Option[ScAssignment]	maybeAssignment
asRegularCase(expressions)	MethodInvocationImpl.RegularCase	nonTupled
binding.pattern	Option[ScPattern]	pattern
binding.patternText	String	patternText
getKinds(incomplete = false)	ResolveTargets.ValueSet	kinds
forDisplay && pattern.exists(needsParenthesisAsNamedPattern)	Boolean	needsParenthesis
gen.referencedExpr.getNonValueType().getOrNothing	ScType	referencedType
facade.findPackage(refText)	PsiPackage	pack
assign.rightExpression .getOrElse(createExpressionFromText("scala.Predef.???"))	ScExpression	rightExpr
call.getContext match { case assign: ScAssignment if call.isUpdateCall => val rightExpr = assign.rightExpression .getOrElse(createExpressionFromText("scala.Predef.???")) //we can't to not add something => add Nothing expression Seq(rightExpr) case _ => Seq.empty }	Seq[ScExpression]	newValueForUpdate
call.argumentExpressions ++ newValueForUpdate	Seq[Compatibility.Expression]	arguments
maybeResolveResult .flatMap(res => this.checkMacro(res).orElse(this.checkMacroExpansion(res))) .map(RegularCase(_))	Option[MethodInvocationImpl.RegularCase]	fromMacroExpansion
createExpressionFromText("\"\"")	ScExpression	emptyStringExpression
qParams.getMethod	PsiMethod	method
extendsBlock.earlyDefinitions match { case Some(e: ScEarlyDefinitions) => e.members.flatMap { case holder: ScDeclaredElementsHolder => Seq(holder) case _ => Seq.empty } case None => Seq.empty }	Seq[ScDeclaredElementsHolder]	earlyHolders
params.getClassToProcess	PsiClass	clazz
clazz.getProject	Project	project
invokedNonValueType match { case polymorphicType@ScTypePolymorphicType(ScMethodType(returnType, parameters, _), _) => Some((returnType, parameters, Some(polymorphicType))) case polymorphicType@ScTypePolymorphicType(FunctionTypeParameters(returnType, parameters), _) => Some((returnType, parameters, Some(polymorphicType))) case ScMethodType(returnType, parameters, _) => Some((returnType, parameters, None)) case _ => None }	Option[(ScType, Seq[Parameter], Option[ScTypePolymorphicType])]	maybeTuple
true	Boolean	continue
PsiManager.getInstance(project).findFile(virtualFile)	PsiFile	psiFile
extendsBlock.superTypes	List[ScType]	superTypes
inReadAction(m.getContainingClass)	PsiClass	cClass
p.getAnnotationClass	PsiClass	annClass
parameters.getScope	SearchScope	searchScope
queryParameters.getMethod	PsiMethod	method
rawMethodWrapper(m, cClass)	PsiMethod	wrapper
c.qualifiedName	String	qualName
scopeOption.getOrElse(member.getUseScope)	SearchScope	scope
!forceSingleLine && (forBindings.length > 1 || forBindings.exists(_.forBinding.getText.contains("\n")))	Boolean	multilineForBindings
useExpectedType && this.expectedType().isDefined	Boolean	canThrowSCE
queryParameters.getClassToProcess	PsiClass	clazz
ScalaPsiUtil.nameContext(x)	PsiElement	nameContext
annClass.qualifiedName	String	annotationFQN
p.getScope match { case searchScope: GlobalSearchScope => searchScope case _ => return true }	GlobalSearchScope	scope
containingClass.getOrElse(memb.containingClass)	PsiClass	cClass
cClass.qualifiedName + "." + elem.name	String	qualName
ScalaFilterScope(qParams.getScope)(wrapper.getProject)	SearchScope	scalaScope
args.filterNot(_._2 == "_")	Seq[(Option[ScPattern], String)]	argsWithoutWildcards
new OverridingMethodsSearch.SearchParameters(wrapper, scalaScope, qParams.isCheckDeep)	OverridingMethodsSearch.SearchParameters	newParams
if (forDisplay) forBindings.filter(!_.isWildCard) else forBindings	Seq[ForBinding]	usedBindings
constructorInvocation.flatMap(_.reference).flatMap(_.resolve().toOption)	Option[PsiElement]	resolvedConstructor
new Processor[PsiMethod] { override def process(t: PsiMethod): Boolean = { if (isSuperMethodForScala(m, t)) consumer.process(t) else true } }	Processor[PsiMethod] { def process(t: PsiMethod): Boolean }	newProcessor
ScalaPsiManager.instance(te.getProject).getCachedClass(te.resolveScope, "java.lang.Throwable")	Option[PsiClass]	throwableClass
argsWithoutWildcards.length + usedBindings.size != 1	Boolean	needsArgParenthesis
mutable.ArrayBuffer[TypeResult]()	ArrayBuffer[result.TypeResult]	buffer
resolvedConstructor.map { case ScalaConstructor(constr) => constr.effectiveParameterClauses.length case JavaConstructor(_) => 1 case _ => -1 }	Option[Int]	constrParamLength
qParams.getPsiClass	PsiClass	clazz
throwableClass.map(new ScDesignatorType(_)).getOrElse(Any)	ValueType with LeafType	throwableType
maybePolymorphicType match { case Some(polymorphicType) => val canThrowSCE = useExpectedType && this.expectedType().isDefined /* optimization to avoid except */ localTypeInferenceWithApplicabilityExt(returnType, parameters, _: Seq[Expression], polymorphicType.typeParameters, canThrowSCE = canThrowSCE) case _ => (expressions: Seq[Expression]) => (returnType, checkConformanceExt(checkNames = true, parameters, expressions, checkWithImplicits = true, isShapesResolve = false)) }	Seq[Compatibility.Expression] => (ScType, Compatibility.ConformanceExtResult)	function
new ArrayBuffer[ParameterType]	ArrayBuffer[(ScType, Option[ScTypeElement])]	buffer
tuple.exprs	Seq[ScExpression]	exprs
exprs.indexOf(sameInContext)	Int	index
printForBindingMap(forBindings, args)	Seq[(Option[ScPattern], String)]	argsWithBindings
expr match { case p: ScParenthesisedExpr => p.innerElement.getOrElse(return Array.empty) case _ => expr }	ScExpression	zExpr
PsiTreeUtil.getContextOfType(ret, true, classOf[ScFunction])	ScFunction	fun
args.exprs	Seq[ScExpression]	argExprs
multiResolveScala(incomplete = false).iterator	Iterator[ScalaResolveResult]	iterator
ANNOTATED_MEMBER_KEY.elements(annClass.name, scope, classOf[ScAnnotation])(annClass.getProject) .iterator	Iterator[ScAnnotation]	iter
iter.next	ScAnnotation	annotation
mutable.Set.empty[PsiNamedElement]	mutable.Set[PsiNamedElement]	buffer
processQualifier(processor)	Array[ScalaResolveResult]	candidates
argIndex(argExprs)	Int	argIdx
for { arguments <- constructorInvocation.map(_.arguments) paramLength <- constrParamLength if paramLength >= 0 } yield { arguments.drop(paramLength) }	Option[Seq[ScArgumentExprList]]	excessArgs
clazz.getUseScope match { case _: LocalSearchScope => clazz.containingScalaFile match { case Some(f) if f.getVirtualFile != null => clazz.containingScalaFile.map(GlobalSearchScope.fileScope) case Some(f) => Some(GlobalSearchScope.allScope(f.getProject)) case None => None } case global: GlobalSearchScope => Some(global) case _ => None }	Option[GlobalSearchScope]	useScope
args.head	ScArgumentExprList	firstArgListOfApply
inheritorsOfType(alias.name)	Boolean	continue
c.arguments.indexOf(args)	Int	clauseIdx
firstArgListOfApply.getTextRange.getStartOffset - this.getTextRange.getStartOffset	Int	startOffsetInThis
inheritorsOfType(td.name)	Boolean	continue
shapeResolve.iterator	Iterator[ScalaResolveResult]	iterator
inReadAction { clazz.getMethods.collect { case m: PsiMethodImpl if hasRawTypeParam(m) && PsiUtil.canBeOverridden(m) => m } }	IndexedSeq[PsiMethodImpl]	potentials
s.arguments.indexOf(args)	Int	clauseIdx
{ val firstArgListOfApply = args.head val startOffsetInThis = firstArgListOfApply.getTextRange.getStartOffset - this.getTextRange.getStartOffset val thisText = getText val newTemplateDefText = thisText.substring(0, startOffsetInThis) val applyArgsText = thisText.substring(startOffsetInThis) s"($newTemplateDefText)$applyArgsText" }	String	desugaredText
inReadAction { val useScope = clazz.getUseScope match { case _: LocalSearchScope => clazz.containingScalaFile match { case Some(f) if f.getVirtualFile != null => clazz.containingScalaFile.map(GlobalSearchScope.fileScope) case Some(f) => Some(GlobalSearchScope.allScope(f.getProject)) case None => None } case global: GlobalSearchScope => Some(global) case _ => None } ScalaUseScope.intersect(queryParameters.getScope, useScope) match { case x: GlobalSearchScope => x case _ => return true } }	GlobalSearchScope	scope
Option(ann.getParent) .collect { case fieldLike: ScValueOrVariable => convertToLightField(fieldLike).getOrElse(fieldLike) case member: PsiMember => member } .forall(consumer.process(_))	Boolean	continue
rawMethodWrapper(superMethod, clazz)	PsiMethod	wrapper
!forceSingleLine && forBindingsInGenBody.nonEmpty	Boolean	needsMultiline
new ArrayBuffer[PsiClass]()	ArrayBuffer[PsiClass]	anonymousClasses
new OverridingMethodsSearch.SearchParameters(wrapper, scalaScope, /*checkDeep*/ true)	OverridingMethodsSearch.SearchParameters	params
new Processor[PsiMethod] { override def process(t: PsiMethod): Boolean = { if (isSuperMethodForScala(superMethod, t)) consumer.process(new Pair(superMethod, t)) else true } }	Processor[PsiMethod] { def process(t: PsiMethod): Boolean }	processor
ctx match { case c: ScConstructorInvocation => val clauseIdx = c.arguments.indexOf(args) if (!withResolvedFunction) c.shapeMultiType(clauseIdx) else c.multiType(clauseIdx) case s: ScSelfInvocation => val clauseIdx = s.arguments.indexOf(args) if (!withResolvedFunction) s.shapeMultiType(clauseIdx) else s.multiType(clauseIdx) }	Array[result.TypeResult]	tps
new mutable.HashMap[String, ArrayBuffer[PsiClass]]()	mutable.HashMap[String, ArrayBuffer[PsiClass]]	map
new JavaOverridingMethodsSearcher().execute(params, processor)	Boolean	continue
method.getParameterList.getParameters	Array[PsiParameter]	parameters
expr.getContext match { case p: ScParenthesisedExpr => p.expectedTypesEx(fromUnderscore = false) //see SLS[6.11] case b: ScBlockExpr => b.resultExpression match { case Some(e) if b.needCheckExpectedType && e == sameInContext => b.expectedTypesEx(fromUnderscore = true) case _ => Array.empty } //see SLS[6.16] case cond: ScIf if cond.condition.getOrElse(null: ScExpression) == sameInContext => Array((api.Boolean, None)) case cond: ScIf if cond.elseExpression.isDefined => cond.expectedTypesEx(fromUnderscore = true) //see SLA[6.22] case tr@ScTry(Some(e), _, _) if e == expr => tr.expectedTypesEx(fromUnderscore = true) case wh: ScWhile if wh.condition.getOrElse(null: ScExpression) == sameInContext => Array((api.Boolean, None)) case _: ScWhile => Array((Unit, None)) case d: ScDo if d.condition.getOrElse(null: ScExpression) == sameInContext => Array((api.Boolean, None)) case _: ScDo => Array((api.Unit, None)) case _: ScFinallyBlock => Array((api.Unit, None)) case _: ScCatchBlock => Array.empty case te: ScThrow => // Not in the SLS, but in the implementation. val throwableClass = ScalaPsiManager.instance(te.getProject).getCachedClass(te.resolveScope, "java.lang.Throwable") val throwableType = throwableClass.map(new ScDesignatorType(_)).getOrElse(Any) Array((throwableType, None)) //see SLS[8.4] case c: ScCaseClause => c.getContext.getContext match { case m: ScMatch => m.expectedTypesEx(fromUnderscore = true) case b: ScBlockExpr if b.isInCatchBlock => b.getContext.getContext.asInstanceOf[ScTry].expectedTypesEx(fromUnderscore = true) case b: ScBlockExpr if b.isAnonymousFunction => b.expectedTypesEx(fromUnderscore = true).flatMap(tp => fromFunction(tp)) case _ => Array.empty } //see SLS[6.23] case f: ScFunctionExpr => f.expectedTypesEx(fromUnderscore = true).flatMap(tp => fromFunction(tp)) case t: ScTypedExpression if t.getLastChild.isInstanceOf[ScSequenceArg] => t.expectedTypesEx(fromUnderscore = true) //SLS[6.13] case t: ScTypedExpression => t.typeElement match { case Some(te) => Array((te.`type`().getOrAny, Some(te))) case _ => Array.empty } //SLS[6.15] case a: ScAssignment if a.rightExpression.getOrElse(null: ScExpression) == sameInContext => a.leftExpression match { case ref: ScReferenceExpression if (!a.getContext.isInstanceOf[ScArgumentExprList] && !( a.getContext.isInstanceOf[ScInfixArgumentExpression] && a.getContext.asInstanceOf[ScInfixArgumentExpression].isCall)) || ref.qualifier.isDefined || ScUnderScoreSectionUtil.isUnderscore(expr) /* See SCL-3512, SCL-3525, SCL-4809, SCL-6785 */ => ref.bind() match { case Some(ScalaResolveResult(named: PsiNamedElement, subst: ScSubstitutor)) => ScalaPsiUtil.nameContext(named) match { case v: ScValue => Array((subst(named.asInstanceOf[ScTypedDefinition]. `type`().getOrAny), v.typeElement)) case v: ScVariable => Array((subst(named.asInstanceOf[ScTypedDefinition]. `type`().getOrAny), v.typeElement)) case f: ScFunction if f.paramClauses.clauses.isEmpty => a.mirrorMethodCall match { case Some(call) => call.args.exprs.head.expectedTypesEx(fromUnderscore = fromUnderscore) case None => Array.empty } case p: ScParameter => //for named parameters Array((subst(p.`type`().getOrAny), p.typeElement)) case f: PsiField => Array((subst(f.getType.toScType()), None)) case _ => Array.empty } case _ => Array.empty } case _: ScReferenceExpression => expectedExprTypes(a) case _: ScMethodCall => a.mirrorMethodCall match { case Some(mirrorCall) => mirrorCall.args.exprs.last.expectedTypesEx(fromUnderscore = fromUnderscore) case _ => Array.empty } case _ => Array.empty } //method application case tuple: ScTuple if tuple.isCall => expectedTypesForArg(tuple.getContext.asInstanceOf[ScInfixExpr], expr) case tuple: ScTuple => val buffer = new ArrayBuffer[ParameterType] val exprs = tuple.exprs val index = exprs.indexOf(sameInContext) @tailrec def addType(aType: ScType): Unit = { aType match { case _: ScAbstractType => addType(aType.removeAbstracts) case TupleType(comps) if comps.length == exprs.length => buffer += ((comps(index), None)) case _ => } } if (index >= 0) { for (tp: ScType <- tuple.expectedTypes(fromUnderscore = true)) addType(tp) } buffer.toArray case infix@ScInfixExpr.withAssoc(_, operation, `sameInContext`) if !expr.isInstanceOf[ScTuple] => val zExpr: ScExpression = expr match { case p: ScParenthesisedExpr => p.innerElement.getOrElse(return Array.empty) case _ => expr } expectedTypesForArg(infix, zExpr) //SLS[4.1] case v @ ScPatternDefinition.expr(`sameInContext`) if v.isSimple => declaredOrInheritedType(v) case v @ ScVariableDefinition.expr(`sameInContext`) if v.isSimple => declaredOrInheritedType(v) //SLS[4.6] case v: ScFunctionDefinition if v.body.contains(sameInContext) => declaredOrInheritedType(v) //default parameters case param: ScParameter => param.typeElement match { case Some(_) => Array((param.`type`().getOrAny, param.typeElement)) case _ => Array.empty } case ret: ScReturn => val fun: ScFunction = PsiTreeUtil.getContextOfType(ret, true, classOf[ScFunction]) if (fun == null) return Array.empty fun.returnTypeElement match { case Some(rte: ScTypeElement) => fun.returnType match { case Right(rt) => Array((rt, Some(rte))) case _ => Array.empty } case None => Array.empty } case args: ScArgumentExprList => args.getContext match { case mc: ScMethodCall => expectedTypesForArg(mc, expr) case ctx @ (_: ScConstructorInvocation | _: ScSelfInvocation) => val argExprs = args.exprs val argIdx = argIndex(argExprs) val tps = ctx match { case c: ScConstructorInvocation => val clauseIdx = c.arguments.indexOf(args) if (!withResolvedFunction) c.shapeMultiType(clauseIdx) else c.multiType(clauseIdx) case s: ScSelfInvocation => val clauseIdx = s.arguments.indexOf(args) if (!withResolvedFunction) s.shapeMultiType(clauseIdx) else s.multiType(clauseIdx) } tps.flatMap(computeExpectedParamType(expr, _, argExprs, argIdx)) case _ => Array.empty } case guard: ScGuard => guard.desugared flatMap { _.content } match { case Some(content) => content.expectedTypesEx(fromUnderscore = fromUnderscore) case _ => Array.empty } case b: ScBlock if b.getContext.isInstanceOf[ScTry] || b.getContext.getContext.getContext.isInstanceOf[ScCatchBlock] || b.getContext.isInstanceOf[ScCaseClause] || b.getContext.isInstanceOf[ScFunctionExpr] => b.resultExpression match { case Some(e) if sameInContext == e => b.expectedTypesEx(fromUnderscore = true) case _ => Array.empty } case _ => Array.empty }	Array[(ScType, Option[ScTypeElement])]	result
candidates.filter(candidatesFilter)	Array[ScalaResolveResult]	filtered
new LightParameterListBuilder(m.getManager, m.getLanguage)	LightParameterListBuilder	lightList
new ArrayBuffer[ParameterType]	ArrayBuffer[(ScType, Option[ScTypeElement])]	res
_	PsiType	thisType
m.getParameterList.getParameters	Array[PsiParameter]	originalParams
p.getType	PsiType	paramType
_	PsiType	superType
p.projectContext	ProjectContext	pc
_	JavaCodeFragment.ExceptionHandler	exceptionHandler
inReadAction { clazz match { case o: ScObject => s"object:${o.qualifiedName}" case c: ScTypeDefinition => s"class:${c.qualifiedName}" case n: ScNewTemplateDefinition => anonymousClasses += n return case _ => val qualName = clazz.getQualifiedName if (qualName == null) { anonymousClasses += clazz return } else qualName } }	String	id
if (withSelfType) TypeDefinitionMembers.getSelfTypeSignatures(inheritor) else TypeDefinitionMembers.getSignatures(inheritor)	TypeDefinitionMembers.TermNodes.Map	signatures
firstGen.withNextSiblings .collect { case e: ScEnumerator => e }.toList .tail	List[ScEnumerator]	restEnums
underscores.valuesIterator match { case iterator if iterator.isEmpty => "" case iterator => (iterator.map(underscoreName).toSeq match { case Seq(arg) => arg case args => args.commaSeparated(model = Model.Parentheses) }) + " " + `=>` + " " }	String	lambdaPrefix
ScalaPsiElementFactory.createExpressionWithContextFromText( resultText.insert(0, lambdaPrefix).toString, getContext, this )	ScExpression	expression
lambdaPrefix.length	Int	shiftOffset
false	Boolean	found
_	GlobalSearchScope	resolveScope
map.getOrElseUpdate(id, new ArrayBuffer[PsiClass]())	ArrayBuffer[PsiClass]	buffer
paramType.toScType().toPsiType	PsiType	typeFromScala
inReadAction { if (!clazz.isValid) return true ScalaInheritors.directInheritorCandidates(clazz, scope) }	Seq[ScTemplateDefinition]	candidates
if (subst.isEmpty) params else params.map(p => p.copy(paramType = subst(p.paramType)))	Seq[Parameter]	newParams
subMethod match { case ScFunctionWrapper(delegate) => delegate case fun: ScFunction => fun case _ => return false }	ScFunction	scFun
_	IntentionFilterOwner.IntentionActionsFilter	filter
getJarFile(clazz)	VirtualFile	clazzJar
newParams.length == 1 && !newParams.head.isRepeated && argExprs.length > 1	Boolean	autoTupling
mutable.HashSet.empty[String]	mutable.HashSet[String]	imports
Some(methodName)	Some[String]	forName
new CompletionProcessor(StdKinds.methodRef, this, isImplicit = true) { override protected def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean = { super.execute(namedElement) found = !levelSet.isEmpty !found } override protected val forName = Some(methodName) }	CompletionProcessor	processor
scFun.superMethods.map(_.containingClass)	IndexedSeq[PsiClass]	superMethodClasses
new Key("DESUGARED_withFilter_METHOD")	Key[ScForImpl.DesugaredWithFilterUserData]	desugaredWithFilterKey
signatures.forName(member.name).nodesIterator	Iterator[MixinNodes.Node[TermSignature]]	signsIterator
getParent.asInstanceOf[ScImportStmt]	ScImportStmt	parent
parent.getNode	ASTNode	node
signsIterator.next()	MixinNodes.Node[TermSignature]	node
node.removeChild _	ASTNode => Unit	remove
getJarFile(inheritor)	VirtualFile	jarFile
getNextSibling	PsiElement	next
maybeResolveResult .find(_.name == Update) .map(_ => getContext) .collect { case ScAssignment(call: ScMethodCall, Some(right)) if call == this => right }	Option[ScExpression]	updateArgument
next.getNode	ASTNode	comma
next.getNextSibling	PsiElement	comma
getPrevSibling	PsiElement	prev
prev.getPrevSibling	PsiElement	prevSibling
node.supers.iterator	Iterator[MixinNodes.Node[TermSignature]]	supersIterator
supersIterator.next()	MixinNodes.Node[TermSignature]	s
false	Boolean	break
sameNameInheritors.maxBy { inheritor => val jarFile = getJarFile(inheritor) if (jarFile == null) 0 else StringUtil.commonPrefixLength(jarFile.getCanonicalPath, clazzJar.getCanonicalPath) }	PsiClass	closestClass
refsContainer match { case st: ScStableCodeReference if st.resolve() == null => Some(createReferenceFromText(st.getText, st.getParent, st)) case expr: ScReferenceExpression if expr.resolve() == null => Some(createExpressionFromText(expr.getText, expr).asInstanceOf[ScReferenceExpression]) case _ => None }	Option[ScReference]	newRef
this.expectedType() match { case Some(downer: DesignatorOwner) => downer.isStable case Some(other) if !t.conforms(other) => other match { case Aliased(AliasType(_, Right(lower: DesignatorOwner), _)) => lower.isStable case Aliased(AliasType(_: ScTypeAliasDefinition, Right(c: ScCompoundType), _)) => isRefinement(c) case c: ScCompoundType => isRefinement(c) case _ => false } case _ => false }	Boolean	expectedStable
elementScope.getCachedClass("java.lang.String") .map(ScalaType.designator(_))	Option[ScType]	maybeStringType
importExprs.takeWhile(_ != lastParent).reverseIterator	Iterator[ScImportExpr]	importsIterator
importsIterator.next()	ScImportExpr	importExpr
importExpr.reference match { case Some(element) => element case _ => return true }	ScStableCodeReference	ref
processor.getHint(NameHint.KEY)	NameHint	nameHint
clean(name)	String	decodedName
PsiTreeUtil.getParentOfType(this, classOf[ScImportExpr])	ScImportExpr	expr
expr.selectors.head == this	Boolean	forward
this.getNode	ASTNode	node
if (forward) node.getTreeNext else node.getTreePrev	ASTNode	prev
ScalaInheritors.getSelfTypeInheritors(parentClass)	Seq[ScTemplateDefinition]	inheritors
null	IElementType	t
aClass.typeParameters.head.name	String	tpName
ScalaPsiUtil.typeParamString(aClass.typeParameters.head)	String	tpText
createImportFromTextWithContext(s"import _root_.$qName", this, this)	ScImportStmt	imp
(`type`, polymorphicType(resolveResult)) match { case (ScTypePolymorphicType(_, head), ScTypePolymorphicType(internal, tail)) => removeBadBounds(ScTypePolymorphicType(internal, head ++ tail)) case (ScTypePolymorphicType(_, head), internalType) => ScTypePolymorphicType(internalType, head) case (_, polymorphicType) => polymorphicType }	ScType	updatedType
new Map	MixinNodes.this.Map	map
calcTreeElement.clone.asInstanceOf[FileElement]	FileElement	fileElement
cloneImpl(fileElement).asInstanceOf[ScalaCodeFragment]	ScalaCodeFragment	clone
getManager.asInstanceOf[PsiManagerEx].getFileManager	FileManager	fileManager
importExpr.importedNames.map(clean)	IndexedSeq[String]	importedNames
new LightVirtualFile(getName, getLanguage, getText)	LightVirtualFile	virtualFile
processor match { case r: ResolveProcessor => if (!r.checkImports()) return false r.checkWildcardImports() case _ => true }	Boolean	checkWildcardImports
importExpr.selectorSet match { case Some(_) => ref case None if importExpr.isSingleWildcard => ref case None => ref.qualifier.getOrElse(return true) }	ScStableCodeReference	exprQual
args.toSeq.flatMap(_.exprs)	IndexedSeq[ScExpression]	exprs
constructor.getOrElse(return "")	ScPrimaryConstructor	constr
fileManager.createFileViewProvider(virtualFile, false).asInstanceOf[SingleRootFileViewProvider]	SingleRootFileViewProvider	cloneViewProvider
new SingleRootFileViewProvider( PsiManager.getInstance(project), new LightVirtualFile("Dummy.scala", ScalaFileType.INSTANCE, text), true )	SingleRootFileViewProvider	viewProvider
fun.polymorphicType(s) match { case ScTypePolymorphicType(internal, params) => ScTypePolymorphicType(internal, params ++ typeParams) case anotherType if typeParams.nonEmpty => ScTypePolymorphicType(anotherType, typeParams) case anotherType => anotherType }	ScType	polyType
new ScalaCodeFragment(viewProvider)	ScalaCodeFragment	fragment
polyType .updateTypeOfDynamicCall(r.isDynamic)	ScType	applyMethodType
exprs.exists { case ScBooleanLiteral(isAlias) => isAlias case ScAssignment(_, Some(ScBooleanLiteral(isAlias))) => isAlias case _ => false }	Boolean	alias
ScSubstitutor.paramToType(matchedParams.map(_._1), matchedParams.map(_._3))	ScSubstitutor	paramSubstitutor
this.expectedTypeEx().collect { case (_, Some(te)) => (for { param <- te.contexts.take(2).findBy[ScParameter] //parameter is first context for stub elements and second context for ast if !param.getDefaultExpression.contains(this) method <- param.owner.asOptionOf[ScFunction] } yield isReferencedInReturnType(method, param)).getOrElse(false) }.getOrElse(false)	Boolean	isParamToDepMethod
paramSubstitutor(inferredType)	ScType	`type`
source match { case obj: ScObject => obj.fakeCompanionClassOrCompanionClass case _ => null }	PsiClass	companionClass
exprs.collectFirst { case ScLiteral(opName) => opName case ScAssignment(_, Some(ScLiteral(opName))) => opName }	Option[String]	name
call.map(_.updateAccordingToExpectedType(applyMethodType)) .getOrElse(applyMethodType)	ScType	updatedMethodCall
processor match { case p: ResolveProcessor => ref match { // do not process methodrefs when importing a type from a type case ref: ScStableCodeReference if p.kinds.contains(ResolveTargets.CLASS) && ref.getKinds(incomplete = false).contains(ResolveTargets.CLASS) && ref.getKinds(incomplete = false).contains(ResolveTargets.METHOD) => ref.resolveTypesOnly(false) case ref: ScStableCodeReference if p.kinds.contains(ResolveTargets.METHOD) => ref.resolveMethodsOnly(false) case _ => ref.multiResolveScala(false) } case _ => ref.multiResolveScala(false) }	Array[ScalaResolveResult]	resolve
new ScalaRecursiveElementVisitor { override def visitSimpleTypeElement(simple: ScSimpleTypeElement): Unit = { if (simple.singleton) { simple.reference match { case Some(ref) if ref.refName == p.name && ref.resolve() == p => found = true case _ => () } } super.visitSimpleTypeElement(simple) } }	ScalaRecursiveElementVisitor { def visitSimpleTypeElement(simple: ScSimpleTypeElement): Unit }	visitor
bind.fromType	Option[ScType]	fromType
resolve.iterator	Iterator[ScalaResolveResult]	resolveIterator
resolveIterator.next()	ScalaResolveResult	next
bind.unresolvedTypeParameters.getOrElse(Seq.empty)	Seq[TypeParameter]	unresolvedTypeParameters
next.getElement	PsiNamedElement	elem
annotation.findAttributeValue("value") match { case ScLiteral(value) => value case _ => "" }	String	prefix
m.parameters.headOption.flatMap(_.`type`().toOption)	Option[ScType]	firstParamType
clazz.typeParameters.map(_.getText).map { // strip variance when moving type parameters to method case str if str.length > 1 && (str.charAt(0) == '+' || str.charAt(0) == '-') => str.substring(1) case other => other } match { case Seq() => "" case seq => seq.mkString("[", ",", "]") }	String	typeParametersText
call.flatMap(_.expectedType()).getOrElse(Any(expr))	ScType	expectedType
m.typeParameters.map(tparam => tparam.name -> tparam).toMap	Map[String, ScTypeParam]	typeParamNames
tArgs.collect { case ptpe: ScParameterizedType => ptpe.canonicalText }	IndexedSeq[String]	nestedTypeArgs
state.withFromType(None)	ResolveState	newState
(comps(1), te.map { case t: ScTupleTypeElement if t.components.length == 2 => t.components(1) case t => t })	(ScType, Option[ScTypeElement])	actualArg
name + typeParametersClause.map(_ => typeParameters.map(_.name). mkString("[", ",", "]")).getOrElse("")	String	returnType
assign.leftExpression	ScExpression	lE
tp.typeParameterText	String	baseText
refPatt.`type`()	result.TypeResult	result
typeParamNames(tp.name)	ScTypeParam	usedTypeParam
baseText.indexOf('-')	Int	i
liftedTypeParams(idx)	ScTypeParam	liftedParam
getFirstReference(exprQual).bind().fold(next.importsUsed)(r => r.importsUsed ++ next.importsUsed)	Set[ImportUsed]	importsUsed
baseText.indexOf('+')	Int	i
"JsonCodec"	String	Jc
"ConfiguredJsonCodec"	String	Cjc
"io.circe.generic.JsonCodec"	String	FqnJc
facade.findPackage(qual)	PsiPackage	pack
"io.circe.generic.extras.ConfiguredJsonCodec"	String	FqnCjc
"_root_.io.circe.Encoder"	String	Enc
"_root_.io.circe.Decoder"	String	Dec
"_root_.scala.Predef.???"	String	Dummy
param.owner match { case f: ScPrimaryConstructor => f.containingClass case _: ScFunctionExpr => null case f => f }	PsiElement	owner
typarams.map(tp => tp.name)	Seq[String]	tparams
if (clazz.isObject) { clazz.name + ScalaTypePresentation.ObjectTypeSuffix } else { clazz.name }	String	nme
join(tparams)	String	tps
state.substitutor.followed(next.substitutor)	ScSubstitutor	subst
Random.nextInt(1000000)	Int	id
ScalaCodeStyleSettings.getInstance(getProject)	ScalaCodeStyleSettings	settings
Option(getQualifiedName).map(_.stripSuffix("$"))	Option[Any]	qualName
param.getRealParameterType.exists(isStableContext)	Boolean	stableTypeRequired
param.getRealParameterType	result.TypeResult	result
if (typeParametersText.isEmpty) { parameter.`type`().toOption.map(_.canonicalText).getOrElse("Any") } else { parameter.typeElement.get.calcType.toString }	String	typeText
Option(getName).map(_.stripSuffix("$"))	Option[Any]	name
fun.definedReturnType.toOption	Option[ScType]	maybeResult
param.`type`()	result.TypeResult	result
s(result match { case Right(tp) => tp case _ => return result })	ScType	computeType
member match { case fun: ScFunctionDefinition if fun.returnTypeElement.isEmpty && !fun.hasAssign => Some((api.Unit, None)) case fun: ScFunction => fun.returnTypeElement.flatMap(te => fun.returnType.toOption.map((_, Some(te)))) case v: ScValueOrVariable => v.typeElement.map(te => (te.`type`().getOrAny, Some(te))) case _ => return Array.empty }	Option[(ScType, Option[ScTypeElement])]	declaredType
new PhysicalMethodSignature(method, subst)	PhysicalMethodSignature	phys
"MODULE$"	String	moduleFieldName
tail	ScType	tp
new MethodResolveProcessor(this, "apply", Nil, Nil, Nil)	MethodResolveProcessor	processor
new ThreadLocal[Long] { override def initialValue(): Long = 0 }	{ def initialValue(): Long }	processing
processor.candidates	Array[ScalaResolveResult]	candidates
f.`type`()	result.TypeResult	result
settings.getImportsWithPrefix.filter(s => !s.startsWith(ScalaCodeStyleSettings.EXCLUDE_PREFIX) && s.substring(0, s.lastIndexOf(".")) == pack.getQualifiedName )	Array[Nothing]	prefixImports
typed.`type`()	result.TypeResult	result
member.asOptionOf[ScFunction].map(_.typeParameters).getOrElse(Seq.empty)	Seq[ScTypeParam]	typeParameters
clazz.constructor .getOrElse(return Failure("Case Class hasn't primary constructor"))	ScPrimaryConstructor	constructor
if (thisProjections) ScThisType(clazz) else clazz.getTypeWithProjections().getOrElse { return Failure("Cannot resolve parent class") }	ScType	projected
getContext match { case infixExpr: ScInfixExpr if infixExpr.operation == this => Some(infixExpr.left) case postfixExpr: ScPostfixExpr if postfixExpr.operation == this => Some(postfixExpr.operand) case _ => ScalaPsiUtil.drvTemplate(this) }	Option[Typeable]	result
qualifier.orElse { val result: Option[Typeable] = getContext match { case infixExpr: ScInfixExpr if infixExpr.operation == this => Some(infixExpr.left) case postfixExpr: ScPostfixExpr if postfixExpr.operation == this => Some(postfixExpr.operand) case _ => ScalaPsiUtil.drvTemplate(this) } result }	Option[Typeable]	maybeReference
TermSignature.withoutParams(field.getName, subst, field)	TermSignature	sig
template	ProjectContext	ctx
settings.getImportsWithPrefix.filter(s => s.startsWith(ScalaCodeStyleSettings.EXCLUDE_PREFIX) && s.substring(ScalaCodeStyleSettings.EXCLUDE_PREFIX.length, s.lastIndexOf(".")) == pack.getQualifiedName )	Array[Nothing]	excludeImports
tArgs.zipWithIndex.collect { case (TypeParameterType(tp), idx) => // do not rewrite nested type arguments, require implicit evidence instead val usedTypeParam = typeParamNames(tp.name) val liftedParam = liftedTypeParams(idx) usedTypeParam -> TypeParameterType(liftedParam) }.toMap	Map[ScTypeParam, TypeParameterType]	usedLiftedArgs
ScalaPsiManager.instance(template.projectContext) .getCachedClass(template.resolveScope, "java.lang.Object")	Option[PsiClass]	javaObject
member match { case fun: ScFunction => fun.superMethodAndSubstitutor case other: ScMember => valSuperSignature(other).map(s => (s.namedElement, s.substitutor)) }	Option[(PsiNamedElement, ScSubstitutor)]	superMemberAndSubstitutor
new mutable.HashSet[String]()	mutable.HashSet[String]	names
new mutable.HashSet[String]()	mutable.HashSet[String]	excludeNames
`type` match { case ScDesignatorType(element) => getType(element) case projectionType: ScProjectionType => getType(projectionType.actualElement).map(projectionType.actualSubst) case _ => None }	Option[ScType]	maybeType
names.contains("_")	Boolean	wildcard
maybeReference.flatMap { _.`type`().toOption }	Option[ScType]	maybeType
ScSubstitutor.bind(fun.typeParameters, typeParameters)(TypeParameterType(_))	ScSubstitutor	typeParamSubst
thisClass match { case syn: ScSyntheticClass => syn.getSuperTypes.map(_.toScType()(syn)).toSeq case newTd: ScNewTemplateDefinition => MixinNodes.linearization(newTd) case _ => MixinNodes.linearization(thisClass).drop(1) }	Seq[ScType]	superTypes
td.fakeCompanionModule.map(TermSignature(_, subst))	Option[TermSignature]	companionSig
signature.namedElement	PsiNamedElement	element
containingClass match { case null => ScalaType.designator(this) case clazz => val projected = if (thisProjections) ScThisType(clazz) else clazz.getTypeWithProjections().getOrElse { return Failure("Cannot resolve parent class") } ScProjectionType(projected, this) }	ScType	designator
thisClass match { case td: ScTemplateDefinition => ScSubstitutor(ScThisType(td)) case _ => ScSubstitutor.empty }	ScSubstitutor	thisTypeSubst
Set(importsUsed.toSeq: _*) + ImportExprUsed(importExpr)	Set[ImportUsed]	newImportsUsed
td match { case c: ScClass if c.hasModifierProperty("implicit") => c.getSyntheticImplicitMethod.map(new PhysicalMethodSignature(_, subst)) case _ => None }	Option[PhysicalMethodSignature]	implicitClassFun
typeParametersClause.map(tp => { tp.typeParameters.map(tp => { val baseText = tp.typeParameterText if (tp.isContravariant) { val i = baseText.indexOf('-') baseText.substring(i + 1) } else if (tp.isCovariant) { val i = baseText.indexOf('+') baseText.substring(i + 1) } else baseText }).mkString("[", ", ", "]") }).getOrElse("")	String	typeParametersText
MixinNodes.linearization(cp)	Seq[ScType]	superTypes
nestedTypeArgs.zipWithIndex.map { case (typeText, idx) => s"ev$idx: _root_.scala.Predef.<:<[LP$idx, $typeText]" }	IndexedSeq[String]	equalityEvidences
ScSubstitutor(compoundThisType.getOrElse(cp))	ScSubstitutor	thisTypeSubst
s"${parameter.name} : ${parameter.typeElement.map(_.getText).getOrElse("Nothing")}"	String	paramText
new SmartList[ScCompoundType]	SmartList[ScCompoundType]	refinements
state.withPrefixCompletion.withImportsUsed(newImportsUsed)	ResolveState	newState
maybeType.flatMap { case ScThisType(clazz) => Some(ScDesignatorType(clazz)) case ScDesignatorType(_: ScObject) => None case ScCompoundType(comps, _, _) => comps.headOption.map(removeTypeDesignator) case tp => Some(tp).map(removeTypeDesignator) }.getOrElse(Any)	ScType	upperBound
constr.parameterList.clauses.map { clause => clause.parameters.map { parameter => val paramText = s"${parameter.name} : ${parameter.typeElement.map(_.getText).getOrElse("Nothing")}" parameter.getDefaultExpression match { case Some(expr) => s"$paramText = ${expr.getText}" case _ => paramText } }.mkString(if (clause.isImplicit) "(implicit " else "(", ", ", ")") }.mkString	String	parametersText
mutable.HashSet.empty[String]	mutable.HashSet[String]	names
ScSubstitutor.bind(typeParamsMappings.keys.toList, typeParamsMappings.values.toList)	ScSubstitutor	subst
ScExistentialArgument("_$1", Nil, Nothing, upperBound)	ScExistentialArgument	argument
new BaseProcessor(StdKinds.stableImportSelector) { override protected def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean = if (isOK(namedElement.name)) completionProcessor.execute(namedElement, state) else true override def getHint[T](hintKey: Key[T]): T = completionProcessor.getHint(hintKey) }	BaseProcessor { def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean def getHint[T](hintKey: Key[T]): T }	importsProcessor
superType match { case p@ScProjectionType(proj, _) => ScSubstitutor(proj).followed(p.actualSubst) case ParameterizedType(p@ScProjectionType(proj, _), _) => ScSubstitutor(proj).followed(p.actualSubst) case _ => ScSubstitutor.empty }	ScSubstitutor	dependentSubst
p.parameters.map(parameterText) ++ (if (p.isImplicit) conformanceEvidences else Seq.empty)	IndexedSeq[String]	parameters
prototype.typeParameters.filterNot(typeParamsMappings.isDefinedAt)	Seq[ScTypeParam]	retainedTypeParams
ScalaPsiManager.instance(c.getProject)	ScalaPsiManager	manager
qualifierType(isInPackageObject(next.element))	Option[ScType]	refType
state .withImportsUsed(newImportsUsed) .withSubstitutor(subst) .withFromType(refType)	ResolveState	newState
combine(s, superClass).followed(thisTypeSubst).followed(dependentSubst)	ScSubstitutor	newSubst
if (retainedTypeParams.isEmpty) "" else s"[${retainedTypeParams.map(ScalaPsiUtil.typeParamString(_)).mkString("", ", ", "")}]"	String	typeParamsText
superClass.getTypeParameters	Array[PsiTypeParameter]	typeParameters
getModifierList.accessModifier.map(am => accessModifierText(am) + " ").getOrElse("")	String	accessModifier
td.getTypeWithProjections().getOrAny	ScType	clazzType
typeParameters match { case typeArgs if typeArgs.isEmpty => designator case typeArgs => ScParameterizedType(designator, typeArgs.map(TypeParameterType(_))) }	ScType	result
Option(method.containingClass).filter { method.getName == "getClass" && _.getQualifiedName == "java.lang.Object" }.flatMap { _ => val maybeReference = qualifier.orElse { val result: Option[Typeable] = getContext match { case infixExpr: ScInfixExpr if infixExpr.operation == this => Some(infixExpr.left) case postfixExpr: ScPostfixExpr if postfixExpr.operation == this => Some(postfixExpr.operand) case _ => ScalaPsiUtil.drvTemplate(this) } result } def getType(element: PsiNamedElement): Option[ScType] = Option(element).collect { case pattern: ScBindingPattern => pattern case fieldId: ScFieldId => fieldId case parameter: ScParameter => parameter }.flatMap { _.`type`().toOption } def removeTypeDesignator(`type`: ScType): ScType = { val maybeType = `type` match { case ScDesignatorType(element) => getType(element) case projectionType: ScProjectionType => getType(projectionType.actualElement).map(projectionType.actualSubst) case _ => None } maybeType.map(removeTypeDesignator).getOrElse(`type`) } def convertQualifier(jlClass: PsiClass): ScType = { val maybeType = maybeReference.flatMap { _.`type`().toOption } val upperBound = maybeType.flatMap { case ScThisType(clazz) => Some(ScDesignatorType(clazz)) case ScDesignatorType(_: ScObject) => None case ScCompoundType(comps, _, _) => comps.headOption.map(removeTypeDesignator) case tp => Some(tp).map(removeTypeDesignator) }.getOrElse(Any) val argument = ScExistentialArgument("_$1", Nil, Nothing, upperBound) ScExistentialType(ScParameterizedType(ScDesignatorType(jlClass), Seq(argument))) } elementScope.getCachedClass("java.lang.Class") .map(convertQualifier) }	Option[ScType]	returnType
prototype.paramClauses.clauses.head.parameters.tail.map(parameterText)	IndexedSeq[String]	headParams
bind match { case ScalaResolveResult(fun: ScFun, s) => fun.polymorphicType(s) //prevent infinite recursion for recursive pattern reference case ScalaResolveResult(self: ScSelfTypeElement, _) => val clazz = PsiTreeUtil.getContextOfType(self, true, classOf[ScTemplateDefinition]) ScThisReferenceImpl.getThisTypeForTypeDefinition(clazz, this) match { case Right(value) => value case failure => return failure } case r@ScalaResolveResult(refPatt: ScBindingPattern, s) => ScalaPsiUtil.nameContext(refPatt) match { case pd: ScPatternDefinition if PsiTreeUtil.isContextAncestor(pd, this, true) => pd.declaredType match { case Some(t) => t case None => return Failure("No declared type found") } case vd: ScVariableDefinition if PsiTreeUtil.isContextAncestor(vd, this, true) => vd.declaredType match { case Some(t) => t case None => return Failure("No declared type found") } case _ => val result = refPatt.`type`() refPatt.`type`().map { tp => if (isStableContext(tp) && refPatt.isStable) { r.fromType match { case Some(fT) => ScProjectionType(fT, refPatt) case None => ScalaType.designator(refPatt) } } else s(tp) }.getOrElse(return result) } case ScalaResolveResult(param: ScParameter, _) if isMetaInlineDefn(param) => ScalaPsiElementFactory.createTypeFromText("scala.meta.Stat", param.getContext, null).get case r @ ScalaResolveResult(param: ScParameter, s) => val owner = param.owner match { case f: ScPrimaryConstructor => f.containingClass case _: ScFunctionExpr => null case f => f } def isMethodDependent(function: ScFunction): Boolean = { def checkte(te: ScTypeElement): Boolean = { var res = false te.accept(new ScalaRecursiveElementVisitor { override def visitReference(ref: ScReference): Unit = { if (ref.resolve() == param) res = true super.visitReference(ref) } }) res } function.returnTypeElement match { case Some(te) if checkte(te) => return true case _ => } !function.parameters.forall { param => param.typeElement match { case Some(te) => !checkte(te) case _ => true } } } val stableTypeRequired = param.getRealParameterType.exists(isStableContext) r.fromType match { case Some(fT) if param.isVal && stableTypeRequired => ScProjectionType(fT, param) case Some(ScThisType(clazz)) if owner != null && PsiTreeUtil.isContextAncestor(owner, this, true) && stableTypeRequired && owner.isInstanceOf[ScTypeDefinition] && owner == clazz => ScalaType.designator(param) //todo: think about projection from this type? case _ if owner != null && PsiTreeUtil.isContextAncestor(owner, this, true) && stableTypeRequired && !owner.isInstanceOf[ScTypeDefinition] => ScalaType.designator(param) case _ => owner match { case function: ScFunction if PsiTreeUtil.isContextAncestor(function, this, true) && isMethodDependent(function) => ScalaType.designator(param) case _ => val result = param.getRealParameterType s(result match { case Right(tp) => tp case _ => return result }) } } case ScalaResolveResult(value: ScSyntheticValue, _) => value.tp case ScalaResolveResult(fun: ScFunction, s) if fun.isProbablyRecursive => val maybeResult = fun.definedReturnType.toOption fun.polymorphicType(s, maybeResult) case result@ScalaResolveResult(fun: ScFunction, s) => fun.polymorphicType(s).updateTypeOfDynamicCall(result.isDynamic) case ScalaResolveResult(param: ScParameter, s) if param.isRepeatedParameter => val result = param.`type`() val computeType = s(result match { case Right(tp) => tp case _ => return result }) computeType.tryWrapIntoSeqType case ScalaResolveResult(obj: ScObject, _) => def tail = { fromType match { case Some(tp) => ScProjectionType(tp, obj) case _ => ScalaType.designator(obj) } } //hack to add Eta expansion for case classes if (obj.isSyntheticObject) { ScalaPsiUtil.getCompanionModule(obj) match { case Some(clazz) if clazz.isCase && !clazz.hasTypeParameters => this.expectedType() match { case Some(tp) => if (FunctionType.isFunctionType(tp)) { val tp = tail val processor = new MethodResolveProcessor(this, "apply", Nil, Nil, Nil) processor.processType(tp, this) val candidates = processor.candidates if (candidates.length != 1) tail else convertBindToType(candidates(0)).getOrElse(tail) } else tail case _ => tail } case _ => tail } } else tail case r@ScalaResolveResult(f: ScFieldId, s) => val result = f.`type`() result.map { tp => if (isStableContext(tp) && f.isStable) { r.fromType match { case Some(fT) => ScProjectionType(fT, f) case None => ScalaType.designator(f) } } else s(tp) }.getOrElse(return result) case ScalaResolveResult(typed: ScTypedDefinition, s) => val result = typed.`type`() result match { case Right(tp) => s(tp) case _ => return result } case ScalaResolveResult(pack: PsiPackage, _) => ScalaType.designator(pack) case ScalaResolveResult(clazz: ScClass, s) if clazz.isCase => val constructor = clazz.constructor .getOrElse(return Failure("Case Class hasn't primary constructor")) constructor.polymorphicType(s) case ScalaResolveResult(clazz: ScTypeDefinition, s) if clazz.typeParameters.nonEmpty => s(ScParameterizedType(ScalaType.designator(clazz), clazz.typeParameters.map(TypeParameterType(_)))) case ScalaResolveResult(clazz: PsiClass, _) => ScDesignatorType.static(clazz) //static Java class case ScalaResolveResult(field: PsiField, s) => s(field.getType.toScType()) case ScalaResolveResult(method: PsiMethod, s) => val returnType = Option(method.containingClass).filter { method.getName == "getClass" && _.getQualifiedName == "java.lang.Object" }.flatMap { _ => val maybeReference = qualifier.orElse { val result: Option[Typeable] = getContext match { case infixExpr: ScInfixExpr if infixExpr.operation == this => Some(infixExpr.left) case postfixExpr: ScPostfixExpr if postfixExpr.operation == this => Some(postfixExpr.operand) case _ => ScalaPsiUtil.drvTemplate(this) } result } def getType(element: PsiNamedElement): Option[ScType] = Option(element).collect { case pattern: ScBindingPattern => pattern case fieldId: ScFieldId => fieldId case parameter: ScParameter => parameter }.flatMap { _.`type`().toOption } def removeTypeDesignator(`type`: ScType): ScType = { val maybeType = `type` match { case ScDesignatorType(element) => getType(element) case projectionType: ScProjectionType => getType(projectionType.actualElement).map(projectionType.actualSubst) case _ => None } maybeType.map(removeTypeDesignator).getOrElse(`type`) } def convertQualifier(jlClass: PsiClass): ScType = { val maybeType = maybeReference.flatMap { _.`type`().toOption } val upperBound = maybeType.flatMap { case ScThisType(clazz) => Some(ScDesignatorType(clazz)) case ScDesignatorType(_: ScObject) => None case ScCompoundType(comps, _, _) => comps.headOption.map(removeTypeDesignator) case tp => Some(tp).map(removeTypeDesignator) }.getOrElse(Any) val argument = ScExistentialArgument("_$1", Nil, Nothing, upperBound) ScExistentialType(ScParameterizedType(ScDesignatorType(jlClass), Seq(argument))) } elementScope.getCachedClass("java.lang.Class") .map(convertQualifier) } method .methodTypeProvider(elementScope) .polymorphicType(s, returnType) case _ => return resolveFailure }	ScType	inner
if (headParams.isEmpty) "" else headParams.mkString("(", ", ", ")")	String	restHeadClause
prototype.paramClauses.clauses.tail	Seq[ScParameterClause]	restClauses
restClauses.filterNot(_.isImplicit).map(clauseText).mkString	String	regularClausesText
tp.extractClass.getOrElse(clazz)	PsiClass	cl
ExtensionPointName.create(CLASS_NAME)	ExtensionPointName[SyntheticMembersInjector]	EP_NAME
qualifier match { case Some(_: ScSuperReference) => None case None => getContext match { case ScSugarCallExpr(baseExpression, operation, _) if operation == this => Some(baseExpression) case _ => None } case result => result }	Option[ScExpression]	maybeExpression
restClauses.find(_.isImplicit).fold(conformanceEvidenceClause)(clauseText)	String	implicitClauseText
new DynamicExtensionPoint[SyntheticMembersInjector]	DynamicExtensionPoint[SyntheticMembersInjector]	DYN_EP
typeParameters.map(tp => superSubst(TypeParameterType(tp)))	IndexedSeq[ScType]	substedTpts
_	MixinNodes.Node[T]	_concreteSuper
new SmartList()	SmartList[MixinNodes.Node[T]]	_supers
subst(prototype.returnType.getOrAny).canonicalText	String	returnType
Logger.getInstance(getClass)	Logger	LOG
new THashSet[String]	THashSet[String]	allNames
source.getProject	Project	ctx
new SmartHashSet[String]	SmartHashSet[String]	implicitNames
source.functions.filter(isEligibleForAdaptation)	Seq[ScFunction]	typeClassMethods
new ArrayBuffer[ScFunction]()	ArrayBuffer[ScFunction]	buffer
new THashMap()	THashMap[String, Any]	thisSignaturesByName
(elem, refType, processor) match { case (cl: PsiClass, _, processor: BaseProcessor) if !cl.isInstanceOf[ScTemplateDefinition] => processor.processType(ScDesignatorType.static(cl), place, newState) case (_, Some(value), processor: BaseProcessor) => processor.processType(value, place, newState) case _ => elem.processDeclarations(processor, newState, this, place) }	Boolean	processed
new THashMap()	THashMap[String, Any]	supersSignaturesByName
mutable.HashSet.empty	mutable.HashSet[(ScImportSelector, PsiElement)]	shadowed
source match { case o: ScObject if o.isSyntheticObject => ScalaPsiUtil.getCompanionModule(o).getOrElse(source) case _ => source }	ScTypeDefinition	context
state.substitutor	ScSubstitutor	subst
set.selectors.iterator	Iterator[ScImportSelector]	selectors
new ArrayBuffer[Node[T]](implicitNames.size)	ArrayBuffer[MixinNodes.Node[T]]	res
selectors.next()	ScImportSelector	selector
getNameHint(processor, state)	String	nameHint
selector.isAliasedImport && !selector.importedName.contains(reference.refName)	Boolean	isImportAlias
processor.isInstanceOf[BaseProcessor]	Boolean	isScalaProcessor
selector.importedName.map(clean)	Option[String]	importedName
forName(iterator.next)	MixinNodes.AllNodes[T]	thisMap
shouldProcessMethods(processor)	Boolean	processMethods
ScSubstitutor.bind(fun.getTypeParameters, typeParameters)(TypeParameterType(_))	ScSubstitutor	typeParamSubst
shouldProcessMethodRefs(processor)	Boolean	processMethodRefs
{ val res = new ArrayBuffer[Node[T]](implicitNames.size) val iterator = implicitNames.iterator() while (iterator.hasNext) { val thisMap = forName(iterator.next) thisMap.nodesIterator.foreach { node => if (node.info.isImplicit) { res += node } } } res }	Seq[MixinNodes.Node[T]]	implicitNodes
superTpe.extractClass.map(_.getQualifiedName)	Option[Nothing]	superFqn
false	Boolean	fromSuper
source.typeParameters.head	ScTypeParam	tCons
isScalaProcessor && shouldProcessVals(processor)	Boolean	processValsForScala
shouldProcessOnlyStable(processor)	Boolean	processOnlyStable
this.name	String	name
TypeDefinitionMembers.getSignatures(containingClass).forName(name)	MixinNodes.AllNodes[TermSignature]	sigs
signature.name	String	name
getContainingFile.getNavigationElement match { case o: ScalaFile => o.typeDefinitions.toArray case o: PsiClassOwner => o.getClasses }	Array[PsiClass]	classes
mutable.ArrayBuffer(getConstructors: _*)	ArrayBuffer[PsiMethod]	result
BaseProcessor.isImplicitProcessor(processor)	Boolean	isImplicitProcessor
node.info.namedElement	PsiNamedElement	named
p.containingClass	ScTemplateDefinition	clazz
classes.iterator	Iterator[PsiClass]	classesIterator
classesIterator.next()	PsiClass	c
qualifierType(isInPackageObject(result.element))	Option[ScType]	refType
this match { case _: ScObject => true case _: ScTrait | _: ScClass => false case _ => return None }	Boolean	isObject
allFunctionsByName(name)	Iterator[PsiMethod]	inThisClass
name	String	thisName
state .withRename(importedName) .withImportsUsed(Set(importsUsed.toSeq: _*) + ImportSelectorUsed(selector)) .withSubstitutor(subst.followed(result.substitutor)) .withFromType(refType)	ResolveState	newState
m match { case v: ScValueOrVariable => v.declaredNames.headOption case cp: ScClassParameter if cp.isClassMember => Some(cp.name) case _ => None }	Option[String]	maybeName
this.getSameElementInContext	PsiElement	sameElementInContext
new MethodResolveProcessor(expr, "apply", List(exprs), Seq.empty, Seq.empty /* todo: ? */ , StdKinds.methodsOnly, isShapeResolve = true)	MethodResolveProcessor	applyProc
applyProc.candidates	Array[ScalaResolveResult]	cand
syntheticPropertyMethods(nameHint, node.info).iterator	Iterator[TermSignature]	iterator
call.get.getEffectiveInvokedExpr	ScExpression	expr
qualifierType(isInPackageObject(namedElement))	Option[ScType]	refType
if (processOnlyStable) provider.stable else provider.allSignatures	MixinNodes.Map[TermSignature]	signatures
ScalaPsiElementFactory.createMethodWithContext(template, context, source)	ScFunction	function
contextStub.getChildrenByType(TYPE_DEFINITIONS, ScTypeDefinitionFactory)	Array[ScTypeDefinition]	siblings
signatures.nodesIterator(nameHint, isSupers, onlyImplicit = isImplicitProcessor)	Iterator[MixinNodes.Node[TermSignature]]	nodesIterator
new ArrayBuffer[ScTypeDefinition]()	ArrayBuffer[ScTypeDefinition]	buffer
sameElementInContext	PsiElement	sibling
ScalaPsiElementFactory.createMethodWithContext(implicitMethodText, this.getContext, this)	ScFunction	method
tp.toPsiType.getCanonicalText	String	psiTypeText
provider.fromCompanion.nodesIterator(nameHint, isSupers)	Iterator[MixinNodes.Node[TermSignature]]	nodesIterator
state .withSubstitutor(subst) .withFromType(refType)	ResolveState	newState
source match { case o: ScObject if o.isSyntheticObject => ScalaPsiUtil.getCompanionModule(o).getOrElse(source) case _ => source }	ScTypeDefinition	contextClass
templateBodyOrSynthetic(contextClass)	ScTemplateBody	context
provider.types.nodesIterator(nameHint, isSupers)	Iterator[MixinNodes.Node[TypeSignature]]	iterator
processor.getHint(ElementClassHint.KEY)	ElementClassHint	hint
getContext match { case stub: ScalaStubBasedElementImpl[_, _] => stub.getStub case file: PsiFileImpl => file.getStub case _ => null }	(_$2) forSome {type _$2 <: StubElement[_$1]; type _$1}	contextStub
false	Boolean	containsValues
JavaPsiFacade.getInstance(clazz.getProject).getElementFactory	PsiElementFactory	elementFactory
elementFactory.createMethodFromText("public static " + clazz.name + "[] values() {}", clazz)	PsiMethod	valuesMethod
elementFactory.createMethodFromText("public static " + clazz.name + " valueOf(java.lang.String name) throws java.lang.IllegalArgumentException {}", clazz)	PsiMethod	valueOfMethod
getModifierList.accessModifier match { case None => "" case Some(am) => accessModifierText(am) + " " }	String	accessModifier
new LightMethod(clazz.getManager, valuesMethod, clazz)	LightMethod	values
new BaseProcessor(bp.kinds) { override def getHint[T](hintKey: Key[T]): T = processor.getHint(hintKey) override def isImplicitProcessor: Boolean = bp.isImplicitProcessor override def handleEvent(event: PsiScopeProcessor.Event, associated: Object) { processor.handleEvent(event, associated) } override def getClassKind: Boolean = bp.getClassKind override def setClassKind(b: Boolean) { bp.setClassKind(b) } override protected def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean = { if (shadowed.exists(p => ScEquivalenceUtil.smartEquivalence(namedElement, p._2))) return true val refType = qualifierType(isInPackageObject(namedElement)) val newState = state .withSubstitutor(subst) .withFromType(refType) processor.execute(namedElement, newState) } }	BaseProcessor { def getHint[T](hintKey: Key[T]): T def getClassKind: Boolean def handleEvent(event: PsiScopeProcessor.Event, associated: Any): Unit def isImplicitProcessor: Boolean def setClassKind(b: Boolean): Unit def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean }	p1
new LightMethod(clazz.getManager, valueOfMethod, clazz)	LightMethod	valueOf
place	ProjectContext	context
Set(importsUsed.toSeq: _*) + ImportWildcardSelectorUsed(importExpr)	Set[ImportUsed]	newImportsUsed
processor.getHint(NameHint.KEY)	NameHint	hint
state.withImportsUsed(newImportsUsed).withSubstitutor(subst)	ResolveState	newState
s"""${accessModifier}object $name { | //Generated synthetic object |}""".stripMargin	String	objText
qualifierType(isInPackageObject(next.element))	Option[ScType]	qualType
signature.name	String	sigName
ScalaPsiElementFactory.createTypeDefinitionWithContext(template, context, source)	ScTypeDefinition	td
new ArrayBuffer[ScTypeElement]()	ArrayBuffer[ScTypeElement]	buffer
ScalaPsiUtil.getStubOrPsiSibling(this, next = true) match { case null => this case next => next }	PsiElement	child
new ArrayBuffer[ScMember]()	ArrayBuffer[ScMember]	buffer
if (decodedName != "") forName(decodedName).nodesIterator else if (onlyImplicit) implicitNodes.iterator else allNodesIterator	Iterator[MixinNodes.Node[T]]	allIterator
source match { // case o: ScObject if o.isSyntheticObject => ScalaPsiUtil.getCompanionModule(o).getOrElse(source) case _ => source }	ScTypeDefinition	context
result.substitutor	ScSubstitutor	rSubst
cls.name	String	className
typeArgsFromTypeParams(cls)	String	typeArgs
typeParamsString(cls.typeParameters)	String	typeParamsDefinition
ScalaPsiElementFactory.createDefinitionWithContext(template, context, source)	ScMember	member
td.extendsBlock	ScExtendsBlock	extendsBlock
x.parameterList.clauses	Seq[ScParameterClause]	clauses
tCons.typeParameters.zipWithIndex.map { case (_, idx) => createTypeParameterFromText(s"LP$idx")(source) }	IndexedSeq[ScTypeParam]	liftedTypeParams
clauses.headOption.map(_.parameters).getOrElse(Seq.empty)	Seq[ScParameter]	params
source.name	String	className
tCons.name	String	tConsName
clauses.head.parameters	Seq[ScParameter]	params
ScalaPsiUtil.typeParamString(tCons)	String	tConsText
liftedTypeParams.isEmpty	Boolean	isProperType
ScalaPsiElementFactory.createTemplateBody(td.getProject)	ScTemplateBody	body
packageName	String	name
state .withImportsUsed(Set(importsUsed.toSeq: _*) + ImportSelectorUsed(selector)) .withSubstitutor(subst.followed(rSubst)) .withFromType(qualifierType(isInPackageObject(result.element)))	ResolveState	newState
adaptMethods(source, tCons, liftedTypeParams, isProperType).mkString("\n ")	String	adaptedMethods
params.map(p => paramTypeText(p, defaultTypeText = AnyCanonical))	IndexedSeq[Any]	caseClassParamTypes
liftedTypeParams.map(_.name)	IndexedSeq[String]	paramNames
qualifiedName(DefaultSeparator)(toJavaName) .split('.') .map(isBacktickedName(_).orNull) .mkString(DefaultSeparator)	String	result
if (isProperType) "" else paramNames.mkString(", ", ", ", "")	String	tParamsText
iterator.next()	MixinNodes.Node[T]	n
if (isProperType) "" else s"[${paramNames.mkString(", ")}]"	String	paramsWithBrackets
-1	Long	typeParamId
s""" |trait Ops[$tConsText$tParamsText] { | type TypeClassType <: $className[$tConsName] | val typeClassInstance: TypeClassType | | def self: $tConsName$paramsWithBrackets | | $adaptedMethods |} """.stripMargin	String	opsTrait
ScSyntheticClass.this	ScSyntheticClass	This
s""" |trait To${className}Ops { | implicit def to${className}Ops[$tConsText$tParamsText]( | target: $tConsName$paramsWithBrackets | )(implicit tc: $className[$tConsName]): $className.Ops[$tConsName$tParamsText] = ??? |} """.stripMargin	String	toOpsTrait
allOpsSupers(source, tConsName, tParamsText).mkString(" ", " ", "")	String	supers
if (lastParent != null) getSubPackages(lastParent.resolveScope) else getSubPackages	Array[PsiPackage]	subPackages
s""" |trait AllOps[$tConsText$tParamsText] extends $className.Ops[$tConsName$tParamsText]$supers { | type TypeClassType <: $className[$tConsName] | val typeClassInstance: TypeClassType |} """.stripMargin	String	allOpsTrait
ScalaShortNamesCacheManager.getInstance(getProject) .methodsByName(name)(scope) .filter { method => isInheritor(method.containingClass, checkDeep = true) }	Iterable[PsiMethod]	inBaseClasses
mutable.Set.empty[Path]	mutable.Set[ScTemplateDefinitionImpl.Path]	collected
ScLightField(param.getName, tp, this, PsiModifier.PUBLIC, PsiModifier.FINAL)	PsiField	lightField
s""" |object ops { | implicit def toAll${className}Ops[$tConsText$tParamsText]( | target: $tConsName$paramsWithBrackets | )(implicit tc: $className[$tConsName]): $className.AllOps[$tConsName$tParamsText] = ??? |} """.stripMargin	String	opsObject
Path(clazz)	ScTemplateDefinitionImpl.Path	path
ArrayBuffer.empty[ScType]	ArrayBuffer[ScType]	buffer
projectContext.stdTypes	StdTypes	stdTypes
constructor match { case Some(constr) => constr.parameters.map { param => param.`type`() match { case Right(tp: TypeParameterType) if tp.psiTypeParameter.findAnnotation("scala.specialized") != null => val psiTypeText: String = tp.toPsiType.getCanonicalText val lightField = ScLightField(param.getName, tp, this, PsiModifier.PUBLIC, PsiModifier.FINAL) Option(lightField) case _ => None } } case _ => Seq.empty }	Seq[Option[PsiField]]	fields
definition.supers.iterator	Iterator[PsiClass]	supersIterator
buffer.find { case AnyVal | AnyRef | Any => true case t => extract(t) }	Option[ScType]	findResult
s""" |object nonInheritedOps extends $className.To${className}Ops """.stripMargin	String	nonInheritedOpsObject
ScalaNamesUtil.clean(state.renamed.getOrElse(p.name))	String	name
scalaProductClass	PsiClass	sp
if (cls.tooBigForUnapply) None else cls.constructor match { case Some(x: ScPrimaryConstructor) => val clauses = x.parameterList.clauses val params = clauses.headOption.map(_.parameters).getOrElse(Seq.empty) val returnTypeText = if (params.isEmpty) BooleanCanonical else { val params = clauses.head.parameters if (params.isEmpty) BooleanCanonical else { val caseClassParamTypes = params.map(p => paramTypeText(p, defaultTypeText = AnyCanonical)) val optionTypeArg = caseClassParamTypes match { case Seq(text) => text case seq => seq.commaSeparated(Model.Parentheses) } OptionCanonical + "[" + optionTypeArg + "]" } } val unapplyName = if (params.lastOption.exists(_.isRepeatedParameter)) UnapplySeq else Unapply Some("def " + unapplyName + typeParamsDefinition + "(x$0: " + className + typeArgs + "): " + returnTypeText + " = throw new Error()") case None => None }	Option[String]	unapply
scalaSerializableClass	PsiClass	sp
NodesMap.empty[T]	MixinNodes.NodesMap[T]	nodesMap
javaObjectClass	PsiClass	so
clazz.getSuperTypes.iterator	Iterator[PsiClassType]	supersIterator
PrivateNodes.empty[T]	MixinNodes.PrivateNodes[T]	privates
PACKAGE_OBJECT_KEY.integerElements(fqn, classOf[PsiClass])	Iterable[PsiClass]	packages
ts.syntheticClass.getOrElse(return PsiClassType.EMPTY_ARRAY)	ScSyntheticClass	syntheticClass
ScPackagingImpl.fullPackageName(parentPackageName, topRefName)	String	top
ScalaNamesUtil.cleanFqn(fqn)	String	cleanName
templateParents.fold(syntheticTypeElements) { _.allTypeElements }	Seq[ScTypeElement]	typeElements
asFunctionParameters(x.effectiveParameterClauses, defaultExpressionString)	String	paramString
JavaPsiFacade.getInstance(projectContext).getElementFactory	PsiElementFactory	factory
typeParameterNames.map { name => new ScSyntheticTypeParameter(name, this) }	Seq[ScSyntheticTypeParameter]	typeParams
if (cls.hasAbstractModifier) None else { cls.constructor match { case Some(x: ScPrimaryConstructor) => val paramString = asFunctionParameters(x.effectiveParameterClauses, defaultExpressionString) Some("def " + Apply + typeParamsDefinition + paramString + ": " + className + typeArgs + " = throw new Error()") case None => None } }	Option[String]	apply
ArrayBuffer[PsiClass]()	ArrayBuffer[PsiClass]	buffer
false	Boolean	classesInitialized
_	ScType => ScSyntheticFunction	stringPlusMethod
ScalaPsiElementFactory.createTemplateDefinitionFromText(text, getParentByStub.getContext, getParentByStub)	ScTemplateDefinition	templDef
templDef.extendsBlock	ScExtendsBlock	extBlock
new Node(thisSig, fromSuper = false)	MixinNodes.Node[Nothing]	node
cons.parameterList.clauses.exists(cl => cl.hasRepeatedParam)	Boolean	hasRepeatedParam
new mutable.HashMap[String, ScSyntheticClass]	mutable.Map[String, ScSyntheticClass]	all
new mutable.HashSet[ScSyntheticClass]	mutable.Set[ScSyntheticClass]	numeric
new mutable.HashSet[ScSyntheticClass]	mutable.Set[ScSyntheticClass]	integer
new mutable.HashMap[String, ScObject]	mutable.Map[String, ScObject]	syntheticObjects
_	PsiFile	file
ctx.stdTypes	StdTypes	stdTypes
clazz.getContainingFile.getVirtualFile	VirtualFile	file
SyntheticClasses.TypeParameter :: Nil	List[Nothing]	typeParameters
state.withFromType(definition.`type`().toOption)	ResolveState	newState
new mutable.HashSet[PsiPackage]	mutable.HashSet[PsiPackage]	buff
new Node(superSig, fromSuper = true)	MixinNodes.Node[Nothing]	superNode
registerClass(Any, "Any")	ScSyntheticClass { def getQualifiedName: Any }	any
brace.getTextRange.getEndOffset - getTextRange.getStartOffset	Int	startOffset
if (text(text.length - 1) == '}') 1 else 0	Int	length
findChildByType[PsiElement](ScalaElementType.REFERENCE)	PsiElement	ref
if (ScalaPsiUtil.isPlaceTdAncestor(this, place)) ScThisType(this) else ScalaType.designator(this)	ScType	fromType
ScPackageImpl.findPackage(project, fqn + "." + tail)	ScPackageImpl	p
ref.getTextRange.getEndOffset + 1 - getTextRange.getStartOffset	Int	startOffset
extBlock.children.find(_.getNode.getElementType == ScalaTokenTypes.kEXTENDS).get	PsiElement	kExtends
TypeParameterType(typeParams.head)	TypeParameterType	retType
oldState.withFromType(fromType)	ResolveState	state
registerClass(AnyRef, "AnyRef")	ScSyntheticClass { def getQualifiedName: Any }	anyRef
hasCopyMethod(cls) || cls.supers.exists(hasCopyMethod)	Boolean	hasUserDefinedCopyMethod
Seq(Seq(Parameter( TypeParameterType(typeParams.head), isRepeated = false, index = 0)))	Seq[Seq[Parameter]]	paramClauses
privates.nodesIterator	Iterator[MixinNodes.Node[T]]	iter2
extBlock.children.find(_.getNode.getElementType == ScalaTokenTypes.kWITH).get	PsiElement	kWith
null	MixinNodes.Node[T]	publicNode
if (templateParents.isEmpty) kExtends else kExtends.getNextSibling	PsiElement	firstElem
TypeParameterType(typeParams.head)	ScType	retType
Path( CommonClassNames.JAVA_LANG_OBJECT_SHORT, Some(CommonClassNames.JAVA_LANG_OBJECT), Kind.NonScala )	ScTemplateDefinitionImpl.Path	JavaObject
if (templateParents.isEmpty) getFirstChild else templateParents.get	PsiElement	anchor
registerClass(Boolean, "Boolean")	ScSyntheticClass { def getQualifiedName: Any }	boolc
cc.constructor.map(_.effectiveParameterClauses).getOrElse(Seq.empty)	Seq[ScParameterClause]	effectiveParamClauses
k.namedElement	PsiNamedElement	element
ic.stdType match { case Long => Long case _ => Int }	ValType	ret
cc.typeParameters.isEmpty && effectiveParamClauses.size == 1	Boolean	extendsFunction
clazz	ProjectContext	ctx
clazz match { case _: ScTrait => Trait case _: ScClass => Class case _: ScObject => Object case _: ScNewTemplateDefinition => NewTd case synthetic: ScSyntheticClass => synthetic.className match { case "AnyRef" | "AnyVal" => Class case _ => SyntheticFinal } case _ => NonScala }	ScTemplateDefinitionImpl.Kind	kind
for { clause <- effectiveParamClauses param <- clause.parameters } yield paramTypeText(param, defaultTypeText = NothingCanonical)	IndexedSeq[Any]	paramTypes
clazz match { case td: ScTypeDefinition => td.`type`().getOrElse(default) case _ => default }	ScType	classType
ctp.resolve().asInstanceOf[PsiClass]	PsiClass	cl
{ clazz match { case td: ScTemplateDefinition => td.superTypes case clazz: PsiClass => clazz.getSuperTypes.map { case ctp: PsiClassType => //noinspection ScalaRedundantCast val cl = ctp.resolve().asInstanceOf[PsiClass] if (cl != null && cl.qualifiedName == "java.lang.Object") ScDesignatorType(cl) else ctp.toScType() case ctp => ctp.toScType() }.toSeq } }	Seq[ScType]	supers
ic1.projectContext.stdTypes	StdTypes	stdTypes
new ScSyntheticClass(name, t) { override def getQualifiedName = "scala." + name }	ScSyntheticClass { def getQualifiedName: Any }	clazz
compound.components	Seq[ScType]	comps
Option(lastParent)	Option[PsiElement]	maybeElement
if (addTp) Some(compound) else None	Option[ScCompoundType]	classType
new ListBuffer[ScType]	ListBuffer[ScType]	buffer
findClass(qName, scope)	PsiClass	c
new mutable.HashSet	mutable.HashSet[String]	set
syntheticObjects.get(qName).orNull	ScObject	obj
"==" :: "!=" :: "<" :: ">" :: "<=" :: ">=" :: Nil	List[B]	numeric_comp_ops
param.typeElement.fold(defaultTypeText)(_.getText)	String	typeText
buffer.indexWhere(_.extractClass match { case Some(newClazz) if ScEquivalenceUtil.areClassesEquivalent(newClazz, clazz) => true case _ => false } )	Int	i
"+" :: "-" :: "*" :: "/" :: "%" :: Nil	List[B]	numeric_arith_ops
defaultParamString(p)	String	defaultExpr
buffer.apply(i)	ScType	newTp
"+" :: "-" :: Nil	List[B]	numeric_arith_unary_ops
supers.iterator	Iterator[ScType]	iterator
iterator.next()	ScType	tp
"&&" :: "||" :: "&" :: "|" :: "==" :: "!=" :: "^" :: Nil	List[B]	bool_bin_ops
byStubOrPsi(_.parentTypeElements ++ syntheticTypeElements) { allTypeElements }	IndexedSeq[ScTypeElement]	elements
"&" :: "|" :: "^" :: Nil	List[B]	bitwise_bin_ops
elements.iterator	Iterator[ScTypeElement]	iterator
"<<" :: ">>" :: ">>>" :: Nil	List[B]	bitwise_shift_ops
reusableId(this)	Long	typeParamId
maybeElement.toSeq flatMap { case definition: ScPatternDefinition => definition.bindings case definition: ScVariableDefinition => definition.bindings case _ => Seq.empty } map { processor.execute(_, state) } forall { result => result }	Boolean	processed
pClause.typeParameters	Seq[ScTypeParam]	tParams
clause.parameters.map(paramText).commaSeparated()	String	paramsText
caseClass.name	String	className
linearization(clazz)	Seq[ScType]	lin
lin.reverseIterator	Iterator[ScType]	newIterator
newIterator.next()	ScType	tp
clauses.iterator	Iterator[ScParameterClause]	clausesIterator
clausesIterator.next()	ScParameterClause	clause
clause.parameters.iterator	Iterator[ScParameter]	paramsIterator
paramsIterator.next()	ScParameter	param
linearization(c, addTp = true)	Seq[ScType]	lin
c.constructor .exists(_.effectiveFirstParameterSection.contains(this))	Boolean	isInPrimaryConstructorFirstParamSection
owner match { case m: ScMethodLike => m.getNavigationElement match { case `m` => None case other: ScMethodLike => other.effectiveParameterClauses .flatMap(_.effectiveParameters) .find(_.name == name) case _ => None } case _ => None }	Option[ScParameter]	maybeResult
originalClass.asInstanceOf[ScClass]	ScClass	c
c.parameters.iterator	Iterator[ScClassParameter]	iterator
iterator.next()	ScClassParameter	param
createClauseFromText()	ScParameterClause	clause
clause.addParameter(param)	ScParameterClause	newClause
clauses.getParent match { case f: ScFunction => Some((f, false)) case p: ScPrimaryConstructor => p.containingClass match { case c: ScClass => Some((c, true)) case _ => None } case _ => None }	Option[(ScMember.WithBaseIconProvider with ScTypeParametersOwner with ScParameterOwner with ScDocCommentOwner with ScNamedElement with Typeable with ScCommentOwner with PsiTypeParametersOwnerAdapter with PomRenameableTarget[PsiElement] with PsiTarget, Boolean)]	maybeOwner
getGreenStub	ScFunctionStub[F]	stub
getParent match { case clauses: ScParameters => val maybeOwner = clauses.getParent match { case f: ScFunction => Some((f, false)) case p: ScPrimaryConstructor => p.containingClass match { case c: ScClass => Some((c, true)) case _ => None } case _ => None } maybeOwner.flatMap { case (owner, isClassParameter) => ScalaPsiUtil.syntheticParamClause(owner, clauses, isClassParameter)(hasImplicit = false) } case _ => None }	Option[ScParameterClause]	maybeSyntheticClause
s"Both stub and name identifier node are null for ${getClass.getSimpleName} \n$getText"	String	message
maybeSyntheticClause.toSeq.flatMap(_.parameters)	IndexedSeq[ScParameter]	syntheticParameters
baseCompanionModule.toSeq.flatMap { case o: ScObject => o.membersWithSynthetic.flatMap { case o: ScObject => Seq(o) ++ o.fakeCompanionClass case t: ScTrait => Seq(t, t.fakeCompanionClass) case c: ScClass => Seq(c) case _ => Seq.empty } case _ => Seq.empty }	IndexedSeq[PsiClass]	inCompanionModule
asFunctionParameters(clauseWithDefault, defaultParamString = p => " = " + className + ".this." + p.name) + asFunctionParameters(restClauses, defaultExpressionString)	String	paramString
typeParamsString(caseClass.typeParameters)	String	typeParamsDefinition
className + typeArgsFromTypeParams(caseClass)	String	returnType
parameters	Seq[ScParameter]	params
if (params.isEmpty) false else params.last.isRepeatedParameter	Boolean	vararg
if (vararg) params.last.getNode else getLastChild.getNode	ASTNode	rParen
declaredNames	Seq[String]	names
`type`().getOrAny match { case FunctionType(rt, _) => rt case tp => tp }	ScType	resultType
if (isConstructor) { containingClass match { case owner: ScTypeParametersOwner => Some(owner) case _ => None } } else Some(this)	Option[ScNamedElement with PsiDocCommentOwner with PsiTypeParametersOwnerAdapter with PsiTarget with PomRenameableTarget[PsiElement] with Typeable with ScTypeParametersOwner]	maybeOwner
new ArrayBuffer[ScFunctionWrapper]	ArrayBuffer[ScFunctionWrapper]	buffer
superMethods	Seq[PsiMethod]	s
Right(tp)	result.TypeResult	res
effectiveParameterClauses	Seq[ScParameterClause]	paramClauses
paramClauses.length - 1	Int	i
paramClauses.apply(i).effectiveParameters	Seq[ScParameter]	parameters
parent.stubOrPsiChildren(FUNCTION_DEFINITION, ScFunctionDefinitionFactory).iterator	Iterator[ScFunctionDefinition]	children
children.next()	ScFunctionDefinition	nextFun
returnTypeInner(nextFun)	result.TypeResult	nextReturnType
Key.create("calculating.function.returns.block")	Key[Any]	calculatingBlockKey
buf.filter(isSimilarMemberForNavigation(_, strictCheck = true))	ArrayBuffer[ScMember]	filter
parse(format.replace("%e", Placeholder))	ScalaFile	file
element match { case cp: ScClassParameter => classParameterScope(cp) case p: ScParameter => Option(parameterScope(p)) case n: ScNamedElement => namedScope(n) case m: ScMember => memberScope(m) case _ => None }	Option[SearchScope]	narrowScope
EditSourceUtil.getDescriptor(nameId)	Navigatable	descriptor
file.depthFirst(_.getText != Placeholder).filter(_.getText == Placeholder).toVector	Vector[PsiElement]	placeholders
new mutable.ArrayBuffer[util.Map[_ <: Any, _ <: Any]]()	ArrayBuffer[Any]	clearCacheOnChange
processor match { case r: ResolveProcessor => r.getResolveScope case _ => place.resolveScope }	GlobalSearchScope	scope
TypeDefinitionMembers.getSignatures(containingClass).forName(name).findNode(this)	Option[MixinNodes.Node[TermSignature]]	option
containingClass	ScTemplateDefinition	clazz
new mutable.ArrayBuffer[util.Map[_ <: Any, _ <: Any]]()	ArrayBuffer[Any]	clearCacheOnTopLevelChange
createIdentifier(name)	ASTNode	id
ScalaShortNamesCacheManager.getInstance(getProject).getClassNames(pack, scope)	Set[String]	namesSet
TypeDefinitionMembers.getSelfTypeSignatures(clazz).forName(name)	MixinNodes.AllNodes[TermSignature]	signs
new mutable.ArrayBuffer[util.Map[_ <: Any, _ <: Any]]()	ArrayBuffer[Any]	clearCacheOnRootsChange
new ImplicitCollectorCache(project)	ImplicitCollectorCache	implicitCollectorCache
ScalaNamesUtil.cleanFqn(inFqn)	String	fqn
element.containingScalaFile .filter(f => f.isWorksheetFile || f.isScriptFile) .map(safeLocalScope(_))	Option[LocalSearchScope]	scriptScope
getQualifiedName match { case fqn@"scala" => ElementScope(place.getProject, scope).getCachedObject(fqn) case _ => findPackageObject(scope) }	Option[ScObject]	maybeObject
newElement.copy	PsiElement	newElementCopy
obj.`type`().toOption.fold(state) { state.withFromType(_) }	ResolveState	newState
args.flatMap { case s: String => Seq(s) case i: Int => Seq(i.toString) case Some(s: String) => Seq(s) case Some(i: Int) => Seq(i.toString) case Some(_: PsiElement) => Seq("%e") case None => Seq.empty case @@(es, s) => Seq(Seq.fill(es.length)("%e").mkString(s)) case _ => Seq("%e") }	IndexedSeq[Any]	separators
clone.asInstanceOf[ScalaStubBasedElementImpl[_, _]]	ScalaStubBasedElementImpl[_, _]	stubbed
Option(cp.containingClass).map(_.getUseScope)	Option[SearchScope]	classScope
args.flatMap { case _: String | _: Int | None => Seq.empty case Some(_: String) => Seq.empty case Some(e: PsiElement) => Seq(e) case @@(es, _) => es case it => Seq(it) }	IndexedSeq[Any]	argumetns
member.containingClass	ScTemplateDefinition	containing
numeric_comp_ops.contains(name)	Boolean	isNumericComp
intersectOptions(byAccessModifier(cp), classScope)	Option[SearchScope]	asMember
numeric_arith_ops.contains(name)	Boolean	isArithOp
safeLocalScope(typeDefinition)	LocalSearchScope	scope
bitwise_bin_ops.contains(name)	Boolean	isBitwiseOp
interleave(parts, separators).mkString	String	s
new Context(identity, identity)	ScalaCode.Context	Block
bitwise_shift_ops.contains(name)	Boolean	isBitwiseShiftOp
new Context("val v: " + _, _.getLastChild.asInstanceOf[ScTypeElement])	ScalaCode.Context	Type
this.children.forall { case _: PsiWhiteSpace => true case _: PsiComment => true case _ => false }	Boolean	empty
interpolated.children.toList	List[PsiElement]	children
children.headOption	Option[PsiElement]	interpolatedPrefix
findLastChildByType[PsiElement](elementType) match { case null => null case element => getNextSiblingOfType(element, classOf[ScTypeElement]) }	Null	result
project	ProjectContext	context
getNode.getChildren(null).iterator	Iterator[ASTNode]	childrenIterator
childrenIterator.next()	ASTNode	node
this.metaExpand match { case Right(templ: Defn.Class) => Some(templ) case Right(templ: Defn.Trait) => Some(templ) case Right(templ: Defn.Object) => Some(templ) case Right(Term.Block(Seq(templ: Defn.Class, _))) => Some(templ) case Right(Term.Block(Seq(templ: Defn.Trait, _))) => Some(templ) case Right(Term.Block(Seq(templ: Defn.Object, _))) => Some(templ) case _ => None }	Option[Defn with Member]	defn
ScalaNamesUtil.escapeKeywordsFqn(inName)	String	name
NullPsiType	PsiType	_returnType
_	PsiTypeParameterList	_typeParameterList
_	PsiModifierList	_modifierList
_	PsiParameterList	_parameterList
_	PsiReferenceList	_throwsList
new LightTypeParameterListBuilder(myManager, getLanguage)	LightTypeParameterListBuilder	list
s.containingClass match { case null => s.syntheticContainingClass case clazz => clazz }	ScTemplateDefinition	res
JavaPsiFacade.getInstance(project).findClass(fqn, scope)	PsiClass	clazz
new ArrayBuffer[PsiMethod]()	ArrayBuffer[PsiMethod]	res
cClass.getOrElse { delegate.nameContext match { case s: ScMember => val res = s.containingClass match { case null => s.syntheticContainingClass case clazz => clazz } if (isStatic) { res match { case o: ScObject => o.fakeCompanionClassOrCompanionClass case _ => res } } else res case _ => null } }	PsiClass	result
toVector(name)	List[String]	vector
PsiDocumentManager.getInstance(getProject)	PsiDocumentManager	documentManager
ScalaShortNamesCacheManager.getInstance(project).getClassByFQName(fqn, scope)	PsiClass	res
documentManager.getDocument(this)	Document	document
NullPsiType	PsiType	computedType
_	PsiReferenceList	extendsList
isBeanProperty(holder)	Boolean	beanProperty
containingClass.definition	ScTemplateDefinition	originalTrait
new LightReferenceListBuilder(scTypeParam.getManager, PsiReferenceList.Role.EXTENDS_BOUNDS_LIST)	LightReferenceListBuilder	refList
new ScLightParameter("This", () => new PsiImmediateClassType(originalTrait, PsiSubstitutor.EMPTY), scope, isVarargs = false)	ScLightParameter	result
isBooleanBeanProperty(holder)	Boolean	booleanBeanProperty
ScalaShortNamesCacheManager.getInstance(project).getClassesByName(name, scope)	Iterable[PsiClass]	scalaClasses
PsiShortNamesCache.getInstance(project).getClassesByName(name, scope).filterNot(p => p.isInstanceOf[ScTemplateDefinition] || p.isInstanceOf[PsiClassWrapper] ).toBuffer	mutable.Buffer[PsiClass]	buffer
scalaClasses.iterator	Iterator[PsiClass]	classesIterator
classesIterator.next()	PsiClass	clazz
new LightReferenceListBuilder(holder.getManager, holder.getLanguage, PsiReferenceList.Role.THROWS_LIST)	LightReferenceListBuilder	refList
param.isRepeatedParameter && isJavaVarargs	Boolean	isVarargs
new ScLightParameter(escapeJavaKeywords(param.getName), () => javaParameterType(param, substitutor, isVarargs), param.owner, isVarargs)	ScLightParameter	result
if (isJavaVarargs) param.`type`() else param.getRealParameterType	result.TypeResult	paramType
params.freshTypeParamId(this)	Long	typeParamId
!isStatic && (isSyntheticMethodFromTrait || delegate.hasModifierProperty("override"))	Boolean	isOverride
delegate.isConstructor	Boolean	isConstructor
delegate.returnType.getOrAny	ScType	originalReturnType
annotation.constructorInvocation.typeArgList	Option[ScTypeArgs]	typeArgList
{ inJavaPsiFacade.set(true) try { JavaPsiFacade.getInstance(project).asInstanceOf[JavaPsiFacadeImpl].getClasses(pack, scope).filterNot(p => p.isInstanceOf[ScTemplateDefinition] || p.isInstanceOf[PsiClassWrapper] ) } finally { inJavaPsiFacade.set(false) } }	Array[PsiClass]	classes
`type`.toScType().canonicalText	String	typeText
ScalaShortNamesCacheManager.getInstance(project).getClasses(pack, scope)	Array[PsiClass]	scalaClasses
computeAnnotations()	Array[PsiAnnotation]	annotations
new THashSet[String]	THashSet[String]	set
annotHolder(scalaElement)	ScAnnotationsHolder	annotationsHolder
annotHolder(scalaElement)	ScAnnotationsHolder	annotationHolder
annotationHolder.annotations.filterNot { a => a.getQualifiedName match { case null => true case s if keywordAnnotations.keySet.contains(s) => true case s if Set("scala.throws", "scala.inline", "scala.unchecked").contains(s) => true case s if s.endsWith("BeanProperty") => true case _ => false } }	Seq[ScAnnotation]	convertibleAnnotations
Key.create("static.psi.method.wrapper.key")	Key[HashMap[PsiClass, (StaticPsiMethodWrapper, Long)]]	KEY
createMethodFromText(s"def foo$clauseText = null")	ScFunction	function
method.getUserData(KEY)	HashMap[PsiClass, (StaticPsiMethodWrapper, Long)]	data
TypeDefinitionMembers.getSignatures(getContainingClass) .forName(delegate.name) .findNode(delegate) .map(_.supers.map(_.info).filterBy[PhysicalMethodSignature])	Option[IndexedSeq[PhysicalMethodSignature]]	superSignatures
ScalaPsiManager.instance(method.getProject).TopLevelModificationTracker.getModificationCount	Long	count
convertArgs(a.constructorInvocation.args.toSeq.flatMap(_.exprs))	String	args
for { list <- Option(member.getModifierList) modifier <- list.accessModifier if modifier.isPrivate && !modifier.isUnqualifiedPrivateOrThis target <- resolve(modifier.getReference).orElse { modifier.parentOfType(classOf[ScTypeDefinition]) } } yield target	Option[PsiNamedElement]	maybeTarget
convertibleAnnotations.map { a => val fqn = a.getQualifiedName val args = convertArgs(a.constructorInvocation.args.toSeq.flatMap(_.exprs)) s"@$fqn$args" }	IndexedSeq[String]	annotationTexts
JavaPsiFacade.getInstance(project).findClasses(fqn, new DelegatingGlobalSearchScope(scope) { override def compare(file1: VirtualFile, file2: VirtualFile): Int = 0 }).filterNot { p => p.isInstanceOf[ScTemplateDefinition] || p.isInstanceOf[PsiClassWrapper] }	Array[PsiClass]	classes
if (isOverride) Seq("@" + CommonClassNames.JAVA_LANG_OVERRIDE) else Seq.empty	Seq[Nothing]	overrideAnnotation
PsiElementFactory.SERVICE.getInstance(annotationHolder.getProject)	PsiElementFactory	factory
data.getOrElse(containingClass, null)	(StaticPsiMethodWrapper, Long)	res
elementConstructor(getPsi, null)	C	result
getCachedFacadeClasses(scope, ScalaNamesUtil.cleanFqn(fqn))	Array[PsiClass]	classes
call.arguments	Seq[ScTypeElement]	arguments
arguments.head.`type`()	result.TypeResult	typeResult
new ScTypeElementOwnerStubImpl[E](lowerBoundText, this)	ScTypeElementOwnerStubImpl[E]	lowerBoundStub
new ScTypeElementOwnerStubImpl[E](upperBoundText, this)	ScTypeElementOwnerStubImpl[E]	upperBoundStub
Map( "scala.native" -> "native", "scala.annotation.strictfp" -> "strictfp", "scala.volatile" -> "volatile", "scala.transient" -> "transient")	Map[String, String]	keywordAnnotations
ScalaShortNamesCacheManager.getInstance(project).getClassesByFQName(fqn, scope)	Seq[PsiClass]	fromScala
PropertyMethods.methodName(delegate.name, role)	String	name
ScLightParameter.fromThis(containingClass, delegate)	PsiParameter	thisParam
toVector(base) :: splitsIn(pathIn(this))	List[List[String]]	splits
ScalaNamesUtil.cleanFqn(psiPackage.getQualifiedName)	String	key
_	SofterReference[Option[ScAnnotationExpr]]	annotationExprRef
null	SofterReference[Option[ScExpression]]	expressionElementReference
null	SofterReference[Option[ScStableCodeReference]]	referenceReference
{ val splits = toVector(base) :: splitsIn(pathIn(this)) splits.foldLeft(List(vector))(splitAt) }	List[List[String]]	path
null	SofterReference[Seq[ScTypeElement]]	viewElementsReferences
TypeDefinitionMembers.getSignatures(getContainingClass) .forName(name) .findNode(delegate) .map(_.supers.map(_.info))	Option[IndexedSeq[TermSignature]]	superSignatures
t.name	String	scalaName
null	SofterReference[Seq[ScTypeElement]]	contextElementsReferences
createMethodFromText(s"def foo($paramText) = null")	ScFunction	function
null	SofterReference[Option[ScTypeElement]]	typeElementReference
JAVA_CLASS_NAME_IN_PACKAGE_KEY.elements(key, scope, classOf[PsiClass]).toSet	Set[PsiClass]	classes
{ val path = { val splits = toVector(base) :: splitsIn(pathIn(this)) splits.foldLeft(List(vector))(splitAt) } path.map(_.mkString("package ", ".", "")).mkString("", "\n", "\n\n") }	String	packagingsText
methodRole(nodeName, scalaName)	Option[PropertyMethods.DefinitionRole]	roleByName
this.typeDefinitions	Seq[ScTypeDefinition]	data
ScalaPsiElementFactory.createAnAnnotation(annotationText)(getProject)	ScAnnotation	annotation
annotation.annotationExpr	ScAnnotationExpr	annotationExpr
staticTrait.map(ScLightParameter.fromThis(_, td))	Option[PsiParameter]	thisParam
if (!isSetter(role)) None else Some(new ScLightParameter(td.getName, () => typeFor(td, SIMPLE_ROLE).toPsiType, td))	Option[ScLightParameter]	setterParam
clazz.name	String	name
StubIndex.getInstance	StubIndex	stubIndex
new CollectMembersProcessor	ImplicitIndex.this.CollectMembersProcessor	collectProcessor
createScalaFileFromText(s"($paramText) =>").getFirstChild.asInstanceOf[ScFunctionExpr]	ScFunctionExpr	function
new ArrayBuffer[ScTemplateDefinition]	ArrayBuffer[ScTemplateDefinition]	inheritors
classes.flatMap { case definition: ScTypeDefinition => definition.additionalClassJavaName case _ => None }	IndexedSeq[String]	additionalClasses
createIndexKey[String, PsiClass]("sc.all.class.names")	StubIndexKey[String, PsiClass]	ALL_CLASS_NAMES
p.getTextOffset	Int	startOffset
null	SofterReference[(Option[ScConstructorInvocation], Seq[ScTypeElement])]	constructorAndParentTypeElementsReference
createIndexKey[String, PsiClass]("sc.class.shortName")	StubIndexKey[String, PsiClass]	SHORT_NAME_KEY
startOffset + p.getTextLength	Int	endOffset
PsiUtilCore.getVirtualFile(this)	VirtualFile	faultyContainer
this.typeDefinitions	Seq[ScTypeDefinition]	definitions
mutable.ArrayBuffer.empty[PsiClass]	ArrayBuffer[PsiClass]	arrayBuffer
ScalaIndexKeys.IMPLICIT_INSTANCE_KEY	StubIndexKey[String, ScMember]	indexKey
createIndexKey[String, PsiClass]("sc.not.visible.in.java.class.shortName")	StubIndexKey[String, PsiClass]	NOT_VISIBLE_IN_JAVA_SHORT_NAME_KEY
createIndexKey[Integer, PsiClass]("sc.class.fqn")	StubIndexKey[Any, PsiClass]	FQN_KEY
createIndexKey[Integer, PsiClass]("sc.package.object.fqn")	StubIndexKey[Any, PsiClass]	PACKAGE_OBJECT_KEY
createIndexKey[String, PsiClass]("sc.package.object.short")	StubIndexKey[String, PsiClass]	PACKAGE_OBJECT_SHORT_NAME_KEY
createIndexKey[Integer, ScPackaging]("sc.package.fqn")	StubIndexKey[Any, ScPackaging]	PACKAGE_FQN_KEY
IMPLICIT_CONVERSION_KEY	StubIndexKey[String, ScMember]	indexKey
createIndexKey[String, ScFunction]("sc.method.name")	StubIndexKey[String, ScFunction]	METHOD_NAME_KEY
"implicit_conversion"	String	dummyStringKey
createIndexKey[String, PsiClass]("sc.class.name.in.package")	StubIndexKey[String, PsiClass]	CLASS_NAME_IN_PACKAGE_KEY
createIndexKey[String, PsiClass]("sc.java.class.name.in.package")	StubIndexKey[String, PsiClass]	JAVA_CLASS_NAME_IN_PACKAGE_KEY
createIndexKey[String, ScObject]("sc.implcit.object")	StubIndexKey[String, ScObject]	IMPLICIT_OBJECT_KEY
createIndexKey[String, ScAnnotation]("sc.annotatde.member.name")	StubIndexKey[String, ScAnnotation]	ANNOTATED_MEMBER_KEY
parameter.typeElement.map { _.getText }	Option[Nothing]	typeText
parameter.getActualDefaultExpression.map { _.getText }	Option[Nothing]	defaultExprText
t.membersWithSynthetic	Seq[ScMember]	members
createIndexKey[String, ScValueOrVariable]("sc.property.name")	StubIndexKey[String, ScValueOrVariable]	PROPERTY_NAME_KEY
createIndexKey[String, ScClassParameter]("sc.class.parameter.name")	StubIndexKey[String, ScClassParameter]	CLASS_PARAMETER_NAME_KEY
createIndexKey[String, ScTypeAlias]("sc.type.alias.name")	StubIndexKey[String, ScTypeAlias]	TYPE_ALIAS_NAME_KEY
definition :: (definition match { case o: ScObject => o.fakeCompanionClass.toList case t: ScTrait => t.fakeCompanionClass :: t.fakeCompanionModule.toList case c: ScClass => c.fakeCompanionModule.toList case _ => Nil })	List[PsiClass]	toAdd
createIndexKey[String, ScTypeAlias]("sc.stable.alias.name")	StubIndexKey[String, ScTypeAlias]	STABLE_ALIAS_NAME_KEY
typeParameter.getExtendsListTypes ++ typeParameter.getImplementsListTypes	IndexedSeq[PsiClassType]	types
new SimpleModificationTracker	SimpleModificationTracker	NonScalaModificationTracker
constructorText.flatMap { text => Option(createConstructorFromText(text, context, child)) }	Option[ScConstructorInvocation]	constructor
createIndexKey[Integer, ScTypeAlias]("sc.stable.alias.fqn")	StubIndexKey[Any, ScTypeAlias]	STABLE_ALIAS_FQN_KEY
createIndexKey[String, ScExtendsBlock]("sc.super.class.name")	StubIndexKey[String, ScExtendsBlock]	SUPER_CLASS_NAME_KEY
PsiManager.getInstance(project).getModificationTracker.asInstanceOf[PsiModificationTrackerImpl]	PsiModificationTrackerImpl	psiModTracker
new SimpleModificationTracker { private val psiModTracker = PsiManager.getInstance(project).getModificationTracker.asInstanceOf[PsiModificationTrackerImpl] override def getModificationCount: Long = super.getModificationCount + NonScalaModificationTracker.getModificationCount override def incModificationCount(): Unit = { psiModTracker.incCounter() //update javaStructureModCount on top-level scala change super.incModificationCount() } }	SimpleModificationTracker	TopLevelModificationTracker
createIndexKey[String, ScSelfTypeElement]("sc.self.type.class.name.key")	StubIndexKey[String, ScSelfTypeElement]	SELF_TYPE_CLASS_NAME_KEY
createIndexKey[String, ScMember]("sc.implicit.conversion")	StubIndexKey[String, ScMember]	IMPLICIT_CONVERSION_KEY
createIndexKey[String, ScMember]("sc.implicit.instance")	StubIndexKey[String, ScMember]	IMPLICIT_INSTANCE_KEY
ProjectRootManager.getInstance(project)	ModificationTracker	rootManager
definition :: (definition match { case _: ScClass => Nil case scalaObject: ScObject => scalaObject.fakeCompanionClass.toList case scalaTrait: ScTrait => scalaTrait.fakeCompanionClass :: Nil })	List[PsiClass]	classes
function.returnTypeElement	Option[ScTypeElement]	returnTypeElement
returnTypeElement.map(_.getText)	Option[Nothing]	returnTypeText
0L	Long	topLevelModCount
file.getFileType	FileType	fileType
createMethodFromText(s"def foo[$name]() = {}")	ScFunction	function
caseClauses.mkString("{ ", "\n", " }")	String	clausesText
parentTypesTexts.toSeq.map { createTypeElementFromText(_, context, child) }	IndexedSeq[ScTypeElement]	parentTypeElems
event.getParent	PsiElement	parent
if (event.getNewChild.getClass == event.getOldChild.getClass) event.getNewChild else parent	PsiElement	changedElement
Key.create("type.variable.key")	Key[TypeParameterType]	TYPE_VARIABLE_KEY
SUPER_CLASS_NAME_KEY.elements(name, scope, classOf[ScExtendsBlock])(clazz.getProject) .iterator	Iterator[ScExtendsBlock]	extendsBlocks
extendsBlocks.next	ScExtendsBlock	extendsBlock
s"""@$name |def foo""".stripMargin	String	text
function.asOptionOf[ScFunctionDefinition]	Option[ScFunctionDefinition]	maybeDefinition
stub.parentPackageName	String	prefix
createScalaFileFromText(text)	ScalaFile	dummyFile
stub.packageName	String	ownNamePart
ScalaPsiManager.instance(project)	ScalaPsiManager	manager
new ScalaPsiManager()(project)	ScalaPsiManager	manager
clazz.resolveScope	GlobalSearchScope	resolveScope
Option(alias)	Option[ScTypeAlias]	maybeAlias
returnTypeText match { case Some(_) => None case None => maybeDefinition.flatMap(_.body) .map(_.getText) }	Option[Nothing]	bodyText
inheritedClazz.name	String	name
maybeAlias.collect { case definition: ScTypeAliasDefinition => definition }.flatMap { _.aliasedTypeElement }.map { _.getText }	Option[Nothing]	aliasedTypeText
maybeAlias.collect { case declaration: ScTypeAliasDeclaration => declaration }	Option[ScTypeAliasDeclaration]	maybeDeclaration
maybeDeclaration.flatMap { _.lowerTypeElement }.map { _.getText }	Option[Nothing]	lowerBoundText
maybeDeclaration.flatMap { _.upperTypeElement }.map { _.getText }	Option[Nothing]	upperBoundText
maybeAlias.map(_.containingClass)	Option[ScTemplateDefinition]	maybeContainingClass
directInheritorCandidates(clazz, clazz.resolveScope).filter(_.isInheritor(td, false))	Seq[ScTemplateDefinition]	directInheritors
typeParam.lowerTypeElement .map(_.getText)	Option[Nothing]	lowerBoundText
typeParam.upperTypeElement .map(_.getText)	Option[Nothing]	upperBoundText
allInheritorObjects(clazz)	Set[ScObject]	allObjects
ScalaNamesUtil.cleanFqn(name)	String	cleanName
expr.reference.map { _.getText }	Option[Nothing]	referenceText
maybeContainingClass.collect { case obj: ScObject if ScalaPsiUtil.hasStablePath(alias) => obj.qualifiedName + "." + alias.name }	Option[String]	stableQualifier
foldStub(findChildrenByClassScala(classOf[ScTypeDefinition])) { _.getChildrenByType(TYPE_DEFINITIONS, JavaArrayFactoryUtil.ScTypeDefinitionFactory) }	Array[ScTypeDefinition]	typeDefinitions
false	Boolean	allowsForwardReferences
parents.typeElements	Seq[ScTypeElement]	parentElements
`type` match { case null => "" case tp if isPresentableText => tp.presentableText case tp => tp.canonicalText }	String	typeText
false	Boolean	duringMoveRefactoring
Array("Object")	Array[String]	defaultParents
selector.reference.map { _.getText }	Option[Nothing]	referenceText
defaultParents :+ "Product" :+ "Serializable"	Array[String]	caseClassDefaults
typeElement.typeElement.map(_.getText)	Option[Nothing]	typeElementText
element match { case typedDefinition: ScTypedDefinition => typedDefinition.isStable case _ => false }	Boolean	isSingleton
true	Boolean	isSingleton
false	Boolean	static
result match { case block: ScBlock if !block.hasRBrace && block.statements.size != 1 => // see ScalaPsiElementFactory.createClassWithBody comment s"{\n${block.getText}\n}" case block@ScBlock(st) if !block.hasRBrace => stmtText(st) case _ => result.getText }	String	resultText
ta.typeParameters	Seq[ScTypeParam]	taArgs
s"scala.$name"	String	fullName
actualSubst	ScSubstitutor	subst
ta.typeParameters	Seq[ScTypeParam]	tParams
p.actualSubst.followed(ScSubstitutor(tp))	ScSubstitutor	newSubst
typeName match { case null | "" => name case _ => // throws an exception if type name is incorrect createTypeElementFromText(typeName) val space = if (isOpCharacter(name.last)) " " else "" s"$name$space: $typeName" }	String	typedName
new Variance(2)	Variance	Bivariant
new Variance(1)	Variance	Covariant
new Variance(-1)	Variance	Contravariant
new Variance(0)	Variance	Invariant
SyntheticClasses.get(projectContext)	SyntheticClasses	classes
if (typeParameters.isEmpty) 0 else typeParameters.map(depth).max	Int	maxDepth
Variance.Bivariant	Variance	Bivariant
Variance.Covariant	Variance	Covariant
Variance.Contravariant	Variance	Contravariant
Variance.Invariant	Variance	Invariant
`type` match { case stdType: StdType => this == stdType case _ => `type`.extractClass match { case Some(_: ScObject) => false case Some(clazz) => clazz.qualifiedName match { case this.fullName => true case "java.lang.Object" if this == AnyRef => true case _ => false } case _ => false } }	Boolean	success
s"$modifiers${if (modifiers.isEmpty) "" else " "}${if (isVariable) kVAR else kVAL} $typedName = ${stmtText(body)}"	String	text
new StdType(Name.Any, None)	StdType	Any
new StdType(Name.AnyRef, Some(Any))	StdType	AnyRef
new StdType(Name.Null, Some(AnyRef)) { override def isFinalType = true }	StdType { def isFinalType: Boolean }	Null
new StdType(Name.Nothing, Some(Any)) { override def isFinalType = true }	StdType { def isFinalType: Boolean }	Nothing
new StdType(Name.Singleton, Some(AnyRef)) { override def isFinalType = true }	StdType { def isFinalType: Boolean }	Singleton
new StdType(Name.AnyVal, Some(Any))	StdType	AnyVal
new ValType(Name.Unit)	ValType	Unit
new ValType(Name.Boolean)	ValType	Boolean
new ValType(Name.Char)	ValType	Char
new ValType(Name.Byte)	ValType	Byte
new ValType(Name.Short)	ValType	Short
new ValType(Name.Int)	ValType	Int
new ValType(Name.Long)	ValType	Long
new ValType(Name.Float)	ValType	Float
new ValType(Name.Double)	ValType	Double
function.annotations .map(_.annotationExpr.constructorInvocation.typeElement) .asStrings { text => text.substring(text.lastIndexOf('.') + 1) }	Array[String]	annotations
ta.typeParameters .map(tp => ScExistentialArgument(tp.name + "$$", Nil, Nothing, Any)) .toList	List[ScExistentialArgument]	existentialArgs
definition.containingVirtualFile.map(_.getName).orNull	Null	fileName
Seq( Any, AnyRef, AnyVal, Unit, Boolean, Byte, Short, Int, Long, Char, Float, Double, Null, Nothing, Singleton ).map(st => (st.fullName, st)).toMap	Map[String, StdType]	QualNameToType
definition.getModifierList match { case null => Array.empty case list => list.getAnnotations }	Array[_ <: PsiAnnotation]	annotations
tParams.length == typeArgs.length && tParams.zip(typeArgs).forall { case (tParam: ScTypeParam, TypeParameterType.ofPsi(param)) if tParam.typeParamId == param.typeParamId => true case _ => false }	Boolean	sameParams
ScSubstitutor.bind(ta.typeParameters, existentialArgs)	ScSubstitutor	genericSubst
ScDesignatorType(element)	ScDesignatorType	des
RecursionManager.RecursionGuard[Key, ConstraintsResult](s"${typeSystem.name}.equivalence.guard")	RecursionManager.RecursionGuard[Equivalence.this.Key, ConstraintsResult]	guard
Map( JAVA_LANG_BOOLEAN -> Boolean, JAVA_LANG_BYTE -> Byte, JAVA_LANG_CHARACTER -> Char, JAVA_LANG_SHORT -> Short, JAVA_LANG_INTEGER -> Int, JAVA_LANG_LONG -> Long, JAVA_LANG_FLOAT -> Float, JAVA_LANG_DOUBLE -> Double )	Map[Nothing, Nothing]	fqnBoxedToScType
RecursionManager.RecursionGuard[Key, ConstraintsResult](s"${typeSystem.name}.conformance.guard")	RecursionManager.RecursionGuard[Conformance.this.Key, ConstraintsResult]	guard
annotations.exists { case annotation: ScAnnotation => val text = annotation.constructorInvocation.typeElement.getText text == "deprecated" || text == "scala.deprecated" case _ => false }	Boolean	isScalaDeprecated
ScTypePolymorphicType(target, tParams.map(TypeParameter.apply))	ScTypePolymorphicType	typeConsuctor
new DynamicVariable(false)	DynamicVariable[Boolean]	eval
definition.containingClass == null && PsiTreeUtil.getParentOfType(definition, classOf[ScTemplateDefinition]) != null	Boolean	isLocal
conformsInner(Key(left, right, checkWeak), visited)	ConstraintsResult	result
this.typeParamId	Long	thisId
definition.parents.forall { case o: ScObject => !o.isPackageObject case _ => true }	Boolean	isVisibleInJava
Bivariant	Variance	result
actualSubst.followed(genericSubst)	ScSubstitutor	s
typeParameter.typeParamId	Long	name
equivInner(Key(left, right, falseUndef))	ConstraintsResult	result
Tracer("Conformance.conformsInner", "Conformance.conformsInner")	Tracer	tracer
designator.typeDepth	Int	result
0	Int	level
TypeParameter.light(s"`${p.name}.type`", Seq.empty, Nothing, Any)	TypeParameter	typeParameter
definition.hasModifierPropertyScala("implicit")	Boolean	isImplicit
definition.qualifiedName	String	qualifiedName
RecursionManager.markStack()	RecursionGuard.StackStamp	stackStamp
Tracer("Equivalence.equivInner", "Equivalence.equivInner")	Tracer	tracer
typeParameters.map(new TypeParameterType(_))	Seq[TypeParameterType]	arguments
eval.value	Boolean	nowEval
typeParameter.name	String	name
ScalaPsiManager.instance(typeParameter.getProject)	ScalaPsiManager	manager
ScalaNamesUtil.cleanFqn(stub.getName)	String	name
ScalaNamesUtil.cleanFqn(stub.javaName)	String	javaName
psiTypeParameter.typeParameters.map(ScalaTypeParameter)	Seq[TypeParameter]	typeParameters
createClassParamClausesWithContext(clauseText, parameter).params	Seq[ScParameter]	classParameters
stub.additionalJavaName	Option[String]	additionalNames
Seq.empty	Seq[TypeParameter]	typeParameters
if (nowEval) NullSafe.empty else eval.withValue(true) { NullSafe(cache.get(key)) }	NullSafe[Null]	fromCache
member.findFirstChildByType(fromToken).getStartOffsetInParent	Int	offset
ScalaNamesUtil.cleanFqn(stub.javaQualifiedName)	String	javaFqn
new DummyLightTypeParam(name)(lowerType.projectContext)	PsiTypeParameter	psiTypeParameter
{ def fromClazz(definition: ScTypeDefinition): PsiElement = definition.extendsBlock.templateBody .flatMap(_.lastChildStub) .getOrElse(definition.extendsBlock) projected.tryExtractDesignatorSingleton.extractClass match { case Some(definition: ScTypeDefinition) => fromClazz(definition) case _ => projected match { case ScThisType(definition: ScTypeDefinition) => fromClazz(definition) case _ => element } } }	PsiElement	resolvePlace
javaFqn.lastIndexOf(".")	Int	i
std.projectContext.stdTypes	StdTypes	stdTypes
try { NullSafe(equivComputable(key).compute()) } finally { tracer.calculationEnd() }	NullSafe[ConstraintsResult]	result
NullSafe(conformsComputable(key, visited).compute())	NullSafe[ConstraintsResult]	result
Option(typeName).filter { _.nonEmpty }.map { name => s": $name" }.getOrElse("")	String	typeText
factory.createType(psiClass, substitutor)	PsiClassType	psiType
new ResolveProcessor(kinds, resolvePlace, element.name) { override protected def addResults(results: Seq[ScalaResolveResult]): Boolean = { candidatesSet ++= results true } }	ResolveProcessor { def addResults(results: Seq[ScalaResolveResult]): Boolean }	processor
ScSubstitutor(projected)	ScSubstitutor	thisSubstitutor
s"$name$typeText = ${expr.getText}"	String	enumText
scParameter.`type`().getOrNothing	ScType	`type`
tp.canonicalText	String	canonicalText
projected match { case _: ScThisType => candidate.substitutor case _ => thisSubstitutor.followed(candidate.substitutor) }	ScSubstitutor	defaultSubstitutor
tp.presentableText	String	presentableText
s"for {\n i <- 1 to 239\n $enumText\n}"	String	text
parameter.paramType(extractVarargComponent = false)	ScType	`type`
element match { case _: PsiClass => element != candidateElement case _ => false }	Boolean	needSuperSubstitutor
`type` match { case that: TypeParameterType => (that.psiTypeParameter eq psiTypeParameter) || { (psiTypeParameter, that.psiTypeParameter) match { case (myBound: ScTypeParam, thatBound: ScTypeParam) => //TODO this is a temporary hack, so ignore substitutor for now myBound.lowerBound.exists(_.equiv(thatBound.lowerBound.getOrNothing)) && myBound.upperBound.exists(_.equiv(thatBound.upperBound.getOrNothing)) && (myBound.name == thatBound.name || thatBound.isHigherKindedTypeParameter || myBound.isHigherKindedTypeParameter) case _ => false } } case _ => false }	Boolean	success
0	Int	contraVariant
0	Int	coOrInVariant
subst(a.`type`().getOrAny)	ScType	tp
ScalaNamesUtil.cleanFqn(stub.getQualifiedName)	String	fqn
p.paramType.inferValueType	ValueType	inferredParamType
constraints	ConstraintSystem	lastConstraints
fqn.lastIndexOf(".")	Int	i
null	Option[AliasType]	aliasType
null	ScType	unpacked
s"val b = {\n${expression.getText}\n}"	String	definition
pt.isAliasType.get	AliasType	aliasType
m.result.equiv(result, lastConstraints, falseUndef)	ConstraintsResult	t
tp.equiv(r, constraints, falseUndef)	ConstraintsResult	resInner
s"val b = {$params=>\n$body\n}"	String	definition
`type`.projectContext	ProjectContext	context
ScDesignatorType(element)	ScDesignatorType	designatorType
new mutable.HashMap[PsiClass, ScType]	mutable.HashMap[PsiClass, ScType]	res
types.iterator	Iterator[ScType]	iterator
iterator.next()	ScType	t
s"""class a extends $superName { |}""".stripMargin	String	text
conforms(pt, ConstraintSystem.empty, checkWeak = true)	ConstraintsResult	conformanceResult
0	Int	index
_substitutions	Array[Update]	substitutions
createScalaFileFromText(text).typeDefinitions.head.extendsBlock	ScExtendsBlock	extendsBlock
typez match { case t: TypeParameterType => t.typeParamId case UndefinedType(t, _) => t.typeParamId case ScAbstractType(t, _, _) => t.typeParamId case _ => -1L }	Long	typeParamId
_fromIndex	Int	fromIndex
hasNonLeafSubstitutionsImpl	Boolean	hasNonLeafSubstitutions
if (hasRecursiveTypeParameters(tp.lowerType)) Nothing else tp.lowerType	ScType	lowerType
fromIndex	Int	idx
if (hasRecursiveTypeParameters(tp.upperType)) Any else tp.upperType	ScType	upperType
substitutions(fromIndex)	Update	currentUpdate
tp.equiv(this, constraints, falseUndef)	ConstraintsResult	resInner
ScSubstitutor(projected) followed actualSubst	ScSubstitutor	s
ScSubstitutor(p1) followed proj2.actualSubst	ScSubstitutor	s
if (isLazySubtype) visited + scType else visited	Set[ScType]	newVisited
actualSubst.followed(ScSubstitutor(projected))	ScSubstitutor	newSubst
-1	Int	hash
subtypeUpdater.updateSubtypes(scType, variance, ScSubstitutor(currentUpdate))(newVisited)	ScType	withCurrentUpdate
substitutions.length	Int	thisLength
other.substitutions.length	Int	otherLength
thisLength + otherLength	Int	newLength
all.get(c) match { case None => true case Some(ts) => !ts.exists(t.conforms(_)) }	Boolean	isBest
new Array[Update](newLength)	Array[Update]	newArray
4	Int	initialCapacity
RecursionManager.RecursionGuard[ScType, Nothing]("aliasProjectionGuard")	RecursionManager.RecursionGuard[ScType, Nothing]	guard
s.typeParams.map(updateTypeParameter(_, substitutor, Invariant))	IndexedSeq[TypeParameter]	tParams
element match { case p: ScClassParameter => Option(p.containingClass) case _ => element.getContext match { case _: ScTemplateBody | _: ScEarlyDefinitions => Option(ScalaPsiUtil.contextOfType(element, strict = true, classOf[ScTypeDefinition])) case _ => None } }	Option[ScTemplateDefinition]	clazzOpt
mutable.Set.empty[ScTypeAlias]	mutable.Set[ScTypeAlias]	visitedAliases
ScSubstitutor.bind(typeParameters)(UndefinedType(_))	ScSubstitutor	subst
mutable.Set.empty[ScType]	mutable.Set[ScType]	seenTypes
try innerUpdate(upper, visited + `type`) catch { case RecursionException => if (visited.nonEmpty) throw RecursionException else `type` }	ScType	updated
projType.actualSubst	ScSubstitutor	actualSubst
subst(retTpe).isConservativelyCompatible(pt)	ConstraintsResult	retTpeConformance
projType.actualElement	PsiNamedElement	actualElement
pf	PartialFunction[LeafType, ScType]	subst
guard.doPreventingRecursion(p) { td.upperBound.map(subst).toOption }	Option[Option[ScType]]	upper
new ScProjectionType(projected, element)	ScProjectionType	simple
{ case th: ScThisType if !hasRecursiveThisType(target, th.element) => doUpdateThisType(th, target) }	PartialFunction[LeafType, ScType]	subst
method.firstChild.collect { case comment: PsiDocComment => comment.getText }	Option[Nothing]	maybeCommentText
if (needSubstitutor) substitutor.followed(parameterizedType.substitutor) else ScSubstitutor.empty	ScSubstitutor	withFollower
s.substitutedTypes.map(_.map(f => () => substitutor.recursiveUpdateImpl(f(), variance, isLazySubtype = true)))	IndexedSeq[IndexedSeq[() => ScType]]	paramTypes
new TermSignature(s.name, paramTypes, tParams, s.substitutor.followed(substitutor), s.namedElement, s.hasRepeatedParam)	TermSignature	updSignature
params.map(_.paramType).foldLeft(Variance.Bivariant) { case (acc, tpe) => acc & tp.varianceInType(tpe) }	Variance	varianceInParams
ScalaPsiManager.instance(element.getProject)	ScalaPsiManager	manager
p.substitutor	ScSubstitutor	pSubst
new withActual(true)	ScProjectionType.withActual	extractor
true	Boolean	expandAliases
c match { case td: ScTemplateDefinition => td.superTypes case _ => c.getSuperTypes.toSeq.map(_.toScType()) }	Seq[ScType]	superTypes
method match { case function: ScFunction => function.annotations.map(_.getText) case _ => Seq.empty }	Seq[Nothing]	annotations
substitutor(st)	ScType	substed
if (lower) _ lub _ else _ glb _	(ScType, ScType) => ScType	combine
{ case a: ScAbstractType => updatedAbstract(a) case u: UndefinedType => updatedUndefined(u) case t: TypeParameterType => updatedTypeParameter(t) }	PartialFunction[LeafType, ScType]	subst
a.typeParameter	TypeParameter	typeParameter
ct.signatureMap.map { case (s: TermSignature, tp) => val tParams = s.typeParams.map(updateTypeParameter(_, substitutor, Invariant)) val paramTypes = s.substitutedTypes.map(_.map(f => () => substitutor.recursiveUpdateImpl(f(), variance, isLazySubtype = true))) val updSignature = new TermSignature(s.name, paramTypes, tParams, s.substitutor.followed(substitutor), s.namedElement, s.hasRepeatedParam) (updSignature, substitutor.recursiveUpdateImpl(tp, Covariant)) }	IndexedSeq[(TermSignature, ScType)]	updSignatureMap
ta.typeParams.map(updateTypeParameter(_, substitutor))	Seq[TypeParameter]	substTps
u.typeParameter	TypeParameter	typeParameter
substitutor.recursiveUpdateImpl(ta.lowerBound)	ScType	substLower
{ case d @ ScDesignatorType(p: ScParameter) => substitutedType(p).getOrElse(d) }	PartialFunction[LeafType, ScType]	subst
substitutor.recursiveUpdateImpl(ta.upperBound)	ScType	substUpper
typeParamsLike.iterator	Iterator[T]	iterator1
ta.substitutor.followed(substitutor)	ScSubstitutor	combinedSubstitutor
types.iterator	Iterator[S]	iterator2
initial	LongMap[ScType]	result
params.indexWhere(_.paramInCode.contains(parameter))	Int	idx
if (lower) lowerMap else upperMap	LongMap[ScType]	map
ScSubstitutor.bind(ta.typeParameters, args)	ScSubstitutor	genericSubst
exprs.lift(idx)	Option[Compatibility.Expression]	expr
createMethodFromSignature(signature, body, withComment, withAnnotation)	ScFunction	function
if (lower) tp.lowerType else tp.upperType	ScType	original
if (useExpected) params.lift(idx).map(_.expectedType) else None	Option[ScType]	expectedType
fromParams.indexOf(parameter)	Int	idx
TypeParamSubstitution.buildMap(from, target, old.tvMap)(TypeParameterType(_))	LongMap[ScType]	newMap
substitutions.clone()	Array[Update]	cloned
(lower: Boolean) => { val combine: (ScType, ScType) => ScType = if (lower) _ lub _ else _ glb _ val map = if (lower) lowerMap else upperMap val original = if (lower) tp.lowerType else tp.upperType map.get(tp.typeParamId) match { case Some(b) => combine(b, original) case None => original } }	Boolean => ScType	bound
if (hasRecursiveTypeParameters(tp.lowerType)) Nothing else bound(true)	ScType	loBound
if (hasRecursiveTypeParameters(tp.upperType)) Any else bound(false)	ScType	hiBound
getOverrideImplementTypeSign(alias, substitutor, needsOverrideModifier)	String	typeSign
substitutions.mkString(" >> ")	String	text
Logger.getInstance("#org.jetbrains.plugins.scala.lang.psi.types.recursiveUpdate.ScSubstitutor")	Logger	LOG
new ScSubstitutor(Array.empty)	ScSubstitutor	empty
800	Int	followLimit
false	Boolean	cacheSubstitutions
loBound.equiv(Nothing)	Boolean	emptyLoBound
LongMap.empty	LongMap[ScType]	cache
ct.typesMap.map { case (s, ta) => val substTps: Seq[TypeParameter] = ta.typeParams.map(updateTypeParameter(_, substitutor)) val substLower: ScType = substitutor.recursiveUpdateImpl(ta.lowerBound) val substUpper: ScType = substitutor.recursiveUpdateImpl(ta.upperBound) val combinedSubstitutor: ScSubstitutor = ta.substitutor.followed(substitutor) (s, TypeAliasSignature(ta.typeAlias, ta.name, substTps, substLower, substUpper, ta.isDefinition, combinedSubstitutor)) }	IndexedSeq[(String, TypeAliasSignature)]	updatedTypes
hiBound.equiv(Any)	Boolean	emptyHiBound
Seq(clazz1, clazz2)	Seq[PsiClass]	classes
TypeParamSubstitution.buildMap(typeParamsLike, typeParamsLike)(toScType)	LongMap[ScType]	tvMap
internalType match { case mt: ScMethodType if mt.isImplicit => mt.copy(result = Any)(mt.elementScope) case _ => internalType }	ScType	forVarianceCheck
typez.head	ScType	res
TypeParamSubstitution.buildMap(typeParamsLike, targets)(toScType)	LongMap[ScType]	tvMap
ct.components.smartMap(substitutor.recursiveUpdateImpl(_, variance))	Seq[ScType]	updatedComponents
exType.quantified	ScType	quantified
tp.varianceInType(forVarianceCheck).isContravariant	Boolean	isContraVar
Logger.getInstance("#org.jetbrains.plugins.scala.lang.psi.types.Compatibility")	Logger	LOG
TypeParamSubstitution.buildMap(typeParamsLike, types)(identity)	LongMap[ScType]	tvMap
widenRecursiveInner(oldDesignator, visited + parameterizedType)	ScType	newDesignator
substitutor.recursiveUpdateImpl(quantified, variance)	ScType	updatedQ
None	Option[PsiClass]	seqClass
pt.designator	ScType	designator
pt.typeArguments	Seq[ScType]	typeArguments
_	ScType	typez
ScalaNamesUtil.clean(_name)	String	name
_	PsiElement	place
ScalaNamesUtil.clean(namedElement.name)	String	name
place.elementScope	ElementScope	elementScope
typeParameters.map(_.typeParamId).toSet	Set[Long]	typeParamIds
getOverrideImplementVariableSign(variable, substitutor, if (withBody) Some("_") else None, needsOverrideModifier, isVal, needsInferType = true)	String	variableSign
typesEval.map(_.length).toArray	Array[Int]	paramClauseSizes
paramClauseSizes.arraySum	Int	paramLength
clazz1.isEffectivelyFinal || clazz2.isEffectivelyFinal	Boolean	oneFinal
!classes.exists(_.isInterface)	Boolean	twoNonTraitsOrInterfaces
definition.typeParameters .zip(typeArguments) .map { case (param, arg) if isSingleton(param) => arg case (_, arg) => widenRecursiveInner(arg, visited + parameterizedType) }	IndexedSeq[ScType]	newArgs
r.conforms(upper, constraints)	ConstraintsResult	conformsUpper
typeParameters(i).lowerType.equiv(p.typeParameters(i).lowerType, lastConstraints, falseUndef)	ConstraintsResult	t
typeParametersBound(lhsParams, rhsParams, boundKind.inverse, checkWeak)	Seq[TypeParameter]	newParams
if (!needVariance) Seq.empty else designator.extractDesignated(expandAliases = false) match { case Some(n: ScTypeParametersOwner) => n.typeParameters.map(_.variance) case _ => Seq.empty }	Seq[Variance]	typeParameterVariances
ScSubstitutor.bind(typeParameters, p.typeParameters)(TypeParameterType(_))	ScSubstitutor	subst
substitutor.recursiveUpdateImpl(designator, variance)	ScType	newDesignator
TypeParameter(tp.psiTypeParameter, tp.typeParameters, lower, upper)	TypeParameter	abstractTp
createOverrideImplementVariable(variable, substitutor, needsOverrideModifier, isVal, comment, withBody)	ScMember	member
if (i < typeParameterVariances.length) typeParameterVariances(i) else Invariant	Variance	v
ScSubstitutor.bind(lhsParams, newParams)(TypeParameterType(_))	ScSubstitutor	lhsSubst
typeArguments.smartMapWithIndex { case (ta, i) => val v = if (i < typeParameterVariances.length) typeParameterVariances(i) else Invariant substitutor.recursiveUpdateImpl(ta, v * variance) }	Seq[ScType]	newTypeArgs
pt.projected	ScType	projected
function.getModifierList.replace(fun.getModifierList)	PsiElement	res
false	Boolean	hasOverride
ScSubstitutor.bind(rhsParams, newParams)(TypeParameterType(_))	ScSubstitutor	rhsSubst
substitutor.recursiveUpdateImpl(projected, Covariant)	ScType	updatedType
ConstraintSystemImpl( LongMap.empty, LongMap.empty, Set.empty )	ConstraintSystem	empty
ScSubstitutor(tvMap)	ScSubstitutor	substitutor
simplify()	ScType	simplified
left.equivInner(right, empty, falseUndef)	ConstraintsResult	t
typeParam.typeParametersClause match { case None => "" case Some(x) => x.typeParameters.map(buildText).mkString("[", ",", "]") }	String	clauseText
FunctionType(expected, Seq(typez))	ValueType	functionType
typeParam.lowerBound.toOption.collect { case x if !x.isNothing => " >: " + substitutor(x).canonicalText }	Option[Any]	lowerBoundText
ps1.method.elementScope	ElementScope	elementScope
typeParam.upperBound.toOption.collect { case x if !x.isAny => " <: " + substitutor(x).canonicalText }	Option[Any]	upperBoundText
right.equivInner(left, empty, falseUndef)	ConstraintsResult	t
typeParam.viewBound.map { x => " <% " + substitutor(x).canonicalText }	IndexedSeq[Any]	viewBoundText
typeParam.contextBound.map { tp => " : " + refactoring.util.ScTypeUtil.stripTypeArgs(substitutor(tp)).canonicalText }	IndexedSeq[Any]	contextBoundText
new LeftConformanceVisitor(key, visited)	ScalaConformance.this.LeftConformanceVisitor	leftVisitor
ScSubstitutor.bind(typeParameter.typeParameters, args)	ScSubstitutor	subst
boundKind match { case BoundKind.Glb => glb(lhsSubst(lhsInt), rhsSubst(rhsInt), checkWeak) case BoundKind.Lub => lub(lhsSubst(lhsInt), rhsSubst(rhsInt), checkWeak) }	ScType	intTpe
subst(upperBound) match { case ParameterizedType(u, _) => ScExistentialType(ScParameterizedType(u, args)) case u => ScExistentialType(ScParameterizedType(u, args)) }	ScType	upper
ScalaPsiUtil.getPsiSubstitutor(ps1.substitutor)	PsiSubstitutor	psiSub1
ScalaPsiUtil.getPsiSubstitutor(ps2.substitutor)	PsiSubstitutor	psiSub2
expr.getTypeAfterImplicitConversion(checkImplicits, isShape, expectedOption)	ScExpression.ExpressionTypeResult	expressionTypeResult
r.conforms(upper, constraints)	ConstraintsResult	conformance
ps1.method.getSignature(psiSub1)	MethodSignature	psiSig1
subst(lowerBound) match { case ParameterizedType(l, _) => ScExistentialType(ScParameterizedType(l, args)) case l => ScExistentialType(ScParameterizedType(l, args)) }	ScType	lower
classes.forall{ case modOwner: ScModifierListOwner => modOwner.hasModifierProperty("sealed") case _ => false }	Boolean	areSealed
ps2.method.getSignature(psiSub2)	MethodSignature	psiSig2
depParamTypeSubstitutor(other)	ScSubstitutor	depParamTypeSubst
constraintsSet.filterNot { _.isEmpty }.flatMap { case impl: ConstraintSystemImpl => Set(impl) case MultiConstraintSystem(impls) => impls }	IndexedSeq[ConstraintSystemImpl]	flattened
classType.resolveGenerics	PsiClassType.ClassResolveResult	result
typeDepth(ts)	Int	td
other.substitutor.withBindings(typeParams, other.typeParams)	ScSubstitutor	unified
ScalaConformance.addParam(typeParameter, des, constraints)	ConstraintSystem	y
substitutedTypes.iterator	Iterator[Seq[() => ScType]]	clauseIterator
other.substitutedTypes.iterator	Iterator[Seq[() => ScType]]	otherClauseIterator
!areClassesEquivalent(clazz1, clazz2) && !(clazz1.isInheritor(clazz2, true) || clazz2.isInheritor(clazz1, true))	Boolean	areUnrelatedClasses
_	Option[ConstraintSystem.SubstitutionBounds]	substWithBounds
clauseIterator.next()	Seq[() => ScType]	clause1
otherClauseIterator.next()	Seq[() => ScType]	clause2
clause1.iterator	Iterator[() => ScType]	typesIterator
clause2.iterator	Iterator[() => ScType]	otherTypesIterator
_	Option[ConstraintSystem.SubstitutionBounds]	substWithBoundsNoSCE
typesIterator.next()	() => ScType	t1
otherTypesIterator.next()	() => ScType	t2
null	ScType	resTpe
unified.followed(depParamTypeSubst)(t1())	ScType	tp1
baseTypeSeqDepth(ts)	Int	bd
cls match { case td: ScTypeDefinition => td.superTypes.map(subst) case _ => cls.getSuperTypes.map( tpe => subst(tpe.toScType()(cls)) match { case exist: ScExistentialType => exist.quantified case other => other } ) }	Seq[ScType]	supers
unified(t2())	ScType	tp2
_tp match { case ex: ScExistentialType => ex.quantified case other => other }	ScType	tp
checkConformanceExt(checkNames, parameters, exprs, checkWithImplicits, isShapesResolve = false)	Compatibility.ConformanceExtResult	r
(lowerBoundText.toSeq ++ upperBoundText.toSeq ++ viewBoundText ++ contextBoundText).mkString	String	boundsText
pType.equivInner(rType, constraints, falseUndef)	ConstraintsResult	res
{ tp.extractClassType match { case None => tp.isAliasType match { case Some(AliasType(ta, _, _)) => Some(ta, ScSubstitutor.empty) case _ => None } case some => some } }	Option[(PsiNamedElement, ScSubstitutor)]	typeNamedElement
ArrayBuffer.empty[(PsiClass, ScSubstitutor)]	ArrayBuffer[(PsiClass, ScSubstitutor)]	toBeProcessed
tp2.equiv(tp1, lastConstraints, falseUndef)	ConstraintsResult	t
projectionOptionImpl(tp)	Option[ScType]	projectionOption
iterator.next()	B	next
c match { case o: ScObject => ScalaPsiUtil.getCompanionModule(o).getOrElse(o) case _ => c }	PsiClass	clazz
result.getSubstitutor	PsiSubstitutor	substitutor
this.projectionOption match { case Some(proj) => ScSubstitutor(proj) case None => ScSubstitutor.empty }	ScSubstitutor	subst
rawClassResult.getElement	PsiClass	clazz
substitutionBoundsImpl(canThrowSCE)	Option[ConstraintSystem.SubstitutionBounds]	value
tp.isAliasType.get.upper.getOrAny	ScType	upperType
from.effectiveParameterClauses.flatMap(_.effectiveParameters)	IndexedSeq[ScParameter]	fromParams
signatureMap.map { case (sign: TermSignature, tp: ScType) => tp.typeDepth .max(sign.typeParams.depth) } ++ typesMap.map { case (_: String, signature: TypeAliasSignature) => signature.lowerBound.typeDepth .max(signature.upperBound.typeDepth) .max(signature.typeParams.toArray.depth) }	IndexedSeq[Int]	depths
LongMap.empty[ScType]	LongMap[ScType]	tvMap
{ upperType match { case ScCompoundType(comps1, _, _) => comps1.map(new ClassLike(_)) case _ => Seq(new ClassLike(upperType)) } }	Seq[ScalaBounds.this.ClassLike]	classes
to.effectiveParameterClauses.flatMap(_.effectiveParameters)	IndexedSeq[ScParameter]	toParams
LongMap.empty[ScType]	LongMap[ScType]	lMap
for(Expression(assignment @ ScAssignment.Named(name)) <- exprs) yield (name, assignment)	IndexedSeq[(String, ScAssignment)]	pairs
new RawTypeParamToExistentialMapBuilder(rawClassResult, paramTopLevel).buildMap	Map[PsiTypeParameter, ScExistentialArgument]	map
parameterlessKind	Int	thisKind
LongMap.empty[ScType]	LongMap[ScType]	uMap
drv match { case td: ScTemplateDefinition => td.superTypes case _ => drv.getSuperTypes.map { _.toScType() } }	Seq[ScType]	superTypes
other.parameterlessKind	Int	otherKind
superTypes.iterator	Iterator[ScType]	iterator
1	Int	Parameterless
2	Int	EmptyParentheses
3	Int	ScalaVal
4	Int	JavaField
5	Int	HasParameters
iterator.next()	ScType	st
components.map(_.typeDepth)	IndexedSeq[Int]	ints
drainIteratorRecursively(supers.iterator)( superTpe => superTpe.extractClassType match { case Some((aClass, s)) if !visited.contains(aClass) => toBeProcessed += ((aClass, s)) process(aClass, superTpe) case _ => false } )	Boolean	inImmediateSupers
if (ints.isEmpty) 0 else ints.max	Int	componentsDepth
visited + id	Set[Long]	newVisited
pairs.map(_._1)	IndexedSeq[String]	names
typeAlias.name	String	name
typeAlias.typeParameters.map(TypeParameter(_))	Seq[TypeParameter]	typeParams
typeAlias.lowerBound.getOrNothing	ScType	lowerBound
names.diff(names.distinct)	IndexedSeq[String]	clashedNames
typeAlias.upperBound.getOrAny	ScType	upperBound
components.zip(r.components)	IndexedSeq[(ScType, ScType)]	list
typeAlias.isDefinition	Boolean	isDefinition
list.iterator	Iterator[(ScType, ScType)]	iterator
new ArrayBuffer[ApplicabilityProblem]()	ArrayBuffer[ApplicabilityProblem]	problems
ConstraintSystem.empty	ConstraintSystem	constraintAccumulator
SmartSuperTypeUtil.smartIsInheritor(rClass, subst, lClass)	Option[ScType]	inh
{ val newVisited = visited + id recursion(!solve(newVisited)(_) && canThrowSCE) _ }	Set[ScType] => Option[Boolean]	needTvMap
constructTypeForClass(clazz) { (tp, idx) => map.getOrElse(tp, TypeParameterType(tp)) }	ScType	quantified
clashedAssignmentsIn(exprs)	Seq[ScAssignment]	clashedAssignments
BaseTypes.iterator(right)	Iterator[ScType]	iterator
w1.equiv(w2, lastConstraints, falseUndef)	ConstraintsResult	t
signatureMap.iterator	Iterator[(TermSignature, ScType)]	iterator2
conformsInner(left, tp, visited, checkWeak = true)	ConstraintsResult	t
method.getParameterList match { case ps: ScParameters => ps.params.map(p => () => scalaParamType(p)) case p => p.getParameters.toSeq.map(p => () => javaParamType(p)) }	IndexedSeq[() => ScType]	lazyParamTypes
clashedAssignments.map(ParameterSpecifiedMultipleTimes)	IndexedSeq[ParameterSpecifiedMultipleTimes]	problems
lhs.lowerType	ScType	lo
parameters.exists(_.isRepeated)	Boolean	hasRepeated
ScSubstitutor.bind(names, existArgsBounds)(TypeParamId.nameBased)	ScSubstitutor	subst
if(hasRepeated) scala.Int.MaxValue else parameters.length	Int	maxParams
ex.simplify()	ScType	simplified
exprs.length - maxParams	Int	excess
t.equiv(t1, lastConstraints, falseUndef)	ConstraintsResult	f
typesMap	Map[String, TypeAliasSignature]	types1
r.typesMap	Map[String, TypeAliasSignature]	types2
types1.iterator	Iterator[(String, TypeAliasSignature)]	types1iterator
exprs.takeRight(excess).map(_.expr)	IndexedSeq[ScExpression]	arguments
ScSubstitutor.bind(ta.typeParameters, typeArguments)	ScSubstitutor	genericSubst
subst.followed(genericSubst)	ScSubstitutor	s
parameters.count(p => !p.isDefault && !p.isRepeated)	Int	minParams
ta.lowerBound.map(s)	Either[Failure, ScType]	lowerBound
0	Int	k
false	Boolean	namedMode
if (ta.isDefinition) lowerBound else ta.upperBound.map(s)	Either[Failure, ScType]	upperBound
l.updateRecursively { case `lhs` => lo }	ScType	updated
typeSystem	ScalaConformance	Conformance
wildcards.zip(poly.typeParameters)	IndexedSeq[(ScExistentialArgument, TypeParameter)]	list
projectContext.stdTypes.Nothing	StdType { def isFinalType: Boolean }	Nothing
list.iterator	Iterator[(ScExistentialArgument, TypeParameter)]	iterator
new Array[Boolean](parameters.length)	Array[Boolean]	used
constraints	ConstraintsResult	t
Nil	List[ApplicabilityProblem]	problems
method match { case s: ScMethodLike => s case wrapper: ScFunctionWrapper => wrapper.delegate case wrapper: ScPrimaryConstructorWrapper => wrapper.delegate case _ => method }	PsiMethod	originalMethod
rawExistentialArgs match { case None => val map = new RawTypeParamToExistentialMapBuilder(rawClassResult, paramTopLevel).buildMap val quantified = constructTypeForClass(clazz) { (tp, idx) => map.getOrElse(tp, TypeParameterType(tp)) } map.values.foreach(_.initialize()) quantified case Some(map) => constructTypeForClass(clazz) { (tp, idx) => ScExistentialArgument(tp.name, Seq.empty, Nothing, AnyRef) } }	ScType	quantified
ScSubstitutor.bind(other.getTypeParameters, typeArgs)	ScSubstitutor	substitutor
ScSubstitutor.bind(poly.typeParameters, wildcards)	ScSubstitutor	polySubst
p.params	Seq[ScParameter]	params
{ t1 match { case ScCompoundType(comps1, _, _) => comps1.map(new ClassLike(_)) case _ => Seq(new ClassLike(t1)) } }	Seq[ScalaBounds.this.ClassLike]	leftClasses
Nil	List[(Parameter, ScExpression, ScType)]	matched
false	Boolean	defaultParameterUsed
mutable.ArrayBuffer.empty[Int]	ArrayBuffer[Int]	res
p.getParameters	Array[PsiParameter]	parameters
{ t2 match { case ScCompoundType(comps1, _, _) => comps1.map(new ClassLike(_)) case _ => Seq(new ClassLike(t2)) } }	Seq[ScalaBounds.this.ClassLike]	rightClasses
p.parentsInFile.instanceOf[PsiClass] match { case Some(cls) if cls.qualifiedName == "java.lang.Object" => true // See SCL-3036 case _ => false }	Boolean	treatJavaObjectAsAny
notBoundArgs(quantified).toList	List[ScExistentialArgument]	args
bounds1.lowerBound.equiv(bounds2.lowerBound, lastConstraints, falseUndef)	ConstraintsResult	t
if (wildcardType.isSuper) scType(wildcardType.getSuperBound) else api.Nothing	ScType	lower
quantified match { case _: ScExistentialArgument | _: ScParameterizedType => Covariant //why? case _ => Invariant }	Variance	startVariance
new ArrayBuffer[ScType]	ArrayBuffer[ScType]	buf
false	Boolean	updated
if (wildcardType.isExtends) scType(wildcardType.getExtendsBound) else api.Any	ScType	upper
clazz.hasModifierProperty(STATIC)	Boolean	isStatic
used.indexOf(false)	Int	getIt
ScSubstitutor.bind(tp.typeParameters, args)	ScSubstitutor	subst
parameters(getIt)	Parameter	param
param.paramType	ScType	paramType
param.expectedType	ScType	expectedType
_constraints	ConstraintSystem	constraints
p.paramType(extractVarargComponent = true, treatJavaObjectAsAny = treatJavaObjectAsAny)	ScType	paramTypeNoVarargs
ElementScope(p.getProject)	ElementScope	scope
variance match { case Covariant => updated = true arg.upper case Contravariant => updated = true arg.lower case _ => arg }	ScType	argOrBound
needTvMap(set).fold { tvMap += ((id, Nothing)) return false } { case true => ScSubstitutor(tvMap) case _ => ScSubstitutor.empty }	ScSubstitutor	substitutor
getLeastUpperClasses(leftClasses, rightClasses)	Array[(ScalaBounds.this.ClassLike, Int, Int)]	supers
r.conforms(subst(upper), constraints)	ConstraintsResult	conformance
p.`type`().getOrAny	ScType	typeElementType
p.elementScope	ElementScope	scope
constructTypeForClass(cClass, withTypeParameters = !isStatic)(typeArgFun)	ScType	projected
expr.getTypeAfterImplicitConversion(checkWithImplicits, isShapesResolve, Some(expectedType))._1	result.TypeResult	typeResult
quantified.recursiveVarianceUpdate(startVariance) { case (ex: ScExistentialType, _) => if (ex.simplified.nonEmpty) { updated = true } ReplaceWith(ex.simplify()) case (arg: ScExistentialArgument, variance) => //fourth rule val argOrBound = variance match { case Covariant => updated = true arg.upper case Contravariant => updated = true arg.lower case _ => arg } ReplaceWith(argOrBound) case _ => ProcessSubtypes }	ScType	simplifiedQ
notBoundArgs(simplifiedQ).toList	List[ScExistentialArgument]	newWildcards
Set.empty	Set[ScExistentialArgument]	result
clazz.containingClass match { case null => ScDesignatorType(clazz) case cClass => val isStatic = clazz.hasModifierProperty(STATIC) val projected = constructTypeForClass(cClass, withTypeParameters = !isStatic)(typeArgFun) ScProjectionType(projected, clazz) }	ScType	designator
new TObjectHashingStrategy[ScExistentialArgument] { def computeHashCode(t: ScExistentialArgument): Int = t.name.hashCode def equals(t: ScExistentialArgument, t1: ScExistentialArgument): Boolean = t.name == t1.name }	TObjectHashingStrategy[ScExistentialArgument]	byName
conformsInner(upper, tp, visited, constraints, checkWeak)	ConstraintsResult	t
designator.equiv(designator1, constraints, falseUndef)	ConstraintsResult	t
set.map(substitutor).reduce { _ lub _ }	ScType	lower
typeArguments.iterator	Iterator[ScType]	iterator1
conformsInner(tp, lower, visited, constraints, checkWeak)	ConstraintsResult	t
typeArgs1.iterator	Iterator[ScType]	iterator2
exprType.weakConforms(paramType)	Boolean	conforms
args1.iterator	Iterator[ScType]	args1Iterator
new THashMap[ScExistentialArgument, ScExistentialArgument](byName)	THashMap[ScExistentialArgument, ScExistentialArgument]	map
new ScParameterizedType(designator, typeArgs)	ScParameterizedType	simple
args2.iterator	Iterator[ScType]	args2Iterator
parametersIterator.next()	PsiTypeParameter	tp
`type`.removeAliasDefinitions()	ScType	t
signatureMap.isEmpty && typesMap.isEmpty || ScCompoundType(components).conforms(this)	Boolean	needOnlyComponents
projectContext.stdTypes.QualNameToType	Map[String, StdType]	qualNameToType
left.wildcards.iterator	Iterator[ScExistentialArgument]	leftIterator
components.filter { case t if t.isAny => false case t if t.isAnyRef => if (!r.conforms(api.AnyRef)) return ConstraintsResult.Left false case ScDesignatorType(obj: PsiClass) if obj.qualifiedName == "java.lang.Object" => if (!r.conforms(api.AnyRef)) return ConstraintsResult.Left false case _ => true }	Seq[ScType]	filtered
right.wildcards.iterator	Iterator[ScExistentialArgument]	rightIterator
leftIterator.next	ScExistentialArgument	left
mutable.HashMap.empty[TermSignature, ScType]	mutable.HashMap[TermSignature, ScType]	signatureMapVal
ScSubstitutor.bind(alias.typeParameters, typeArgs)	ScSubstitutor	subst
rightIterator.next	ScExistentialArgument	right
aliasMap(alias.name)	TypeAliasSignature	typeAliasSignature
conformsInner(rhs, lhs, HashSet.empty, constraints)	ConstraintsResult	y
internalType.asInstanceOf[ScParameterizedType]	ScParameterizedType	internal
set.map(substitutor).reduce { _ glb _ }	ScType	upper
conformsInner(lhs, rhs, HashSet.empty, constraints)	ConstraintsResult	y
ScParameterizedType(stpe, Seq(param.paramType))	ValueType	tpe
ScParameterizedType(stpe, Seq(param.expectedType))	ValueType	expectedTpe
constraints match { case impl: ConstraintSystemImpl => Set(impl) case MultiConstraintSystem(otherSubstitutors) => otherSubstitutors }	Set[ConstraintSystemImpl]	otherImpls
addParam(typeParameter, rt, constraints)	ConstraintSystem	y
ScSubstitutor.bind(right.typeParameters, left.typeParameters)(TypeParameterType(_))	ScSubstitutor	subst
addParam(typeParameter, lt, constraints)	ConstraintSystem	y
replaceRightToLeft(subst(right.lower))	ScType	updatedRightLower
method match { case function: ScFunction if function.typeParameters.nonEmpty => def buildText(typeParam: ScTypeParam): String = { val variance = if (typeParam.isContravariant) "-" else if (typeParam.isCovariant) "+" else "" val clauseText = typeParam.typeParametersClause match { case None => "" case Some(x) => x.typeParameters.map(buildText).mkString("[", ",", "]") } val lowerBoundText = typeParam.lowerBound.toOption.collect { case x if !x.isNothing => " >: " + substitutor(x).canonicalText } val upperBoundText = typeParam.upperBound.toOption.collect { case x if !x.isAny => " <: " + substitutor(x).canonicalText } val viewBoundText = typeParam.viewBound.map { x => " <% " + substitutor(x).canonicalText } val contextBoundText = typeParam.contextBound.map { tp => " : " + refactoring.util.ScTypeUtil.stripTypeArgs(substitutor(tp)).canonicalText } val boundsText = (lowerBoundText.toSeq ++ upperBoundText.toSeq ++ viewBoundText ++ contextBoundText).mkString s"$variance${typeParam.name}$clauseText$boundsText" } function.typeParameters.map(buildText) case _ if method.hasTypeParameters => for { param <- method.getTypeParameters.toSeq extendsTypes = param.getExtendsListTypes extendsTypesText = if (extendsTypes.nonEmpty) { extendsTypes.map { classType => substitutor(classType.toScType()).canonicalText }.mkString(" <: ", " with ", "") } else "" } yield param.name + extendsTypesText case _ => Seq.empty }	Seq[String]	typeParameters
lhs.equiv(rhs, constraints, falseUndef = false)	ConstraintsResult	t
getTypeForAppending(leftClasses(sup._2), rightClasses(sup._3), sup._1, depth, checkWeak)	ScType	tp
l.projectContext	ProjectContext	projectContext
left.lower.equiv(updatedRightLower, lastConstraints, falseUndef)	ConstraintsResult	lowerResult
ScSubstitutor.bind(arg.typeParameters, typeParameters)(TypeParameterType(_))	ScSubstitutor	s
replaceRightToLeft(subst(right.upper))	ScType	updatedRightUpper
typeParameters.mkString(tLSQBRACKET.toString, ", ", tRSQBRACKET.toString)	String	typeParametersText
update(arg.lower)	ScType	updatedArgLower
left.upper.equiv(updatedRightUpper, lastConstraints, falseUndef)	ConstraintsResult	upperResult
if (param.isCallByNameParameter) functionArrow else ""	String	arrow
replaceRightToLeft(right.quantified)	ScType	updatedRightQuantified
lower.equiv(updatedArgLower, constraints, falseUndef)	ConstraintsResult	t
update(arg.upper)	ScType	updatedArgUpper
(_, _) => false	TypePresentationContext	emptyContext
args.zip(c.getTypeParameters).foldLeft(PsiSubstitutor.EMPTY) { case (s, (targ, tp)) => s.put(tp, toPsiTypeInner(targ, noPrimitives = true)) }	PsiSubstitutor	subst
false	Boolean	isInitialized
_	ScType	_lower
parameters.indexWhere { p => ScalaNamesUtil.equivalent(p.name, name) || p.deprecatedName.exists(ScalaNamesUtil.equivalent(_, name)) }	Int	index
_	ScType	_upper
ta.name	String	name
ta.lowerBound.getOrNothing	ScType	lower
param.name	String	name
ta.upperBound.getOrAny	ScType	upper
InternalApplicabilityProblem("Found named parameter which were not supposed to be checked")	InternalApplicabilityProblem	internalProblem
Set.empty[ScExistentialArgument]	Set[ScExistentialArgument]	used
new StringBuilder(if (param.isContravariant) "-" else if (param.isCovariant) "+" else "")	StringBuilder	buffer
Set.empty[ScExistentialArgument]	Set[ScExistentialArgument]	result
ScExistentialArgument("_$" + count, List.empty, substed1, substed2)	ScExistentialArgument	ex
projType.actualElement	PsiNamedElement	e
conformsInner(upper, right, visited, constraints, checkWeak)	ConstraintsResult	t
args.zip(c.getTypeParameters).foldLeft(PsiSubstitutor.EMPTY) { case (s, (targ, tp)) => s.put(tp, toPsiTypeInner(targ)) }	PsiSubstitutor	subst
tpe.typeArguments	Seq[ScType]	args
param.`type`().map(substitutor).getOrAny	ScType	tpe
tpe.designator	ScType	des
argument.upper	ScType	upper
parameters(index)	Parameter	param
projectContext	PsiManager	manager
argument.lower	ScType	lower
ScExistentialArgument("_$" + count, List.empty, substed2, substed1)	ScExistentialArgument	ex
conformsInner(right, lower, visited, constraints, checkWeak)	ConstraintsResult	t
toPsiTypeInner(lower)(visitedExistentialArgs + argument)	PsiType	sup
Set(JavaObjectCanonical, ProductCanonical, SerializableCanonical, AnyRefCanonical)	Set[Nothing]	uselessTypeNames
toPsiTypeInner(upper)(visitedExistentialArgs + argument)	PsiType	psi
true	Boolean	isScala
conformsInner(upper, left, visited, constraints, checkWeak)	ConstraintsResult	t
false	Boolean	isScala
""	String	sourceName
conformsInner(left, lower, visited, constraints, checkWeak)	ConstraintsResult	t
paramClause.parameters.map { param => val arrow = if (param.isCallByNameParameter) functionArrow else "" val asterisk = if (param.isRepeatedParameter) tSTAR.toString else "" val name = param.name val tpe = param.`type`().map(substitutor).getOrAny s"$name${colon(name)} $arrow${tpe.canonicalText}$asterisk" }	IndexedSeq[String]	parameters
325	Int	getStubVersion
collectRawTypeParameters(rawClassResult.getElement, rawClassResult.getSubstitutor)	Set[PsiTypeParameter]	rawTypeParams
sourceTextComputation()	String	sourceText
rightExpression.collect { case typedStmt: ScTypedExpression if typedStmt.isSequenceArg => typedStmt }.flatMap { seqTypeFor }	Option[ScType]	maybeSeqType
leftArg.equiv(rightArg, constraints, falseUndef = false)	ConstraintsResult	t
exprs.drop(parameters.length).map(_.expr)	IndexedSeq[ScExpression]	excessiveExprs
args.length - tvArgs.length	Int	captureLength
parameters.last.paramType	ScType	paramType
e.name	String	refName
if (stopAddingUpperBound) Any else lubInner(upper, upper2, checkWeak, stopAddingUpperBound = true)	ScType	newLub
components.filterNot(tp => uselessTypeNames.contains(tp.canonicalText))	Seq[ScType]	withoutUselessComponents
withoutUselessComponents.isEmpty	Boolean	refinementsAreNecessary
parameters.last.expectedType	ScType	expectedType
extractTypeParameters(des).drop(captureLength)	Seq[TypeParameter]	abstractedTypeParams
tvDes.typeParameters	Seq[TypeParameter]	tvTypeParameters
e match { case c: PsiClass => ScalaPsiUtil.isStaticJava(c) case _ => false }	Boolean	isStaticJavaClass
if (refinementsAreNecessary) signatureMap else Map.empty[TermSignature, ScType]	Map[TermSignature, ScType]	newSignatures
if (stopAddingUpperBound) Any else lubInner(upper, substed2, checkWeak, stopAddingUpperBound = true)	ScType	newLub
if (withoutUselessComponents.isEmpty) components.headOption.toList else withoutUselessComponents	Seq[ScType]	newComponents
new Key[SoftReference[DecompilationResult]]("Is Scala File Key")	Key[SoftReference[DecompilationResult]]	Key
conformsInner(a.upper, l, visited, result.constraints, checkWeak)	ConstraintsResult	t
decode(fileName)	String	string
param.name match { case null => param match { case param: ClsParameterImpl => param.getStub.getName case _ => null } case x => x }	String	paramName
if (stopAddingUpperBound) Any else lubInner(upper, substed1, checkWeak, stopAddingUpperBound = true)	ScType	newLub
{ val rawTypeParams = collectRawTypeParameters(rawClassResult.getElement, rawClassResult.getSubstitutor) rawTypeParams.map { tp => (tp, ScExistentialArgument.deferred(tp.getName, Seq.empty, () => Nothing, () => upperForRaw(tp))) }.toMap }	Map[PsiTypeParameter, ScExistentialArgument]	lazyMap
escapeKeyword(paramName)	String	pName
nameRenderer.escapeName(refName)	String	escapedName
new RawTypeParamCollector(rawSubstitutor)	ScalaPsiTypeBridge.RawTypeParamCollector	collector
glb(substed1, substed2)	ScType	newGlb
if (ScalaCompilerLoader.isDisabled) None else Some(new newvfs.FileAttribute("_is_scala_compiled_new_key_", getStubVersion, true))	Option[FileAttribute]	DecompilerFileAttribute
SimpleUpdate { case tpe @ ScCompoundType(components, signatureMap, _) => val withoutUselessComponents = components.filterNot(tp => uselessTypeNames.contains(tp.canonicalText)) val refinementsAreNecessary = withoutUselessComponents.isEmpty val newSignatures = if (refinementsAreNecessary) signatureMap else Map.empty[TermSignature, ScType] val newComponents = if (withoutUselessComponents.isEmpty) components.headOption.toList else withoutUselessComponents tpe.copy(newComponents, newSignatures)(tpe.projectContext) }	SimpleUpdate	cleanUp
bytes match { case null => if (file.isDirectory || !file.isInstanceOf[VirtualFileWithId]) None else Some(() => file.contentsToByteArray) case content => Some(() => content) }	Option[() => Array[Byte]]	maybeContent
Set.empty	Set[PsiTypeParameter]	rawTypeParameters
innerTypeText(p)	String	innerText
ScSubstitutor.bind(typeParameter.typeParameters, p.typeArguments)	ScSubstitutor	subst
param.paramType()	ScType	tpe
file.getTimeStamp	Long	timeStamp
subst(lowerBound) match { case ParameterizedType(lower, _) => ScParameterizedType(lower, p.typeArguments) case lower => ScParameterizedType(lower, p.typeArguments) }	ScType	lower
{ val tpe = param.paramType() substitutor(tpe) }	ScType	paramType
mutable.Set.empty	mutable.Set[PsiClass]	visited
lubInner(substed1, substed2, checkWeak = false, stopAddingUpperBound = true)	ScType	newLub
paramType match { case t if t.isAnyRef => "scala.Any" case t => t.canonicalText }	String	typeText
classType.resolveGenerics	PsiClassType.ClassResolveResult	resolveResult
getFromUserData(file)	DecompilationResult	fromCache
string.length	Int	stringLength
resolveResult.getElement	PsiClass	psiClass
-1	Int	endIndex
checkParameterizedType( tvTypeParameters.map(_.psiTypeParameter).iterator, tvArgs, abstracted, constraints, visited, checkWeak, boundKind == Bound.Equivalence )	ConstraintsResult	conformance
ScExistentialArgument("_$" + count, List.empty, newGlb, newLub)	ScExistentialArgument	ex
getManager	PsiManager	manager
l.equiv(r, constraints)	ConstraintsResult	equiv
ScExistentialArgument("_$" + count, List.empty, newGlb, Any)	ScExistentialArgument	ex
e.simplify()	ScType	simplified
baseClass.baseDesignator	ScType	baseClassDesignator
if (comps.isEmpty) Nil else Seq(comps.map { case tp@FunctionType(_, _) => "(" + innerTypeText(tp) + ")" case tp => innerTypeText(tp) }.mkString(" with "))	Seq[String]	componentsText
this.typeDefinitions	Seq[ScTypeDefinition]	typeDefinitions
abstracted.indices.map( idx => TypeParameter.light("p" + idx + "$$", tvTypeParameters(idx).typeParameters, Nothing, Any) )	IndexedSeq[TypeParameter]	abstractedTypeParams
for (param <- method.parameters) yield { val paramName = param.name match { case null => param match { case param: ClsParameterImpl => param.getStub.getName case _ => null } case x => x } val pName: String = escapeKeyword(paramName) val colon = if (pName.endsWith("_")) " " else "" val paramType = { val tpe = param.paramType() substitutor(tpe) } val asterisk = if (param.isVarArgs) "*" else "" val typeText = paramType match { case t if t.isAnyRef => "scala.Any" case t => t.canonicalText } s"$pName$colon: $typeText$asterisk" }	IndexedSeq[String]	params
Set()	ReachingDefinitions.RDSet	bottom
Option.empty[VirtualFile]	Option[VirtualFile]	result
s.namedElement.asInstanceOf[ScFunction]	ScFunction	function
s.substitutor	ScSubstitutor	substitutor
ScParameterizedType(baseClassDesignator, baseClass.getTypeParameters.map(TypeParameterType(_)))	ValueType	tp
Decompiler.sourceNameAndText(file.getName, content()) match { case Some((sourceName, sourceText)) => Full(sourceName, sourceText, timeStamp) case None => NonScala(timeStamp) }	DecompilationResult with Product with Serializable	recomputedResult
getFromFileAttribute(file) match { case Some(nonScala: NonScala) => nonScala case Some(PartialScala(sourceName, _)) => Lazy(sourceName, timeStamp, () => Decompiler.sourceNameAndText(file.getName, content()).map(_._2).getOrElse("")) case None => val recomputedResult = Decompiler.sourceNameAndText(file.getName, content()) match { case Some((sourceName, sourceText)) => Full(sourceName, sourceText, timeStamp) case None => NonScala(timeStamp) } writeToFileAttribute(file, recomputedResult) recomputedResult }	DecompilationResult	result
el.elementScope.getCachedClass("scala.NotNull") .map(ScDesignatorType(_)) .exists(l.conforms(_))	Boolean	flag
ScTypePolymorphicType( ScParameterizedType( des, captured ++ abstractedTypeParams.map(TypeParameterType(_)) ), abstractedTypeParams )	ScTypePolymorphicType	typeConstructor
superSubst1(tp).asInstanceOf[ScParameterizedType]	ScParameterizedType	tp1
ConstraintsResult.Left	ConstraintsResult	unificationConstraints
superSubst2(tp).asInstanceOf[ScParameterizedType]	ScParameterizedType	tp2
new ArrayBuffer[ScType]	ArrayBuffer[ScType]	resTypeArgs
findCommonParent(fragment: _*)	PsiElement	commonParent
new ArrayBuffer[ScExistentialArgument]()	ArrayBuffer[ScExistentialArgument]	wildcards
d.element match { case v: ScBindingPattern => v.`type`() case v: ScParameter => v.`type`() case v: ScFieldId => v.`type`() case _ => return }	result.TypeResult	maybeType
for ((parameter: Parameter, b) <- parameters.zip(used) if !b && !parameter.isDefault) yield MissedValueParameter(parameter)	IndexedSeq[MissedValueParameter]	missed
conformsInner(l, value, visited, constraints)	ConstraintsResult	res
tp1.typeArguments.apply(i)	ScType	substed1
c.components	Seq[ScType]	comps
method match { case function: ScFunction => function.returnType.toOption.map { (_, function.isParameterless && function.typeParameters.isEmpty && isIdentifier(method.name + tCOLON)) } case _ => Option(method.getReturnType).map { returnType => (returnType.toScType(), false) } }	Option[(ScType, Boolean)]	maybeReturnType
tp2.typeArguments.apply(i)	ScType	substed2
unifyTypeVariable(hkTv, ptpe, constraints, boundKind, visited, checkWeak)	ConstraintsResult	tryUnify
Set[ConstraintSystem]()	Set[ConstraintSystem]	results
comps.iterator	Iterator[ScType]	iterator
substitutor(returnType).canonicalText match { case "_root_.java.lang.Object" => "AnyRef" case text => text }	String	typeText
iterator.next()	ScType	comp
parameters.zip(used)	IndexedSeq[(Parameter, Boolean)]	pack
extractTypeParameters(lhs)	Seq[TypeParameter]	lhsParams
extractTypeParameters(rhs)	Seq[TypeParameter]	rhsParams
item.getVirtualFile	VirtualFile	sourceFile
new ArrayBuffer[(ClassLike, Int, Int)]	ArrayBuffer[(ScalaBounds.this.ClassLike, Int, Int)]	res
for (v <- cfg) yield (v, l.bottom)	Seq[(Instruction, E)]	initial
check(comp, constraints)	ConstraintsResult	t
mutable.HashMap(initial: _*)	mutable.HashMap[Instruction, E]	after
parseParameters(function, -1)(scType => typeText0(substitutor(scType)))	String	paramClauses
param.paramInCode .flatMap(_.getDefaultExpression) .get	ScExpression	expr
dfa.isForward	Boolean	forward
substitutor(alias.aliasedType.getOrAny).canonicalText	String	typeText
nameContext(variable) match { case m: ScModifierListOwner => m case _ => null }	ScModifierListOwner	modOwner
dfa.fun(v) _	E => E	fv
res(i)._1	ScalaBounds.this.ClassLike	alreadyFound
variable.name	String	name
if (!compType.equiv(returnType)) typeText0(substitutor(returnType)) else s"this$ObjectTypeSuffix"	String	retType
leftClasses.iterator	Iterator[ScalaBounds.this.ClassLike]	leftIterator
fv(l.join((if (forward) v.pred() else v.succ()).map(after(_))))	E	newAfter
leftIterator.next()	ScalaBounds.this.ClassLike	leftClass
rightClasses.iterator	Iterator[ScalaBounds.this.ClassLike]	rightIterator
proj1.projected	ScType	projected1
proj2.projected	ScType	projected2
rightIterator.next()	ScalaBounds.this.ClassLike	rightClass
leftClass.getNamedElement	PsiNamedElement	element
typeParametersText(function.typeParameters, substitutor)	String	typeParameters
if (needsInferType) substitutor(variable.`type`().getOrAny).canonicalText else ""	String	typeText
new ImplicitCollector(state.copy(fullInfo = true))	ImplicitCollector	collector
substitutor(p.`type`().getOrNothing)	ScType	t
`type`.projectContext.stdTypes	StdTypes	stdTypes
s.namedElement match { case _ if s.paramLength > 0 => None case pattern: ScBindingPattern => Some(pattern) case fieldId: ScFieldId => Some(fieldId) case _ => None }	Option[ScTypedDefinition]	named
proj2.actualElement match { case syntheticClass: ScSyntheticClass => result = conformsInner(l, syntheticClass.stdType, HashSet.empty, constraints) return case v: ScBindingPattern => v.`type`() case v: ScParameter => v.`type`() case v: ScFieldId => v.`type`() case _ => return }	result.TypeResult	res
null	ConstraintsResult	result
ConstraintSystem.empty	ConstraintSystem	constraints
new ValDesignatorSimplification with UndefinedSubstVisitor with AbstractVisitor with ParameterizedAbstractVisitor {}	ScalaTypeVisitor	rightVisitor
signature.typeAlias	ScTypeAlias	alias
if (signature.isDefinition) s" = ${typeText0(signature.upperBound)}" else lowerBoundText(signature.lowerBound)(typeText0) + upperBoundText(signature.upperBound)(typeText0)	String	defnText
new MappedTopPrecedenceHolder(nameUniquenessStrategy)	TopPrecedenceHolder	holder
p.getDefaultExpression.flatMap(_.`type`().toOption.map(substitutor))	Option[ScType]	default
createTypeElementFromText(text, context, child)	ScTypeElement	typeElement
typeParametersText(alias.typeParameters, signature.substitutor)	String	typeParameters
new CompoundTypeCheckSignatureProcessor(s,retType, constraints)	CompoundTypeCheckSignatureProcessor	processor
ImplicitState(place, tp, expandedTp, coreElement, isImplicitConversion, searchImplicitsRecursively, extensionData, fullInfo, Some(ImplicitsRecursionGuard.currentMap))	ImplicitCollector.ImplicitState	collectorState
candidatesSet	Set[ScalaResolveResult]	res
place.getProject	Project	project
r match { case ScDesignatorType(_: ScParameter | _: ScFieldId | _: ScBindingPattern) => ScSubstitutor(r) case _ => ScSubstitutor.empty }	ScSubstitutor	singletonSubst
element match { case _: ScTemplateBody | _: ScExtendsBlock => true // template body and inherited members are at the same level case _ => changedLevel }	Boolean	isNewLevel
p.paramType(extractVarargComponent = false)	ScType	tp
new CompoundTypeCheckTypeAliasProcessor(sign, constraints, singletonSubst)	CompoundTypeCheckTypeAliasProcessor	processor
tp.extractClass	Option[PsiClass]	clazz
new DfaEngine(cfg, ReachingDefinitionsInstance, ReachingDefinitionsLattice)	DfaEngine[ReachingDefinitions.RDSet]	engine
clazz.flatMap(possibleFunctionN)	Option[Int]	possibleScalaFunction
engine.performDFA	mutable.Map[Instruction, ReachingDefinitions.RDSet]	dfaResult
if (p.isInstanceOf[ClsParameterImpl]) "" else p.name	String	name
conformsInner(comp, r, HashSet.empty, constraints)	ConstraintsResult	t
argClauses.headOption.getOrElse(Seq.empty)	Seq[Compatibility.Expression]	firstArgumentListArgs
MostSpecificUtil(place, 1)	MostSpecificUtil	mostSpecificUtil
visibleNamesCandidates	Set[ScalaResolveResult]	visible
PsiTreeUtil.findCommonContext(function, place)	PsiElement	commonContext
collectFullInfo(visible)	Seq[ScalaResolveResult]	fromNameCandidates
filterByFragment(cfg, fragment)	Seq[Instruction]	fragmentInstructions
synthetic.paramClauses.head.map(p => p.copy(paramType = substitutor(p.paramType)) )	IndexedSeq[Parameter]	parameters
c.components.forall(comp => { val t = conformsInner(comp, r, HashSet.empty, constraints) constraints = t.constraints t.isRight }) && c.signatureMap.forall { case (s: TermSignature, retType) => workWithSignature(s, retType) } && c.typesMap.forall { case (_, sign) => workWithTypeAlias(sign) }	Boolean	isSuccess
QuasiquoteInferUtil.getMetaQQExpectedTypes(ref.asInstanceOf[ScReferenceExpression])	Seq[Parameter]	params
computeInputVariables(fragmentInstructions).filter(info => !isVisible(info.element, place))	Iterable[VariableInfo]	inputInfos
proj.projected	ScType	projected1
proj1.projected	ScType	projected2
createElementWithContext[ScMethodCall](s"foo($text)", context, child)(expressions.Expr.parse)	ScMethodCall	methodCall
methodCall.argumentExpressions .headOption .getOrElse { throw elementCreationException("expression", text, context) }	ScExpression	firstArgument
(signatureMap ++ typeMap).flatMap { case (s: TermSignature, returnType: ScType) if s.namedElement.isInstanceOf[ScFunction] => val function = s.namedElement.asInstanceOf[ScFunction] val substitutor = s.substitutor val paramClauses = parseParameters(function, -1)(scType => typeText0(substitutor(scType))) val retType = if (!compType.equiv(returnType)) typeText0(substitutor(returnType)) else s"this$ObjectTypeSuffix" val typeParameters = typeParametersText(function.typeParameters, substitutor) Some(s"def ${s.name}$typeParameters$paramClauses: $retType") case (s: TermSignature, returnType: ScType) if s.namedElement.isInstanceOf[ScTypedDefinition] => val substitutor = s.substitutor val named: Option[ScTypedDefinition] = s.namedElement match { case _ if s.paramLength > 0 => None case pattern: ScBindingPattern => Some(pattern) case fieldId: ScFieldId => Some(fieldId) case _ => None } named.map { typedDefinition => (if (typedDefinition.isVar) "var" else "val") + s" ${typedDefinition.name} : ${typeText0(substitutor(returnType))}" } case (_: String, signature: TypeAliasSignature) => val alias = signature.typeAlias val defnText: String = if (signature.isDefinition) s" = ${typeText0(signature.upperBound)}" else lowerBoundText(signature.lowerBound)(typeText0) + upperBoundText(signature.upperBound)(typeText0) val typeParameters = typeParametersText(alias.typeParameters, signature.substitutor) Some(s"type ${signature.name}$typeParameters$defnText") case _ => None }	IndexedSeq[Any]	declsTexts
conformsInner(projected1, projected2, visited, constraints)	ConstraintsResult	t
if (declsTexts.isEmpty) Nil else Seq(declsTexts.mkString("{\n ", "\n\n ", "\n}"))	Seq[String]	refinementText
computeOutputVariables(fragmentInstructions, dfaResult)	Iterable[VariableInfo]	outputInfos
conformsInner(lower, r, visited, constraints)	ConstraintsResult	conforms
new UndefinedSubstVisitor(){}	ScalaTypeVisitor	rightVisitor
new ValDesignatorSimplification with UndefinedSubstVisitor with AbstractVisitor {}	ScalaTypeVisitor	rightVisitor
fun.effectiveParameterClauses .headOption .toList .flatMap(_.effectiveParameters) .map(toParameter(_, substitutor))	IndexedSeq[Parameter]	parameters
DummyHolderFactory.createHolder( PsiManager.getInstance(project), context ).getTreeElement	FileElement	chameleon
(`type`, scope)	(ScType, GlobalSearchScope)	cacheKey
ScalaLanguage.INSTANCE	ScalaLanguage	language
findInSources(sourceFile, qualifiedName)	Boolean	found
ScSubstitutor.bind(a.typeParameter.typeParameters, p.typeArguments)	ScSubstitutor	subst
element match { case fun: ScFunction => !fun.isLocal case m: PsiMethod => !m.hasModifierPropertyScala("static") case _ => false }	Boolean	isInstanceMethod
subst(a.upper) match { case up if up.equiv(Any) => ScParameterizedType(WildcardType(a.typeParameter), p.typeArguments) case ParameterizedType(up, _) => ScParameterizedType(up, p.typeArguments) case up => ScParameterizedType(up, p.typeArguments) }	ScType	upper
LanguageParserDefinitions.INSTANCE.forLanguage(language)	ParserDefinition	parserDefinition
subst(a.lower) match { case low if low.equiv(Nothing) => ScParameterizedType(WildcardType(a.typeParameter), p.typeArguments) case ParameterizedType(low, _) => ScParameterizedType(low, p.typeArguments) case low => ScParameterizedType(low, p.typeArguments) }	ScType	lower
wildcard.typeParameters.map(_.name) match { case Seq() => "" case parameters => parameters.commaSeparated(model = Model.SquareBrackets) }	String	argsText
findImplicitObjectsImpl(`type`)(ElementScope(context.project, scope))	Seq[ScType]	implicitObjects
findFile(sourceFile) match { case scalaFile: api.ScalaFile => scalaFile.typeDefinitions.iterator case classOwner: PsiClassOwner => classOwner.getClasses.iterator case _ => Iterator.empty }	Iterator[PsiClass]	clazzIterator
manager.getProject	Project	project
mutable.HashSet.empty[ScType]	mutable.HashSet[ScType]	visited
constructor.effectiveFirstParameterSection.map(toParameter(_, substitutor))	IndexedSeq[Parameter]	parameters
mutable.Queue.empty[ScType]	mutable.Queue[ScType]	parts
conformsInner(r, lower, visited, result.constraints, checkWeak)	ConstraintsResult	t
if (fromNameCandidates.exists(_.implicitReason == OkResult)) fromNameCandidates else { fromNameCandidates ++ collectFullInfo(fromTypeCandidates.diff(visible)) }	Seq[ScalaResolveResult]	allCandidates
lowerBoundText(wildcard.lower)(innerTypeText(_))	String	lowerBound
p.typeArguments	Seq[ScType]	args1
p.designator	ScType	des1
Seq.empty	Seq[TypeParameter]	unresolvedTypeParameters
Tracer("ImplicitCollector.collect", "ImplicitCollector.collect")	Tracer	tracer
iterable.toIterator	Iterator[ScType]	iterator
ScalaResolveState.withImplicitConversion(result.resolveResult)	ResolveState	innerState
ImplicitCollector.cache(project)	ImplicitCollectorCache	implicitCollectorCache
MixinNodes.asSeenFromSubstitutor(containingObject, member.containingClass)	ScSubstitutor	substitutor
upperBoundText(wildcard.upper)(innerTypeText(_))	String	upperBound
j.getParameterizedType	Option[ValueType]	parameterizedType
compatible(visibleNamesCandidates)	Seq[ScalaResolveResult]	firstCandidates
compatible(fromTypeCandidates)	Seq[ScalaResolveResult]	secondCandidates
if (firstCandidates.exists(_.isApplicable())) firstCandidates else { val secondCandidates = compatible(fromTypeCandidates) if (secondCandidates.nonEmpty) secondCandidates else firstCandidates }	Seq[ScalaResolveResult]	result
ScExistentialArgument.usedMoreThanOnce(quant)	Set[ScExistentialArgument]	usedMoreThanOnce
ImplicitsRecursionGuard.currentMap	ImplicitsRecursionGuard.RecursionMap	currentMap
mutable.HashMap.empty[String, Seq[ScType]]	mutable.HashMap[String, Seq[ScType]]	res
method.parameters.map(param => Parameter(substitutor(param.paramType()), isRepeated = param.isVarArgs, index = -1, param.getName) )	IndexedSeq[Parameter]	parameters
PsiBuilderFactory.getInstance.createBuilder( project, chameleon, parserDefinition.createLexer(project), language, seq )	PsiBuilder	delegate
FunctionType(Any(place.projectContext), Seq(expressionType))	ValueType	functionType
new builder.ScalaPsiBuilderImpl(delegate)	ScalaPsiBuilderImpl	psiBuilder
InternalApplicabilityProblem(s"Cannot handle compatibility for $unknown")	InternalApplicabilityProblem	problem
ownerDesignator match { case td: ScTypeParametersOwner => td.typeParameters.iterator case ownerDesignator: PsiTypeParameterListOwner => ownerDesignator.getTypeParameters.iterator case _ => result = ConstraintsResult.Left return }	Iterator[PsiTypeParameter]	parametersIterator
collectCompatibleCandidates(candidates, withLocalTypeInference = false)	Set[ScalaResolveResult]	withoutLocalTypeInference
p2.designator	ScType	des2
if (withoutLocalTypeInference.nonEmpty) withoutLocalTypeInference else collectCompatibleCandidates(candidates, withLocalTypeInference = true)	Set[ScalaResolveResult]	compatible
p2.typeArguments	Seq[ScType]	args2
psiBuilder.getTreeBuilt .getFirstChildNode .asInstanceOf[TreeElement]	TreeElement	first
if (argClauses.isEmpty) Seq(Seq.empty) else argClauses.map(_.exprs)	Seq[Seq[ScExpression]]	nonEmptyArgClause
createElementFromText("val _ = x")	PsiElement	element
parameterizedTypeText(quant) { case arg: ScExistentialArgument => if (placeholders.contains(arg)) placeholder(arg) else arg.name case t => innerTypeText(t, needDotType = true, checkWildcard) }	String	prefix
ScSubstitutor.bind(t.typeParameters, p.typeArguments)	ScSubstitutor	subst
"scala.annotation.showAsInfix"	String	showAsInfixAnnotation
element match { case _: SyntheticNamedElement => true case fun: ScFunction => fun.isSynthetic case _ => false }	Boolean	isSynthetic
ScSubstitutor.bind(actualElem.typeParameters, args)	ScSubstitutor	genericSubst
conformsInner(proj1, proj2, visited, constraints)	ConstraintsResult	t
named.name	String	simpleName
function.projectContext	ProjectContext	projectContext
s"/**=header${StringUtils.repeat("=", length)}*/"	String	text
ImplicitSearchScope.forElement(place)	ImplicitSearchScope	scope
e.wildcards.map(w => UndefinedType(lightTypeParam(w)))	IndexedSeq[UndefinedType]	undefines
createDocComment(text)	ScDocComment	comment
InfixExpr.associate(op)	Int	assoc
createDeclarationFromText(s"val dummyVal: ${element.name}", place.getContext, place) .asInstanceOf[ScValueDeclaration]	ScValueDeclaration	decl
refName == "+" && place.getTypeWithoutImplicits().exists { _.isInstanceOf[ValType] }	Boolean	isHardCoded
processor.kinds	Set[ResolveTargets.Value]	kinds
comment.getNode.getChildren(null)	Array[ASTNode]	children
resolveResult.element.getProject	Project	project
FunctionType(expressionType, arguments(processor, noImplicitsForArgs))	ValueType	expandedFunctionType
candidates.flatMap(c => checkCompatible(c, withLocalTypeInference = false)) ++ candidates.flatMap(c => checkCompatible(c, withLocalTypeInference = true))	IndexedSeq[ScalaResolveResult]	allCandidates
e.wildcards.zip(undefines).toMap	Map[ScExistentialArgument, UndefinedType]	wildcardsToUndefined
`type` match { case ParameterizedType(InfixDesignator(newOp), _) => assoc != InfixExpr.associate(newOp) || assoc == requiredAssoc case _ => false }	Boolean	needParenthesis
function.typeParameters.map { typeParameter => typeParameter -> typeParameter.typeParamId }	IndexedSeq[(ScTypeParam, Long)]	typeParameters
paramClause.effectiveParameters.map(toParameter(_, prevSubstitutor))	IndexedSeq[Parameter]	params
allCandidates.flatMap(applyExtensionPredicate)	IndexedSeq[ScalaResolveResult]	afterExtensionPredicate
typeParameters.map(_._2).toSet	Set[Long]	typeParamIds
ExtensionConversionData(place, ref, refName, processor, noApplicability, withoutImplicitsForArgs)	ExtensionConversionData	data
e.quantified.recursiveUpdate { case arg: ScExistentialArgument => ReplaceWith(wildcardsToUndefined.getOrElse(arg, arg)) case _: ScExistentialType => Stop case _ => ProcessSubtypes }	ScType	updatedWithUndefinedTypes
argument match { case _: ScTuple | _: ScParenthesisedExpr | _: ScUnitExpr => argument.getText case ElementText(text) => text.parenthesize() }	String	clauseText
candidate match { case ScalaResolveResult(function: ScFunction, _) if function.hasTypeParameters => function.typeParameters.map { TypeParameter(_) } case _ => Seq.empty }	Seq[TypeParameter]	typeParams
args.map(new Expression(_))	IndexedSeq[Compatibility.Expression]	argExprs
candidate.implicitParameterType	Option[ScType]	parameterType
checkImplicits() match { case Seq() => checkImplicits(noApplicability = true) case seq@Seq(_) => seq case _ => checkImplicits(withoutImplicitsForArgs = true) }	Seq[ScalaResolveResult]	foundImplicits
args.length != 1 && params.length == 1 && !params.head.isDefault	Boolean	eligibleForAutoTupling
substitutor.andThen(unSubst)	ScType => ScType	boundsSubstitutor
candidate.substitutor.followed(foundInType.substitutor).followed(substitutor)	ScSubstitutor	combinedSubstitutor
new ResolveProcessor(kinds, ref, refName)	ResolveProcessor	newProc
solvingSubstitutor(un)	ScType	solvedType
conformsInner(solvedType, un.typeParameter.lowerType.unpackedType, constraints = constraints)	ConstraintsResult	t
s"(${base.getText}).$operationText$typeArgText$clauseText"	String	exprText
clauses.headOption.toSeq.flatMap(_.parameters).map(Parameter(_))	IndexedSeq[Parameter]	parameters
createExpressionWithContextFromText(base.getText, infix, base)	ScExpression	exprA
params match { case Seq(fun @ FunctionType(_, _)) => innerTypeText(fun).parenthesize() case Seq(tup @ TupleType(tps)) => innerTypeText(tup).parenthesize() case Seq(head) => innerTypeText(head) case _ => typesText(params) }	String	paramsText
contextFile(e)	Option[Nothing]	resolveFile
element match { case _: PsiMethod | _: ScFun => checkResolve(createExpressionWithContextFromText(element.name + " _", place.getContext, place).getFirstChild) case _: ScObject => checkResolve(createExpressionWithContextFromText(element.name, place.getContext, place)) case _: ScTypeAlias | _: ScTypeDefinition => val decl = createDeclarationFromText(s"val dummyVal: ${element.name}", place.getContext, place) .asInstanceOf[ScValueDeclaration] decl.typeElement match { case Some(st: ScSimpleTypeElement) => st.reference.exists(checkResolve) case _ => false } case _ => checkResolve(createExpressionWithContextFromText(element.name, place.getContext, place)) }	Boolean	resolvesAtNewPlace
ScSubstitutor.paramToType(parameters, Seq.fill(parameters.length)(fromType))	ScSubstitutor	dependentSubstitutor
new ArrayBuffer[PsiNamedElement]	ArrayBuffer[PsiNamedElement]	buffer
None	Option[ScParameterClause]	result
contextFile(getPlace)	Option[Nothing]	placeFile
mutable.Set[PsiNamedElement]()	mutable.Set[PsiNamedElement]	buffer
undefines.map { _.typeParameter.typeParamId }.toSet	Set[Long]	typeParamIds
ScalaPsiUtil.nameContext(c.element)	PsiElement	nameContext
createExpressionWithContextFromText(exprText.toString, infix.getContext, infix)	ScExpression	methodCall
mutable.HashSet.empty[PsiNamedElement]	mutable.HashSet[PsiNamedElement]	seen
mutable.ArrayBuffer.empty[ImplicitResolveResult]	ArrayBuffer[ImplicitResolveResult]	buffer
conformsInner(tpt1.lowerType, r, HashSet.empty, constraints)	ConstraintsResult	res
dependentMethodTypes.toSeq .flatMap(_.effectiveParameters) .map(Parameter(_))	IndexedSeq[Parameter]	effectiveParameters
function.returnType.map(substitutor).toOption	Option[ScType]	returnType
innerInstructions.collect { case DefinitionInstruction(_, named, _) => named }	IndexedSeq[ScNamedElement]	definedHere
conformsInner(tpt1.lowerType, r, HashSet.empty, constraints)	ConstraintsResult	t
element match { case clazz: ScTypeDefinition => clazz.name + "." case _ => "" }	String	prefix
element match { case _: ScObject | _: ScReferencePattern | _: ScParameter => true case _ => false }	Boolean	flag
currentTopLevelModCount(elementScope.project)	Long	currentCount
if (ApplicationManager.getApplication.isUnitTestMode) 10000 else 100	Int	defaultTimeoutMs
function.parameters.headOption.flatMap(_.`type`().toOption)	Option[ScType]	rawParamType
ApplicationManager.getApplication.getMessageBus.connect	MessageBusConnection	connection
conformsInner(s.lower, r, HashSet.empty, constraints)	ConstraintsResult	t
ScalaPsiUtil.undefineMethodTypeParams(function)	ScSubstitutor	undefiningSubst
mutable.Map.empty[GlobalImplicitConversion, ImplicitConversionData]	mutable.Map[GlobalImplicitConversion, ImplicitConversionData]	resultMap
buffer.filter(_.isPhysical).toSeq	Seq[PsiNamedElement]	physical
fun.effectiveParameterClauses.exists(!_.isImplicit)	Boolean	hasNonImplicitClause
named match { case fun: ScFunction => ScalaPsiUtil.undefineMethodTypeParams(fun) case _ => ScSubstitutor.empty }	ScSubstitutor	undefiningSubst
fun.paramClauses.clauses.head	ScParameterClause	clause
functionType.projectContext	ProjectContext	projectContext
clause.parameters.size	Int	paramsCount
Set.empty[ScalaResolveResult]	Set[ScalaResolveResult]	filteredCandidates
candidates.iterator	Iterator[ScalaResolveResult]	iterator
iterator.next()	ScalaResolveResult	c
methodCall match { case ScMethodCall(reference: ScReferenceExpression, _) => reference case ScMethodCall(ScGenericCall(reference, _), _) => reference }	ScReferenceExpression	referenceExpression
Set()	Set[ScalaResolveResult]	results
postfix.operand	ScExpression	operand
u2.typeParameter.typeParamId	Long	name
new ValDesignatorSimplification { override def visitUndefinedType(u2: UndefinedType) { val name = u2.typeParameter.typeParamId result = if (u2.level > u.level) { constraints.withUpper(name, u) } else if (u.level > u2.level) { constraints.withUpper(name, u) } else { constraints } } }	LeftConformanceVisitor.this.ValDesignatorSimplification { def visitUndefinedType(u2: UndefinedType): Unit }	rightVisitor
s"($operandText).${postfix.operation.getText}"	String	qualRefText
getPlace.elementScope.function1Type(level = 0)	Option[ScParameterizedType]	functionType
state.substitutorWithThisType	ScSubstitutor	subst
new ArrayBuffer[Instruction]	ArrayBuffer[Instruction]	mySucc
checkConformanceExt(checkNames = true, params, argExprs, checkWithImplicits = true, isShapesResolve = false) match { case res if eligibleForAutoTupling && res.problems.nonEmpty => // try autotupling. If the conformance check succeeds without problems we use that result ScalaPsiUtil .tupled(args, constrInvocation) .map(checkConformanceExt(checkNames = true, params, _, checkWithImplicits = true, isShapesResolve = true)) .filter(_.problems.isEmpty) .getOrElse(res) case res => res }	Compatibility.ConformanceExtResult	curRes
m1.params	Seq[Parameter]	params1
new ArrayBuffer[Instruction]	ArrayBuffer[Instruction]	myPred
m2.params	Seq[Parameter]	params2
m1.result	ScType	returnType1
m2.result	ScType	returnType2
createExpressionWithContextFromText(qualRefText, postfix.getContext, postfix).asInstanceOf[ScReferenceExpression]	ScReferenceExpression	expr
createExpressionWithContextFromText(operandText, postfix, operand)	ScExpression	qualWithoutPars
namedElement.name	String	myName
conformsInner(returnType1, returnType2, HashSet.empty, constraints)	ConstraintsResult	t
subst(namedElement.`type`().getOrAny)	ScType	elemType
new ValDesignatorSimplification with UndefinedSubstVisitor {}	LeftConformanceVisitor.this.ValDesignatorSimplification with LeftConformanceVisitor.this.UndefinedSubstVisitor	rightVisitor
mostSpecificUtil.nextMostSpecific(filteredCandidates)	Option[ScalaResolveResult]	next
checkCompatible(c, withLocalTypeInference)	Option[ScalaResolveResult]	compatible
s"class a {\n $body\n}"	String	fileText
compatible.flatMap(applyExtensionPredicate)	Option[ScalaResolveResult]	afterExtensionPredicate
conformsInner(r, a.lower, visited, result.constraints, checkWeak)	ConstraintsResult	t
new ArrayBuffer[InstructionImpl]	ArrayBuffer[InstructionImpl]	myInstructions
t1.typeParameters	Seq[TypeParameter]	typeParameters1
t2.typeParameters	Seq[TypeParameter]	typeParameters2
new ArrayBuffer[(InstructionImpl, ScalaPsiElement)]	ArrayBuffer[(InstructionImpl, ScalaPsiElement)]	myPending
t1.internalType	ScType	internalType1
t2.internalType	ScType	internalType2
new ArrayBuffer[(InstructionImpl, HandleInfo)]	ArrayBuffer[(InstructionImpl, ScalaControlFlowBuilder.this.HandleInfo)]	myTransitionInstructions
new mutable.Stack[HandleInfo]	mutable.Stack[ScalaControlFlowBuilder.this.HandleInfo]	myCatchedExnStack
0	Int	myInstructionNum
_	InstructionImpl	myHead
conformsInner(typeParameters1(i).lowerType, typeParameters2(i).lowerType, HashSet.empty, constraints)	ConstraintsResult	t
new InstructionImpl(inc, None)	InstructionImpl	instr
myInstructionNum	Int	num
new InstructionImpl(inc, element)	InstructionImpl	instr
new ArrayBuffer[Int]	ArrayBuffer[Int]	ab
mostSpecificUtil.notMoreSpecificThan(r)	ScalaResolveResult => Boolean	notMoreSpecific
ScSubstitutor.bind(typeParameters1, typeParameters2)(TypeParameterType(_))	ScSubstitutor	subst
c.substitutor	ScSubstitutor	subst
conformsInner(subst(internalType1), internalType2, HashSet.empty, constraints)	ConstraintsResult	t
value.asInstanceOf[Parameters]	Parameters	tuple
tuple.newExpression	PsiNamedElement	item
collectRegulars(place, placeType).map(_.element) ++ collectCompanions(placeType, arguments = place.expectedTypes(fromUnderscore), place).map(_.element)	IndexedSeq[PsiNamedElement]	result
tuple.elements	Seq[PsiNamedElement]	firstPart
DefinitionInstruction(inc, b, DefinitionType.VAL)	DefinitionInstruction	instr
new ImplicitConversionProcessor(place, false) .candidatesByPlace	Set[ScalaResolveResult]	candidates
prevRes.copy( problems = prevRes.problems ++ curRes.problems, defaultParameterUsed = prevRes.defaultParameterUsed || curRes.defaultParameterUsed, matched = prevRes.matched ++ curRes.matched )	Compatibility.ConformanceExtResult	res
DefinitionInstruction(inc, b, DefinitionType.VAR)	DefinitionInstruction	instr
typeParams.filter(tp => !tp.lowerType.equiv(Nothing) || !tp.upperType.equiv(Any))	Seq[TypeParameter]	filteredTypeParams
curRes.constraints match { case ConstraintSystem(csSubstitutor) => prevSubstitutor.followed(csSubstitutor) case _ => prevSubstitutor }	ScSubstitutor	newSubstitutor
paramClauses.length	Int	minParamClauses
ScTypePolymorphicType(internalType, filteredTypeParams)	ScTypePolymorphicType	newPolymorphicType
t.typeParameters.map { UndefinedType(_, level = level) }	IndexedSeq[UndefinedType]	parameters
element.resolveScope	GlobalSearchScope	scope
arguments match { case Seq() => placeType case seq => TupleType(Seq(placeType) ++ seq)(place.elementScope) }	ScType	expandedType
paramClauses.lastOption.exists(_.isImplicit)	Boolean	hasImplicitClause
new ImplicitConversionProcessor(place, true) .candidatesByType(expandedType)	Set[ScalaResolveResult]	candidates
paramClauses.drop(nonEmptyArgClause.length)	Seq[ScParameterClause]	missingClauses
ReadWriteVariableInstruction(inc, ref, usedVariable(ref), ScalaPsiUtil.isLValue(ref))	ReadWriteVariableInstruction	instr
stmt.leftExpression	ScExpression	lValue
newPolymorphicType.inferValueType.updateLeaves { case u: UndefinedType => u.inferValueType }	ScType	updated
call.matchedParameters	Seq[(ScExpression, Parameter)]	matchedParams
c.element.asInstanceOf[ScFunction]	ScFunction	fun
matchedParams.toMap.get(arg)	Option[Parameter]	param
call.getInvokedExpr	ScExpression	receiver
myHead	InstructionImpl	head
owner.projectContext	ProjectContext	project
forBinding.pattern	ScPattern	pat
new StringBuilder("")	StringBuilder	buffer
Option(getRightCellRenderer(item))	Option[Nothing]	maybeRenderer
param.name	String	paramText
param.projectContext.stdTypes	StdTypes	stdTypes
mutable.ArrayBuffer.empty[SmartPsiElementPointer[PsiElement]]	ArrayBuffer[SmartPsiElementPointer[PsiElement]]	markedElements
markedElements.head	SmartPsiElementPointer[PsiElement]	head
Option(myHead).getOrElse(ifStmtInstr)	InstructionImpl	head
myHead == null || (myHead.element match { case Some(e) => e != ret case None => false })	Boolean	isNodeNeeded
param.getModifierList	PsiModifierList	list
buffer.length	Int	lastSize
infix.matchedParameters.exists(_._2.isByName)	Boolean	byNameParam
this match { case s: ScalaStubBasedElementImpl[_, _] => s.getGreenStub case f: ScalaFileImpl => f.getStub case _ => null }	(_$2) forSome {type _$2 <: StubElement[_$1]; type _$1}	stub
DefinitionInstruction(inc, fun, DefinitionType.DEF)	DefinitionInstruction	instr
paramOwner match { case owner: ScParameterOwner => owner.parameters case ScFunctionExpr(params, _) => params case _ => return }	Seq[ScParameter]	parameters
ArrayBuffer[ScReferenceExpression]()	ArrayBuffer[ScReferenceExpression]	collectedRefs
new ScalaRecursiveElementVisitor { override def visitReferenceExpression(ref: ScReferenceExpression) { if (ref.qualifier.nonEmpty) return ref.bind() match { case Some(srr @ ScalaResolveResult(p: ScParameter, _)) if parameters.contains(p) || srr.isNamedParameter => () case Some(ScalaResolveResult(named: PsiNamedElement, _)) if !PsiTreeUtil.isAncestor(paramOwner, named, false) => collectedRefs += ref case _ => () } } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	visitor
psiClass.getContainingFile	PsiFile	psiFile
a.getNameReferenceElement	PsiJavaCodeReferenceElement	element
holder.declaredElements	Seq[PsiNamedElement]	elements
ScalaPsiUtil.getStubOrPsiSibling(lastParent)	PsiElement	run
psiFile.getVirtualFile	VirtualFile	vFile
lastParent match { case element: ScalaPsiElement => element.getDeepSameElementInContext case _ => lastParent }	PsiElement	run
mutable.ArrayBuffer.empty[ScImportStmt]	ArrayBuffer[ScImportStmt]	buffer
psiClass.getProject	Project	project
markedElements.collect { case ValidSmartPointer(element) => element }	IndexedSeq[PsiElement]	elements
myHead == null || (myHead.element match { case Some(e) => e != throwStmt case None => false })	Boolean	isNodeNeeded
ProjectRootManager.getInstance(project).getFileIndex	ProjectFileIndex	idx
idx.getOrderEntriesForFile(vFile)	List[OrderEntry]	orderEntries
mutable.HashSet.empty[ImportUsed]	mutable.HashSet[ImportUsed]	res
psiClass.qualifiedName	String	fqn
fun.containingClass.qualifiedName	String	qual
c.copy( implicitParameterType = Some(valueType), implicitReason = OkResult, unresolvedTypeParameters = Some(typeParams) )	ScalaResolveResult	result
obj match { case clauses: ScParameters => clauses.clauses.map(presentationString(_, substitutor)).mkString("") case clause: ScParameterClause => val buffer = new StringBuilder("") buffer.append("(") if (clause.isImplicit) buffer.append("implicit ") buffer.append(clause.parameters.map(presentationString(_, substitutor)).mkString(", ")) buffer.append(")") buffer.toString() case param: ScParameter => ScalaDocumentationProvider.parseParameter(param)(presentationString(_, substitutor)) case param: Parameter => val builder = new StringBuilder builder.append(param.name) builder.append(": " + presentationString(param.paramType, substitutor)) if (param.isRepeated) builder.append("*") if (param.isDefault) builder.append(" = _") builder.toString() case tp: ScType => substitutor(tp).presentableText case tp: PsiEllipsisType => presentationString(tp.getComponentType, substitutor) + "*" case tp: PsiType => presentationString(tp.toScType(), substitutor) case tp: ScTypeParamClause => tp.typeParameters.map(t => presentationString(t, substitutor)).mkString("[", ", ", "]") case param: ScTypeParam => var paramText = param.name if (param.isContravariant) paramText = "-" + paramText else if (param.isCovariant) paramText = "+" + paramText val stdTypes = param.projectContext.stdTypes param.lowerBound foreach { case stdTypes.Nothing => case tp: ScType => paramText = paramText + " >: " + presentationString(tp, substitutor) } param.upperBound foreach { case stdTypes.Any => case tp: ScType => paramText = paramText + " <: " + presentationString(tp, substitutor) } param.viewBound foreach { (tp: ScType) => paramText = paramText + " <% " + presentationString(tp, substitutor) } param.contextBound foreach { (tp: ScType) => paramText = paramText + " : " + presentationString(ScTypeUtil.stripTypeArgs(substitutor(tp)), substitutor) } paramText case param: PsiTypeParameter => var paramText = param.name //todo: possibly add supers and extends? paramText case params: PsiParameterList => params.getParameters.map(presentationString(_, substitutor)).mkString("(", ", ", ")") case param: PsiParameter => val buffer: StringBuilder = new StringBuilder("") val list = param.getModifierList if (list == null) return "" val lastSize = buffer.length for (a <- list.getAnnotations) { if (lastSize != buffer.length) buffer.append(" ") val element = a.getNameReferenceElement if (element != null) buffer.append("@").append(element.getText) } if (lastSize != buffer.length) buffer.append(" ") val name = param.name if (name != null) { buffer.append(name) } buffer.append(": ") buffer.append(presentationString(param.getType, substitutor)) //todo: create param type, java.lang.Object => Any buffer.toString() case fun: ScFunction => val buffer: StringBuilder = new StringBuilder("") fun.getParent match { case _: ScTemplateBody if fun.containingClass != null => val qual = fun.containingClass.qualifiedName if (qual != null) { buffer.append(qual).append(".") } case _ => } buffer.append(fun.name) fun.typeParametersClause match {case Some(tpc) => buffer.append(presentationString(tpc)) case _ =>} buffer.append(presentationString(fun.paramClauses, substitutor)).append(": ") buffer.append(presentationString(fun.returnType.getOrAny, substitutor)) buffer.toString() case elem: PsiElement => elem.getText case null => "" case _ => obj.toString }	String	res
idx.getOrderEntriesForFile(file)	List[OrderEntry]	entries
entries.get(i)	OrderEntry	entry
ScalaPsiManager.instance(project).getCachedClasses(new GlobalSearchScope(project) { override def compare(file1: VirtualFile, file2: VirtualFile): Int = 0 def contains(file: VirtualFile): Boolean = { val entries: List[OrderEntry] = idx.getOrderEntriesForFile(file) var i: Int = 0 while (i < entries.size) { { val entry: OrderEntry = entries.get(i) if (orderEntries.contains(entry)) return true } i += 1 } false } def isSearchInModuleContent(aModule: Module): Boolean = false def isSearchInLibraries: Boolean = true }, fqn)	Array[PsiClass]	classes
reference match { case null => true case ref: ScReference if ref.isValid => !ref.isReferenceTo(named) case _ => false }	Boolean	needImport
state.withForwardRef	ResolveState	forwardState
implicitParams.map(_.importsUsed).foldLeft(c.importsUsed)(_ ++ _)	Set[ImportUsed]	allImportsUsed
tryStmt.catchBlock match { case None => Nil case Some(cb) => cb.expression match { case Some(b: ScBlockExpr) if b.hasCaseClauses => for (t <- b.caseClauses.toSeq.flatMap(_.caseClauses)) yield CatchInfo(t) case _ => Nil } }	Seq[ScalaControlFlowBuilder.this.CatchInfo]	handledExnTypes
handledExnTypes.size	Int	catchedExnCount
tryStmt.finallyBlock match { case None => null case Some(x) => x }	ScFinallyBlock	fBlock
c.copy( implicitParameterType = Some(valueType), implicitParameters = implicitParams, implicitReason = OkResult, unresolvedTypeParameters = Some(typeParams), importsUsed = allImportsUsed )	ScalaResolveResult	result
Option(myHead).getOrElse(tryStmtInstr)	InstructionImpl	head
c.copy(implicitParameterType = Some(rt))	ScalaResolveResult	newCandidate
c.qualifiedName	String	qName
updateNonValueType(nonValueType0)	ScType	updated
new ScalaTokenType("class")	ScalaTokenType	ClassKeyword
new ScalaTokenType("trait")	ScalaTokenType	TraitKeyword
new ScalaTokenType("enum")	ScalaTokenType	EnumKeyword
new ScalaTokenType("object")	ScalaTokenType	ObjectKeyword
new ScalaTokenType("given")	ScalaTokenType	GivenKeyword
try { val updated = updateNonValueType(nonValueType0) if (hadDependents) UndefinedType.revertDependentTypes(updated) else updated } catch { case _: SafeCheckException => return wrongTypeParam(CantInferTypeParameterResult) }	ScType	nonValueType
new ScalaTokenType("new")	ScalaTokenType	NewKeyword
new ScalaXmlTokenType(debugName)	ScalaXmlLexer.ScalaXmlTokenType	tokenType
new ScalaTokenType("long")	ScalaTokenType	Long
new ScalaTokenType("integer")	ScalaTokenType	Integer
new ScalaTokenType("double")	ScalaTokenType	Double
ScalaProjectSettings.getInstance(project).getImplicitParametersSearchDepth	Int	depth
new ScalaTokenType("float")	ScalaTokenType	Float
new ScalaTokenType("export")	ScalaTokenType	ExportKeyword
new ScalaTokenType("then")	ScalaTokenType	Then
new ScalaTokenType("as")	ScalaTokenType	As
new ScalaTokenType("derives")	ScalaTokenType	Derives
ScalaTokenTypes.kINLINE	ScalaModifierTokenType	Inline
new ScalaTokenType("opaque")	ScalaTokenType	Opaque
depth < 0 || searchImplicitsRecursively < depth	Boolean	notTooDeepSearch
maybeClass match { case Some(clazz) => Option(clazz.qualifiedName).map(_ + "." + named.name) case _ => ScalaNamesUtil.qualifiedName(named) }	Option[String]	maybeQualifiedName
project.project != null && ScalaCodeStyleSettings.getInstance(project).REPLACE_CASE_ARROW_WITH_UNICODE_CHAR	Boolean	useUnicode
TokenSet.create( ClassKeyword, TraitKeyword, EnumKeyword, ObjectKeyword )	TokenSet	tokenSet
for { element <- elements typeElement <- collectAdjustableTypeElements(element).distinct info = SimpleInfo(typeElement) simplified <- simplify(info) shortened = shortenReference(simplified, useTypeAliases) } yield shortened	IndexedSeq[TypeAdjuster.ReplacementInfo]	infos
implicitParams0.getOrElse(Seq.empty)	Seq[ScalaResolveResult]	implicitParams
createReferenceFromText(path)	ScStableCodeReference	ref
TokenSet.create( tWHITE_SPACE_IN_LINE, tINTERPOLATED_MULTILINE_STRING, tINTERPOLATED_STRING, tINTERPOLATED_STRING_INJECTION )	TokenSet	TokensToMerge
rewriteInfosAsInfix(infos)	Seq[TypeAdjuster.ReplacementInfo]	rewrittenInfos
TokenSet.create( ScalaXmlTokenTypes.XML_DATA_CHARACTERS, ScalaXmlTokenTypes.XML_TAG_CHARACTERS, // merging can be performed in locateToken() => we need to merge both types of tokens ScalaXmlTokenTypes.XML_ATTRIBUTE_VALUE_TOKEN, ScalaXmlTokenTypes.XML_COMMENT_CHARACTERS, XmlTokenType.XML_DATA_CHARACTERS, XmlTokenType.XML_TAG_CHARACTERS, XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN, XmlTokenType.XML_PI_TARGET, XmlTokenType.XML_COMMENT_CHARACTERS )	TokenSet	TokensToMerge
Key.create[String]("type.element.to.replace")	Key[String]	toReplaceKey
fun.effectiveParameterClauses.lastOption.filter(_.isImplicit)	Option[ScParameterClause]	implicitClause
TokenSet.create( SCALA_DOC_COMMENT, tBLOCK_COMMENT, ScalaTokenTypesEx.SCALA_PLAIN_CONTENT )	TokenSet	TokensToMerge
ScalaXmlTokenType("XML_EQ")	IElementType	XML_EQ
ScalaXmlTokenType("XML_ATTRIBUTE_VALUE_START_DELIMITER")	IElementType	XML_ATTRIBUTE_VALUE_START_DELIMITER
ScalaXmlTokenType("XML_ATTRIBUTE_VALUE_TOKEN")	IElementType	XML_ATTRIBUTE_VALUE_TOKEN
ScalaXmlTokenType("XML_ATTRIBUTE_VALUE_END_DELIMITER")	IElementType	XML_ATTRIBUTE_VALUE_END_DELIMITER
ScalaXmlTokenType("XML_NAME")	IElementType	XML_NAME
ScalaXmlTokenType("XML_TAG_NAME")	IElementType	XML_TAG_NAME
ScalaXmlTokenType("XML_ATTRIBUTE_NAME")	IElementType	XML_ATTRIBUTE_NAME
ScalaXmlTokenType("XML_WHITESPACE")	IElementType	XML_WHITE_SPACE
elem.getFirstChild	PsiElement	firstChild
ScalaXmlTokenType("XML_TAG_END")	IElementType	XML_TAG_END
context.elementScope	ElementScope	scope
MacroImpl("mkSelector", "shapeless.ops.record.Selector") :: Nil	Seq[MacroImpl]	boundMacro
MacroImpl("product", "shapeless.Generic") :: MacroImpl("apply", "shapeless.LowPriorityGeneric") :: Nil	Seq[MacroImpl]	boundMacro
ScalaXmlTokenType("XML_CDATA_END")	IElementType	XML_CDATA_END
ScalaXmlTokenType("XML_PI_END")	IElementType	XML_PI_END
context.place	PsiElement	place
ScalaXmlTokenType("XML_EMPTY_ELEMENT_END")	IElementType	XML_EMPTY_ELEMENT_END
ScalaXmlTokenType("XML_START_TAG_START")	IElementType	XML_START_TAG_START
ScalaXmlTokenType("XML_END_TAG_START")	IElementType	XML_END_TAG_START
ScalaXmlTokenType("XML_CDATA_START")	IElementType	XML_CDATA_START
ScalaXmlTokenType("XML_PI_START")	IElementType	XML_PI_START
ScalaXmlTokenType("XML_DATA_CHARACTERS")	IElementType	XML_DATA_CHARACTERS
ScalaXmlTokenType("XML_COMMENT_CHARACTERS")	IElementType	XML_COMMENT_CHARACTERS
implicitClause.map { li => ScMethodType(ret, li.getSmartParameters, isImplicit = true)(place.elementScope) }.fold(ret)(subst)	ScType	methodType
ScalaXmlTokenType("XML_COMMENT_START")	IElementType	XML_COMMENT_START
ScalaXmlTokenType("XML_COMMENT_END")	IElementType	XML_COMMENT_END
context.place match { case ScMethodCall(_, Seq(ScSymbolLiteral(value))) => Some(value.name) case _ => None }	Option[String]	name
ScalaXmlTokenType("XML_BAD_CHARACTER")	IElementType	XML_BAD_CHARACTER
ScalaXmlTokenType("XML_CHAR_ENTITY_REF")	IElementType	XML_CHAR_ENTITY_REF
ScalaXmlTokenType("XML_ENTITY_REF_TOKEN")	IElementType	XML_ENTITY_REF_TOKEN
ScalaXmlTokenType("XML_TAG_CHARACTERS")	IElementType	XML_TAG_CHARACTERS
this.getContainingFile match { case sf: ScalaFile => sf case _ => return }	ScalaFile	file
findValType(name.get)(context.expectedType.get)	Option[ScType]	vt
vt.map(_.canonicalText).getOrElse("Any")	String	Out
MacroImpl("applyDynamic", "shapeless.ProductArgs") :: Nil	Seq[MacroImpl]	boundMacro
resolveResult.nameArgForDynamic match { case Some(name) => name case _ => //todo: support explicit invocation like x.applyDynamic("methodName")(args) return None }	String	nameArg
mc.argumentExpressions.map(_.`type`().getOrAny)	IndexedSeq[ScType]	argTypes
MacroImpl("materialize", "shapeless.Generic") :: Nil	Seq[MacroImpl]	boundMacro
hlistText(argTypes)	String	productType
TokenSet.create( XML_PI, XML_ATTRIBUTE, XML_CD_SECT, XML_COMMENT, XML_ELEMENT, XML_EMPTY_TAG, XML_END_TAG, XML_EXPR, XML_PATTERN, XML_START_TAG, ScalaTokenTypesEx.SCALA_IN_XML_INJECTION_START, ScalaTokenTypesEx.SCALA_IN_XML_INJECTION_END, XML_EQ, XML_ATTRIBUTE_VALUE_START_DELIMITER, XML_NAME, XML_TAG_END, XML_CDATA_END, XML_PI_END, XML_EMPTY_ELEMENT_END, XML_START_TAG_START, XML_END_TAG_START, XML_CDATA_START, XML_PI_START, XML_DATA_CHARACTERS, XML_COMMENT_CHARACTERS)	TokenSet	XML_ELEMENTS
s"null: $productType"	String	exprOfProductType
typeParameters.map(TypeParameter(_).update(subst))	IndexedSeq[TypeParameter]	polymorphicTypeParameters
TokenSet.create(XML_COMMENT_START, XML_COMMENT_CHARACTERS, XML_COMMENT_END)	TokenSet	XML_COMMENTS
extractTargetType(context)	ScType	targetType
if (polymorphicTypeParameters.isEmpty) methodType else ScTypePolymorphicType(methodType, polymorphicTypeParameters)	ScType	nonValueType0
if (invokedExprText.isEmpty) "" else s"$invokedExprText."	String	invokedWithDot
extractFields(targetType).map(_._2)	IndexedSeq[ScType]	fields
OptimizeImportSettings(file).copy(classCountToUseImportOnDemand = Int.MaxValue)	OptimizeImportSettings	settings
coreType(tp)	ScType	coreTypeForTp
hlistText(fields)	String	reprTpStr
findOptimizerFor(file) match { case Some(o: ScalaImportOptimizer) => o case _ => return }	ScalaImportOptimizer	optimizer
s"$invokedWithDot${nameArg}Product($exprOfProductType)"	String	newCallText
newTypeElem(replacement, place).calcType	ScType	replacementType
s"$fqGeneric.Aux[${targetType.canonicalText}, $reprTpStr]"	String	genericStr
s match { case Seq() => Some(Unit) // object A { def foo(a: Any) = ()}; A foo () ==>> A.foo(()), or A.foo() ==>> A.foo( () ) case _ => def getType(expression: Expression) = { val (result, _) = expression.getTypeAfterImplicitConversion(checkImplicits = true, isShape = false, None) result.getOrAny } TupleType(s.map(getType)) match { case t if t.isNothing => None case t => Some(t) } }	Option[ValueType]	maybeType
getImportStatements.lastOption.getOrElse(getFirstChild.getNextSibling)	PsiElement	place
coreElement.getOrElse(place)	PsiElement	element
sibling.getNextSibling	PsiElement	child
fun.name	String	name
fun	ProjectContext	ctx
fun.containingClass	ScTemplateDefinition	clazz
replacementType.removeAliasDefinitions(expandableOnly = true)	ScType	withoutAliases
MacroImpl("selectDynamic", "shapeless.Witness") :: Nil	Seq[MacroImpl]	boundMacro
MacroImpl("mkDefaultSymbolicLabelling", "shapeless.DefaultSymbolicLabelling") :: Nil	Seq[MacroImpl]	boundMacro
newTypeElem(withoutAliases.canonicalText, place)	ScTypeElement	newTypeElement
functionTypeNoImplicits(fun)	Option[ScType]	ft
extractTargetType(context)	ScType	targetClass
extractFields(targetClass)	Seq[(String, ScType)]	fields
e match { case r: ScStableCodeReference => r case _ => return None }	ScStableCodeReference	ref
ScalaMacroEvaluator.getInstance(project)	ScalaMacroEvaluator	macroEvaluator
fields.foldRight(fqHNil) { case ((pName, pType), suffix) => s"$fqColonColon[${mkParamTp(pName, pType.canonicalText)}, $suffix]" }	String	reprTpStr
fun match { case fun: ScFunction => fun.typeParameters case fun: PsiMethod => fun.getTypeParameters.toSeq }	Seq[PsiTypeParameter]	typeParameters
s""" |object `$literalText` { | type T = $literalText | type Field[V] = $fqFieldType[$literalText, V] | type ->>[V] = Field[V] |}""".stripMargin	String	text
s"$fqDefSymLab.Aux[${targetClass.canonicalText}, $reprTpStr]"	String	genericStr
macroEvaluator.checkMacro(fun, MacroContext(place, Some(tp))) getOrElse _funType	ScType	funType
createObjectWithContext(text, insertionPlace.getContext, insertionPlace)	ScObject	typeCarrier
ScalaPsiUtil.undefineMethodTypeParams(fun)	ScSubstitutor	undefineTypeParams
subst.followed(undefineTypeParams)(funType)	ScType	substedFunTp
ApplyOrUpdateInvocation(call, tp, isDynamic)	ApplyOrUpdateInvocation	applyOrUpdateInvocation
Some(tp)	Option[ScType]	res
mutable.HashMap.empty	mutable.HashMap[Place, MacroExpansion]	collectedExpansions
_	ScalaReflectMacroExpansionParser	parser
approximateDependent(substedFunTp, fun.parameters.toSet)	Option[ScType]	withoutDependents
ScUnderScoreSectionUtil.underscores(expr)	Seq[ScUnderscoreSection]	seq
withoutDependents.nonEmpty	Boolean	hadDependents
withoutDependents.getOrElse(substedFunTp)	ScType	updatedRetType
false	Boolean	hasDependents
ProjectRootManager.getInstance(element.getProject).getFileIndex	ProjectFileIndex	index
paths .filterNot(samePackage) .flatMap(createInfoFromPath(_, place)) .filter(hasValidQualifier(_, place))	IndexedSeq[ImportInfo]	importInfosToAdd
PsiTreeUtil.getParentOfType(elem, classOf[ScAnnotation]) match { case _: ScAnnotation => elem.getTextOffset case _ => elem.getNode.getTextRange.getEndOffset }	Int	offset
packageFqn.lastIndexOf('.')	Int	lastDot
new Key[UndoExpansionData]("MACRO_EXPANDED_KEY")	Key[MacroExpansionLineMarkerProvider.this.UndoExpansionData]	EXPANDED_KEY
NotificationGroup.toolWindowGroup("macroexpand_messages", ToolWindowId.MESSAGES_WINDOW)	NotificationGroup	messageGroup
tpe.updateRecursively { case original @ ScProjectionType(ScDesignatorType(p: ScParameter), _) if params.contains(p) => hasDependents = true UndefinedType(p, original) }	ScType	updated
Place(path, offset)()	Place	place
LibraryExtensionsManager.getInstance(project) .getExtensions(tag.runtimeClass).asInstanceOf[Seq[T]]	Seq[T]	external
tp.updateLeaves { case ScAbstractType(_, _, upper) => upper }	ScType	noAbstracts
optimizer.collectImportRanges(this, createInfo(_), Set.empty)	Set[RangeInfo]	importRanges
v.`type`().getOrAny	ScType	valueType
if (importRanges.isEmpty) true else refsContainer == null && hasCodeBeforeImports	Boolean	needToInsertFirst
DaemonCodeAnalyzer.getInstance(project)	DaemonCodeAnalyzer	analyzer
PsiManager.getInstance(project)	PsiManager	psiManager
createImportFromText("import dummy.dummy")	ScImportStmt	dummyImport
x.expandMacro(m, context)	Option[ScExpression]	expanded
insertFirstImport(dummyImport, getFirstChild).asInstanceOf[ScImportStmt]	ScImportStmt	inserted
MacroImpl(m.name, m.containingClass.qualifiedName)	MacroImpl	macroImpl
Key.create("macro.original.expression")	Key[AnyRef]	isMacroExpansionKey
ParsingState.PLACE	ScalaReflectMacroExpansionParser.this.ParsingState.Value	parsingState
Seq( ShapelessForProduct, ShapelessMaterializeGeneric, ShapelessDefaultSymbolicLabelling, ShapelessMkSelector, ShapelessWitnessSelectDynamic )	Seq[ScalaMacroTypeable]	defaultTypeProviders
PsiAnchor.create(inserted)	PsiAnchor	psiAnchor
Seq( ShapelessProductArgs )	Seq[ScalaMacroExpandable]	defaultExprProviders
mutable.ArrayBuffer[MacroExpansion]()	ArrayBuffer[MacroExpansion]	expansions
ReflectExpansionsCollector.getInstance(element.getProject)	ReflectExpansionsCollector	collector
RangeInfo(psiAnchor, psiAnchor, importInfosToAdd, usedImportedNames = Set.empty, isLocal = false)	RangeInfo	rangeInfo
element.createSmartPointer	SmartPsiElementPointer[PsiElement]	eltPointer
optimizedImportInfos(rangeInfo, settings)	Seq[ImportInfo]	infosToAdd
ensugarExpansion(expansion.body)	String	fixed
annot.constructorInvocation.reference.get.resolve().module	Option[Module]	module
importRanges.toSeq.sortBy(_.startOffset)	Seq[RangeInfo]	sortedRanges
element.getParent	PsiElement	parent
if (refsContainer != null && ScalaCodeStyleSettings.getInstance(getProject).isAddImportMostCloseToReference) sortedRanges.reverse.find(_.endOffset < refsContainer.getTextRange.getStartOffset) else sortedRanges.headOption	Option[RangeInfo]	selectedRange
ScalaPsiManager.instance(project).getCachedPackage(name).orNull	PsiPackage	psiPack
Set.empty	Set[ImportUsed]	res
if (expansion.tree.startsWith("Block")) ScalaPsiElementFactory.createExpressionFromText(fixed) else ScalaPsiElementFactory.createBlockExpressionWithoutBracesFromText(fixed)	ScExpression	psi
new ScalaRecursiveElementVisitor { override def visitExpression(expr: ScExpression) { //Implicit parameters expr.findImplicitArguments match { case Some(results) => for (r <- results if r != null) res = res ++ r.importsUsed case _ => } //implicit conversions def addConversions(fromUnderscore: Boolean) { res = res ++ expr.getTypeAfterImplicitConversion(expectedOption = expr.smartExpectedType(fromUnderscore), fromUnderscore = fromUnderscore).importsUsed } if (ScUnderScoreSectionUtil.isUnderscoreFunction(expr)) addConversions(fromUnderscore = true) addConversions(fromUnderscore = false) expr match { case f: ScFor => f.desugared() match { case Some(e) => res = res ++ getExprImports(e) case _ => } case call: ScMethodCall => res = res ++ call.getImportsUsed super.visitExpression(expr) case ref: ScReferenceExpression => res ++= ref.multiResolveScala(false).flatMap(_.importsUsed) super.visitExpression(expr) case _ => super.visitExpression(expr) } } }	ScalaRecursiveElementVisitor { def visitExpression(expr: ScExpression): Unit }	visitor
Seq( "\\<init\\>" -> "this", // replace constructor names " *\\<[a-z]+\\> *" -> "", // remove compiler attributes "super\\.this\\(\\);" -> "this();", // replace super constructor calls "def this\\(\\) = \\{\\s*this\\(\\);\\s*\\(\\)\\s*\\};" -> "", // remove invalid super constructor calls "_root_." -> "" // _root_ package is obsolete )	Seq[Nothing]	rules
start.getContainingFile	PsiFile	file
insertImportInfos(importInfosToAdd, infosFromRange, rangeStart, settings)	Seq[ImportInfo]	resultInfos
PsiTreeUtil.findCommonParent(start, end)	PsiElement	commonParent
start.getTextRange.getStartOffset	Int	startOffset
end.getTextRange.getEndOffset	Int	endOffset
commonParent.getParent	PsiElement	parent
commonParent	PsiElement	prev
mutable.ArrayBuffer.empty[PsiElement]	ArrayBuffer[PsiElement]	buffer
commonParent.getNode.getFirstChildNode	ASTNode	child
false	Boolean	writeBuffer
createReferenceFromText(importInfo.prefixQualifier, this, place)	ScStableCodeReference	ref
builder.mark	PsiBuilder.Marker	marker
s"import ${ScalaNamesUtil.escapeKeywordsFqn(path)}"	String	importText
file.findElementAt(startOffset)	PsiElement	startElem
braceReported	Boolean	br
1	Int	balance
0	Int	seen
builder.mark	PsiBuilder.Marker	classParamMarker
builder.mark	PsiBuilder.Marker	modifierMarker
false	Boolean	isModifier
createImportFromTextWithContext(importText, this, place)	ScImportStmt	importStmt
collectAdjustableTypeElements(newTypeElement).toList.collect { case typeElement if typeElement != newTypeElement => SimpleInfo(typeElement) } match { case Nil => SimpleInfo(newTypeElement).copy(place = place) case childInfos => CompoundInfo(childInfos)(place, newTypeElement) }	TypeAdjuster.ReplacementInfo with Product with Serializable	result
ScalaPsiElementFactory .createBlockExpressionWithoutBracesFromText(original.trim)(PsiManager.getInstance(element.getProject))	ScBlockImpl	newPsi
childBeforeFirstImport.getOrElse(getFirstChild)	PsiElement	firstChild
firstChild	PsiElement	nextChild
place match { case _: ScTypeElement => Some(newTypeElem(replacement, place)) case _: ScReference => newRef(replacement, place) case _ => None }	Option[ScalaPsiElement]	maybeNewElement
ScalaPsiElementFactory.createNewLine(newText)	PsiElement	indented
builder.mark()	PsiBuilder.Marker	classParamClausesMarker
findRef(place).getOrElse(place)	PsiElement	position
ScalaPsiElementFactory.createNewLine(s"$indent")	PsiElement	indented
Key.create[Int]("type.element.to.rewrite.as.infix")	Key[Int]	toRewriteKey
anchor.getNode	ASTNode	anchorNode
CodeEditUtil.addChildren(getNode, element.getNode, element.getNode, anchorNode).getPsi	PsiElement	result
createNewLine(node.getText.replaceFirst("[\n]", ""))(getManager)	PsiElement	nl
for { ResolvesTo(target) <- findRef(place) } yield replacement -> target	Option[(String, PsiElement)]	maybePair
stmt.getNode	ASTNode	node
node.getTreeNext	ASTNode	next
node.getTreePrev	ASTNode	prev
parseParent()	Boolean	result
ScalaPsiElementFactory.createTypeDefinitionWithContext(companionText.trim, parent.getContext, null)	ScTypeDefinition	definition
builder.mark	PsiBuilder.Marker	qualMarker
CodeStyleManager.getInstance(psi.getProject).reformat(psi)	PsiElement	res
new ArrayBuffer[PsiElement]	ArrayBuffer[PsiElement]	tobeDeleted
qualMarker.precede	PsiBuilder.Marker	newMarker
builder.mark()	PsiBuilder.Marker	templateMarker
builder.mark()	PsiBuilder.Marker	modifierMarker
file.findElementAt(element.getTextRange.getEndOffset)	PsiElement	nextLeaf
builder.mark	PsiBuilder.Marker	earlyMarker
new PsiElementVisitor { override def visitElement(element: PsiElement): Unit = { if (element.getNode.getElementType == ScalaTokenTypes.tSEMICOLON) { val file = element.getContainingFile val nextLeaf = file.findElementAt(element.getTextRange.getEndOffset) if (nextLeaf.isInstanceOf[PsiWhiteSpace] && nextLeaf.getText.contains("\n")) { tobeDeleted += element } } element.acceptChildren(this) } }	PsiElementVisitor { def visitElement(element: PsiElement): Unit }	v
isCaseState	Boolean	caseState
builder.mark()	PsiBuilder.Marker	modifiersMarker
builder.mark	PsiBuilder.Marker	extendsMarker
false	Boolean	nonEmpty
startElem.withParentsInFile.takeWhile(fit).toList.filterBy[T]	List[T]	allInRange
builder.mark()	PsiBuilder.Marker	tagMarker
infos .filter(_.place.parentsInFile.contains(e)) .flatMap(infoToMappings) .toMap	Map[String, PsiElement]	mappings
builder.mark()	PsiBuilder.Marker	contentMarker
(name, target) => mappings.get(name).exists(smartEquivalence(_, target))	TypePresentationContext	presentationContext
false	Boolean	isReturn
builder.mark	PsiBuilder.Marker	patternMarker
builder.mark	PsiBuilder.Marker	PIMarker
builder.mark	PsiBuilder.Marker	args
builder.mark	PsiBuilder.Marker	wild
e.calcType.presentableText(presentationContext)	String	newTypeText
builder.mark()	PsiBuilder.Marker	cDataMarker
builder.mark	PsiBuilder.Marker	commentMarker
mutable.Map.empty[String, Set[ReplacementInfo]] .withDefaultValue(Set.empty)	mutable.Map[String, Set[TypeAdjuster.ReplacementInfo]]	pathToInfo
if ((XmlContent.parse(builder) || Reference.parse(builder)) || ScalaExpr.parse(builder) || builder.skipExternalToken()) false else true	Boolean	isReturn
builder.mark	PsiBuilder.Marker	xmlMarker
builder.mark()	PsiBuilder.Marker	elemMarker
builder.mark	PsiBuilder.Marker	attributeMarker
allInRange.map(_.endOffset).max	Int	maxEndOffset
TokenSet.create(ScalaXmlTokenTypes.XML_ATTRIBUTE_VALUE_TOKEN, ScalaXmlTokenTypes.XML_CHAR_ENTITY_REF)	TokenSet	VALID_ATTRIBUTE_TOKENS
builder.mark	PsiBuilder.Marker	importExprMarker
builder.mark	PsiBuilder.Marker	constrMarker
builder.mark()	PsiBuilder.Marker	attrValueMarker
false	Boolean	patched
builder.getLatestDoneMarker	LighterASTNode	latestDoneMarker
builder.mark	PsiBuilder.Marker	importSelectorMarker
builder.mark()	PsiBuilder.Marker	sel
latestDoneMarker == null || (latestDoneMarker.getTokenType != ScalaElementType.TYPE_GENERIC_CALL && latestDoneMarker.getTokenType != ScalaElementType.MODIFIERS && latestDoneMarker.getTokenType != ScalaElementType.TYPE_PARAM_CLAUSE)	Boolean	annotationAllowed
for { info <- infos place = info.place } yield info -> ScalaAddImportAction.getImportHolder(place, place.getProject)	IndexedSeq[(TypeAdjuster.ReplacementInfo, ScImportsHolder)]	infoToHolders
builder.mark	PsiBuilder.Marker	typeMarker
false	Boolean	isTuple
typeMarker.precede()	PsiBuilder.Marker	funMarker
builder.mark	PsiBuilder.Marker	thisMarker
builder.mark	PsiBuilder.Marker	typesMarker
true	Boolean	exit
builder.mark	PsiBuilder.Marker	refMarker
thisMarker.precede	PsiBuilder.Marker	nm
builder.mark	PsiBuilder.Marker	selfTypeMarker
builder.mark	PsiBuilder.Marker	annotMarker
false	Boolean	isAnnotation
infoToHolders.map(_._2)	IndexedSeq[ScImportsHolder]	holders
builder.mark	PsiBuilder.Marker	annotationsMarker
false	Boolean	couldBeVarArg
marker.precede	PsiBuilder.Marker	nm
builder.mark	PsiBuilder.Marker	infixTypeMarker
builder.mark	PsiBuilder.Marker	refineMarker
builder.mark	PsiBuilder.Marker	compoundMarker
false	Boolean	isCompound
List[PsiBuilder.Marker]()	List[PsiBuilder.Marker]	markerList
builder.mark()	PsiBuilder.Marker	typeMarker
Refinement parse builder	Boolean	hasRefinement
curMarker.precede	PsiBuilder.Marker	newMarker
0	Int	assoc
builder.mark	PsiBuilder.Marker	newMarker
builder.mark	PsiBuilder.Marker	simpleMarker
infixTypeMarker.precede	PsiBuilder.Marker	newMarker
builder.mark	PsiBuilder.Marker	tupleMarker
holders.filterNot { holder => holders.exists(_.isAncestorOf(holder)) }	IndexedSeq[ScImportsHolder]	maxHolders
builder.mark	PsiBuilder.Marker	fMarker
builder.mark	PsiBuilder.Marker	idMarker
builder.mark	PsiBuilder.Marker	existMarker
marker.precede()	PsiBuilder.Marker	nm
nm.precede()	PsiBuilder.Marker	nm1
builder.mark	PsiBuilder.Marker	paramMarker
builder.mark()	PsiBuilder.Marker	typeParameterMarker
builder.mark	PsiBuilder.Marker	annotationMarker
false	Boolean	exist
builder.mark()	PsiBuilder.Marker	idMarker
true	Boolean	parsedType
builder.mark()	PsiBuilder.Marker	constructorMarker
parseBound(builder) _	String => Boolean	boundParser
builder.mark	PsiBuilder.Marker	funMarker
getContexts(before, topLevel.orNull) zip getContexts(after, topLevel.orNull)	IndexedSeq[(PsiElement, PsiElement)]	contexts
contexts.find { case (a, b) => a != b }	Option[(PsiElement, PsiElement)]	firstDifference
builder.mark	PsiBuilder.Marker	guardMarker
false	Boolean	isComposite
new collection.mutable.Stack[Boolean]	mutable.Stack[Boolean]	newlinesEnabled
builder.mark	PsiBuilder.Marker	pattern1Marker
builder.mark	PsiBuilder.Marker	backupMarker
builder.mark	PsiBuilder.Marker	m
builder.mark	PsiBuilder.Marker	patternsMarker
false	Boolean	end
builder.mark	PsiBuilder.Marker	caseClauseMarker
builder.mark	PsiBuilder.Marker	caseClausesMarker
Set(ScalaTokenTypes.tAT, ScalaTokenTypes.tIDENTIFIER, ScalaTokenTypes.tDOT, ScalaTokenTypes.tLPARENTHESIS)	Set[IElementType]	s
!s.contains(builder.getTokenType)	Boolean	b
builder.mark	PsiBuilder.Marker	pattern2Marker
builder.mark	PsiBuilder.Marker	parMarker
builder.mark	PsiBuilder.Marker	err
Option { myDelegate.getUserData(CONTAINING_FILE_KEY) }	Option[PsiFile]	containingFile
containingFile.exists(_.isMetaEnabled)	Boolean	isMetaEnabled
collectImportHolders(otherResolve)	Map[TypeAdjuster.ReplacementInfo, ScImportsHolder]	importHolders
builder.mark	PsiBuilder.Marker	simplePatternMarker
builder.mark	PsiBuilder.Marker	rpm
builder.mark	PsiBuilder.Marker	rb1
mutable.Map.empty[ScImportsHolder, Set[String]] .withDefaultValue(Set.empty)	mutable.Map[ScImportsHolder, Set[String]]	result
new Stack[PsiBuilder.Marker]	mutable.Stack[PsiBuilder.Marker]	markerStack
new Stack[String]	mutable.Stack[String]	opStack
builder.mark	PsiBuilder.Marker	defMarker
info.pathsToImport	List[String]	pathsToImport
containingFile.exists(_.isTrailingCommasEnabled)	Boolean	_isTrailingCommasEnabled
builder.mark	PsiBuilder.Marker	dclMarker
builder.mark	PsiBuilder.Marker	faultMarker
false	Boolean	exit
backupMarker.precede	PsiBuilder.Marker	newMarker
None	Option[ScTypeAliasDefinition]	collected
new FindTypeAliasProcessor	FindTypeAliasProcessor	processor
builder.mark	PsiBuilder.Marker	someMarker
containingFile.exists(_.isIdBindingEnabled)	Boolean	_isIdBindingEnabled
builder.mark	PsiBuilder.Marker	pattern2sMarker
false	Boolean	hasTypeDcl
builder.mark	PsiBuilder.Marker	returnMarker
words.dropRight(prefixLength).mkString(".")	String	packageName
builder.mark	PsiBuilder.Marker	valDefMarker
words.takeRight(prefixLength + 1).mkString(".")	String	prefixed
if (TypeParamClause.parse(builder)) { true } else false	Boolean	isTypeParamClause
builder.mark	PsiBuilder.Marker	patVarMarker
builder.mark	PsiBuilder.Marker	constrExprMarker
false	Boolean	hasSemicolon
builder.mark	PsiBuilder.Marker	exprMarker
builder.mark	PsiBuilder.Marker	pmarker
pmarker.precede	PsiBuilder.Marker	psm
psm.precede	PsiBuilder.Marker	pssm
builder.mark()	PsiBuilder.Marker	rollbackMarker
builder.mark	PsiBuilder.Marker	rollbackMarker
builder.mark	PsiBuilder.Marker	catchMarker
builder.mark	PsiBuilder.Marker	finallyMarker
builder.mark	PsiBuilder.Marker	ipmarker
builder.mark	PsiBuilder.Marker	bindingsMarker
Nil	List[IElementType]	tts
bindingsMarker.precede	PsiBuilder.Marker	pm
builder.mark	PsiBuilder.Marker	blockExprMarker
builder.mark	PsiBuilder.Marker	backMarker
builder.mark	PsiBuilder.Marker	blockMarker
builder.mark()	PsiBuilder.Marker	bm
parseImpl(builder)	Int	count
builder.mark	PsiBuilder.Marker	genMarker
builder.mark	PsiBuilder.Marker	ascriptionMarker
builder.mark	PsiBuilder.Marker	seqArgMarker
0	Int	x
builder.mark	PsiBuilder.Marker	forBindingMarker
builder.mark	PsiBuilder.Marker	prefixMarker
builder.mark	PsiBuilder.Marker	refExpr
builder.mark	PsiBuilder.Marker	resultMarker
new MStack[PsiBuilder.Marker]	mutable.Stack[PsiBuilder.Marker]	markerStack
builder.mark()	PsiBuilder.Marker	paramMarker
builder.mark	PsiBuilder.Marker	pt
new MStack[String]	mutable.Stack[String]	opStack
target match { case clazz: PsiClass if needPrefix(clazz) => prefixAndPath(clazz.qualifiedName, 1) case _ => qualifiedName(target).flatMap(prefixAndPathGenerator) }	Option[(String, Option[String])]	maybePrefixAndPath
builder.mark	PsiBuilder.Marker	infixMarker
paramsMarker.precede	PsiBuilder.Marker	psm
true	Boolean	exitOf
builder.mark()	PsiBuilder.Marker	pmarker
builder.mark	PsiBuilder.Marker	setMarker
builder.mark	PsiBuilder.Marker	opMarker
(tokens: ju.List[IElementType], _: Boolean, _: WhitespacesAndCommentsBinder.TokenTextGetter) => tokens.size	WhitespacesAndCommentsBinder	LeftEdgeBinder
newRef(refText, place) .flatMap(reference => Option(reference.resolve()))	Option[PsiElement]	ref
null	PsiBuilder.Marker	newMarker
builder.mark	PsiBuilder.Marker	enumsMarker
false	Boolean	state
builder.getTokenType match { case ScalaTokenTypes.tSEMICOLON => builder.advanceLexer() // eat all semicolons (which is not correct), show error in ScForAnnotator CommonUtils.eatAllSemicolons(builder) false case _ if builder.newlineBeforeCurrentToken => false case _ if Guard.parse(builder) => true case _ => exit = false; true }	Boolean	guard
marker.precede	PsiBuilder.Marker	tMarker
builder.mark	PsiBuilder.Marker	argMarker
for { stub <- stub(element) parent <- stub.getParentStub.nullSafe childrenStubs = parent.getChildrenStubs maybeElement = childrenStubs.indexOf(stub) match { case -1 => null case index => at(childrenStubs)(index + (if (next) 1 else -1)) } } yield maybeElement	NullSafe[Option[PsiElement]]	container
builder.mark	PsiBuilder.Marker	postfixMarker
builder.mark	PsiBuilder.Marker	nameMarker
builder.mark	PsiBuilder.Marker	annotExprMarker
parse()	PsiBuilder.Marker	marker
builder.mark	PsiBuilder.Marker	selfMarker
0	Int	EMPTY_STATE
1	Int	FILE_STATE
2	Int	SCRIPT_STATE
builder.mark	PsiBuilder.Marker	packMarker
3	Int	ADDITIONAL_STATE
builder.mark()	PsiBuilder.Marker	prefixMarker
builder.mark()	PsiBuilder.Marker	patternArgsMarker
builder.mark()	PsiBuilder.Marker	literalMarker
getPlaceTd(placer)	ScTemplateDefinition	newTd
ScalaCodeStyleSettings.getInstance(place.getProject).hasImportWithPrefix(c.qualifiedName)	Boolean	fromSettings
Seq.empty	Seq[Nothing]	empty
EMPTY_STATE	Int	parseState
ParserState.EMPTY_STATE	Int	parseState
x match { case x: ScTypedDefinition => x case _ => return empty }	ScTypedDefinition	typed
typed.nameContext match { case e@(_: ScValue | _: ScVariable | _: ScObject) if e.getParent.isInstanceOf[ScTemplateBody] || e.getParent.isInstanceOf[ScEarlyDefinitions] => e.asInstanceOf[ScMember].containingClass case e: ScClassParameter if e.isClassMember => e.containingClass case _ => return empty }	ScTemplateDefinition	clazz
repr.mark()	PsiBuilder.Marker	marker
parse(repr)	Boolean	result
new ScalaPsiBuilderImpl(delegate)	ScalaPsiBuilder	builder
namedElementSig(x)	TermSignature	s
delegate.mark()	PsiBuilder.Marker	rootMarker
Option(c.containingClass).exists(!_.isAncestorOf(place))	Boolean	isExternalRefToInnerClass
ScStubFileElementType(ScalaLanguage.INSTANCE)	ScStubFileElementType	FileNodeType
if (withSelfType) TypeDefinitionMembers.getSelfTypeSignatures(clazz) else TypeDefinitionMembers.getSignatures(clazz)	TypeDefinitionMembers.TermNodes.Map	signatures
new ScIdListElementType	ScIdListElementType	IDENTIFIER_LIST
new ScFieldIdElementType	ScFieldIdElementType	FIELD_ID
new ScImportSelectorElementType	ScImportSelectorElementType	IMPORT_SELECTOR
new ScImportSelectorsElementType	ScImportSelectorsElementType	IMPORT_SELECTORS
new ScImportExprElementType	ScImportExprElementType	IMPORT_EXPR
new lexer.ScalaLexer	ScalaLexer	scalaLexer
ScStubFileElementType(Scala3Language.INSTANCE)	ScStubFileElementType	FileNodeType
for { ResolvesTo(target) <- findRef(element) } yield target	Option[PsiElement]	resolve
0	Int	PREFIX_COMPLETION
1	Int	JAVA_LANG
2	Int	SCALA
3	Int	SCALA_PREDEF
4	Int	PACKAGE_LOCAL_PACKAGE
5	Int	WILDCARD_IMPORT_PACKAGE
6	Int	IMPORT_PACKAGE
signatures.forName(x.name)	MixinNodes.AllNodes[TermSignature]	sigs
7	Int	PACKAGE_LOCAL
8	Int	OTHER_MEMBERS
9	Int	WILDCARD_IMPORT
10	Int	IMPORT
11	Int	OTHER_MEMBERS_SAME_UNIT
repr.isTrailingComma && repr.predict { expectedBrace == _.getTokenType && findPreviousNewLine.isDefined }	Boolean	result
(sigs.get(s): @unchecked) match { //partial match case Some(node) if !withSelfType || node.info.namedElement == x => node.supers.map { _.info } case Some(node) => node.supers.map { _.info }.filter { _.namedElement != x } :+ node.info case None => //this is possible case: private member of library source class. //Problem is that we are building signatures over decompiled class. Seq.empty }	Seq[TermSignature]	res
Set(OTHER_MEMBERS, OTHER_MEMBERS_SAME_UNIT)	Set[Int]	otherMembersValuesSet
getBeanMethods(typed)	Seq[PsiMethod]	beanMethods
ResolveUtils.getPlacePackage(getPlace)	String	placePackageName
collectPackages(getPlace)	Set[String]	suspiciousPackages
results.head	ScalaResolveResult	result
ScalaPsiUtil.fileContext(target) == ScalaPsiUtil.fileContext(place)	Boolean	sameFile
results.iterator	Iterator[ScalaResolveResult]	iterator
TypeDefinitionMembers.getSignatures(clazz).forName(method.name)	MixinNodes.AllNodes[TermSignature]	sigs
precedence(result)	Int	currentPrecedence
new TObjectIntHashMap[ScalaResolveResult](strategy)	TObjectIntHashMap[ScalaResolveResult]	precedences
0	Int	precedence
holder(result)	Int	topPrecedence
builder.lookAhead(1) match { case `tCOMMA` => Ids() ScalaElementType.EnumCases case _ => builder.advanceLexer() ClassConstr() parseParents() SingleCase }	IElementType with SelfPsiCreator	targetElementType
None	Option[Int]	knownPriority
knownPriority	Option[Int]	oldPriority
new ScImportStmtElementType("ScImportStatement") { override protected def createPsi(stub: ScImportStmtStub, nodeType: this.type, node: ASTNode, debugName: String) = new ScImportStmtImpl(stub, nodeType, node, debugName) }	ScImportStmtElementType { def createPsi(stub: ScImportStmtStub, nodeType: this.type, node: ASTNode, debugName: String): ScImportStmtImpl }	ImportStatement
element.nameContext match { case e@(_: ScTypeAlias | _: ScTrait | _: ScClass) if e.getParent.isInstanceOf[ScTemplateBody] => e.asInstanceOf[ScMember].containingClass case _ => return Seq.empty }	ScTemplateDefinition	clazz
RecursionState(Set.empty, Set.empty)	BaseProcessor.RecursionState	empty
Set.empty	Set[ScalaResolveResult]	candidatesSet
true	Boolean	accessibility
ScalaCodeFoldingSettings.getInstance()	ScalaCodeFoldingSettings	foldingSettings
node.getTextRange	TextRange	nodeTextRange
new ScImportStmtElementType("ScExportStatement") { override protected def createPsi(stub: ScImportStmtStub, nodeType: this.type, node: ASTNode, debugName: String) = new ScExportStmtImpl(stub, nodeType, node, debugName) }	ScImportStmtElementType { def createPsi(stub: ScImportStmtStub, nodeType: this.type, node: ASTNode, debugName: String): ScExportStmtImpl }	ExportStatement
node.getTreeParent	ASTNode	treeParent
if (withSelfType) TypeDefinitionMembers.getSelfTypeTypes(clazz) else TypeDefinitionMembers.getTypes(clazz)	TypeDefinitionMembers.TypeNodes.Map	types
ValueDeclaration	ScPropertyElementType[ScValueDeclaration]	VALUE_DECLARATION
PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_TYPE | PsiFormatUtilBase.TYPE_AFTER	Int	PARAM_OPTIONS
candidatesS	Set[ScalaResolveResult]	set
method.elementScope	ElementScope	elementScope
set.size	Int	size
ValueDefinition	ScPropertyElementType[ScPatternDefinition]	PATTERN_DEFINITION
toInnerSRR(result)	MostSpecificUtil.this.InnerScalaResolveResult[ScalaResolveResult]	inner
FoldingGroup.newGroup("typelambda")	FoldingGroup	group
new TextRange(nodeTextRange.getStartOffset, typeParamClause.getTextRange.getStartOffset)	TextRange	range1
JavaArrayFactoryUtil.ScalaResolveResultFactory.create(size)	Array[ScalaResolveResult]	res
set.iterator	Iterator[ScalaResolveResult]	iter
VariableDeclaration	ScPropertyElementType[ScVariableDeclaration]	VARIABLE_DECLARATION
iter.next()	ScalaResolveResult	next
true	Boolean	classKind
VariableDefinition	ScPropertyElementType[ScVariableDefinition]	VARIABLE_DEFINITION
new FoldingDescriptor(node, range1, group) { override def getPlaceholderText: String = typeName }	FoldingDescriptor { def getPlaceholderText: String }	d1
new TextRange(aliasedType.getTextRange.getEndOffset, nodeTextRange.getEndOffset)	TextRange	range2
FunctionDeclaration	ScFunctionElementType[ScFunctionDeclaration]	FUNCTION_DECLARATION
FunctionDefinition	ScFunctionElementType[ScFunctionDefinition]	FUNCTION_DEFINITION
SyntheticClasses.get(place.getProject).stringPlusMethod	ScType => ScSyntheticFunction	plusMethod
new FoldingDescriptor(aliasedType.getNode, range2, group) { override def getPlaceholderText = "" }	FoldingDescriptor { def getPlaceholderText: Nothing }	d2
Set("java.lang", "scala", "scala.Predef")	Set[String]	IgnoredPackages
clazz.isInstanceOf[ScObject]	Boolean	isObject
MacroDefinition	ScFunctionElementType[ScMacroDefinition]	MACRO_DEFINITION
new ScTypeAliasDeclarationElementType	ScTypeAliasDeclarationElementType	TYPE_DECLARATION
new ScPatternListElementType	ScPatternListElementType	PATTERN_LIST
new ScTypeAliasDefinitionElementType	ScTypeAliasDefinitionElementType	TYPE_DEFINITION
new ScEarlyDefinitionsElementType	ScEarlyDefinitionsElementType[Nothing]	EARLY_DEFINITIONS
new mutable.Stack[PsiElement]	mutable.Stack[PsiElement]	stack
new ScModifiersElementType("moifiers")	ScModifiersElementType	MODIFIERS
new ScAccessModifierElementType	ScAccessModifierElementType	ACCESS_MODIFIER
new ScAnnotationElementType	ScAnnotationElementType	ANNOTATION
new ScAnnotationsElementType	ScAnnotationsElementType	ANNOTATIONS
if (!strict) element else { if (element == null) return null.asInstanceOf[T] element.getContext }	PsiElement	el
if (!strict) element else { if (element == null) return null element.getContext }	PsiElement	el
ScPackagingElementType	ScPackagingElementType.type	PACKAGING
new ScExtendsBlockElementType	ScExtendsBlockElementType	EXTENDS_BLOCK
new ScTemplateParentsElementType	ScTemplateParentsElementType	TEMPLATE_PARENTS
new ScTemplateBodyElementType	ScTemplateBodyElementType	TEMPLATE_BODY
new signatures.ScParameterElementType	ScParameterElementType	PARAM
new signatures.ScParamClauseElementType	ScParamClauseElementType	PARAM_CLAUSE
new signatures.ScParamClausesElementType	ScParamClausesElementType	PARAM_CLAUSES
null	GlobalSearchScope	resolveScope
clazz.getTypeWithProjections().getOrElse(return true)	ScType	clazzType
new signatures.ScClassParameterElementType	ScClassParameterElementType	CLASS_PARAM
new ScTypeParamClauseElementType	ScTypeParamClauseElementType	TYPE_PARAM_CLAUSE
new ScTypeParamElementType	ScTypeParamElementType	TYPE_PARAM
new ScSelfTypeElementElementType	ScSelfTypeElementElementType	SELF_TYPE
new ScPrimaryConstructorElementType	ScPrimaryConstructorElementType	PRIMARY_CONSTRUCTOR
new ArrayBuffer[HistoryEvent]	ArrayBuffer[ResolveProcessor.HistoryEvent]	history
false	Boolean	fromHistory
new mutable.HashSet[ScalaResolveResult]()	mutable.HashSet[ScalaResolveResult]	ignoredSet
ref.getParent match { case _: ScThisReference | _: ScSuperReference => true case _ => false }	Boolean	isThisOrSuperResolve
rest.map(toInnerSRR)	IndexedSeq[MostSpecificUtil.this.InnerScalaResolveResult[ScalaResolveResult]]	inners
new SimpleTopPrecedenceHolder	SimpleTopPrecedenceHolder	holder
{ named match { case memb: PsiMember => memb case _ => ScalaPsiUtil.nameContext(named) match { case memb: PsiMember => memb case _ => return true //something strange } } }	PsiMember	memb
toInnerSRR(result)	MostSpecificUtil.this.InnerScalaResolveResult[ScalaResolveResult]	innerResult
isAccessible(namedElement, ref)	Boolean	accessible
new ScalaResolveResult(ScPackageImpl(pack), state.substitutor, state.importsUsed, renamed, isAccessible = accessible)	ScalaResolveResult	resolveResult
ScSubstitutor.bind(typeParams)(UndefinedType(_))	ScSubstitutor	s
if (a1.getPrevSibling.isInstanceOf[PsiWhiteSpace]) a1.getPrevSibling else a1	PsiElement	startElement
caseClause.findLastChildByType(TokenSet.create(tFUNTYPE, tFUNTYPE_ASCII))	PsiElement	funTypeToken
if (a2.getNextSibling.isInstanceOf[PsiWhiteSpace]) a2.getNextSibling else a2	PsiElement	endElement
new mutable.HashSet[PsiElement]	mutable.HashSet[PsiElement]	processedComments
new mutable.HashSet[PsiElement]	mutable.HashSet[PsiElement]	processedRegions
node.getText.replaceFirst(".*desc\\s*=\\s*\"(.*)\".*", "$1").trim	String	customText
ScSubstitutor.bind(typeParams)(toExistentialArg)	ScSubstitutor	s
node.getText.replaceFirst("..?\\s*region(.*)", "$1").trim	String	customText
r1.element.elementScope	ElementScope	scope
node.getTreeParent	ASTNode	parent
parent.getElementType	IElementType	parentElementType
mutable.HashSet[TermSignature]()	mutable.HashSet[TermSignature]	signatures
true	Boolean	includePrefixImports
None	Option[String]	forName
from.getStartOffsetInParent	Int	startInParent
new ScTemplateDefinitionElementType[ScClass]("ScClass") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScClass], nodeType: this.type, node: ASTNode, debugName: String) = new ScClassImpl(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScClass] { def createPsi(stub: ScTemplateDefinitionStub[ScClass], nodeType: this.type, node: ASTNode, debugName: String): ScClassImpl }	ClassDefinition
startInParent + from.getTextLength	Int	endInParent
node.getPsi.asInstanceOf[ScMatch].children	Iterator[PsiElement]	children
state.renamed.getOrElse(namedElement.name)	String	elementName
createExpressionFromText(modifiedParentText, parent.getContext)	ScExpression	modifiedParent
false	Boolean	passedMatch
!fromHistory && super.ignored(results)	Boolean	result
findCandidates(namedElement)	Seq[(PsiNamedElement, Boolean)]	candidates
func.body.orNull	ScExpression	body
body.getTextRange	TextRange	range
createScalaFileFromText(text)(expr.getManager)	ScalaFile	dummyFile
state.substitutor	ScSubstitutor	substitutor
range.getStartOffset + 1 < range.getEndOffset	Boolean	isCorrectRange
if (isMultilineBody) range else null	TextRange	textRange
from.getParent	PsiElement	parent
expr.getText.last	Char	lastChar
state.implicitConversion	Option[ScalaResolveResult]	implicitConversion
node	ASTNode	next
next.getTextRange.getEndOffset	Int	last
state .withCompoundOrSelfType(t) .withSubstitutor(ScSubstitutor(ScThisType(clazz)))	ResolveState	newState
null	PsiElement	end
comment.getNextSibling	PsiElement	current
true	Boolean	flag
current.getNode	ASTNode	node
node.getElementType	IElementType	elementType
element.getNextSibling	PsiElement	current
selfType.glb(clazzType)	ScType	glb
createResolveResults(candidates, substitutor, implicitConversion)	Seq[ScalaResolveResult]	resolveResults
state.withCompoundOrSelfType(t)	ResolveState	newState
true	Boolean	break
new ScTemplateDefinitionElementType[ScTrait]("ScTrait") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScTrait], nodeType: this.type, node: ASTNode, debugName: String) = new ScTraitImpl(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScTrait] { def createPsi(stub: ScTemplateDefinitionStub[ScTrait], nodeType: this.type, node: ASTNode, debugName: String): ScTraitImpl }	TraitDefinition
e.getParent	PsiElement	parent
e match { case p: ScParameter => p.getRealParameterType case _ => e.`type`() }	result.TypeResult	result
tp.typeElement	ScTypeElement	element
tp.nameId	PsiElement	nameId
getSignature(namedElement, substitutor)	Option[TermSignature]	maybeSignature
p.paramType match { case ScExistentialType(q, _) => ScExistentialType(q.tryWrapIntoSeqType) case paramType => paramType.tryWrapIntoSeqType }	ScType	newParamType
if (params1.nonEmpty) 0.max(length - params1.length) else 0	Int	i
new Expression(if (params1.nonEmpty) params1.last.paramType else Nothing, elem)	Compatibility.Expression	default
state.isNamedParameter	Boolean	isNamedParameter
params1.map(p => new Expression(p.paramType, elem)) ++ Seq.fill(i)(default)	Seq[Compatibility.Expression]	exprs
nameContext(signature.namedElement)	PsiElement	element
state.withSubstitutor(ScSubstitutor(p))	ResolveState	newState
p.substitutor(ParameterizedType(tpt.upperType, typeArgs))	ScType	substedType
new ScProjectionType.withActual(updateWithProjectionSubst)	ScProjectionType.withActual	withActual
simpleBoundName(typeElement)	Option[String]	boundName
NameTransformer.encode(typeParameter.name)	String	tpName
isNamedParameter || isAccessible(namedElement, ref)	Boolean	accessible
(calcParams(t1, undefine = false), calcParams(t2, undefine = true)) match { case (Left(p1), Left(p2)) => var (params1, params2) = (p1, p2) if ((t1.isInstanceOf[ScTypePolymorphicType] && t2.isInstanceOf[ScTypePolymorphicType] || (!(m1.isInstanceOf[ScFunction] || m1.isInstanceOf[ScFun] || m1.isInstanceOf[ScPrimaryConstructor]) || !(m2.isInstanceOf[ScFunction] || m2.isInstanceOf[ScFun] || m2.isInstanceOf[ScPrimaryConstructor]))) && (lastRepeated(params1) ^ lastRepeated(params2))) return lastRepeated(params2) //todo: this is hack!!! see SCL-3846, SCL-4048 if (lastRepeated(params1) && !lastRepeated(params2)) params1 = params1.map { case p: Parameter if p.isRepeated => implicit val scope: ElementScope = r1.element.elementScope val newParamType = p.paramType match { case ScExistentialType(q, _) => ScExistentialType(q.tryWrapIntoSeqType) case paramType => paramType.tryWrapIntoSeqType } Parameter( p.name, p.deprecatedName, newParamType, p.expectedType, p.isDefault, isByName = p.isByName ) case p => p } val i: Int = if (params1.nonEmpty) 0.max(length - params1.length) else 0 val default: Expression = new Expression(if (params1.nonEmpty) params1.last.paramType else Nothing, elem) val exprs: Seq[Expression] = params1.map(p => new Expression(p.paramType, elem)) ++ Seq.fill(i)(default) Compatibility.checkConformance(checkNames = false, params2, exprs, checkImplicits) case (Right(type1), Right(type2)) => type1.conforms(type2, ConstraintSystem.empty) //todo: with implcits? //todo this is possible, when one variant is empty with implicit parameters, and second without parameters. //in this case it's logical that method without parameters must win... case (Left(_), Right(_)) if !r1.implicitCase => return false case _ => return true }	ConstraintsResult	conformance
undefined	ConstraintSystem	u
alias.upperBound.getOrElse(return true)	ScType	upper
if (updateWithProjectionSubst) ScSubstitutor(proj) followed s else s	ScSubstitutor	subst
new ScTemplateDefinitionElementType[ScObject]("ScObject") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScObject], nodeType: this.type, node: ASTNode, debugName: String) = new ScObjectImpl(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScObject] { def createPsi(stub: ScTemplateDefinitionStub[ScObject], nodeType: this.type, node: ASTNode, debugName: String): ScObjectImpl }	ObjectDefinition
expressions.collect { case ScAssignment(reference: ScReferenceExpression, _) => reference.qualifier }	IndexedSeq[Option[ScExpression]]	qualifiers
namedElement match { case AuxiliaryConstructor(_) => Seq.empty // do not add constructor case definition: ScTypeDefinition => (Seq(definition) ++ getCompanionModule(definition)).map((_, false)) case _ => val isNamedParameter = state.isNamedParameter Seq((namedElement, isNamedParameter)) }	Seq[(PsiNamedElement, Boolean)]	results
ScalaPsiManager.instance(place.getProject).getCachedClass(scope, "java.lang.Object").orNull	PsiClass	obj
typeParams.map { _.typeParamId }.toSet	Set[Long]	typeParamIds
Set("hashCode", "toString", "equals", "getClass")	Set[Nothing]	namesSet
obj.getMethods.iterator	Iterator[PsiMethod]	methods
methods.next()	PsiMethod	method
getType(e1, r1.implicitCase)	ScType	t1
getType(e2, r2.implicitCase)	ScType	t2
if (isAsSpecificAs(r1, r2, checkImplicits)) 1 else 0	Int	s1
if (isDerived(getClazz(r1), getClazz(r2))) 1 else 0	Int	s2
state.substitutorWithThisType	ScSubstitutor	s
ref.getContext match { case postfix: ScPostfixExpr => Left(postfix) case MethodInvocation(`ref`, expressions) => Right(expressions) case _ => Left(ref) }	Either[ScExpression, Seq[ScExpression]]	expressionsOrContext
relativeWeight(r1, r2, checkImplicits)	Int	weightR1R2
state.compoundOrThisType	Option[ScType]	compoundOrThis
relativeWeight(r2, r1, checkImplicits)	Int	weightR2R1
expressionsOrContext match { case Right(expressions) => getDynamicNameForMethodInvocation(expressions) case Left(reference) => reference.getContext match { case ScAssignment(`reference`, _) => UPDATE_DYNAMIC case _ => SELECT_DYNAMIC } }	String	name
applicable.iterator	Iterator[MostSpecificUtil.this.InnerScalaResolveResult[T]]	a1iterator
createExpressionFromText("\"\"")(qualifier.projectContext)	ScExpression	emptyStringExpression
if (compoundOrThis.nonEmpty) subst else subst.followed(s)	ScSubstitutor	newSubst
a1iterator.next()	MostSpecificUtil.this.InnerScalaResolveResult[T]	a1
applicable.iterator	Iterator[MostSpecificUtil.this.InnerScalaResolveResult[T]]	a2iterator
fromType match { case Some(tp) => Right(ScProjectionType(tp, obj)) case _ => obj.`type`() }	result.TypeResult	typeResult
a2iterator.next()	MostSpecificUtil.this.InnerScalaResolveResult[T]	a2
new CollectMethodsProcessor(ref, functionName)	CollectMethodsProcessor	processor
calc(checkImplicits = false)	Option[MostSpecificUtil.this.InnerScalaResolveResult[T]]	result
state.withSubstitutor(ScSubstitutor.empty)	ResolveState	newState
des match { case p: ScParameter => p.getRealParameterType case _ => des.`type`() }	result.TypeResult	typeResult
ScalaResolveState.withImportsUsed(state.importsUsed)	ResolveState	newState
state.fromType match { case Some(tp) => Right(ScProjectionType(tp, obj)) case _ => obj.`type`() }	result.TypeResult	typeResult
new CollectMethodsProcessor(ref, unapplyName)	CollectMethodsProcessor	processor
filterRest match { case Some(r) => rest.filter(!isMoreSpecific(r, _, checkImplicits = false)) case _ => rest }	Seq[MostSpecificUtil.this.InnerScalaResolveResult[T]]	filteredRest
filteredRest.head	MostSpecificUtil.this.InnerScalaResolveResult[T]	found
false	Boolean	trueResult
filteredRest.tail.iterator	Iterator[MostSpecificUtil.this.InnerScalaResolveResult[T]]	iter
parameter.owner match { case ScPrimaryConstructor.ofClass(cls) => Option(cls) case other: ScTypeParametersOwner => Option(other) case _ => None }	Option[ScTypeParametersOwner]	maybeOwner
new ArrayBuffer[InnerScalaResolveResult[T]]()	ArrayBuffer[MostSpecificUtil.this.InnerScalaResolveResult[T]]	out
iter.next()	MostSpecificUtil.this.InnerScalaResolveResult[T]	res
rest.iterator	Iterator[MostSpecificUtil.this.InnerScalaResolveResult[T]]	iter
iter.next	MostSpecificUtil.this.InnerScalaResolveResult[T]	foundMax
constraints	ConstraintSystem	innerConstraints
elem.elementScope	ElementScope	scope
processor.candidatesS.flatMap { case ScalaResolveResult(meth: PsiMethod, subst) => Some((meth, subst, Some(obj))) case _ => None }.toSeq	Seq[(PsiMethod, ScSubstitutor, Some[ScTypedDefinition])]	sigs
new ScalaResolveResult(m, subst, state.importsUsed, fromType = state.fromType, parentElement = parent, isAccessible = accessible)	ScalaResolveResult	resolveToMethod
state.fromType	Option[ScType]	fromType
processor.candidatesS.flatMap { case ScalaResolveResult(meth: PsiMethod, subst) => Some((meth, subst)) case _ => None }.toSeq	Seq[(PsiMethod, ScSubstitutor)]	sigs
new ScalaResolveResult(namedElement, subst, state.importsUsed, fromType = state.fromType, parentElement = parent, isAccessible = accessible)	ScalaResolveResult	resolveToNamed
new ScTemplateDefinitionElementType[ScEnum]("ScEnum") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScEnum], nodeType: this.type, node: ASTNode, debugName: String) = new ScEnumImpl(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScEnum] { def createPsi(stub: ScTemplateDefinitionStub[ScEnum], nodeType: this.type, node: ASTNode, debugName: String): ScEnumImpl }	EnumDefinition
new ScTemplateDefinitionElementType[ScEnumCase]("ScEnumCase") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScEnumCase], nodeType: this.type, node: ASTNode, debugName: String) = new ScEnumCaseImpl(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScEnumCase] { def createPsi(stub: ScTemplateDefinitionStub[ScEnumCase], nodeType: this.type, node: ASTNode, debugName: String): ScEnumCaseImpl }	EnumCase
new ScalaElementType("ScEnumCases") { override def createElement(node: ASTNode) = new ScEnumCasesImpl(node, toString) }	ScalaElementType { def createElement(node: ASTNode): ScEnumCasesImpl }	EnumCases
super.candidatesS	Set[ScalaResolveResult]	candidates
state.substitutorWithThisType	ScSubstitutor	defaultSubstitutor
fun.paramClauses.clauses	Seq[ScParameterClause]	clauses
constraints	ConstraintSystem	undef
candidates.filter(t => isApplicable(t))	Set[ScalaResolveResult]	filtered
sigs.map { case (m, subst) => new ScalaResolveResult(m, subst, importsUsed, renamed, implicitConversion = implFunction, implicitType = implType, fromType = fromType, parentElement = Some(obj), isAccessible = accessible && isAccessible(m, ref), isForwardReference = forwardReference, unresolvedTypeParameters = unresolvedTypeParameters) }.filter { r => !accessibility || r.isAccessible }	IndexedSeq[ScalaResolveResult]	seq
tp1.typeParameters.zip(tp2.typeParameters).iterator	Iterator[(ScTypeParam, TypeParameter)]	iter
tp1.lowerBound.getOrNothing	ScType	lower1
tp2.lowerType	ScType	lower2
MethodResolveProcessor.candidates(this, input)	Set[ScalaResolveResult]	cand1
argumentClauses	List[Seq[Compatibility.Expression]]	oldArg
if (v == Covariant) lower1.conforms(lower2, undef) else lower2.conforms(lower1, undef)	ConstraintsResult	lowerConformance
new ScTemplateDefinitionElementType[ScNewTemplateDefinition]("ScNewTemplateDefinition") { override protected def createPsi(stub: ScTemplateDefinitionStub[ScNewTemplateDefinition], nodeType: this.type, node: ASTNode, debugName: String) = new ScNewTemplateDefinitionImpl(stub, nodeType, node, debugName) }	ScTemplateDefinitionElementType[ScNewTemplateDefinition] { def createPsi(stub: ScTemplateDefinitionStub[ScNewTemplateDefinition], nodeType: this.type, node: ASTNode, debugName: String): ScNewTemplateDefinitionImpl }	NewTemplate
ScReferencePatternElementType	ScBindingPatternElementType[ScReferencePattern]	REFERENCE_PATTERN
ScTypedPatternElementType	ScBindingPatternElementType[ScTypedPattern]	TYPED_PATTERN
ScNamingPatternElementType	ScBindingPatternElementType[ScNamingPattern]	NAMING_PATTERN
tp1.upperBound.getOrAny	ScType	upper1
tp2.upperType	ScType	upper2
new ScalaElementType("constructor") { override def createElement(node: ASTNode) = new ScConstructorInvocationImpl(node) }	ScalaElementType	CONSTRUCTOR
ScalaPsiUtil.tupled(argumentClauses.head, ref)	Option[Seq[Compatibility.Expression]]	tpl
new ScalaElementType("parameter type") { override def createElement(node: ASTNode) = new ScParameterTypeImpl(node) }	ScalaElementType	PARAM_TYPE
new ScalaElementType("sequence argument type") { override def createElement(node: ASTNode) = new ScSequenceArgImpl(node) }	ScalaElementType	SEQUENCE_ARG
new ScalaElementType("reference") { override def createElement(node: ASTNode) = new ScStableCodeReferenceImpl(node) }	ScalaElementType	REFERENCE
new ScalaElementType("name value pair") { override def createElement(node: ASTNode) = new ScNameValuePairImpl(node) }	ScalaElementType	NAME_VALUE_PAIR
MethodResolveProcessor.candidates(this, input)	Set[ScalaResolveResult]	res
new ScalaElementType("annotation expression") { override def createElement(node: ASTNode) = new ScAnnotationExprImpl(node) }	ScalaElementType	ANNOTATION_EXPR
new ScTypeElementType("compound type") { override def createElement(node: ASTNode) = new ScCompoundTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	COMPOUND_TYPE
for { owner <- maybeOwner.toSeq typeParameter <- owner.typeParameters (bound, idx) <- typeParameter.contextBoundTypeElement.zipWithIndex } yield (typeParameter, bound, idx)	IndexedSeq[(ScTypeParam, ScTypeElement, Int)]	bounds
new ScTypeElementType("existential type") { override def createElement(node: ASTNode) = new ScExistentialTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	EXISTENTIAL_TYPE
new ScTypeElementType("simple type") { override def createElement(node: ASTNode) = new ScSimpleTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	SIMPLE_TYPE
Logger.getInstance("#org.jetbrains.plugins.scala.lang.resolve.processor.MethodResolveProcessor")	Logger	LOG
new ScTypeElementType("infix type") { override def createElement(node: ASTNode) = new ScInfixTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	INFIX_TYPE
new ScTypeElementType("common type") { override def createElement(node: ASTNode) = new ScFunctionalTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	TYPE
new ScTypeElementType("annotation type") { override def createElement(node: ASTNode) = new ScAnnotTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	ANNOT_TYPE
c.element	ProjectContext	ctx
new ScTypeElementType("wildcard type") { override def createElement(node: ASTNode) = new ScWildcardTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	WILDCARD_TYPE
new ScTypeElementType("tuple type") { override def createElement(node: ASTNode) = new ScTupleTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	TUPLE_TYPE
new ScTypeElementType("type in parenthesis") { override def createElement(node: ASTNode) = new ScParenthesisedTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	TYPE_IN_PARENTHESIS
new ScTypeElementType("type projection") { override def createElement(node: ASTNode) = new ScTypeProjectionImpl(node) }	ScalaElementType.ScTypeElementType	TYPE_PROJECTION
new ScTypeElementType("type generic call") { override def createElement(node: ASTNode) = new ScParameterizedTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	TYPE_GENERIC_CALL
new ScTypeElementType("Literal type") { override def createElement(node: ASTNode) = new ScLiteralTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	LITERAL_TYPE
new ScTypeElementType("type variable") { override def createElement(node: ASTNode) = new ScTypeVariableTypeElementImpl(node) }	ScalaElementType.ScTypeElementType	TYPE_VARIABLE
new ScalaElementType("type arguments") { override def createElement(node: ASTNode) = new ScTypeArgsImpl(node) }	ScalaElementType	TYPE_ARGS
new ScalaElementType("existential clause") { override def createElement(node: ASTNode) = new ScExistentialClauseImpl(node) }	ScalaElementType	EXISTENTIAL_CLAUSE
new ScalaElementType("common type") { override def createElement(node: ASTNode) = new ScTypesImpl(node) }	ScalaElementType	TYPES
new ScExpressionElementType("prefix expression") { override def createElement(node: ASTNode) = new ScPrefixExprImpl(node) }	ScalaElementType.ScExpressionElementType	PREFIX_EXPR
new ScExpressionElementType("postfix expression") { override def createElement(node: ASTNode) = new ScPostfixExprImpl(node) }	ScalaElementType.ScExpressionElementType	POSTFIX_EXPR
new ScExpressionElementType("infix expression") { override def createElement(node: ASTNode) = new ScInfixExprImpl(node) }	ScalaElementType.ScExpressionElementType	INFIX_EXPR
new ScExpressionElementType("simple expression") { override def createElement(node: ASTNode) = new ScUnderscoreSectionImpl(node) }	ScalaElementType.ScExpressionElementType	PLACEHOLDER_EXPR
new ScExpressionElementType("Expression in parentheses") { override def createElement(node: ASTNode) = new ScParenthesisedExprImpl(node) }	ScalaElementType.ScExpressionElementType	PARENT_EXPR
new ScExpressionElementType("Method call") { override def createElement(node: ASTNode) = new ScMethodCallImpl(node) }	ScalaElementType.ScExpressionElementType	METHOD_CALL
new ScExpressionElementType("Reference expression") { override def createElement(node: ASTNode) = new ScReferenceExpressionImpl(node) }	ScalaElementType.ScExpressionElementType	REFERENCE_EXPRESSION
new ScExpressionElementType("This reference") { override def createElement(node: ASTNode) = new ScThisReferenceImpl(node) }	ScalaElementType.ScExpressionElementType	THIS_REFERENCE
new ScExpressionElementType("Super reference") { override def createElement(node: ASTNode) = new ScSuperReferenceImpl(node) }	ScalaElementType.ScExpressionElementType	SUPER_REFERENCE
new ScExpressionElementType("Generified call") { override def createElement(node: ASTNode) = new ScGenericCallImpl(node) }	ScalaElementType.ScExpressionElementType	GENERIC_CALL
new ScExpressionElementType("expression") { override def createElement(node: ASTNode) = new ScFunctionExprImpl(node) }	ScalaElementType.ScExpressionElementType	FUNCTION_EXPR
new ScExpressionElementType("constructor block") { override def createElement(node: ASTNode) = new ScConstrBlockImpl(node) }	ScalaElementType.ScExpressionElementType	CONSTR_BLOCK
if (v == Covariant) upper2.conforms(upper1, undef) else upper1.conforms(upper2, undef)	ConstraintsResult	upperConformance
new ScExpressionElementType("block") { override def createElement(node: ASTNode) = new ScBlockImpl(node) }	ScalaElementType.ScExpressionElementType	BLOCK
new ScExpressionElementType("Tuple") { override def createElement(node: ASTNode) = new ScTupleImpl(node) }	ScalaElementType.ScExpressionElementType	TUPLE
new ScExpressionElementType("unit expression") { override def createElement(node: ASTNode) = new ScUnitExprImpl(node) }	ScalaElementType.ScExpressionElementType	UNIT_EXPR
new ScExpressionElementType("constructor expression") { override def createElement(node: ASTNode) = new ScConstrExprImpl(node) }	ScalaElementType.ScExpressionElementType	CONSTR_EXPR
e match { case m: PsiMethod => val scope = elem.elementScope m.methodTypeProvider(scope).polymorphicType() case fun: ScFun => fun.polymorphicType() case refPatt: ScReferencePattern => refPatt.getParent /*id list*/ .getParent match { case pd: ScPatternDefinition if PsiTreeUtil.isContextAncestor(pd, elem, true) => pd.declaredType.getOrElse(Nothing) case vd: ScVariableDefinition if PsiTreeUtil.isContextAncestor(vd, elem, true) => vd.declaredType.getOrElse(Nothing) case _ => refPatt.`type`().getOrAny } case typed: ScTypedDefinition => typed.`type`().getOrAny case f: PsiField => f.getType.toScType() case _ => Nothing }	ScType	res
new ScExpressionElementType("self invocation") { override def createElement(node: ASTNode) = new ScSelfInvocationImpl(node) }	ScalaElementType.ScExpressionElementType	SELF_INVOCATION
new ScExpressionElementType("Interpolated Prefix Literal Reference") { override def createElement(node: ASTNode) = new ScInterpolatedExpressionPrefix(node) }	ScalaElementType.ScExpressionElementType	INTERPOLATED_PREFIX_LITERAL_REFERENCE
new ScExpressionElementType("if statement") { override def createElement(node: ASTNode) = new ScIfImpl(node) }	ScalaElementType.ScExpressionElementType	IF_STMT
new ScExpressionElementType("for statement") { override def createElement(node: ASTNode) = new ScForImpl(node) }	ScalaElementType.ScExpressionElementType	FOR_STMT
new ScExpressionElementType("do-while statement") { override def createElement(node: ASTNode) = new ScDoImpl(node) }	ScalaElementType.ScExpressionElementType	DO_STMT
new ScExpressionElementType("try statement") { override def createElement(node: ASTNode) = new ScTryImpl(node) }	ScalaElementType.ScExpressionElementType	TRY_STMT
new ScExpressionElementType("catch block") { override def createElement(node: ASTNode) = new ScCatchBlockImpl(node) }	ScalaElementType.ScExpressionElementType	CATCH_BLOCK
new ScExpressionElementType("finally block") { override def createElement(node: ASTNode) = new ScFinallyBlockImpl(node) }	ScalaElementType.ScExpressionElementType	FINALLY_BLOCK
new ScExpressionElementType("while statement") { override def createElement(node: ASTNode) = new ScWhileImpl(node) }	ScalaElementType.ScExpressionElementType	WHILE_STMT
new ScExpressionElementType("return statement") { override def createElement(node: ASTNode) = new ScReturnImpl(node) }	ScalaElementType.ScExpressionElementType	RETURN_STMT
new ScExpressionElementType("throw statement") { override def createElement(node: ASTNode) = new ScThrowImpl(node) }	ScalaElementType.ScExpressionElementType	THROW_STMT
new ScExpressionElementType("assign statement") { override def createElement(node: ASTNode) = new ScAssignmentImpl(node) }	ScalaElementType.ScExpressionElementType	ASSIGN_STMT
new ScExpressionElementType("match statement") { override def createElement(node: ASTNode) = new ScMatchImpl(node) }	ScalaElementType.ScExpressionElementType	MATCH_STMT
ValueSet(PACKAGE, OBJECT, VAL)	ResolveTargets.ValueSet	stableQualRef
stableQualRef + CLASS	ResolveTargets.ValueSet	stableQualOrClass
ValueSet(OBJECT, VAL, CLASS)	ResolveTargets.ValueSet	noPackagesClassCompletion
ValueSet(OBJECT, VAL, VAR, METHOD, PACKAGE, CLASS)	ResolveTargets.ValueSet	stableImportSelector
ValueSet(CLASS)	ResolveTargets.ValueSet	stableClass
ValueSet(CLASS, OBJECT)	ResolveTargets.ValueSet	stableClassOrObject
ValueSet(OBJECT, VAL)	ResolveTargets.ValueSet	objectOrValue
o.typeParameters.zip(s.typeParams).iterator	Iterator[(ScTypeParam, TypeParameter)]	iter
parameterOwner.typeParameters.zipMapped(_.name)	Seq[(ScTypeParam, String)]	namedTypeParameters
new ScExpressionElementType("typed statement") { override def createElement(node: ASTNode) = new ScTypedExpressionImpl(node) }	ScalaElementType.ScExpressionElementType	TYPED_EXPR_STMT
new ScalaElementType("generator") { override def createElement(node: ASTNode) = new ScGeneratorImpl(node) }	ScalaElementType	GENERATOR
new ScalaElementType("for binding") { override def createElement(node: ASTNode) = new ScForBindingImpl(node) }	ScalaElementType	FOR_BINDING
new ScalaElementType("enumerators") { override def createElement(node: ASTNode) = new ScEnumeratorsImpl(node) }	ScalaElementType	ENUMERATORS
new ScalaElementType("guard") { override def createElement(node: ASTNode) = new ScGuardImpl(node) }	ScalaElementType	GUARD
c.innerResolveResult match { case Some(rr) => rr case _ => c }	ScalaResolveResult	realResolveResult
new ScalaElementType("arguments of function") { override def createElement(node: ASTNode) = new ScArgumentExprListImpl(node) }	ScalaElementType	ARG_EXPRS
realResolveResult.element	PsiNamedElement	element
realResolveResult.substitutor	ScSubstitutor	s
new ScalaElementType("Interpolated Prefix Pattern Reference") { override def createElement(node: ASTNode) = new ScInterpolatedPatternPrefix(node) }	ScalaElementType	INTERPOLATED_PREFIX_PATTERN_REFERENCE
ValueSet(OBJECT, VAL, VAR, METHOD)	ResolveTargets.ValueSet	refExprLastRef
new ScalaElementType("Tuple Pattern") { override def createElement(node: ASTNode) = new ScTuplePatternImpl(node) }	ScalaElementType	TUPLE_PATTERN
new ScalaElementType("Sequence Wildcard") { override def createElement(node: ASTNode) = new ScSeqWildcardImpl(node) }	ScalaElementType	SEQ_WILDCARD
new ScalaElementType("Constructor Pattern") { override def createElement(node: ASTNode) = new ScConstructorPatternImpl(node) }	ScalaElementType	CONSTRUCTOR_PATTERN
refExprLastRef + PACKAGE	ResolveTargets.ValueSet	refExprQualRef
ValueSet(VAL, VAR, METHOD)	ResolveTargets.ValueSet	methodRef
ValueSet(METHOD)	ResolveTargets.ValueSet	methodsOnly
new ScalaElementType("Pattern arguments") { override def createElement(node: ASTNode) = new ScPatternArgumentListImpl(node) }	ScalaElementType	PATTERN_ARGS
new ScalaElementType("Infix pattern") { override def createElement(node: ASTNode) = new ScInfixPatternImpl(node) }	ScalaElementType	INFIX_PATTERN
definition.aliasedType.toOption.toSeq flatMap { _.extractClassType } flatMap { case (clazz, substitutor) => constructors(clazz, substitutor.followed(defaultSubstitutor)) }	IndexedSeq[(PsiMethod, ScSubstitutor, Some[PsiNamedElement])]	result
new ScalaElementType("Composite Pattern") { override def createElement(node: ASTNode) = new ScCompositePatternImpl(node) }	ScalaElementType	PATTERN
ValueSet(VAL, VAR)	ResolveTargets.ValueSet	valuesRef
new ScalaElementType("patterns") { override def createElement(node: ASTNode) = new ScPatternsImpl(node) }	ScalaElementType	PATTERNS
new ScalaElementType("any sequence") { override def createElement(node: ASTNode) = new ScWildcardPatternImpl(node) }	ScalaElementType	WILDCARD_PATTERN
ValueSet(VAR)	ResolveTargets.ValueSet	varsRef
new ScalaElementType("case clause") { override def createElement(node: ASTNode) = new ScCaseClauseImpl(node) }	ScalaElementType	CASE_CLAUSE
p.getTypeParameters.toSeq.zip(s.typeParams).iterator	Iterator[(PsiTypeParameter, TypeParameter)]	iter
new ScalaElementType("case clauses") { override def createElement(node: ASTNode) = new ScCaseClausesImpl(node) }	ScalaElementType	CASE_CLAUSES
s	TermSignature	sign2
new ScalaElementType("literal pattern") { override def createElement(node: ASTNode) = new ScLiteralPatternImpl(node) }	ScalaElementType	LITERAL_PATTERN
ValueSet(PACKAGE)	ResolveTargets.ValueSet	packageRef
ValueSet(CLASS, ANNOTATION)	ResolveTargets.ValueSet	annotCtor
element match { case ScalaConstructor(_) if !selfConstructorResolve => Seq(realResolveResult.getActualElement) case Constructor(_) => Seq(realResolveResult.getActualElement, element).distinct case _ => Seq(element) //do not }	Seq[PsiNamedElement]	elementsForUndefining
new ScalaElementType("interpolation pattern") { override def createElement(node: ASTNode) = new ScInterpolationPatternImpl(node) }	ScalaElementType	INTERPOLATION_PATTERN
elementsForUndefining.iterator	Iterator[PsiNamedElement]	iterator
new ScalaElementType("pattern in parenthesis") { override def createElement(node: ASTNode) = new ScParenthesisedPatternImpl(node) }	ScalaElementType	PATTERN_IN_PARENTHESIS
state.substitutor	ScSubstitutor	parentSubst
new ScalaElementType("Type pattern") { override def createElement(node: ASTNode) = new ScTypePatternImpl(node) }	ScalaElementType	TYPE_PATTERN
ScSubstitutor.empty	ScSubstitutor	tempSubstitutor
sign1.paramTypesEquivExtended(sign2, undef, falseUndef = false)	ConstraintsResult	t
namedElement match { case clazz: PsiClass => orDefault(constructors(clazz, defaultSubstitutor)) case _: ScTypeAliasDeclaration => orDefault() case definition: ScTypeAliasDefinition => val result = definition.aliasedType.toOption.toSeq flatMap { _.extractClassType } flatMap { case (clazz, substitutor) => constructors(clazz, substitutor.followed(defaultSubstitutor)) } orDefault(result) case _ => Seq() }	Seq[(PsiNamedElement, ScSubstitutor, Option[PsiNamedElement])]	tuples
new ScalaElementType("refinement") { override def createElement(node: ASTNode) = new ScRefinementImpl(node) }	ScalaElementType	REFINEMENT
new ScalaElementType("Xml expr") { override def createElement(node: ASTNode) = new ScXmlExprImpl(node) }	ScalaElementType	XML_EXPR
new ScalaElementType("Xml start tag") { override def createElement(node: ASTNode) = new ScXmlStartTagImpl(node) }	ScalaElementType	XML_START_TAG
iterator.next()	PsiNamedElement	element
new ScalaElementType("Xml end tag") { override def createElement(node: ASTNode) = new ScXmlEndTagImpl(node) }	ScalaElementType	XML_END_TAG
new ScalaElementType("Xml empty tag") { override def createElement(node: ASTNode) = new ScXmlEmptyTagImpl(node) }	ScalaElementType	XML_EMPTY_TAG
sign1.typeParams	Seq[TypeParameter]	typeParams
new ScalaElementType("Xml proccessing instruction") { override def createElement(node: ASTNode) = new ScXmlPIImpl(node) }	ScalaElementType	XML_PI
new ScalaElementType("Xml cdata section") { override def createElement(node: ASTNode) = new ScXmlCDSectImpl(node) }	ScalaElementType	XML_CD_SECT
new ScalaElementType("Xml attribute") { override def createElement(node: ASTNode) = new ScXmlAttributeImpl(node) }	ScalaElementType	XML_ATTRIBUTE
new ScalaElementType("Xml pattern") { override def createElement(node: ASTNode) = new ScXmlPatternImpl(node) }	ScalaElementType	XML_PATTERN
new ScalaElementType("Xml comment") { override def createElement(node: ASTNode) = new ScXmlCommentImpl(node) }	ScalaElementType	XML_COMMENT
new ScalaElementType("Xml element") { override def createElement(node: ASTNode) = new ScXmlElementImpl(node) }	ScalaElementType	XML_ELEMENT
s.typeParams	Seq[TypeParameter]	otherTypeParams
new ScalaElementType("Dotty refined type") { override def createElement(node: ASTNode): ScalaPsiElement = ??? }	ScalaElementType	REFINED_TYPE
new ScalaElementType("Dotty with type") { override def createElement(node: ASTNode): ScalaPsiElement = ??? }	ScalaElementType	WITH_TYPE
subst.withBindings(typeParams, typeParams)	ScSubstitutor	unified1
state.importsUsed	Set[ImportUsed]	parentImports
new ScalaElementType("Dotty type argument name") { override def createElement(node: ASTNode): ScalaPsiElement = ??? }	ScalaElementType	TYPE_ARGUMENT_NAME
namedElement match { case _: ScTypeAliasDefinition => true case constructor: PsiMethod if accessible => constructorIsAccessible(constructor) case _ => accessible }	Boolean	elementIsAccessible
tempSubstitutor.followed(ScSubstitutor.bind(prevTypeInfo)(UndefinedType(_)))	ScSubstitutor	substitutor
prevTypeInfo ++ (element match { case fun: ScFunction => fun.typeParameters.map(TypeParameter(_)) case fun: PsiMethod => fun.getTypeParameters.map(TypeParameter(_)).toSeq case _ => Seq.empty })	Seq[TypeParameter]	typeParameters
state.fromType match { case Some(tp) => ScProjectionType(tp, bind) case _ => bind.`type`().getOrAny }	ScType	typez
false	Boolean	seq
ResolveState.initial()	ResolveState	empty
ScSubstitutor.bind(otherTypeParams, typeParams.map(TypeParameterType(_)))	ScSubstitutor	unified2
eOption.get	ScType	expected
element match { case f: ScFunction if f.paramClauses.clauses.length > 1 && !f.paramClauses.clauses(1).isImplicit => problems += ExpectedTypeMismatch //do not check expected types for more than one param clauses Nothing case f: ScFunction => substitutor(f.returnType.getOrNothing) case f: ScFun => substitutor(f.retType) case m: PsiMethod => Option(m.getReturnType).map { rt => substitutor(rt.toScType()) }.getOrElse(Nothing) case _ => Nothing }	ScType	retType
new ArrayBuffer[ScalaResolveResult]	ArrayBuffer[ScalaResolveResult]	buffer
unified1(returnType)	ScType	bType
Key.create("from.type.key")	Key[ScType]	FROM_TYPE_KEY
unified2(retType)	ScType	gType
retType.typeSystem.conformsInner(expected, retType)	ConstraintsResult	conformance
clazz.getContainingClass	PsiClass	cclazz
Key.create("unresolved.type.parameters.key")	Key[Seq[TypeParameter]]	UNRESOLVED_TYPE_PARAMETERS_KEY
Key.create("compound.or.this.type.key")	Key[ScType]	COMPOUND_OR_SELF_TYPE
Key.create("forward.reference.key")	Key[ResolveStateOps.TRUE.type]	FORWARD_REFERENCE_KEY
Key.create("implicit.type")	Key[ScType]	IMPLICIT_TYPE
Key.create("implicit.function")	Key[ScalaResolveResult]	IMPLICIT_CONVERSION
patt.nonStrictParentOfType(Seq(classOf[ScVariable], classOf[ScValue])) match { case Some(_: ScVariable) => VAR case _ => VAL }	ResolveTargets.Value	value
Key.create("named.parameter.key")	Key[ResolveStateOps.TRUE.type]	NAMED_PARAM_KEY
Key.create("scala.used.imports.key")	Key[Set[ImportUsed]]	IMPORT_USED_KEY
_place	PsiElement	place
Key.create("scala substitutor key")	Key[ScSubstitutor]	SUBSTITUTOR_KEY
Key.create("prefix.completion.key")	Key[ResolveStateOps.TRUE.type]	PREFIX_COMPLETION_KEY
memb	PsiMember	member
Key.create("scala.renamed.key")	Key[String]	RENAMED_KEY
new BaseProcessor(StdKinds.methodRef) { override protected def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean = { namedElement match { case fun: ScFunction if fun.name == "unapply" || (seq && fun.name == "unapplySeq") => buffer += new ScalaResolveResult(fun, parentSubst.followed(state.substitutor), parentImports, parentElement = Some(bind), isAccessible = accessible) case _ => } true } }	BaseProcessor { def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean }	proc
place.getContainingFile.getOriginalFile	PsiFile	originalFile
originalFile.findElementAt(place.getTextRange.getStartOffset)	PsiElement	newPlace
member match { case m: PsiMethod => m.isConstructor case _ => false }	Boolean	isConstr
if (expected.equiv(api.Unit)) aResult.constraints else aResult.constraints + conformance.constraints	ConstraintSystem	substitutor
getPlaceTd(place, isConstr)	ScTemplateDefinition	placeTd
subst(namedElement match { case b: ScBindingPattern => b.`type`().getOrNothing case f: ScFieldId => f.`type`().getOrNothing case param: ScParameter => param.`type`().getOrNothing })	ScType	rt
namedElement.asInstanceOf[ScTypedDefinition]	ScTypedDefinition	dcl
dcl.isVar	Boolean	isVar
new PhysicalMethodSignature(method, subst)	PhysicalMethodSignature	sign1
sign.name	String	name
params.map(new Expression(_))	IndexedSeq[Compatibility.Expression]	args
element.name	String	name
substitutor(tp2.lowerType)	ScType	lower2
typeParameters	Seq[PsiTypeParameter]	typeParams
Compatibility.compatible(fun, substitutor, List(args), checkWithImplicits = false, scope = ref.resolveScope, isShapesResolve = isShapeResolve)	Compatibility.ConformanceExtResult	result
element match { case named: ScNamedElement => named.name case it => it.toString }	String	name
ScalaResolveResult.toStringRepresentation(this)	String	qualifiedNameId
-1	Int	precedence
namedTypeParameters.flatMap { case (typeParameter, name) => typeParameter.viewTypeElement.map((typeParameter, name, _)) }.zipWithIndex.map { case ((typeParameter, name, typeElement), index) => ParameterDescriptor(typeParameter, name, typeElement, index + 1) }	IndexedSeq[ParameterDescriptor]	views
typeElement match { case _: ScCompoundTypeElement | _: ScInfixTypeElement | _: ScFunctionalTypeElement | _: ScExistentialTypeElement => true case _ => false }	Boolean	needParenthesis
TypeParameterType(p)	TypeParameterType	tpt
o.qualifiedName	String	qualifier
getCompanionModule(placeTd).orNull	ScTypeDefinition	companion
".`package`"	String	packageSuffix
PrecedenceTypes.OTHER_MEMBERS(element, place)	Int	OTHER_MEMBERS
scMember.containingClass	ScTemplateDefinition	containingClass
qualifier.lastIndexOf('.')	Int	index
classTypeParameters.forall { p => isContextAncestor(p.getOwner, ref, true) || isSubstituted(p) }	Boolean	allTypeParametersDefined
ref.resolve()	PsiElement	resolve
substitutor(tp2.upperType)	ScType	upper2
am.getReference	PsiReference	ref
ref.resolve	PsiElement	bind
context(place)	PsiElement	placeEnclosing
placeEnclosing match { case _: ScalaFile => "" case obj: ScObject => obj.qualifiedName case pack: ScPackaging => pack.fullPackageName }	String	placePackageName
Compatibility.compatible(constr, substitutor, argumentClauses, checkWithImplicits, ref.resolveScope, isShapeResolve)	Compatibility.ConformanceExtResult	result
InternalApplicabilityProblem( "not all type parameters are defined. typeargs=[" + typeArgElements.mkString(", ") + "] and classTypeParams=[" + classTypeParameters.mkString(", ") + "]" )	InternalApplicabilityProblem	problem
views.map { case ParameterDescriptor(_, name, typeElement, index) => val needParenthesis = typeElement match { case _: ScCompoundTypeElement | _: ScInfixTypeElement | _: ScFunctionalTypeElement | _: ScExistentialTypeElement => true case _ => false } import typeElement.projectContext s"ev$$$index: $name $functionArrow ${typeElement.getText.parenthesize(needParenthesis)}" }	IndexedSeq[String]	viewsTexts
getKindsFor(ref)	Set[ResolveTargets.Value]	kinds
ref.getConstructorInvocation.get	ScConstructorInvocation	constr
if (typeParams.isEmpty) methodType(returnType) else ScTypePolymorphicType(methodType(returnType), typeParams.map(TypeParameter(_)))	ScType	tpe
constr.getClassTypeParameters.map(_.typeParameters).getOrElse(Seq())	Seq[ScTypeParam]	classTypeParameters
constr.typeArgList.map(_.typeArgs).getOrElse(Seq())	Seq[ScTypeElement]	typeArgs
o.typeParameters.zip(sign.typeParams).iterator	Iterator[(ScTypeParam, TypeParameter)]	iter
constr.containingClass.getTypeParameters	Array[PsiTypeParameter]	classTypeParmeters
argumentClauses.headOption.toList	List[Seq[Compatibility.Expression]]	args
typeArgElements.length	Int	typeArgCount
returnType.getOrElse(element.retType)	ScType	retType
tp.typeParameters.length	Int	typeParamCount
p.getTypeParameters.toSeq.zip(sign.typeParams).iterator	Iterator[(PsiTypeParameter, TypeParameter)]	iter
for { (typeParameter, name) <- namedTypeParameters (typeElement, index) <- typeParameter.contextBoundTypeElement.zipWithIndex } yield ParameterDescriptor(typeParameter, name, typeElement, index)	IndexedSeq[ParameterDescriptor]	bounds
returnType.getOrElse(element.returnType.getOrAny)	ScType	retType
element.effectiveParameterClauses	Seq[ScParameterClause]	clauses
Compatibility.compatible(tp, substitutor, args, checkWithImplicits, ref.resolveScope, isShapeResolve, ref)	Compatibility.ConformanceExtResult	result
element.parameterList	ScParameters	parameters
substitutor(sign.lowerBound).conforms(subst(tp.lowerBound.getOrNothing), undef)	ConstraintsResult	conformance
returnType.getOrElse(containingClassType)	ScType	retType
tp.getTypeParameters.length	Int	typeParamCount
element.containingClass	ScTypeDefinition	clazz
constr.arguments.toList.map(_.exprs.map(new Expression(_))) match { case List() => List(List()) case x => x }	Seq[Seq[Compatibility.Expression]]	effectiveArgs
bounds.map { case ParameterDescriptor(typeParameter, name, typeElement, index) => s"${contextBoundParameterName(typeParameter, typeElement, index)} : (${typeElement.getText})[$name]" }	IndexedSeq[String]	boundsTexts
returnType.getOrElse(computeReturnType)	ScType	retType
viewsTexts ++ boundsTexts	IndexedSeq[String]	clausesTexts
call.argumentExpressions ++ call.getContext.asInstanceOf[ScAssignment].rightExpression.toList	IndexedSeq[ScExpression]	args
if (ref.isConstructorReference && !noConstructorResolve) { val constr = ref.getConstructorInvocation.get val typeArgs = constr.typeArgList.map(_.typeArgs).getOrElse(Seq()) val effectiveArgs = constr.arguments.toList.map(_.exprs.map(new Expression(_))) match { case List() => List(List()) case x => x } new ConstructorResolveProcessor(ref, ref.refName, effectiveArgs, typeArgs, kinds, shapeResolve, allConstructorResults) } else ref.getContext match { //last ref may import many elements with the same name case e: ScImportExpr if e.selectorSet.isEmpty && !e.isSingleWildcard => new CollectAllForImportProcessor(kinds, ref, reference.refName) case e: ScImportExpr if e.isSingleWildcard => new ResolveProcessor(kinds, ref, reference.refName) case _: ScImportSelector => new CollectAllForImportProcessor(kinds, ref, reference.refName) case constr: ScInterpolationPattern => new ExtractorResolveProcessor(ref, reference.refName, kinds, constr.expectedType) case constr: ScConstructorPattern => new ExtractorResolveProcessor(ref, reference.refName, kinds, constr.expectedType) case infix: ScInfixPattern => new ExtractorResolveProcessor(ref, reference.refName, kinds, infix.expectedType) case _ => new ResolveProcessor(kinds, ref, reference.refName) }	ResolveProcessor	proc
psiParameter.paramType()	ScType	scType
new StableCodeReferenceResolver(stableRef, false, false, false) { override protected def getKindsFor(ref: ScStableCodeReference): Set[ResolveTargets.Value] = { ref.getKinds(incomplete = false) -- StdKinds.methodRef } }	StableCodeReferenceResolver { def getKindsFor(ref: ScStableCodeReference): Set[ResolveTargets.Value] }	importResolverNoMethods
Compatibility.compatible(tp, substitutor, args, checkWithImplicits, ref.resolveScope, isShapeResolve)	Compatibility.ConformanceExtResult	result
0	Int	flags
this.resolveWithName(_: String, reference, shapesOnly, incomplete)	String => Array[ScalaResolveResult]	resolveWithName
obj.qualifiedName	String	qualifier
reference.getContext	PsiElement	context
resolveWithName("withFilter")	Array[ScalaResolveResult]	withFilterResults
new StableCodeReferenceResolver(stableRef, false, false, false) { override protected def getKindsFor(ref: ScStableCodeReference): Set[ResolveTargets.Value] = { ref.getKinds(incomplete = false) -- StdKinds.stableClass } }	StableCodeReferenceResolver { def getKindsFor(ref: ScStableCodeReference): Set[ResolveTargets.Value] }	importResolverNoTypes
new StableCodeReferenceResolver(stableRef, false, false, true)	StableCodeReferenceResolver	noConstructorResolver
new StableCodeReferenceResolver(stableRef, false, true, false)	StableCodeReferenceResolver	resolverAllConstructors
new StableCodeReferenceResolver(stableRef, true, false, false)	StableCodeReferenceResolver	shapesResolver
new StableCodeReferenceResolver(stableRef, true, true, false)	StableCodeReferenceResolver	shapesResolverAllConstructors
context match { case ScPrefixExpr(`reference`, _) => s"unary_$refName" case _ if reference.getUserData(ScForImpl.desugaredWithFilterKey) == ScForImpl.DesugaredWithFilterUserData => // This is a call to withFilter in a desugared for comprehension // in scala version 2.11 and below withFilter will be rewritten into filter // we try first to resolve withFilter and if we do not get any results we try filter val withFilterResults = resolveWithName("withFilter") if (withFilterResults.nonEmpty) return withFilterResults "filter" case _ => refName }	String	name
createImplicitClauseFromTextWithContext(clausesTexts, paramClauses, isClassParameter)	ScParameterClause	result
getContextInfo(reference, reference)	ReferenceExpressionResolver.this.ContextInfo	info
position.getParent	PsiElement	parent
getContextOfType(scMember, true, classOf[ScalaFile], classOf[ScPackaging], classOf[ScTemplateDefinition])	PsiElement	enclosing
() => info.expectedType.apply()	() => Option[ScType]	expectedOption
reference.getPrevTypeInfoParams	Seq[TypeParameter]	prevInfoTypeParams
collection.mutable.Set[(ScReference, String)]()	mutable.Set[(ScReference, String)]	aliases
ScalaPsiUtil.getContextOfType(getActualElement, false, classOf[PsiClass])	PsiElement	clazzStub
substitutor(ScProjectionType(thisType, namedElement))	ScType	asSeenFrom
clazzStub match { case clazz: PsiClass => clazz case _ => null }	PsiClass	clazz
substitutor(sign.upperBound)	ScType	aliased
o.qualifiedName	String	q
reference.shapeResolve.iterator	Iterator[ScalaResolveResult]	iterator
importsUsed.toSeq	Seq[ImportUsed]	importsUsedSeq
aliased.equiv(asSeenFrom, constraints)	ConstraintsResult	conforms
importsUsedSeq.last	ImportUsed	importUsed
Array.empty[ScalaResolveResult]	Array[ScalaResolveResult]	EMPTY_ARRAY
(count: Int) => if (count == 0) EMPTY_ARRAY else new Array[ScalaResolveResult](count)	ArrayFactory[ScalaResolveResult]	arrayFactory
createReferenceFromText(text, position.getContext, position)	ScStableCodeReference	ref
element match { //objects case obj: ScObject => if (argumentClauses.isEmpty) { expectedOption().map(_.removeAbstracts) match { case Some(FunctionType(_, params)) => problems += ExpectedTypeMismatch case Some(tp: ScType) if obj.isSAMEnabled => SAMUtil.toSAMType(tp, obj) match { case Some(FunctionType(_, params)) => problems += ExpectedTypeMismatch case _ => } case _ => } } else { problems += new DoesNotTakeParameters } ConformanceExtResult(problems) case _: PsiClass => ConformanceExtResult(problems) case _: ScTypeAlias => ConformanceExtResult(problems) //Implicit Application case f: ScMethodLike if hasMalformedSignature(f) => problems += new MalformedDefinition ConformanceExtResult(problems) case ScalaConstructor(constructor) => scalaConstructorCompatibility(constructor) case JavaConstructor(constructor) => javaConstructorCompatibility(constructor) case fun: ScFunction if (typeArgElements.isEmpty || typeArgElements.length == fun.typeParameters.length) && fun.paramClauses.clauses.length == 1 && fun.paramClauses.clauses.head.isImplicit && argumentClauses.isEmpty => addExpectedTypeProblems() //eta expansion case fun: ScTypeParametersOwner if (typeArgElements.isEmpty || typeArgElements.length == fun.typeParameters.length) && argumentClauses.isEmpty && fun.isInstanceOf[PsiNamedElement] => checkFunction(fun.asInstanceOf[PsiNamedElement]) case fun: PsiTypeParameterListOwner if (typeArgElements.isEmpty || typeArgElements.length == fun.getTypeParameters.length) && argumentClauses.isEmpty && fun.isInstanceOf[PsiNamedElement] => checkFunction(fun.asInstanceOf[PsiNamedElement]) //simple application including empty application case tp: ScTypeParametersOwner with PsiNamedElement => val args = argumentClauses.headOption.toList val typeArgCount = typeArgElements.length val typeParamCount = tp.typeParameters.length if (typeArgCount > 0 && typeArgCount != typeParamCount) { if (typeParamCount == 0) { problems += DoesNotTakeTypeParameters } else if (typeParamCount < typeArgCount) { problems ++= typeArgElements.drop(typeParamCount).map(ExcessTypeArgument) } else { problems ++= tp.typeParameters.drop(typeArgCount).map(ptp => MissedTypeParameter(TypeParameter(ptp))) } addExpectedTypeProblems() } else { val result = Compatibility.compatible(tp, substitutor, args, checkWithImplicits, ref.resolveScope, isShapeResolve, ref) problems ++= result.problems addExpectedTypeProblems(result = Some(result)) } case tp: PsiTypeParameterListOwner with PsiNamedElement => val typeArgCount = typeArgElements.length val typeParamCount = tp.getTypeParameters.length if (typeArgCount > 0 && typeArgCount != typeParamCount) { if (typeParamCount == 0) { problems += DoesNotTakeTypeParameters } else if (typeParamCount < typeArgCount) { problems ++= typeArgElements.drop(typeParamCount).map(ExcessTypeArgument) } else { problems ++= tp.getTypeParameters.drop(typeArgCount).map(ptp => MissedTypeParameter(TypeParameter(ptp))) } addExpectedTypeProblems() } else { val args = argumentClauses.headOption.toList val result = Compatibility.compatible(tp, substitutor, args, checkWithImplicits, ref.resolveScope, isShapeResolve) problems ++= result.problems addExpectedTypeProblems(result = Some(result)) } case _ => if (typeArgElements.nonEmpty) problems += DoesNotTakeTypeParameters if (argumentClauses.nonEmpty) problems += new DoesNotTakeParameters addExpectedTypeProblems() }	Compatibility.ConformanceExtResult	result
FileDocumentManager.getInstance().getDocument(getContainingFile.getVirtualFile)	Document	doc
subst(tp.aliasedType.getOrNothing).equiv(substitutor(sign.lowerBound), undef, falseUndef = false)	ConstraintsResult	t
getFirstChild.getTextRange	TextRange	range
getNode.getChildren(null).lift(2).exists( _.getElementType == ScalaDocTokenType.DOC_COMMENT_LEADING_ASTERISKS)	Boolean	firstLineIsEmpty
parentTagName	String	parentTagType
availableImportAliases(refPosition)	Set[(ScReference, String)]	importAliases
mutable.ArrayBuilder.make[PsiDocTag]()	mutable.ArrayBuilder[PsiDocTag]	answer
typeParameters.map { _.typeParamId }.toSet	Set[Long]	typeParamIds
undefined	ConstraintSystem	uSubst
o.getParent.asOptionOf[ScPackaging].map(_.fullPackageName).mkString	String	packageName
!am.isThis	Boolean	withCompanion
importAliases.collect { case (aliasRef, aliasName) if aliasRef.multiResolveScala(false).exists(rr => ScEquivalenceUtil.smartEquivalence(rr.getElement, element)) => aliasName }	IndexedSeq[String]	suitableAliases
reference.refName != applyName && found.exists(isApplySugarResult)	Boolean	isApplySugarCall
createReferenceFromText(suitableAliases.head)(refPosition.getManager)	ScStableCodeReference	newRef
element.getTextRange	TextRange	range
range.getStartOffset - 1	Int	previousOffset
range.getEndOffset	Int	nextOffset
null	ScaladocConsoleRunConfigurationForm	configurationDialog
null	ScaladocConfiguration	config
createRef(reference, _ + s".$applyName")	ScReferenceExpression	applyRef
new ScaladocRunConfiguration(project, configurationDialog, config)	ScaladocAction.ScaladocRunConfiguration	runConfig
new MethodResolveProcessor( reference, reference.refName.init, List(argumentsOf(reference)), Nil, prevInfoTypeParams, isShapeResolve = shapesOnly, enableTupling = true)	MethodResolveProcessor	assignProcessor
smartResolve()	Array[ScalaResolveResult]	smartResult
false	Boolean	isInInlinedTag
false	Boolean	hasClosingElementsInWikiSyntax
true	Boolean	canHaveTags
ProgramRunner.getRunner(DefaultRunExecutor.EXECUTOR_ID, config)	ProgramRunner[_ <: RunnerSettings]	runner
new ExecutionEnvironmentBuilder(project, DefaultRunExecutor.getRunExecutorInstance)	ExecutionEnvironmentBuilder	builder
builder.getTokenType.asInstanceOf[ScaladocSyntaxElementType]	ScaladocSyntaxElementType	tokenType
if (shapesOnly) { doResolve(reference, processor(smartProcessor = false)) } else { val smartResult = smartResolve() if (smartResult.exists(_.isApplicable())) smartResult else fallbackResolve(smartResult) }	Array[ScalaResolveResult]	result
result.isEmpty && (context.isInstanceOf[ScInfixExpr] || context.isInstanceOf[ScMethodCall]) && name.endsWith("=") && !name.startsWith("=") && !Seq("!=", "<=", ">=").contains(name) && !name.exists(_.isLetterOrDigit)	Boolean	resolveAssignment
ref.getContext	PsiElement	context
mutable.ArrayBuilder.make[ScNamedElement]()	mutable.ArrayBuilder[ScNamedElement]	result
new ScaladocCommandLineState(env, project)	ScaladocCommandLineState	state
TokenSet.orSet(set, MyScaladocParsing.nonDataTokens)	TokenSet	uset
builder.getTokenType	IElementType	tt
tParam.typeParamId	Long	typeParamId
clazz.constructor	Option[ScPrimaryConstructor]	constr
getContextOfType(scMember, true, classOf[ScalaFile], classOf[ScTemplateDefinition], classOf[ScPackaging])	PsiElement	enclosing
(context, processor) match { case (x: ScAssignment, _) if x.leftExpression == ref => Some(context) case (_, _: DependencyProcessor) => None case (_, _: CompletionProcessor) => Some(ref) case _ => None }	Option[PsiElement]	contextElement
ref.refName	String	refName
builder.getTokenType	IElementType	tokenType
builder.mark()	PsiBuilder.Marker	valueMarker
builder.mark()	PsiBuilder.Marker	tagValMarker
""	String	outputDir
parent.getLastChild	PsiElement	last
false	Boolean	showInBrowser
""	String	additionalScaladocFlags
HashMap[String, String]("`" -> "&#96;", "^" -> "&#94;", "__" -> "&#95;&#95;", "'''" -> "&#39;&#39;&#39;", "''" -> "&#39;&#39;", ",," -> "&#44;&#44;", "[[" -> "&#91;&#91;", "=" -> "&#61;")	Map[String, String]	escapeSequencesForWiki
result.constraints match { case undefined@ConstraintSystem(newSubstitutor) => val typeParamIds = typeParameters.map { _.typeParamId }.toSet var uSubst = undefined for (TypeParameter(tParam, _, lowerType, upperType) <- typeParameters) { val typeParamId = tParam.typeParamId if (!lowerType.isNothing) { s(newSubstitutor(lowerType)) match { case lower if !lower.hasRecursiveTypeParameters(typeParamIds) => uSubst = uSubst.withLower(typeParamId, lower) .withTypeParamId(typeParamId) case _ => } } if (!upperType.isAny) { s(newSubstitutor(upperType)) match { case upper if !upper.hasRecursiveTypeParameters(typeParamIds) => uSubst = uSubst.withUpper(typeParamId, upper) .withTypeParamId(typeParamId) case _ => } } } uSubst match { case ConstraintSystem(_) => Some(result) case _ => None } case _ => None }	Option[Compatibility.ConformanceExtResult]	maybeResult
_	AnalysisScope	scope
""	String	docTitle
""	String	maxHeapSize
Set(PARAM_TAG, TYPE_PARAM_TAG, THROWS_TAG, SEE_TAG, AUTHOR_TAG, NOTE_TAG, RETURN_TAG, SINCE_TAG, DEFINE_TAG, VERSION_TAG, TODO_TAG, USECASE_TAG, EXAMPLE_TAG, DEPRECATED_TAG, MIGRATION_TAG, GROUP_TAG, GROUP_NAME_TAG, GROUP_DESC_TAG, GROUP_PRIO_TAG, CONSTRUCTOR_TAG, INHERITDOC_TAG)	Set[Nothing]	allTags
anchorOpt match { case Some(a) => a case None => val last = parent.getLastChild if (isLineTerminator(last.getPrevSibling)) last.getPrevSibling else last }	PsiElement	anchor
element match { case t: ScTypeParametersOwner => Some(t.typeParameters) case p: PsiTypeParameterListOwner => Some(p.getTypeParameters) case _ => None }	Option[Seq[PsiTypeParameter]]	maybeTypeParameters
comment.getText	String	commentText
Set(DEFINE_TAG, PARAM_TAG, TYPE_PARAM_TAG, THROWS_TAG)	Set[Nothing]	tagsWithParameters
TokenSet.create(DOC_COMMENT_END, DOC_WHITESPACE, DOC_COMMENT_LEADING_ASTERISKS)	TokenSet	nonDataTokens
isDocComment(comment, commenter)	Boolean	docComment
JavaCommandLineStateUtil.startProcess(createCommandLine)	OSProcessHandler	handler
if (docComment) commenter.getDocumentationCommentSuffix else commenter.getBlockCommentSuffix	String	expectedCommentEnd
enclosing match { case _: ScalaFile => "" case packaging: ScPackaging => packaging.fullPackageName }	String	packageName
positionFromParameters(parameters).getContext	PsiElement	posParent
getContextOfType(place, true, classOf[ScPackaging], classOf[ScalaFile])	PsiElement	placeEnclosing
isLineTerminator(anchor)	Boolean	anchorEndsLine
isLineTerminator(anchor.getPrevSibling)	Boolean	anchorStartsLine
comment.getContainingFile	PsiFile	containingFile
placeEnclosing match { case _: ScalaFile => "" case pack: ScPackaging => pack.fullPackageName }	String	placePackageName
comment.getParent.getLanguage	Language	language
addBefore(element).asInstanceOf[T]	T	addedStmt
getContextOfType(place, true, classOf[ScPackaging]) match { case pack: ScPackaging => pack case _ => null }	ScPackaging	pack
member.getModifierList	ScModifierList	modifierList
if (!equivalent(param.name, refName)) param.deprecatedName else None	Option[String]	rename
LanguageParserDefinitions.INSTANCE.forLanguage(language).createLexer(containingFile.getProject)	Lexer	lexer
if (docComment) commenter.getDocumentationCommentPrefix else commenter.getBlockCommentPrefix	String	commentPrefix
TypedHandler.getQuoteHandler(containingFile, editor)	QuoteHandler	fileTypeHandler
fileTypeHandler match { case quoteHandler: JavaLikeQuoteHandler => quoteHandler case _ => null }	JavaLikeQuoteHandler	javaLikeQuoteHandler
resolveResult.fromType	Option[ScType]	fromType
if (checkCompanion) getCompanionModule(td) else None	Option[ScTypeDefinition]	companion
posParent.asInstanceOf[ScDocComment].getOwner match { case _ : ScFunction => MyScaladocParsing.allTags case _ : ScClass => MyScaladocParsing.allTags - MyScaladocParsing.RETURN_TAG case _ : ScTypeAlias | _: ScTrait => MyScaladocParsing.allTags -- Set(MyScaladocParsing.RETURN_TAG, MyScaladocParsing.THROWS_TAG, MyScaladocParsing.PARAM_TAG) case _ => MyScaladocParsing.allTags -- MyScaladocParsing.tagsWithParameters - MyScaladocParsing.RETURN_TAG }	Set[Nothing]	allowedTags
lexer.getTokenType	IElementType	tokenType
{ val fromType = resolveResult.fromType def isPredef = fromType.exists(_.presentableText == "Predef.type") import resolveResult.projectContext qualifierType.orElse(fromType).getOrElse(api.Nothing) match { case qualType if !isPredef && resolveResult.importsUsed.isEmpty => qualType.extractDesignated(expandAliases = false).flatMap { case clazz: PsiClass => Some(clazz) case Typeable(tp) => tp.extractClass case _ => None } case _ => None } }	Option[PsiClass]	extractedType
commentText.substring(lexer.getTokenStart, lexer.getTokenEnd)	String	text
comment.getTextRange.getEndOffset	Int	endOffset
false	Boolean	continue
element.asInstanceOf[PsiComment]	PsiComment	comment
visitInner(file, scope, acc)	mutable.MutableList[VirtualFile]	answer
base.getNextSibling	PsiElement	current
{ val extractedType: Option[PsiClass] = { val fromType = resolveResult.fromType def isPredef = fromType.exists(_.presentableText == "Predef.type") import resolveResult.projectContext qualifierType.orElse(fromType).getOrElse(api.Nothing) match { case qualType if !isPredef && resolveResult.importsUsed.isEmpty => qualType.extractDesignated(expandAliases = false).flatMap { case clazz: PsiClass => Some(clazz) case Typeable(tp) => tp.extractClass case _ => None } case _ => None } } extractedType.orElse(containingClass).exists { expectedClass => ScalaPsiUtil.nameContext(element) match { case m: PsiMember => m.containingClass match { //allow boldness only if current class is package object, not element availiable from package object case packageObject: ScObject if packageObject.isPackageObject && packageObject == expectedClass => containingClass.contains(packageObject) case clazz => clazz == expectedClass } case _ => false } } }	Boolean	isCurrentClassMember
ScalaPsiManager.instance(pack.getProject)	ScalaPsiManager	manager
element match { case doc: PsiDocCommentOwner => doc.isDeprecated case _ => false }	Boolean	isDeprecated
7	Int	MaxWords
createModifierFromText(newVisibility)	PsiElement	newElem
modifierList.getFirstChild	PsiElement	mod
new ScalaLookupItem(element, name, containingClass)	ScalaLookupItem	result
if (typeArgElements.nonEmpty && typeParameters.length == typeArgElements.length) ScSubstitutor.bind(typeParameters, typeArgElements)(_.calcType) else ScSubstitutor.bind(typeParameters)(UndefinedType(_))	ScSubstitutor	follower
m.containingClass	ScTemplateDefinition	clazz1
splitParams(params)	List[String]	paramTokens
m2.containingClass	ScTemplateDefinition	clazz2
mutable.ListBuffer.empty[String]	ListBuffer[String]	result
ScalaResolveState .withSubstitutor(subst) .withNamedParam .withRename(rename)	ResolveState	state
_input.filter { r => r.element match { case f: ScFunction if f.hasParameterClause => true case b: ScTypedDefinition => b.nameContext match { case m: ScMember => val clazz1: ScTemplateDefinition = m.containingClass if (clazz1 == null) true else { _input.forall { r2 => r2.element match { case f: ScFunction if f.hasParameterClause => true case b2: ScTypedDefinition => b2.nameContext match { case m2: ScMember => val clazz2: ScTemplateDefinition = m2.containingClass if (clazz2 == null) true else clazz1.sameOrInheritor(clazz2) case _ => true } case _ => true } } } case _ => true } case _ => true } }	Set[ScalaResolveResult]	input
new CollectMethodsProcessor(ref, "apply")	CollectMethodsProcessor	processor
manager. getPackageImplicitObjects(pack.getQualifiedName, place.resolveScope).iterator	Iterator[ScObject]	objectsIterator
objectsIterator.next()	ScObject	obj
createElementFromText("(_)")	PsiElement	block
ScalaResolveState.withSubstitutor(subst).withNamedParam	ResolveState	state
collection.mutable.HashSet	mutable.HashSet.type	MutableHashSet
new JavaParameters	JavaParameters	jp
new ArrayBuffer[PsiAnnotationMethod] ++ clazz.getMethods.toSeq.flatMap { case f: PsiAnnotationMethod => Seq(f) case _ => Seq.empty }	ArrayBuffer[PsiAnnotationMethod]	methods
args.exprs	Seq[ScExpression]	exprs
PathUtilEx.getAnyJdk(project)	Sdk	jdk
Position.getValue(location)	PsiElement	position
originalResultSet.getPrefixMatcher	PrefixMatcher	prefixMatcher
location.getProject	Project	project
base.getHint(NameHint.KEY)	NameHint	nameHint
methods.indexWhere(p => equivalent(p.name, ref.refName))	Int	ind
TypeDefinitionMembers.getSignatures(td).forName(pat.name + "_=").iterator	Iterator[TermSignature]	signaturesByName
originalResultSet.withPrefixMatcher { prefixMatcher.cloneWithPrefix(capitalize(prefix)) }	CompletionResultSet	resultSet
result.getLookupElement	LookupElement	lookupElement
base match { case r: ResolveProcessor => r.getResolveScope case _ => place.resolveScope }	GlobalSearchScope	scope
element match { case ScalaLookupItem(item, _) => Some(item) case _ => None }	Option[ScalaLookupItem]	scalaLookupItem
scalaLookupItem.map(_.element)	Option[PsiNamedElement]	maybeElement
scalaLookupItem.map(_.name)	Option[String]	maybeName
new MethodResolveProcessor(elem, "this", arguments.toList.map(_.exprs.map(Expression(_))), typeArgs, Seq.empty /* todo: ? */ , constructorResolve = true, enableTupling = true)	MethodResolveProcessor	processor
ScalaResolveState.withSubstitutor(subst)	ResolveState	state
manager.getCachedClasses(scope, fqn).iterator	Iterator[PsiClass]	classes
false	Boolean	stop
classes.next()	PsiClass	clazz
{ val fqn = if (qName.length() > 0) qName + "." + name else name val scope = base match { case r: ResolveProcessor => r.getResolveScope case _ => place.resolveScope } val classes = manager.getCachedClasses(scope, fqn).iterator var stop = false while (classes.hasNext && !stop) { val clazz = classes.next() stop = clazz.containingClass == null && !processor.execute(clazz, state) } !stop }	Boolean	calcForName
pack match { case s: ScPackageImpl => s.pack case _ => pack }	PsiPackage	psiPack
psiPack.getQualifiedName	String	qName
if (qName.isEmpty) name else qName + "." + name	String	subpackageQName
project.anyScalaModule.getOrElse { throw new ExecutionException("No modules with Scala SDK are configured") }	Module	scalaModule
mutable.ListBuffer.empty[String]	ListBuffer[String]	classpathWithFacet
mutable.ListBuffer.empty[String]	ListBuffer[String]	sourcepathWithFacet
jp.getVMParametersList	ParametersList	vmParamList
jp.getProgramParametersList	ParametersList	paramList
mutable.ListBuffer.empty[String]	ListBuffer[String]	paramListSimple
manager.getCachedPackageInScope(subpackageQName, place.getResolveScope).orNull	PsiPackage	subPackage
OrderEnumerator.orderEntries(project).withoutLibraries().withoutSdk().getAllSourceRoots	Array[VirtualFile]	sourcePath
mutable.ListBuffer.empty[String]	ListBuffer[String]	documentableFilesList
withInsertHandler( withRenderer(lookupElement, createRenderer(itemText)), createInsertHandler(itemText) )	LookupElementDecorator[LookupElement]	decoratedLookupElement
if (equivalent(param.name, refName)) None else param.deprecatedName.map(clean)	Option[String]	rename
manager.getClasses(pack, scope).iterator	Iterator[PsiClass]	iterator
iterator.next()	PsiClass	clazz
MutableHashSet.apply(modules: _*)	mutable.HashSet[Module]	allModules
createElement( Delimiter + StringUtil.capitalize(position.getText), prefix, position )	E	replacement
processor.candidatesS.map(rr => (r.copy(innerResolveResult = Some(rr)), cleanTypeArguments))	IndexedSeq[(ScalaResolveResult, Boolean)]	cands
MutableHashSet.apply[Module]()	mutable.HashSet[Module]	modulesNeeded
findContext(replacement)	PsiElement	context
b.`type`().toOption	Option[ScType]	tpe
maybeType match { case Some(FunctionType(returnType, argTypes)) => returnType +: argTypes case Some(PartialFunctionType(returnType, argType)) => Seq(returnType, argType) case Some(scType) => Seq(scType) case _ => Seq.empty }	Seq[ScType]	typesSortedByRelevance
MutableHashSet.apply[String]()	mutable.HashSet[String]	allEntries
MutableHashSet.apply[String]()	mutable.HashSet[String]	allSourceEntries
false	Boolean	needFilter
mutable.Set.empty[String]	mutable.Set[String]	words
MaxWords - words.size	Int	wordsLeft
new TypeNamesExtractor(wordsLeft)	ml.TypeNamesExtractor	visitor
className.getChildren	Array[VirtualFile]	children
input.flatMap(expand).iterator	Iterator[(ScalaResolveResult, Boolean)]	expanded
ArrayBuffer.empty[ScalaResolveResult]	ArrayBuffer[ScalaResolveResult]	results
collector.lift	E => Option[(ScPattern, ScTypeElement)]	findTypeElement
if (cleanTypeArguments) Seq.empty else typeArgElements	Seq[ScTypeElement]	typeArgElems
createParameters(typeElement, Some(prefix.length))	CompletionParameters	newParameters
visitAll(c, scope)	List[VirtualFile]	documentableFiles
ScalaPsiUtil.getContextOfType(s, true, classOf[ScClass])	PsiElement	clazz
clazz.asInstanceOf[ScClass].`type`().getOrElse(return)	ScType	tp
Seq.empty	Seq[ScTypeElement]	typeArgs
s.arguments	Seq[ScArgumentExprList]	arguments
Set( JAVA_LANG_OBJECT, JAVA_LANG_THROWABLE, JAVA_LANG_EXCEPTION, JAVA_LANG_ERROR, AnyRefFqn, AnyFqn, NothingFqn )	Set[Nothing]	BlackListedNames
param	String	paramEsc
(c: ScClass) => { if (c != clazz) Seq.empty else { c.secondaryConstructors.filter(f => !PsiTreeUtil.isContextAncestor(f, s, true) && f.getTextRange.getStartOffset < s.getTextRange.getStartOffset ) } }	ScClass => Seq[ScFunction]	secondaryConstructors
constrInvocation.typeElement.`type`().getOrElse(return)	ScType	tp
List("-d", "-doc-title", "-classpath")	List[Nothing]	generatedParamsWithArgs
List("-verbose")	List[Nothing]	generatedParamsWithoutArgs
constrInvocation.typeArgList.map(_.typeArgs).getOrElse(Seq())	Seq[ScTypeElement]	typeArgs
if (actual.nonEmpty) expected.map(word => actual.map(relativePrefixMatch(word, _)).max).sum else 0	Double	similarity
constrInvocation.arguments	Seq[ScArgumentExprList]	arguments
(clazz: ScClass) => clazz.secondaryConstructors	ScClass => Seq[ScFunction]	secondaryConstructors
problemsFor(r, applicationImplicits, ref, argumentClauses, typeArgElems, selfConstructorResolve, prevTypeInfo, expectedOption, isUnderscore, isShapeResolve)	Compatibility.ConformanceExtResult	pr
clauses.clauses(invocationCount - 1)	ScParameterClause	actualClause
rr.copy(problems = pr.problems, defaultParameterUsed = pr.defaultParameterUsed)	ScalaResolveResult	innerCopy
itemText.indexOf(Delimiter) + Delimiter.length	Int	delta
new ArrayBuffer[ScParameter] ++ actualClause.parameters	ArrayBuffer[ScParameter]	params
str1.length min str2.length	Int	minLength
mutable.Set.empty[String]	mutable.Set[String]	consumed
r.innerResolveResult match { case Some(rr) if argumentClauses.nonEmpty => val innerCopy = rr.copy(problems = pr.problems, defaultParameterUsed = pr.defaultParameterUsed) r.copy(innerResolveResult = Some(innerCopy)) case _ => r.copy(problems = pr.problems, defaultParameterUsed = pr.defaultParameterUsed, resultUndef = Some(pr.constraints)) }	ScalaResolveResult	result
params.indexWhere(p => equivalent(p.name, ref.refName))	Int	ind
mapper(applicationImplicits = false)	Set[ScalaResolveResult]	mapped
mapped.filter(_.isApplicableInternal(withExpectedType = true))	Set[ScalaResolveResult]	filtered
reference.map { _.getParent match { case simple: ScSimpleTypeElement => simple case parent => throw new IllegalArgumentException(s"Simple type expected, actual `${parent.getClass}`: ${parent.getText}") } }.flatMap { _.`type`() }.flatMap { suggestNamesByType(_) .headOption .toRight(Placeholder) }.getOrElse(Placeholder)	String	suggestedName
components.map(function).commaSeparated(Model.Parentheses)	String	presentableSuffix
str1.length max str2.length	Int	maxLength
0.0	Double	result
func.parameterList.params.map(_.name)	IndexedSeq[String]	paramsNames
tpt.typeParameterOrLowerSubstitutor(internal)	ScType	substed
mapped.forall { r => r.element match { case _: ScFunction => false case _: ScReferencePattern if r.innerResolveResult.exists(_.element.getName == "apply") => true case _: ScTypedDefinition => r.innerResolveResult.isEmpty && r.problems.size == 1 case _ => false } }	Boolean	onlyValues
psiClass.getSuperClass	PsiClass	superClass
processor match { case m: MethodResolveProcessor => m.isShapeResolve case _ => false }	Boolean	shape
`class`.isSealed	Boolean	isSealed
if (isSealed) Ordering.by(_.getNavigationElement.getTextRange.getStartOffset) else Ordering.by(_.getName)	Ordering[PsiClass]	ordered
qualifier match { case ref: ScReferenceExpression => ref.bind() match { case Some(ScalaResolveResult(_: ScSelfTypeElement, _)) => aType case Some(r@ScalaResolveResult(b: ScTypedDefinition, _)) if b.isStable => r.fromType match { case Some(fT) => ScProjectionType(fT, b) case None => ScalaType.designator(b) } case _ => aType } case _ => aType }	ScType	fromType
fromType match { case ScDesignatorType(_: PsiPackage) => ScalaResolveState.empty case _ => ScalaResolveState.withFromType(fromType) }	ResolveState	state
strategy.patterns	Seq[PatternComponents]	components
dynamicResolveProcessor(ref, qualifier, methodProcessor)	MethodResolveProcessor	dynamicProcessor
processor match { case rp: ResolveProcessor => rp.name // See SCL-2934. case _ => ref.refName }	String	name
input.filter(r => { r.element match { case fun: ScFun if fun.paramClauses.nonEmpty => fun.paramClauses.head.length == 1 case fun: ScFunction if fun.paramClauses.clauses.nonEmpty => fun.paramClauses.clauses.head.parameters.length == 1 case p: ScPrimaryConstructor if p.parameterList.clauses.nonEmpty => p.parameterList.clauses.head.parameters.length == 1 case m: PsiMethod => m.parameters.length == 1 case _ => false } }).map(r => r.copy(tuplingUsed = true))	IndexedSeq[ScalaResolveResult]	filtered2
ref.qualifier match { case None => resolveUnqalified(processor) case Some(superQ: ScSuperReference) => ResolveUtils.processSuperReference(superQ, processor, ref) processor case Some(q) => processTypes(q, processor) }	BaseProcessor	actualProcessor
actualProcessor.candidates	Array[ScalaResolveResult]	res
child.getParent	PsiElement	currentParrent
if (argumentClauses.isEmpty) 0 else argumentClauses.head.length	Int	len
expectedTypeWords.nonEmpty || expectedNameWords.nonEmpty	Boolean	calculateWords
mutable.Set.empty[String]	mutable.Set[String]	result
0	Int	visited
if (calculateWords) extractWords(maybeName) else Array.empty[String]	Array[String]	nameWords
createRef(ref, "this." + _)	ScReferenceExpression	thisExpr
textUpdate(ref.getText)	String	newText
clausePosition match { case -1 => ml.parameters case i if i < 0 || i >= ml.effectiveParameterClauses.length => Seq.empty case _ => ml.effectiveParameterClauses.apply(clausePosition).effectiveParameters }	Seq[ScParameter]	parameters
components.map(_.canonicalClauseText) .mkString( prefix.getOrElse(ScalaKeyword.MATCH + " {\n"), "\n", suffix.getOrElse("\n}") )	String	clausesText
scalaLookupItem .filter(_ => calculateWords) .flatMap(item => ScalaByExpectedTypeWeigher.computeType(item.element, item.substitutor))	Option[ScType]	maybeType
extractWords(maybeType)	Array[String]	typeWords
`type`.extractDesignatorSingleton.getOrElse(`type`)	ScType	valueType
`class` match { case scalaClass: ScClass => scalaClass.hasAbstractModifier case _ => true }	Boolean	isNotConcrete
positionFromParameters(parameters)	PsiElement	position
elementKind(maybeElement).getOrElse { element.getObject match { case string: String if isKeyword(string) => CompletionItem.KEYWORD case _ => CompletionItem.UNKNOWN } }	CompletionItem	kind
NotNullLazyKey.create[PsiElement, CompletionLocation]("scala.feature.element.position", location => { positionFromParameters(location.getCompletionParameters) })	NotNullLazyKey[PsiElement, CompletionLocation]	Position
definitionByPosition(position, ScalaAfterNewCompletionContributor.isAfterNew(position))	Option[ScExpression]	expressionOption
expressionOption .flatMap(_.expectedTypeEx()) .map { case (expectedType, typeElement) => expectedType -> expectedName(typeElement) }	Option[(ScType, Option[String])]	expectedTypeAndName
expectedTypeAndName.map(_._1)	Option[ScType]	expectedType
expectedTypeAndName.flatMap(_._2).orElse(expectedName(Option(position)))	Option[String]	expetedName
NotNullLazyKey.create[(Array[String], Array[String]), CompletionLocation]("scala.feature.element.expected.type.and.name.words", location => { val position = Position.getValue(location) val expressionOption = definitionByPosition(position, ScalaAfterNewCompletionContributor.isAfterNew(position)) val expectedTypeAndName = expressionOption .flatMap(_.expectedTypeEx()) .map { case (expectedType, typeElement) => expectedType -> expectedName(typeElement) } val expectedType = expectedTypeAndName.map(_._1) val expetedName = expectedTypeAndName.flatMap(_._2).orElse(expectedName(Option(position))) extractWords(expectedType) -> extractWords(expetedName) })	NotNullLazyKey[(Array[String], Array[String]), CompletionLocation]	ExpectedTypeAndNameWords
statement.findLastChildByType[ScCaseClauses](parser.ScalaElementType.CASE_CLAUSES)	ScCaseClauses	caseClauses
NotNullLazyKey.create[util.HashMap[String, MLFeatureValue], CompletionLocation]("scala.feature.element.context", location => { val position = Position.getValue(location) val contextFeatures = new util.HashMap[String, MLFeatureValue] // theses features should be moved to context after IntellijIdeaRulezzz fix contextFeatures.put("postfix", MLFeatureValue.binary(isPostfix(Option(position)))) contextFeatures.put("type_expected", MLFeatureValue.binary(ScalaAfterNewCompletionContributor.isInTypeElement(position, Some(location)))) contextFeatures.put("after_new", MLFeatureValue.binary(ScalaAfterNewCompletionContributor.isAfterNew(position))) contextFeatures.put("inside_catch", MLFeatureValue.binary(isInsideCatch(Option(position)))) contextFeatures })	NotNullLazyKey[Any, CompletionLocation]	Context
getLeafByOffset(context.getTextRange.getStartOffset, context)	PsiElement	leaf
for { value <- values if isAccessible(value) if value.`type`().exists(_.conforms(valueType)) declaredName <- value.declaredNames } yield declaredName	IndexedSeq[String]	membersNames
valueType match { case ScProjectionType(DesignatorOwner(enumClass@ScalaEnumeration(values)), _) => val membersNames = for { value <- values if isAccessible(value) if value.`type`().exists(_.conforms(valueType)) declaredName <- value.declaredNames } yield declaredName membersNames match { case Seq() => null case _ => new EnumGenerationStrategy(enumClass, enumClass.qualifiedName, membersNames) } case ScDesignatorType(enumClass@JavaEnum(enumConstants)) => enumConstants match { case Seq() => null case _ => new EnumGenerationStrategy( enumClass, valueType.presentableText, enumConstants.map(_.getName) ) } case ExtractClass(DirectInheritors(inheritors)) => new DirectInheritorsGenerationStrategy(inheritors) case _ => null }	PatternGenerationStrategy	strategy
5	Int	NonSealedInheritorsThreshold
isSealed && isNotConcrete && restInheritors.isEmpty	Boolean	isExhaustive
leaf.getParent	PsiElement	parent
position.findContextOfType(classOf[ScConstructorPattern]).collect { case ScConstructorPattern(ScReference(function: ScFunctionDefinition), _) => function }.flatMap { function => Option(function.syntheticCaseClass).orElse { if (function.isUnapplyMethod) Some(function) else None } }	Option[ScMember.WithBaseIconProvider with ScTypeParametersOwner with ScParameterOwner with ScDocCommentOwner with ScNamedElement with Typeable with ScCommentOwner with PsiTypeParametersOwnerAdapter with PomRenameableTarget[PsiElement] with PsiTarget]	maybeParametersOwner
context.getTextRange.getStartOffset - 1	Int	i
context.getContainingFile	PsiFile	file
leaf.getPrevSiblingNotWhitespace	PsiElement	prev
leaf.getParent	PsiElement	leafParent
prev.getPrevSibling	PsiElement	prev2
for { clause <- clauses.caseClauses Some(arrow) = clause.funType } yield TextRange.from(clause.getTextOffset, arrow.getStartOffsetInParent)	IndexedSeq[TextRange]	rangesToReformat
maybeParametersOwner.toSeq .flatMap(_.parameters)	IndexedSeq[ScParameter]	caseClassParameters
findPosition(position, caseClassParameters.length)	Int	myPosition
getLeafByOffset(i, context)	PsiElement	leaf1
leaf.getPrevSibling	PsiElement	node
caseClassParameters.map { parameter => (parameter, parameter.name) }	IndexedSeq[(ScParameter, String)]	byName
ErrMsg("wrong.top.statment.declaration")	String	s
ScalaCompletionUtil.getForAll(parent,leaf)	(Boolean, Boolean)	tuple
ScalaCompletionUtil.getForAll(parent, leaf)	(Boolean, Boolean)	tuple
createElement("".parenthesize(), prefix, pattern)	ScPattern	replacement
createParameters(replacement)	CompletionParameters	newParameters
lookupElement.getPsiElement match { case Extractor(_) => true case _ => false }	Boolean	extractorExists
index	Int	i
parent.getPrevSibling	PsiElement	prev
clause.funType match { case Some(elem) => elem.getStartOffsetInParent case None => clause.getTextLength }	Int	position
parent.getPrevSibling match { case x: ScIf => x case x if x.isInstanceOf[PsiWhiteSpace] || x.getNode.getElementType == ScalaTokenTypes.tWHITE_SPACE_IN_LINE => x.getPrevSibling match { case x: ScIf => x case _ => null } case _ => null }	ScIf	ifStmt
getPrevNotWhitespaceAndComment(context.getTextRange.getStartOffset - 1, context)	Int	i
getLeafByOffset(i, context)	PsiElement	elem
leaf1.getText == "}"	Boolean	prevIsRBrace
leaf1.getText == ")"	Boolean	prevIsRParan
parent.getPrevSibling match { case x: ScDo => x case x if x.isInstanceOf[PsiWhiteSpace] || x.getNode.getElementType == ScalaTokenTypes.tWHITE_SPACE_IN_LINE => x.getPrevSibling match { case x: ScDo => x case _ => null } case _ => null }	ScDo	doStmt
new THashSet[String]	THashSet[String]	result
if (_name != "this") escapeKeyword(_name) else _name	String	name
new LookupElementPresentation	LookupElementPresentation	prefixPresentation
findParent(parent)	PsiElement	otherParent
position.getContext match { case pattern: ScPattern => for { (parameter, expectedType) <- caseClassParameters.lift(myPosition).zip(pattern.expectedType) name <- NameSuggester.suggestNamesByType(expectedType) } yield (parameter, name) case _ => Iterable.empty }	Iterable[(ScParameter, String)]	byType
element.projectContext	ProjectContext	project
false	Boolean	isClassName
None	Option[String]	isRenamed
element.someSmartCompletion	Boolean	old
false	Boolean	isAssignment
ScSubstitutor.empty	ScSubstitutor	substitutor
false	Boolean	shouldImport
Set(IF, FOR, WHILE)	Set[Nothing]	parentheses
false	Boolean	isOverloadedForClassName
false	Boolean	isNamedParameter
context.getEditor	Editor	editor
false	Boolean	isDeprecated
editor.getCaretModel	CaretModel	caretModel
false	Boolean	isUnderlined
false	Boolean	isInImport
result match { case head :: tail if head.getText == current.getText => tail case list => list }	List[PsiElement]	newTail
false	Boolean	isInStableCodeReference
false	Boolean	usedImportStaticQuickfix
caretModel.getOffset + (if (element.someSmartCompletion) 5 else 0) - element.getLookupString.length - 1	Int	offsetForPrefix
context.getDocument	Document	document
None	Option[PsiNamedElement]	elementToImport
(_: PsiElement).isInstanceOf[ScExpression]	Condition[PsiElement]	AnyExpression
None	Option[PsiClass]	classToImport
false	Boolean	someSmartCompletion
CompletionSorter.defaultSorter(parameters, result.getPrefixMatcher) .weighAfter("prefix", createWeigher(myPosition, caseClassParameters))	CompletionSorter	sorter
false	Boolean	typeParametersProblem
expressionTypeCondition { case (expression, scType) => scType.conforms(api.Boolean(expression)) }	Condition[PsiElement]	BooleanExpression
Set(CATCH, ELSE, EXTENDS, FINALLY, FOR, FOR_SOME, NEW, TRY, DO, YIELD)	Set[Nothing]	braces
Seq.empty	Seq[ScType]	typeParameters
false	Boolean	bold
Array(element)	Array[PsiElement]	elements
false	Boolean	etaExpanded
parenthesized	ProjectContext	context
false	Boolean	prefixCompletion
false	Boolean	isLocalVariable
false	Boolean	isSbtLookupItem
false	Boolean	isInSimpleString
TemplateManager.getInstance(expression.getProject)	TemplateManager	manager
false	Boolean	isInSimpleStringNoBraces
false	Boolean	isInInterpolatedString
containingClass0.orElse(element.containingClassOfNameContext).orNull	PsiClass	containingClass
element match { case _: PsiPackage | _: PsiClass => true case _ => false }	Boolean	greyed
if (isRenamed.nonEmpty) s"$name <= ${element.name}" else if (isClassName && shouldImport && containingClass != null) s"${containingClass.name}.$name" else name	String	itemText
getTemplateString(expression)	String	templateString
expression.getContainingFile	PsiFile	file
count >= 0 && !(count == 0 && isAccessor)	Boolean	addParams
context.getStartOffset + keyword.length	Int	offset
context.getStartOffset	Int	offset
CodeStyle.getSettings(context.getProject).getCommonSettings(ScalaLanguage.INSTANCE)	CommonCodeStyleSettings	settings
keyword match { case IF => settings.SPACE_BEFORE_IF_PARENTHESES case FOR => settings.SPACE_BEFORE_FOR_PARENTHESES case WHILE => settings.SPACE_BEFORE_WHILE_PARENTHESES }	Boolean	add
keyword match { case CATCH => settings.SPACE_BEFORE_CATCH_LBRACE case ELSE => settings.SPACE_BEFORE_ELSE_LBRACE case EXTENDS => true case FINALLY => settings.SPACE_BEFORE_FINALLY_LBRACE case FOR => settings.SPACE_BEFORE_FOR_LBRACE case FOR_SOME => true case NEW => true case TRY => settings.SPACE_BEFORE_TRY_LBRACE case DO => settings.SPACE_BEFORE_DO_LBRACE case YIELD => settings.SPACE_BEFORE_FOR_LBRACE }	Boolean	add
PsiDocumentManager.getInstance(context.getProject)	PsiDocumentManager	manager
manager.getPsiFile(document)	PsiFile	file
ScalaWithMatchSurrounder.surroundedNode(Array(expression))	ASTNode	matchNode
CodeStyleManager.getInstance(expression.getProject)	CodeStyleManager	styleManager
ClauseCompletionParameters(expression, expression.getContainingFile.getResolveScope)	clauses.ClauseCompletionParameters	parameters
new ScalaLookupItem(parameter, name)	ScalaLookupItem	result
expression.getTextRange	TextRange	range
range.getStartOffset	Int	startOffset
range.getEndOffset	Int	endOffset
s"$expressionText $clausesText"	String	templateString
TemplateManager.getInstance(project)	TemplateManager	manager
if (!etaExpanded) fun.returnType.getOrAny else fun.`type`().getOrAny	ScType	scType
context.getStartOffset	Int	startOffset
4	Int	MAX_DISTANCE
startOffset + lookupStringLength	Int	endOffset
location.getPosition	PsiElement	position
item.isRenamed.isDefined	Boolean	isRenamed
false	Boolean	hasNonEmptyParams
{ UIFreezingGuard.withDefaultValue("") { element match { case fun: ScFunction => val scType = if (!etaExpanded) fun.returnType.getOrAny else fun.`type`().getOrAny presentationString(scType, substitutor) case fun: ScFun => presentationString(fun.retType, substitutor) case alias: ScTypeAliasDefinition => presentationString(alias.aliasedType.getOrAny, substitutor) case param: ScParameter => presentationString(param.getRealParameterType.getOrAny, substitutor) case t: ScTemplateDefinition if name == "this" || name.endsWith(".this") => t.getTypeWithProjections(thisProjections = true) match { case Right(tp) => tp.presentableText case _ => "" } case f: PsiField => presentationString(f.getType, substitutor) case m: PsiMethod => presentationString(m.getReturnType, substitutor) case t: Typeable => presentationString(t.`type`().getOrAny, substitutor) case _ => "" } } }	String	typeText
editor.getCaretModel	CaretModel	model
context.getStartOffset	Int	contextStartOffset
Key.create("text.for.position")	Key[String]	textForPositionKey
context.getFile.findElementAt(contextStartOffset).getParent	PsiElement	literal
contextStartOffset	Int	startOffset
context.getTailOffset	Int	tailOffset
positionFromParameters(location.getCompletionParameters)	PsiElement	position
literal.getTextRange.getStartOffset	Int	literalOffset
location.getCompletionParameters.getOriginalPosition	PsiElement	originalPostion
position.getContext.getContext.getContext	PsiElement	result
namedElement.scopes	Iterator[PsiElement]	scopes
item.typeParameters.map(_.canonicalText).mkString("[", ", ", "]")	String	str
context.getFile	PsiFile	file
file.findElementAt(endOffset - 1)	PsiElement	element
typedDeclaration.declaredElements.headOption.map(_.name)	Option[String]	result
position.getContext.getContext.getContext.getContext	PsiElement	result
bp.name	String	name
fun.paramClauses.map(_.map(presentationString(_, substitutor)).mkString("(", ", ", ")")).mkString	String	paramClausesText
maybeDefinition.fold(Seq.empty[ScType]) { _.expectedTypes() }	Seq[ScType]	expectedTypes
clazz.getPresentation.getLocationString	String	location
name.compareTo(o.name)	Int	i
{ UIFreezingGuard.withDefaultValue("") { element match { //scala case fun: ScFunction => if (etaExpanded) " _" else if (isAssignment) " = " + presentationString(fun.paramClauses, substitutor) else textForMethod(fun) case fun: ScFun => val paramClausesText = fun.paramClauses.map(_.map(presentationString(_, substitutor)).mkString("(", ", ", ")")).mkString withTypeParamsText + paramClausesText case clazz: PsiClass => val location: String = clazz.getPresentation.getLocationString s"$withTypeParamsText $location" case method: PsiMethod => textForMethod(method) case p: PsiPackage => s" (${p.getQualifiedName})" case _ => "" } } }	String	tailText
substitutor(scType)	ScType	substituted
m match { case fun: ScFunction => fun.paramClauses case _ => m.getParameterList }	PsiParameterList	params
if (!isOverloadedForClassName) presentationString(params, substitutor) else "(...)"	String	paramsText
{ if (isClassName && containingClass != null) { if (shouldImport) " " + containingClass.getPresentation.getLocationString else " in " + containingClass.name + " " + containingClass.getPresentation.getLocationString } else "" }	String	containingClassText
if (someSmartCompletion) 5 else 0	Int	smartAdd
if (isInSimpleString && isInSimpleStringNoBraces) 1 else if (isInSimpleString) 2 else if (isInInterpolatedString) 1 else 0	Int	simpleStringAdd
Set[PostfixTemplate]( new ScalaTryPostfixTemplate, new ScalaAssertPostfixTemplate, new ScalaCastPostfixTemplate, new ScalaElseExpressionPostfixTemplate, new ScalaIfExpressionPostfixTemplate, new ScalaMatchPostfixTemplate, new ScalaForEachPostfixTemplate, new ScalaIntroduceFieldPostfixTemplate, new ScalaIntroduceVariablePostfixTemplate, new ScalaNotPostfixTemplate, new ScalaNotPostfixTemplate("!"), new ScalaParenthesizedExpressionPostfixTemplate, new ScalaReturnPostfixTemplate, new ScalaPrintlnPostfixTemplate, new ScalaPrintlnPostfixTemplate("prtln"), new ScalaThrowExceptionPostfixTemplate, new ScalaWhilePostfixTemplate, new ScalaDoWhilePostfixTemplate, new ScalaIsNullPostfixTemplate, new ScalaNotNullPostfixTemplate, new ScalaNotNullPostfixTemplate("nn"), new ScalaOptionPostfixTemplate, new ScalaSeqPostfixTemplate, new ScalaListPostfixTemplate, new ScalaExhaustiveMatchPostfixTemplate )	Set[PostfixTemplate]	Templates
undefineMethodTypeParams(method)	ScSubstitutor	substitutor
context.getCompletionChar	Char	completionChar
ScalaStatisticManager.memberKey(member).getOrElse(return StatisticsInfo.EMPTY)	String	key
member.getContainingClass	PsiClass	containingClass
ScalaStatisticManager.memberKey(containingClass).getOrElse("")	String	context
item.someSmartCompletion	Boolean	some
if (some) 1 else 0	Int	someNum
newT.extendsBlock.templateParents.toSeq.flatMap(_.typeElements) match { case Seq(ScSimpleTypeElement.unwrapped(reference)) => Some(reference) case _ => None }	Option[ScStableCodeReference]	maybeRef
Option(PsiTreeUtil.getContextOfType(position, classOf[ScNewTemplateDefinition]))	Option[Nothing]	newTemplateDefinition
PsiDocumentManager.getInstance(context.getProject).getPsiFile(document)	PsiFile	file
elem.getParent.asInstanceOf[ScReferenceExpression]	ScReferenceExpression	ref
parameters.getPosition	PsiElement	positionInCompletionFile
newTemplateDefinition.map(_.getContext).flatMap { case patterDef: ScPatternDefinition => patterDef.bindings.headOption.map(_.name) case assignement: ScAssignment => assignement.referenceName case _ => None }	Option[String]	result
qual.lastIndexOf('.')	Int	index
lookup.getPsiFile	PsiFile	file
element match { case clazz: PsiClass => Some(ClassToImport(clazz)) case ta: ScTypeAlias => Some(TypeAliasToImport(ta)) case pack: ScPackage => Some(PrefixPackageToImport(pack)) case _ => None }	Option[ElementToImport with Product with Serializable]	maybeTypeToImport
context.getFile.findElementAt(context.getStartOffset).getParent	PsiElement	literal
ref match { case psiElement: PsiElement => psiElement case _ => ref.getElement //this case for anonymous method in ScAccessModifierImpl }	PsiElement	e
context.getStartOffset + 2	Int	index
context.getFile.findElementAt(index)	PsiElement	elem
elem.getParent	PsiElement	reference
EditDistance.optimalAlignment(name, text, false)	Int	distance
clazz.qualifiedName.split('.').takeRight(2).mkString(".")	String	newRefText
createExpressionFromText(newRefText)(ref.getManager)	ScExpression	newRef
createReferenceFromText(newRefText)(clazz.getManager)	ScStableCodeReference	newRef
resultSet.getPrefixMatcher	PrefixMatcher	prefixMatcher
if (completionChar == '\t') { file.findElementAt(startOffset) match { case elem if elem.getNode.getElementType == ScalaTokenTypes.tIDENTIFIER && elem.getParent.isInstanceOf[ScReferenceExpression] && elem.getParent.getParent.isInstanceOf[ScReferenceExpression] && item.getAllLookupStrings.size() > 1 => val ref = elem.getParent.asInstanceOf[ScReferenceExpression] val newRefText = ref.getText val newRef = createExpressionFromText(newRefText)(ref.getManager) ref.getParent.replace(newRef).getFirstChild case elem => elem } } else file.findElementAt(startOffset)	PsiElement	element
if (ScalaAfterNewCompletionContributor.isInTypeElement(position, Some(location))) { element match { case ScalaLookupItem(_, namedElement) => namedElement match { case _: ScTypeAlias | _: ScTypeDefinition | _: PsiClass | _: ScParameter => handleByText(namedElement.getName) case _ => None } case _ => None } } else None	Option[Any]	maybeResult
if (item.prefixCompletion) { val newRefText = clazz.qualifiedName.split('.').takeRight(2).mkString(".") val newRef = createReferenceFromText(newRefText)(clazz.getManager) value.replace(newRef).asInstanceOf[ScStableCodeReference] } else value	ScStableCodeReference	referenceElement
element	PsiElement	elem
elem.getParent	PsiElement	parent
elem.getTextRange.getStartOffset	Int	start
elem.getTextRange.getEndOffset	Int	end
if (endOffset < document.getTextLength) documentText.charAt(endOffset) else 0.toChar	Char	nextChar
Key.create("prefix.completion.key")	Key[Boolean]	PREFIX_COMPLETION_KEY
element.getParent match { case ref: ScReferenceExpression => ref.getParent match { case ass: ScAssignment if ass.leftExpression == ref => ass.getParent match { case _: ScArgumentExprList => false case _ => true } case _ => true } case _ => true //should be impossible }	Boolean	shouldAddEqualsSign
if (context.getCompletionChar == '{') '{' else '('	Char	openChar
element match { case f: ScFunction => s"function#${f.name}" + f.parameters.map(p => "#" + p.`type`().getOrAny.presentableText).mkString case o: ScObject => s"object#${o.qualifiedName}" case c: ScClass => s"class#${c.qualifiedName}" case t: ScTrait => s"trait#${t.qualifiedName}" case t: ScTypeAlias => s"typeAlias#${t.name}" case v: ScBindingPattern => v.nameContext match { case _: ScValue => s"value#${v.name}" case _: ScVariable => s"variable${v.name}" case _ => return None } case f: ScFieldId => f.nameContext match { case _: ScValue => s"value#${f.name}" case _: ScVariable => s"variable#${f.name}" case _ => return None } case c: ScClassParameter => s"classParameter#${c.name}" case p: ScParameter => s"parameter#${p.name}" case _ => return None }	String	value
if (context.getCompletionChar == '{') '}' else ')'	Char	closeChar
reference.completionVariants().toSet[ScalaLookupItem].map(_.element)	IndexedSeq[PsiNamedElement]	simpleElements
element.getContainingFile	PsiElement	candidate
position.getUserData(ScalaExplicitlyImportedWeigher.key)	(ArrayBuffer[ScImportStmt], Long)	tuple
candidatesForType(originalType).map(_.name)	Set[String]	originalTypeMemberNames
if (tuple != null) tuple._1 else null	ArrayBuffer[ScImportStmt]	buffer
position.getManager.getModificationTracker.getModificationCount	Long	currentModCount
clazz.getText	String	classText
buffer.iterator	Iterator[ScImportStmt]	iter
iter.next()	ScImportStmt	stmt
stmt.importExprs.iterator	Iterator[ScImportExpr]	exprIter
exprIter.next()	ScImportExpr	expr
ScalaShortNamesCacheManager.getInstance	ScalaShortNamesCacheManager	cacheManager
member.containingClass	PsiClass	clazz
cl.qualifiedName.split('.')	Array[String]	parts
obj.qualifiedName	String	qualNoPoint
containingClass	PsiClass	classToImport
new ScalaResolveResult(elementToImport)	ScalaResolveResult	resolveResult
candidatesForType(resultType) .filterNot(c => originalTypeMemberNames.contains(c.name))	Set[ScalaResolveResult]	newCandidates
new CompletionProcessor(StdKinds.methodRef, place)	CompletionProcessor	processor
m.containingClass	PsiClass	cClass
ScalaAfterNewCompletionContributor.isAfterNew(position)	Boolean	isAfterNew
null	PsiClass	containingClass
ScalaPsiManager.instance(m.getProject)	ScalaPsiManager	manager
ScalaOIUtil.getMembersToImplement(newTemplateDef)	Seq[overrideImplement.ClassMember]	members
parts.takeRight(2).mkString(".")	String	newRefText
qualNoPoint + "." + memberName	String	qual
definitionByPosition(position, isAfterNew)	Option[ScExpression]	maybeDefinition
element.getContainingFile	PsiFile	elementFile
replaceDummy(classText + " " + additionText)	String	text
position.getContainingFile	PsiFile	positionFile
clazz.qualifiedName	String	qual
endOffset < documentText.length() && documentText.charAt(endOffset) == '{'	Boolean	lBraceAtCaret
for { e <- elements if e.getContainingFile == originalFile && e.name == name className <- contextContainingClassName(e) } yield className	IndexedSeq[String]	objectNames
contextStartOffset + 2	Int	index
block.getTextRange.getEndOffset	Int	blockEndOffset
block.getTextRange.getStartOffset	Int	blockStartOffset
CompletionSorter.defaultSorter(parameters, prefixMatcher) match { case defaultSorter if parameters.getCompletionType == CompletionType.SMART => defaultSorter case defaultSorter => val position = positionFromParameters(parameters) val isAfterNew = ScalaAfterNewCompletionContributor.isAfterNew(position) val maybeDefinition = definitionByPosition(position, isAfterNew) defaultSorter .weighBefore("liftShorter", new ScalaByTypeWeigher(position)) .weighAfter(if (isAfterNew) "scalaTypeCompletionWeigher" else "scalaKindWeigher", new ScalaByExpectedTypeWeigher(maybeDefinition)(position)) }	CompletionSorter	sorter
clazz.qualifiedName	String	qualNoPoint
qualifier.getTypeWithoutImplicits().toOption	Option[ScType]	qualifierType
resultSet .withPrefixMatcher(new BacktickPrefixMatcher(prefixMatcher)) .withRelevanceSorter(sorter)	CompletionResultSet	updatedResultSet
parameters	CompletionParameters	p
context	ProcessingContext	c
completionsFor(positionFromParameters)	Iterable[LookupElement]	lookupElements
PsiFileFactory.getInstance(manager.getProject). createFileFromText(DUMMY + ScalaFileType.INSTANCE.getDefaultExtension, ScalaFileType.INSTANCE, "class a {\n" + text + "\n}").asInstanceOf[ScalaFile]	ScalaFile	dummyFile
Option(position.getContext.getContext).collect { case body: ScTemplateBody => body }	Option[ScTemplateBody]	maybeBody
ref match { case ref: ScReferenceExpression if prefixCompletion => val parts = cl.qualifiedName.split('.') if (parts.length > 1) { val newRefText = parts.takeRight(2).mkString(".") createExpressionFromText(newRefText).asInstanceOf[ScReferenceExpression] } else { createReferenceToReplace(ref, cl, useFullyQualifiedName) } case ref: ScStableCodeReference if prefixCompletion => val parts = cl.qualifiedName.split('.') if (parts.length > 1) { val newRefText = parts.takeRight(2).mkString(".") createReferenceFromText(newRefText) } else { createReferenceToReplace(ref, cl, useFullyQualifiedName) } case _ => createReferenceToReplace(ref, cl, useFullyQualifiedName) }	ScReference	newRef
identifier.getTextRange	TextRange	range
PsiTreeUtil.findElementOfClassAtOffset(context.getFile, context.getStartOffset + shift, classOf[ScReference], false)	ScReference	ref
Option(PsiTreeUtil.getContextOfType(element, classOf[ScObject]))	Option[Nothing]	packageObject
context.getEditor.getDocument	Document	document
maybeLength.getOrElse(range.getLength)	Int	length
packageObject.collect { case po: ScObject if po.isPackageObject => po.qualifiedName }	Option[Any]	nameAsPackageObject
CompletionSorter.defaultSorter(parameters, resultSet.getPrefixMatcher) .weighAfter("prefix", ScalaTextLookupItem.Weigher)	CompletionSorter	sorter
replaceDummy("class a { x:" + typeText + " " + additionText + "}")	String	text
resultSet.withRelevanceSorter(sorter)	CompletionResultSet	newResultSet
ModuleUtilCore.findModuleForPsiElement(element)	Module	elementModule
scalaFile.findElementAt(context.getStartOffset + shift)	PsiElement	elem
Key.create("scala.explicitly.imported.weigher.key")	Key[(ArrayBuffer[ScImportStmt], Long)]	key
Set( "+", "-", "*", "/", "%", ">", "<", "&&", "||", "&", "|", "==", "!=", "^", "<<", ">>", ">>>" )	Set[Nothing]	ReservedNames
position match { case _: ScObject => new ScalaTextLookupItem.Object(reference) case _ => new ScalaTextLookupItem.Regular(reference) }	ScalaTextLookupItem	lookupElement
replaceDummy("class a { val x:" + typeText + " " + additionText + "}")	String	text
createExpressionFromText(s"${containingClass.name}.${ref.getText}")(containingClass.getManager) .asInstanceOf[ScReferenceExpression]	ScReferenceExpression	newRef
if (ref.isInstanceOf[ScDocResolvableCodeReference] || useFQN) toImport.qualifiedName else toImport.name	String	refText
positionFromParameters(parameters)	PsiElement	element
PlatformPatterns.psiElement().withParent(classOf[ScReferenceExpression]). withSuperParent(2, classOf[ScArgumentExprList]).withSuperParent(3, classOf[ScConstructorInvocation])	PsiElementPattern.Capture[PsiElement]	constructorFilter
delegate.cloneWithPrefix { withoutBackticks(myPrefix) }	PrefixMatcher	backticklessMatcher
PlatformPatterns.psiElement().withParent(classOf[ScReferenceExpression]). withSuperParent(2, classOf[ScArgumentExprList]).withSuperParent(3, classOf[ScMethodCall])	PsiElementPattern.Capture[PsiElement]	superCallFilter
positionFromParameters(parameters)	PsiElement	dummyPosition
position.getNode.getElementType	IElementType	elementType
replaceDummy("class a { " + typeText + " " + additionText + "}")	String	text
PsiTreeUtil.getContextOfType(ref, classOf[ScFunction])	ScFunction	fun
replaceDummy("class a { " + newsText + " " + additionText + "}")	String	text
dummyPosition	PsiElement	position
parameters.getOffset - parameters.getPosition.getTextRange.getStartOffset + 1	Int	offsetInString
(inString, inInterpolatedString) match { case (true, true) => return case (true, _) => Some(("s" + dummyPosition.getText, dummyPosition, parameters.getPosition)) case (_, true) => (dummyPosition.getContext, parameters.getPosition.getParent) match { case (interpolated: ScInterpolated, dummyInterpolated: ScInterpolated) => splitInterpolatedString(interpolated, parameters.getOffset, dummyInterpolated) match { case Some((first, second, third)) => Some((s"$first{$second}$third", interpolated, dummyInterpolated)) case _ => return } case _ => return } case _ => None }	Option[(Any, PsiElement, PsiElement)]	maybePosition
ScalaPsiElementFactory.createExpressionFromText("s" + position.getText, position.getContext.getContext)	ScExpression	interpolated
parameters.getInvocationCount	Int	invocationCount
psiElement.afterLeaf("@").accepts(position)	Boolean	lookingForAnnotations
position.scopes.toSeq.headOption.collect { case element: ScalaPsiElement => element.getSameElementInContext }.getOrElse(originalFile)	PsiElement	scope
scope.getTextRange	TextRange	scopeRange
highlightInfo.getStartOffset	Int	startOffset
PsiFileFactory.getInstance(manager.getProject). createFileFromText(DUMMY + ScalaFileType.INSTANCE.getDefaultExtension, ScalaFileType.INSTANCE, text).asInstanceOf[ScalaFile]	ScalaFile	dummyFile
expectedTypes(definition).flatMap { collectProps(_) { ResolveUtils.isAccessible(_, definition, forCompletion = true) }(definition.getProject) }	IndexedSeq[ScalaAfterNewCompletionContributor.LookupElementProps]	propses
elem.getChildren.iterator	Iterator[PsiElement]	iterator
originalFile.findReferenceAt(startOffset) match { case (_: ScReference) childOf ((_: ScAssignment) childOf (_: ScArgumentExprList)) => None case reference: ScReference if reference.getTextRange.containsRange(startOffset, highlightInfo.getEndOffset) => Some(reference) case _ => None }	Option[ScReference]	maybeReference
iterator.next()	PsiElement	child
reference.refName	String	name
createRenamesMap(position)	ScalaAfterNewCompletionContributor.RenamesMap	renamesMap
maybePosition match { case Some((text, projectContext, offsetContext)) => ScalaPsiElementFactory.createExpressionFromText(text, projectContext.getContext) .findElementAt(parameters.getOffset - offsetContext.getTextRange.getStartOffset + 1) case _ => dummyPosition }	PsiElement	position
if (propses.nonEmpty) { val renamesMap = createRenamesMap(position) propses.map(_.createLookupElement(renamesMap)) } else Seq.empty	Seq[ScalaLookupItem]	items
reference.getParent match { case MethodInvocation(`reference`, expressions) => Some(expressions) // TODO: List(1, 2) map myFunc -> to support case parent => PsiTreeUtil.getNextSiblingOfType(parent, classOf[ScArgumentExprList]) match { case null => None case list => Some(list.exprs) } }	Option[Seq[ScExpression]]	maybeArguments
maybeArguments.fold("")(createParameters)	String	arguments
new UniqueNameSuggester()	NameSuggester.UniqueNameSuggester	suggester
shouldRunClassNameCompletion(dummyPosition, result.getPrefixMatcher)(parameters)	Boolean	classNameCompletion
position.getContainingFile.findElementAt(position.getTextOffset - 1) match { case null => false case element => element.getNode.getElementType == ScalaTokenTypes.tAT }	Boolean	lookingForAnnotations
mutable.HashSet.empty	mutable.HashSet[String]	classesNames
expression.`type`().getOrAny	ScType	`type`
mutable.HashSet.empty	mutable.HashSet[String]	objectNames
position.getContext.getContext	PsiElement	parent
parent match { case _: ScalaFile => true case _: ScPackaging => true case _ => false }	Boolean	shouldCompleteFileName
ref.getSimpleVariants().collect { case ScalaResolveResult(method: ScMethodLike, subst) => paramsInClause(method, subst, index) }.filter(_.length > 1)	IndexedSeq[Seq[(String, ScType)]]	signatures
getContextOfType(position, false, classOf[ScImportStmt]) != null	Boolean	isInImport
getContextOfType(position, false, classOf[ScStableCodeReference])	PsiElement	stableRefElement
stableRefElement != null && !stableRefElement.getContext.isInstanceOf[ScConstructorPattern]	Boolean	onlyClasses
invocationCount == 0	Boolean	topLevelOnly
expectedTypeAfterNew(dummyPosition)	Option[(PsiClass, ScalaAfterNewCompletionContributor.RenamesMap) => ScalaLookupItem]	maybeExpectedTypes
position.getProject	Project	project
finder.lookupItems(parameters.getOriginalFile, refExpr)	Seq[ScalaLookupItem]	items
invocationCount >= 3	Boolean	accessAll
positionFromParameters	PsiElement	element
dummyPosition.getProject	Project	project
expectedTypeAfterNew(position)(context)	Option[(PsiClass, ScalaAfterNewCompletionContributor.RenamesMap) => ScalaLookupItem]	maybeExpectedTypes
CodeInsightSettings.getInstance.EXCLUDED_PACKAGES.contains(packageFqn.startsWith(_: String))	Boolean	isExcluded
parameters.getInvocationCount < 2	Boolean	checkAccessibility
invocationCount >= 2 || (element match { case member: PsiMember => ResolveUtils.isAccessible(member, position, forCompletion = true) case _ => true })	Boolean	isAccessible
new PostProcessor(position)	ScalaBasicCompletionContributor.PostProcessor	processor
renamesMap.get(name).collect { case (`element`, s) => s }	Option[String]	renamed
new PostProcessor(position, isImplicit = true)	ScalaBasicCompletionContributor.PostProcessor	processor
members.map { member => createLookupElement(member, createText(member, clazz, full = true), hasOverride = false) }	IndexedSeq[LookupElementDecorator[LookupElement]]	lookupElements
clazz match { case c: ScClass => c.constructors case _ => clazz.getConstructors.toSeq }	Seq[PsiMethod]	constructors
positionFromParameters(completionParameters)	PsiElement	position
prefix + "." + memberName	String	newPrefix
inReadAction(JavaPsiFacade.getInstance(project).findPackage(packageFqn))	PsiPackage	pckg
result.getPrefixMatcher	PrefixMatcher	prefixMatcher
name + "."	String	nameWithDot
ScalaCodeStyleSettings.getInstance(project)	ScalaCodeStyleSettings	settings
super.changedLevel	Boolean	superRes
Some(ref.refName)	Some[String]	forName
element.withParents	Iterator[PsiElement]	parents
settings.getImportsWithPrefix.filter(!_.startsWith(ScalaCodeStyleSettings.EXCLUDE_PREFIX))	Array[Nothing]	patterns
parents.find { case null | _: ScValue | _: ScVariable => true case _ => false }	Option[PsiElement]	parent
(toImport, maybeExpectedTypes) match { case (ClassToImport(clazz), Some(createLookups)) => Some(createLookups(clazz, renamesMap)) case _ => val renamed = renamesMap.get(name).collect { case (`element`, s) => s } new ScalaResolveResult(element, renamed = renamed).getLookupElement( isClassName = true, isInImport = isInImport, isInStableCodeReference = stableRefElement != null, isInSimpleString = inString ) }	Option[ScalaLookupItem]	maybeLookup
element.getContext.asInstanceOf[ScReferenceExpression]	ScReferenceExpression	referenceExpression
StdTypes.instance.QualNameToType	Map[String, StdType]	QualNameToType
referenceExpression.getContext.asInstanceOf[ScBlockExpr]	ScBlockExpr	block
tp.extractClassType match { case Some((clazz: ScClass, subst)) if !clazz.hasTypeParameters || (clazz.hasTypeParameters && typeElement.isInstanceOf[ScParameterizedTypeElement]) => val constructors = clazz match { case c: ScClass => c.constructors case _ => clazz.getConstructors.toSeq } constructors .map(paramsInClause(_, subst, index)) .filter(_.length > 1) case _ => Seq.empty }	Seq[Seq[(String, ScType)]]	signatures
block.getContext.asInstanceOf[ScArgumentExprList]	ScArgumentExprList	args
new NameHint { override def getName(state: ResolveState): String = forName.get }	NameHint { def getName(state: ResolveState): String }	nameHint
m.projectContext	ProjectContext	projectContext
(ref match { case refImpl: ScStableCodeReferenceImpl => val processor = new PostProcessor(position) refImpl.doResolve(processor) processor.lookupElements case refImpl: ScReferenceExpressionImpl => val processor = new PostProcessor(position, isImplicit = true) refImpl.doResolve(processor) processor.lookupElements case refImpl: ScTypeProjectionImpl => val processor = new PostProcessor(position) refImpl.doResolve(processor) processor.lookupElements case _ => (ref: PsiReference).getVariants.toSeq }).collect { case ValidItem(item) => item } ++ prefixedThisAndSupers(ref)	IndexedSeq[ScalaLookupItem]	defaultLookupElements
"dynamic"	String	name
"2.0.0-RC4+34-ce4e2199+20190210-1617-SNAPSHOT"	String	version
"4.0.0"	String	scalameta
"2.0.0-RC4+34-ce4e2199+20190210-1617-SNAPSHOT"	String	nightly
"2.0.0-RC4"	String	stable
"2.12.8"	String	scala
"2.11.12"	String	scala211
fun.effectiveParameterClauses	Seq[ScParameterClause]	clauses
"1.0.3"	String	coursier
"ce4e2199157b4d4432335731427c84977fa871fc"	String	commit
"1549804620575"	String	timestamp
"2.12.8"	String	scalaVersion
"1.2.6"	String	sbtVersion
{ "name: %s, version: %s, scalameta: %s, nightly: %s, stable: %s, scala: %s, scala211: %s, coursier: %s, commit: %s, timestamp: %s, scalaVersion: %s, sbtVersion: %s" format ( name, version, scalameta, nightly, stable, scala, scala211, coursier, commit, timestamp, scalaVersion, sbtVersion ) }	String	toString
new ArrayBuffer[String]()	ArrayBuffer[String]	names
p.getElement	PsiElement	element
mutable.Set(defaultLookupElements.map(_.getLookupString): _*)	mutable.Set[Nothing]	lookupStrings
element.parentsInFile.containsInstanceOf[ScImportExpr]	Boolean	isImport
identifierWithParentsPattern( classOf[ScStableCodeReference], classOf[ScSimpleTypeElement], classOf[ScConstructorInvocation], classOf[ScTemplateParents], classOf[ScExtendsBlock], classOf[ScNewTemplateDefinition] )	PsiElementPattern.Capture[PsiElement]	afterNewPattern
new ArrayBuffer[ScType]	ArrayBuffer[ScType]	typez
signature.map { case (name: String, tp: ScType) => methodLike.parameterList.params.find(_.name == name) match { case Some(param) if param.`type`().getOrAny.conforms(tp) => names += name name case _ => names += "" } }.mkString(", ")	String	res
infix.operation.getText	String	op
unqualifiedReferencesInRange(range).groupBy { reference => (reference.refName, scopeEstimate(reference), reference.getKinds(incomplete = false)) }.values	Iterable[Seq[ScReference]]	groupedReferences
Icons.PARAMETER.getIconWidth	Int	w
ref.projectContext	ProjectContext	ts
insertHandlerDecorator(s".asInstanceOf[$canonicalText]")	InsertHandlerDecorator[ScalaLookupItem]	decorator
new DependencyProcessor(ref)	Dependency.DependencyProcessor	processor
new LayeredIcon(2)	LayeredIcon	icon
members.collect { case member@(_: ScValueMember | _: ScVariableMember) => createLookupElement(member, createText(member, clazz, full = !hasOverride, withBody = false), hasOverride) }	IndexedSeq[LookupElementDecorator[LookupElement]]	lookupElements
Some(qualifierCastType)	Some[ScType]	qualifierType
file.findElementAt(context.getStartOffset)	PsiElement	element
maybeLocation.fold(new ProcessingContext)(_.getProcessingContext)	ProcessingContext	context
reference.getContext match { case newReference: ScReferenceExpression => newReference case _ => reference }	ScReferenceExpression	result
item.element	PsiNamedElement	element
element match { case x: PsiMethod => var res = PsiFormatUtil.formatMethod(x, PsiSubstitutor.EMPTY, PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_PARAMETERS, PsiFormatUtilBase.SHOW_TYPE) if (x.containingClass != null) res = res + " of " + getDescriptiveName(x.containingClass) res case x: PsiVariable => x.name case x: PsiFile => x.name case x: ScTypeDefinition => x.qualifiedName case x: ScNamedElement => x.name case c: PsiClass if !c.isInstanceOf[PsiClassFake] => c.qualifiedName case _ => element.getText }	String	name
processor.lookupElements	Seq[LookupElement]	runtimeLookupElements
mutable.ArrayBuffer.empty[LookupElement]	ArrayBuffer[LookupElement]	lookupElements_
parameters match { case Seq(head) => Some(head) case _ => None }	Option[PsiTypeParameter]	maybeParameter
_subst(_tp)	ScType	tp
false	Boolean	elementAdded
expectedTypes(definition)	Seq[ScType]	types
scalaLookupItem.substitutor(tp)	ScType	scType
Option(declaration.getContext).collect { case body: ScTemplateBody => body }	Option[Nothing]	maybeBody
s"failed to resolve Scalafmt version '$version'"	String	message
ref match { case rExpr: ScReferenceExpressionImpl => rExpr.doResolve(processor) case stRef: ScStableCodeReferenceImpl => stRef.doResolve(processor) case _ => ScalaResolveResult.EMPTY_ARRAY }	Array[ScalaResolveResult]	results
if (filename.endsWith(".sbt") || filename.endsWith(".sc")) { config.withSbtDialect } else { config }	ScalafmtDynamicConfig	configWithDialect
"Extractor"	UsageType	Extractor
"Typed Pattern"	UsageType	ClassTypedPattern
"Typed Statement"	UsageType	TypedStatement
element match { case c: PsiMethod => PsiFormatUtil.formatMethod(c, PsiSubstitutor.EMPTY, PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_PARAMETERS, PsiFormatUtilBase.SHOW_TYPE) case c: PsiVariable => c.name case c: PsiFile => c.name case c: ScTypeDefinition => if (useFullName) c.qualifiedName else c.name case c: ScNamedElement => c.name case c: PsiClass if !c.isInstanceOf[PsiClassFake] => if (useFullName) c.qualifiedName else c.name case _ => element.getText }	String	name
"Method `apply`"	UsageType	MethodApply
result.getLookupElement().head	ScalaLookupItem	newElem
downloadWriter.println _	ScalafmtDynamicDownloader.DownloadProgressListener	progressListener
new ScalafmtDynamicDownloader(progressListener)	ScalafmtDynamicDownloader	downloader
"This Reference"	UsageType	ThisReference
"Access Modifier"	UsageType	AccessModifier
"Package Clause"	UsageType	PackageClause
"Function expression"	UsageType	FunctionExpression
"Named parameter"	UsageType	NamedParameter
new CompletionProcessor(StdKinds.refExprLastRef, place) { override protected def postProcess(result: ScalaResolveResult): Unit = { if (!result.isNamedParameter) { val newElem = result.getLookupElement().head applyVariant(new ScalaChainLookupElement(scalaLookupItem, newElem)) } } }	CompletionProcessor { def postProcess(result: ScalaResolveResult): Unit }	processor
entity match { case e: PsiClass => e.qualifiedName case e: PsiPackage => e.getQualifiedName case _ => return None }	String	qName
Option(getContextOfType(position, classOf[PsiClass]))	Option[Nothing]	containingClass
"Interpolated string prefix"	UsageType	PrefixInterpolatedString
"Parameter in pattern"	UsageType	ParameterInPattern
path.asString()	String	string
"Self type"	UsageType	SelfType
findAppropriateType(types: _*)(designatorType, maybeParameter)(clazz)	Option[(ScType, Boolean)]	maybeAppropriateType
new URLClassLoader(urls, null)	ScalaClassLoader.URLClassLoader	classloader
Try( scalafmtCls.getMethod("format", classOf[String], defaultScalaFmtConfig.getClass, scalaSetCls, classOf[String]) ).toOption	Option[Nothing]	formatMethodWithFilename
"Type bound"	UsageType	TypeBound
{ // TODO: see implementation details for other versions of scalafmt, find where intellij config is kept assert(version == "1.5.1", "intellij scalafmt config is only supported fot version 1.5.1 for now") val scalaFmtConfigCls = classLoader.loadClass("org.scalafmt.config.ScalafmtConfig") val configTarget = scalaFmtConfigCls.invokeStatic("intellij") new ScalafmtDynamicConfig(this, configTarget, classLoader) }	ScalafmtDynamicConfig	intellijScalaFmtConfig
"Type alias"	UsageType	TypeAlias
new String(Files.readAllBytes(configPath), StandardCharsets.UTF_8)	String	configText
"Secondary constructor"	UsageType	SecondaryConstructor
string.lastIndexOf('.')	Int	index
"Implicit Conversion/Parameter"	UsageType	ImplicitConversionOrParam
"Unresolved Implicit Conversion/Parameter"	UsageType	UnresolvedImplicit
"SAM interface implementation"	UsageType	SAMImplementation
checkForSecondCompletion && fun.paramClauses.flatten.isEmpty	Boolean	second
Try(targetCls.getMethod("rewrite")).toOption	Option[Nothing]	rewriteRulesMethod
Try(targetCls.getMethod("continuationIndent")).toOption	Option[Nothing]	continuationIndentMethod
target match { case o: ScObject => Some(o) case ContainingClass(o: ScObject) => Some(o) case _ => None }	Option[ScObject]	obj
Try(targetCls.getMethod("continuationIndentCallSite")).toOption	Option[Nothing]	continuationIndentCallSiteMethod
Try(targetCls.getMethod("continuationIndentDefnSite")).toOption	Option[Nothing]	continuationIndentDefnSiteMethod
2	Int	DefaultIndentCallSite
4	Int	DefaultIndentDefnSite
if (chainVariant) ScSubstitutor.empty else ScalaPsiUtil.undefineMethodTypeParams(fun)	ScSubstitutor	infer
new ScalafmtDependencyResolver(progressListener)	ScalafmtDynamicDownloader.ScalafmtDependencyResolver	resolver
{ target.invokeAs[String]("version").trim }	String	version
renamesMap.get(name).collect { case (`clazz`, s) => s }	Option[String]	isRenamed
checkForSecondCompletion && fun.paramClauses.clauses.filterNot(_.isImplicit).flatMap(_.parameters).isEmpty	Boolean	second
clazz match { case _: ScTrait => true case _ => clazz.isInterface || clazz.hasModifierPropertyScala("abstract") }	Boolean	isInterface
{ continuationIndentMethod match { case Some(method) => // >v0.4 val indentsObj = method.invoke(target) indentsObj.invokeAs[Int]("callSite") case None => continuationIndentCallSiteMethod match { case Some(method) => // >v0.2.0 method.invoke(target).asInstanceOf[Int] case None => DefaultIndentCallSite } } }	Int	continuationIndentCallSite
resolver.resolve(dependencies(version): _*)	Seq[DependencyManagerBase.ResolvedDependency]	resolvedDependencies
{ continuationIndentMethod match { case Some(method) => val indentsObj = method.invoke(target) indentsObj.invokeAs[Int]("defnSite") case None => continuationIndentDefnSiteMethod match { case Some(method) => method.invoke(target).asInstanceOf[Int] case None => DefaultIndentDefnSite } } }	Int	continuationIndentDefnSite
resolvedDependencies.map(_.file.toPath)	Seq[Any]	jars
getPlace.isInstanceOf[ScStableCodeReference]	Boolean	isInStableCodeReference
fun.returnType match { case Right(tp) => checkType(tp, infer, second) case _ => false }	Boolean	added
None	Option[ScType]	qualifierType
new NotificationGroup("Scalafmt (Scala plugin)", NotificationDisplayType.BALLOON, true)	NotificationGroup	notificationGroup
checkForSecondCompletion && method.getParameterList.getParametersCount == 0	Boolean	second
new NotificationGroup("Scalafmt errors (Scala plugin)", NotificationDisplayType.STICKY_BALLOON, true)	NotificationGroup	notificationErrorGroup
`type` match { case ParameterizedType(_, types) => types case _ => Seq.empty }	Seq[ScType]	typeParameters
if (chainVariant) ScSubstitutor.empty else ScalaPsiUtil.undefineMethodTypeParams(method)	ScSubstitutor	infer
ScalaCollectionsUtil.newConcurrentMap	mutable.Map[String, WeakReference[Notification]]	messagesShown
if (notificationType == NotificationType.INFORMATION) { notificationGroup.createNotification(message, notificationType) } else { notificationErrorGroup.createNotification(message, notificationType) }	Notification	notification
declaration match { case _: PsiMethod => classOf[ScMethodMember] case _: ScValueDeclaration => classOf[ScValueMember] case _: ScVariableDeclaration => classOf[ScVariableMember] case _: ScTypeAlias => classOf[ScAliasMember] case _ => classOf[ScalaNamedMember] }	(Class[_ >: _$1 <: ScalaNamedMember]) forSome {type _$1 >: ScAliasMember <: _$1; type _$1 >: ScVariableMember <: _$1; type _$1 >: ScMethodMember with ScValueMember <: PsiElementClassMember[_ >: PsiMethod with ScValue] with ScalaTypedMember}	filterClass
clazz match { case owner: PsiDocCommentOwner => owner.isDeprecated case _ => false }	Boolean	isDeprecated
interpolated.getTextRange.getStartOffset	Int	startOffset
notification.getBalloon	Balloon	balloon
isRenamed match { case Some(newName) => s"$newName <= $name" case _ => name }	String	nameText
rangeEndOffset - startOffset	Int	pointPosition
new ScalaLexer()	ScalaLexer	lexer
jars.map(_.toUri.toURL).toArray	Array[Any]	urls
_ => {}	ScalafmtDynamicDownloader.DownloadProgressListener	NoopProgressListener
Set()	Set[String]	artifactBlackList
org.apache.ivy.util.Message.MSG_INFO	Int	logLevel
str	String	strTrimmed
new ScalaResolveResult(namedElement) .getLookupElement(isClassName = true, shouldImport = true) .head	ScalaLookupItem	lookup
positionRange(pos)	RangePosition	range
strTrimmed.indexOf("\n")	Int	newLineIdx
typez.iterator	Iterator[ScType]	iterator
s"""{ | val xxx: $canonicalText = null | xxx.xxx |}""".stripMargin	String	text
typeParameters match { case Seq() => "" case seq => seq.map(substitutor) .map(_.presentableText) .mkString("[", ", ", "]") }	String	parametersText
new ScalaFmtSuggesterComponent.State()	ScalaFmtSuggesterComponent.State	state
e.invokeAs[String]("shortMessage")	String	shortMessage
new LookupElementRenderer[LookupElement] { def renderElement(ignore: LookupElement, presentation: LookupElementPresentation) { val tailText = if (isInterface) "{...} " else "" presentation.setTailText(" " + tailText + clazz.getPresentation.getLocationString, true) presentation.setIcon(clazz.getIcon(0)) val isDeprecated = clazz match { case owner: PsiDocCommentOwner => owner.isDeprecated case _ => false } presentation.setStrikeout(isDeprecated) val nameText = isRenamed match { case Some(newName) => s"$newName <= $name" case _ => name } val parametersText = typeParameters match { case Seq() => "" case seq => seq.map(substitutor) .map(_.presentableText) .mkString("[", ", ", "]") } presentation.setItemText(nameText + parametersText) } }	LookupElementRenderer[LookupElement] { def renderElement(ignore: LookupElement, presentation: LookupElementPresentation): Unit }	renderer
new CodeStyleSchemesModel(project)	CodeStyleSchemesModel	codeStyleSchemesModel
config.version	String	obtained
place	PsiElement	parent
false	Boolean	foundClazz
codeStyleSchemesModel.getSelectedScheme	CodeStyleScheme	scheme
new ScalaLookupItem(clazz, isRenamed.getOrElse(name)) { override def renderElement(presentation: LookupElementPresentation): Unit = renderer.renderElement(this, presentation) }	ScalaLookupItem { def renderElement(presentation: LookupElementPresentation): Unit }	result
{ import AutoCompletionPolicy._ if (ApplicationManager.getApplication.isUnitTestMode) Some(ALWAYS_AUTOCOMPLETE) else if (isInterface) Some(NEVER_AUTOCOMPLETE) else None }	Option[AutoCompletionPolicy]	maybePolicy
expression.contexts.instancesOf[ScTemplateDefinition].size <= 1	Boolean	notInsideSeveralClasses
(if (foundClazz) t.name + "." else "") + "this"	String	lookupString
new ScalaLookupItem(t, lookupString)	ScalaLookupItem	el
args.isBraceArgs	Boolean	isBraceArgs
if (td.extendsBlock.templateParents.isEmpty) Nil else List(new ScalaLookupItem(td, td.name + ".super"))	List[ScalaLookupItem]	superItem
classMembers.filter(filterClass.isInstance).map { member => createLookupElement(member, createText(member, clazz), hasOverride) }	IndexedSeq[LookupElementDecorator[LookupElement]]	lookupElements
if (notInsideSeveralClasses || td.isInstanceOf[ScObject]) Nil else List(new ScalaLookupItem(td, td.name + ".this"))	List[ScalaLookupItem]	thisItem
new ScalaFmtSuggesterComponent.State()	ScalaFmtSuggesterComponent.State	newState
new NotificationListener.Adapter { override def hyperlinkActivated(notification: Notification, e: HyperlinkEvent): Unit = { notification.expire() e.getDescription match { case `enableProjectDescription` => enableForProject() case `dontShowDescription` => val newState = new ScalaFmtSuggesterComponent.State() newState.enableForCurrentProject = false loadState(newState) case _ => } } }	NotificationListener	listener
true	Boolean	enableForCurrentProject
NotificationGroup.balloonGroup("Scalafmt detection")	NotificationGroup	suggesterNotificationGroup
ScalaCollectionsUtil.newConcurrentMap	mutable.Map[String, ScalafmtDynamicConfigManager.CachedConfig]	configsCache
ScalaCodeStyleSettings.getInstance(project)	ScalaCodeStyleSettings	scalaSettings
scalaSettings.USE_SCALAFMT_FORMATTER	Boolean	isScalafmtEnabled
if (isOverride) ScalaGenerationInfo.getMethodBody(member, clazz, isImplement = false) else "???"	String	mBody
scalafmtProjectConfigFile(project, scalaSettings.SCALAFMT_CONFIG_PATH)	Option[VirtualFile]	configFile
for { parameterType <- params simplifiedType = parameterType.removeAbstracts } yield (simplifiedType, simplifiedType.presentableText)	IndexedSeq[(ScType, String)]	presentableParams
new CodeStyleSettingsInferComponent.State	CodeStyleSettingsInferComponent.State	state
FileBasedIndex.getInstance()	FileBasedIndex	fileIndex
if (full) createOverrideImplementMethod(signature, needsOverrideModifier = true, mBody, withComment = false, withAnnotation = false) else createMethodFromSignature(signature, mBody, withComment = false, withAnnotation = false)	ScFunction	fun
ScalaDocAsteriskAlignStyleIndexer.Id	ID[ScalaDocAsteriskAlignStyleIndexer.AsteriskAlignStyle, Any]	indexId
configFile.flatMap(readVersion(_).toOption.flatten).getOrElse(DefaultVersion)	String	version
builder(presentableParams)	String	itemText
itemText match { case isEnoughSpaceFor() => itemText case _ => @tailrec def innerItemText(index: Int): String = index - 1 match { case 0 => s"... $functionArrow " case newIndex => builder(presentableParams.take(newIndex), separator = ", ...") match { case string@isEnoughSpaceFor() => string case _ => innerItemText(newIndex) } } innerItemText(presentableParams.length) }	String	text
CodeStyleSchemesImpl.getSchemeManager.getAllSchemes.asScala	Seq[CodeStyleScheme]	codeStyleSchemes
resolveConfig( configFile, Some(version), verbosity, resolveFast = true )	ScalafmtDynamicConfigManager.ConfigResolveResult	configOrError
mutable.HashSet.empty[ScAbstractType]	mutable.HashSet[ScAbstractType]	result
createOverrideImplementVariable(member.element, member.substitutor, needsOverrideModifier = false, isVal = true, withBody = withBody)	ScMember	variable
{ val result = mutable.HashSet.empty[ScAbstractType] params.foreach { _.visitRecursively { case abstractType: ScAbstractType => result += abstractType case _ => } } result.toSet }	Set[ScAbstractType]	abstracts
ScalaCollectionsUtil.newConcurrentMap	mutable.Map[ScalafmtDynamicService.ScalafmtVersion, ScalafmtDynamicService.ResolveStatus]	formattersCache
new ServiceState	ScalafmtDynamicService.ServiceState	state
createOverrideImplementVariable(member.element, member.substitutor, needsOverrideModifier = false, isVal = false, withBody = withBody)	ScMember	variable
classMember match { case member@ScMethodMember(signature, isOverride) => val mBody = if (isOverride) ScalaGenerationInfo.getMethodBody(member, clazz, isImplement = false) else "???" val fun = if (full) createOverrideImplementMethod(signature, needsOverrideModifier = true, mBody, withComment = false, withAnnotation = false) else createMethodFromSignature(signature, mBody, withComment = false, withAnnotation = false) removeTypeAnnotationIfNeeded(fun) fun.getText case ScAliasMember(element, substitutor, _) => getOverrideImplementTypeSign(element, substitutor, needsOverride = false) case member: ScValueMember => val variable = createOverrideImplementVariable(member.element, member.substitutor, needsOverrideModifier = false, isVal = true, withBody = withBody) removeTypeAnnotationIfNeeded(variable) variable.getText case member: ScVariableMember => val variable = createOverrideImplementVariable(member.element, member.substitutor, needsOverrideModifier = false, isVal = false, withBody = withBody) removeTypeAnnotationIfNeeded(variable) variable.getText case _ => " " }	String	text
member.getElement	PsiDocCommentOwner	lookupObject
SourceFilterScope(Seq(ScalaFileType.INSTANCE))(project)	SourceFilterScope	sourcesScope
scalafmtProjectConfigFile(project, configPath)	Option[VirtualFile]	configFile
context.getFile.findElementAt(context.getStartOffset)	PsiElement	startElement
ScalaDocAsteriskAlignStyleIndexer.Id	ID[ScalaDocAsteriskAlignStyleIndexer.AsteriskAlignStyle, Any]	getName
inputData.getProject	Project	project
fileIndex.getAllKeys(indexId, project).asScala.map { alignType => val occurrences = fileIndex.getValues(indexId, alignType, sourcesScope).asScala alignType -> occurrences.foldLeft(0)(_ + _) }.filter(_._2 > 0).toMap	Map[ScalaDocAsteriskAlignStyleIndexer.AsteriskAlignStyle, Int]	alignTypeCounts
configFile match { case Some(file) => resolveConfig(file, Some(DefaultVersion), verbosity, resolveFast).toOption case None => intellijDefaultConfig }	Option[ScalafmtDynamicConfig]	config
scheme.getCodeStyleSettings.getCommonSettings(ScalaLanguage.INSTANCE)	CommonCodeStyleSettings	commonSettings
mutable.HashSet.empty[String]	mutable.HashSet[String]	addedClasses
clazz.getUseScope match { case _: LocalSearchScope => GlobalSearchScope.allScope(project) case useScope => useScope }	SearchScope	searchScope
CodeStyle.getSettings(project).getTabSize(ScalaFileType.INSTANCE)	Int	tabSize
if (psiFile.isInstanceOf[SbtFileImpl]) { config.map(_.withSbtDialect) } else { config }	Option[ScalafmtDynamicConfig]	configWithDialect
Set("scala.Boolean", "scala.Byte", "scala.Short", "scala.Int", "scala.Long", "scala.Float", "scala.Double", "scala.AnyVal", "scala.Char", "scala.Unit", "scala.Any")	Set[Nothing]	names
configFile.map(_.getPath).flatMap(configsCache.get).map(_.vFileModificationTimestamp)	Option[Long]	timestamp
configFile.getModificationStamp	Long	currentVFileTimestamp
inReadAction(FileDocumentManager.getInstance.getDocument(configFile)).getModificationStamp	Long	currentDocTimestamp
configsCache.get(configPath)	Option[ScalafmtDynamicConfigManager.CachedConfig]	cachedConfig
parameters.map(UndefinedType(_))	IndexedSeq[UndefinedType]	undefinedTypes
alignTypeCounts.maxBy(_._2)._1	ScalaDocAsteriskAlignStyleIndexer.AsteriskAlignStyle	mostUsedStyle
inReadAction(FileDocumentManager.getInstance.getDocument(configFile))	Document	document
this.builder { params.map { `type` => `type` -> `type`.canonicalText } }(project)	String	text
fromParametersTypes(designatorType, undefinedTypes)	ValueType	predefinedType
Logger.getInstance(this.getClass)	Logger	Log
new MyState	CodeStyleSettingsMigrationServiceBase.MyState	state
CodeStyleSchemesImpl.getSchemeManager.getAllSchemes.asScala.toSeq	Seq[CodeStyleScheme]	appLevelSchemes
formattersCache.get(version) match { case Some(ResolveStatus.Resolved(scalaFmt)) => Right(scalaFmt) case _ if resolveFast => Left(ScalafmtResolveError.NotFound(version)) case Some(ResolveStatus.DownloadInProgress) => Left(ScalafmtResolveError.DownloadInProgress(version)) case _ => if (state.resolvedVersions.containsKey(version)) { val jarUrls = state.resolvedVersions.get(version).map(new URL(_)) resolveClassPath(version, jarUrls) } else if (downloadIfMissing) { downloadAndResolve(version, progressListener) } else { Left(ScalafmtResolveError.NotFound(version)) } }	ScalafmtDynamicService.ResolveResult	resolveResult
new ScalafmtDynamicDownloader(listener)	ScalafmtDynamicDownloader	downloader
getState.version	Int	currentVersion
!cachedConfig.map(_.config).contains(config)	Boolean	contentChanged
new URLClassLoader(jarUrls, null)	ScalaClassLoader.URLClassLoader	classloader
documentManager.getPsiFile(document)	PsiFile	file
codeStyleSchemesModel.getProjectScheme	CodeStyleScheme	projectScheme
member match { case member: ScalaTypedMember if !member.isInstanceOf[JavaFieldMember] => Some(member.scType) case ScAliasMember(definition: ScTypeAliasDefinition, _, _) => definition.aliasedTypeElement.map(_.calcType) case _ => None }	Option[ScType]	maybeType
fromParameters(designatorType, parameters)	ValueType	valueType
StringUtils.indexOf(fileText, '\n', regMatch.end)	Int	nextNewLineIdx
codeStyleSchemesModel.getSelectedScheme	CodeStyleScheme	selectedScheme
if (codeStyleSchemesModel.isProjectScheme(selectedScheme)) { selectedScheme } else { codeStyleSchemesModel.copyToProject(selectedScheme) codeStyleSchemesModel.getProjectScheme }	CodeStyleScheme	projectScheme
projectScheme.getCodeStyleSettings	CodeStyleSettings	settings
false	Boolean	done
Migrations.all.map(_.version).max	Int	latestVersion
indentSize(fileText, regMatch.start + 1, tabSize)	Int	indentSizeDocStart
Migrations.all.filter(_.version > currentVersion)	Seq[CodeStyleSettingsMigrationServiceBase.MigrationItem]	unappliedMigrations
indentSize(fileText, nextNewLineIdx + 1, tabSize)	Int	indentSizeNextLine
ID.create("ScalaDocAsteriskAlignStyleIndexer")	ID[ScalaDocAsteriskAlignStyleIndexer.AsteriskAlignStyle, Any]	Id
MigrationItem(1, scalaSettings => { import ScalaCodeStyleSettings._ import scalaSettings._ MULTILINE_STRING_CLOSING_QUOTES_ON_NEW_LINE = MULTILINE_STRING_SUPORT >= MULTILINE_STRING_QUOTES_AND_INDENT MULTILINE_STRING_INSERT_MARGIN_ON_ENTER = MULTILINE_STRING_SUPORT >= MULTILINE_STRING_INSERT_MARGIN_CHAR })	CodeStyleSettingsMigrationServiceBase.MigrationItem	DecomposeMultilineStringSupportSettings
Seq( DecomposeMultilineStringSupportSettings )	Seq[CodeStyleSettingsMigrationServiceBase.MigrationItem]	all
ScalafmtReflect( classloader, version, respectVersion = true )	ScalafmtReflect	scalaFmt
_	Seq[(Any, Any)]	scopeCheckboxes
startOffset + text.length()	Int	endOffset
s"Can not resolve scalafmt version `${error.version}`:<br>"	String	baseMessage
ListMap( ("TRAILING_COMMA_ARG_LIST_ENABLED", "Arguments list"), ("TRAILING_COMMA_PARAMS_ENABLED", "Parameters list"), ("TRAILING_COMMA_TUPLE_ENABLED", "Tuple"), ("TRAILING_COMMA_TUPLE_TYPE_ENABLED", "Tuple type"), ("TRAILING_COMMA_PATTERN_ARG_LIST_ENABLED", "Pattern arguments list"), ("TRAILING_COMMA_TYPE_PARAMS_ENABLED", "Type parameters list"), ("TRAILING_COMMA_IMPORT_SELECTOR_ENABLED", "Import selector"), )	ListMap[String, String]	scopeFields
PsiTreeUtil.findCommonParent(file.findElementAt(startOffset), file.findElementAt(endOffset - 1))	PsiElement	commonParent
s"Scalafmt version `$version` is not downloaded yet.<br>Would you like to to download it?"	String	message
s"$baseMessage Download is in progress"	String	errorMessage
TemplateBuilderFactory.getInstance() .createTemplateBuilder(commonParent) .asInstanceOf[TemplateBuilderImpl]	TemplateBuilderImpl	builder
`type`.typeParameter.name	String	name
createConfigEditor	EditorEx	getEditor
configText.exists(_ != editorText)	Boolean	configTextChangedInEditor
configError match { case ConfigFileNotFound(_) => s"file not found" case ConfigMissingVersion(_) => "missing version setting" case ConfigParseError(_, cause) => s"parse error: ${cause.getMessage}" case UnknownError(unknownMessage, _) => s"unknown error: $unknownMessage" // do not report, rely on ScalafmtDynamicUtil resolve error reporting case _: ConfigScalafmtResolveError => return }	String	details
s"Failed to load scalafmt config:<br>$details"	String	errorMessage
new OpenFileNotificationActon(project, configFile, offset = 0, title = "open config file")	OpenFileNotificationActon	openFileAction
configForFile(file)	Option[ScalafmtDynamicConfig]	configOpt
".scalafmt.conf"	String	DefaultConfigurationFileName
abstracts.map { `type` => val name = `type`.typeParameter.name name + ScTypePresentation.ABSTRACT_TYPE_POSTFIX -> (`type`, name) }.toMap	Map[String, (ScAbstractType, String)]	abstractNames
_	ScalaTabbedCodeStylePanel.ScalafmtTabbedLanguageCodeStylePanel	shortenedPanel
ConfigFactory.parseString(document.getText)	Config	config
if (configPath.nonEmpty) configPath else DefaultConfigurationFileName	String	configPathActual
new ScalaRecursiveElementVisitor { override def visitSimpleTypeElement(simple: ScSimpleTypeElement): Unit = for { reference <- simple.reference refName = reference.refName (abstractType, name) <- abstractNames.get(refName) value = abstractType.simplifyType match { case simplifiedType if simplifiedType.isAny || simplifiedType.isNothing => name case simplifiedType => simplifiedType.presentableText } } builder.replaceElement(simple, refName, new ConstantNode(value), false) }	ScalaRecursiveElementVisitor { def visitSimpleTypeElement(simple: ScSimpleTypeElement): Unit }	visitor
Set( "addFullQualifiedImports", "addImportMostCloseToReference", "classCountToUseImportOnDemand", "importMembersUsingUnderScore", "importShortestPathForAmbiguousReferences", "importsWithPrefix", "sortImports" )	Set[Nothing]	actualSettingsSet
builder.buildTemplate()	Template	template
new ComponentManagerSettingsImpl(file, context) {}	ComponentManagerSettingsImpl	settings
s"$baseMessage An error occurred during downloading:<br>${cause.getMessage}"	String	errorMessage
new NameSuggester.UniqueNameSuggester("x")	NameSuggester.UniqueNameSuggester	suggester
settings.getRootElement	Element	root
new DownloadScalafmtNotificationActon(version, title = "resolve again") { override def actionPerformed(e: AnActionEvent, notification: Notification): Unit = { state.resolvedVersions.remove(version) super.actionPerformed(e, notification) } }	ScalafmtDynamicService.this.DownloadScalafmtNotificationActon { def actionPerformed(e: AnActionEvent, notification: Notification): Unit }	action
true	Boolean	myIsValid
s"${if (isDownloaded) "Resolving" else "Downloading"}"	String	titlePrefix
new ProgressIndicatorDownloadListener(indicator, s"$titlePrefix: ")	ScalafmtDynamicService.ProgressIndicatorDownloadListener	progressListener
new CommonCodeStyleSettings(getLanguage)	CommonCodeStyleSettings	commonSettings
value.getChild("ScalaCodeStyleSettings")	Element	settingsValue
commonSettings.initIndentOptions	CommonCodeStyleSettings.IndentOptions	indentOptions
new PsiRecursiveElementVisitor() { override def visitElement(element: PsiElement): Unit = { CodeEditUtil.setNodeGenerated(element.getNode, false) super.visitElement(element) } }	PsiRecursiveElementVisitor	generatedVisitor
new ArrayBuffer	ArrayBuffer[String]	buffer
TypeAdjuster.isMarkedForAdjustment(before)	Boolean	originalMarkedForAdjustment
before.getParent	PsiElement	parent
before.getTextRange.getStartOffset	Int	offset
new ComboBoxItem(scalaSettings.TRAILING_COMMA_MODE, "")	TrailingCommaPanel.ComboBoxItem[Nothing]	fictiveItem
if (keysAndValues != null) Array(keysAndValues._1, keysAndValues._2) else Array()	Array[_ <: Array[_ >: String with Int]]	options
LanguageCodeStyleSettingsProvider.forLanguage(ScalaLanguage.INSTANCE)	LanguageCodeStyleSettingsProvider	provider
if (parent != null) { Option(inWriteAction(parent.addBefore(formatted, before))) } else None	Option[PsiElement]	inserted
2	Int	gridRows
ProjectUtil.guessProjectDir(project).toOption	Option[VirtualFile]	projectRoot
classOf[ScalaCodeStyleSettings]	Class[ScalaCodeStyleSettings]	styleClass
absolutePath(baseDir)	String	result
try { resolve(version, downloadIfMissing = true, FmtVerbosity.Verbose, progressListener = progressListener) } catch { case pce: ProcessCanceledException => Left(DownloadError(version, pce)) }	ScalafmtDynamicService.ResolveResult	result
formatters.find(_._2 == scalaSettings.FORMATTER).map(_._1).get	String	formatterKey
new Task.Backgroundable(project, s"$titlePrefix scalafmt version $version", true) { override def run(indicator: ProgressIndicator): Unit = { indicator.setIndeterminate(true) val progressListener = new ProgressIndicatorDownloadListener(indicator, s"$titlePrefix: ") val result = try { resolve(version, downloadIfMissing = true, FmtVerbosity.Verbose, progressListener = progressListener) } catch { case pce: ProcessCanceledException => Left(DownloadError(version, pce)) } onResolved(result) } }	Task.Backgroundable { def run(indicator: ProgressIndicator): Unit }	backgroundTask
selectedTrailingCommaMode.exists(_ != TrailingCommaMode.TRAILING_COMMA_KEEP)	Boolean	isScopeEnabled
VcsUtil.getVcsRootFor(project, baseDir).toOption	Option[VirtualFile]	vcsRoot
_	ScalaTabbedCodeStylePanel	panel
( CodeStyleSettingsCustomizable.BRACE_OPTIONS, CodeStyleSettingsCustomizable.BRACE_VALUES )	(Array[String], Array[Int])	BRACE_OPTION_AND_VALUES
vcsRoot.map(absolutePath).filter(exists)	Option[String]	vcsResult
"""import scala.collection.immutable.{Seq, List} // one line comment 1 | |class A { | | def foo(): Int = 42 | | // `Within | Simple one line block braces` changes can only be visible if | // `Wrapping and Braces | Keep when reformatting | Simple blocks/methods in one line` setting is enabled | def bar(x: Int): Option[Int] = { Some(24) } | | class B() { // one line comment 2 | } | | class C private(val param1: Int, param2: Long) { | } | | foo[Int]() | | bar(7) | | new B() | | List(1, 2, 3).foreach { item => | } | | // `Within | Self type braces` changes can only be visible if | // `Wrapping and Braces | Class definition | Place self type on new line` setting is disabled | trait T { self: A => | } | | if (true) { // one line comment 3 | } | else if (false) { | } | else { | } | | for (x <- Option(1); y <- Option(2)) | yield x * y | | for { | item <- Seq("item1", "item2", "item3") | } yield item | | while (true) { | } | | do { | } while (true) | | try { | } catch { | } finally { | } | | obj.method() | obj.method("1") | obj.method("1", "2") | obj method() | obj method("1") // operator-like method call, takes single argument | obj method("1", "2") | obj * 42 // operator calls are always surrounded with space | obj % (42) | obj + (42, 23) | | "hello" slice(1, 2) intern() | | def +++(s: StringBuilder): StringBuilder = { | s append (this.toString) | } | | def fooWithExplicitSpace () {} | | bar(7) match { | case s@Some(24) => | case _ => | } | | @inline def multiply(x: Int, y: Int): Int = x * y | | trait X1[F] | trait X2[F: T] | trait X4[F: T1 : T2] | trait X3[F[_] : T] | trait X5[F[_] : T1 : T2] | trait X6[F <: G : T1 : T2] |} """.stripMargin.withNormalizedSeparator	String	SpacingCodeSample
SIZEPOLICY_CAN_SHRINK | SIZEPOLICY_CAN_GROW	Int	CAN_SHRINK_AND_GROW
settings.clone()	CodeStyleSettings	tempSettings
Map( "IntelliJ" -> ScalaCodeStyleSettings.INTELLIJ_FORMATTER, "scalafmt" -> ScalaCodeStyleSettings.SCALAFMT_FORMATTER, )	Map[String, Int]	formatters
_	ScalaFmtSettingsPanel	scalaFmtSettingsPanel
new OtherCodeStylePanel(settings)	OtherCodeStylePanel	otherCodeStylePanel
isPanelEnabled != scalaSettings.USE_SCALAFMT_FORMATTER	Boolean	panelWasJustEnabled
isModified(settings) || configTextChangedInEditor || panelWasJustEnabled	Boolean	modified
addDelta( original.getTextRange.getStartOffset + commonPrefixLength, original.getContainingFile, formatted.getTextLength - original.getTextLength )	Int	delta
projectOpt match { case Some(value) => value case None => return }	Project	project
settings.getCommonSettings(ScalaLanguage.INSTANCE)	CommonCodeStyleSettings	commonSettings
original.getParent	PsiElement	parent
original.getTextOffset	Int	offset
ScalafmtDynamicConfigManager.readVersion(configFile) match { case Right(v) => v case Left(ex) => reportConfigParseError(ex.getMessage) return }	Option[String]	versionOpt
isNextChangeSibling(nextChange, original)	Boolean	nextChangeIsSibling
versionOpt.getOrElse(DefaultVersion)	String	version
original.getNextSibling	PsiElement	nextSibling
new PostFormatProcessorHelper(commonSettings)	PostFormatProcessorHelper	myPostProcessor
replaced.getNextSibling	PsiElement	nextSibling
externalFormatterSettingsPath	TextFieldWithBrowseButton	component
addDelta(remove, -remove.getTextLength)	Int	res
option == CommonCodeStyleSettings.FORCE_BRACES_ALWAYS || (option == CommonCodeStyleSettings.FORCE_BRACES_IF_MULTILINE && PostFormatProcessorHelper.isMultiline(stmt))	Boolean	needBraces
head.getParent	PsiElement	parent
parent.getTextLength	Int	oldTextLength
head.getProject	Project	project
TokenSet.create( ScalaElementType.MODIFIERS, ScalaElementType.ANNOTATIONS, ScalaTokenTypes.tLINE_COMMENT )	TokenSet	ModifiersOrAnnotationOrLineComment
element.getPsi	PsiElement	psiElement
TokenSet.create( ScalaElementType.TRY_STMT, ScalaElementType.PACKAGING )	TokenSet	TryOrPackaging
ScalaCodeStyleSettings.getInstance(psiElement.getProject)	ScalaCodeStyleSettings	scalaSettings
new PostFormatProcessorHelper(commonSettings)	PostFormatProcessorHelper	postProcessor
TokenSet.create( ScalaTokenTypes.kIF, ScalaTokenTypes.kELSE )	TokenSet	IfOrElse
psiElement.getTextRange	TextRange	oldRange
new ScalaDocNewlinedPreFormatVisitor(scalaSettings)	ScalaDocNewlinedPreFormatProcessor.this.ScalaDocNewlinedPreFormatVisitor	visitor
psiElement.getTextRange.getEndOffset - oldRange.getEndOffset	Int	diff
element.getPrevSibling	PsiElement	prevElement
if (isParamTag(prevElement) && !isParamTag(element) && scalaSettings.SD_BLANK_LINE_AFTER_PARAMETERS_COMMENTS || isReturnTag(prevElement) && !isReturnTag(element) && scalaSettings.SD_BLANK_LINE_AFTER_RETURN_COMMENTS || isParamTag(prevElement) && isParamTag(element) && scalaSettings.SD_BLANK_LINE_BETWEEN_PARAMETERS || !isParamTag(prevElement) && isParamTag(element) && scalaSettings.SD_BLANK_LINE_BEFORE_PARAMETERS) 2 else 1	Int	newlinesNew
prevElement	PsiElement	current
parent.commonSettings	CommonCodeStyleSettings	settings
elements.map(_.getText).mkString("{\n", "\n", "\n}")	String	concatText
PsiTreeUtil.nextLeaf(element)	PsiElement	nextElement
createExpressionFromText(concatText)(head.getManager)	ScExpression	newExpr
PsiTreeUtil.prevLeaf(head)	PsiElement	prev
PsiTreeUtil.nextLeaf(elements.last)	PsiElement	next
{ import ScCodeBlockElementType.BlockExpression TokenSet.create(BlockExpression, TEMPLATE_BODY, PACKAGING, MATCH_STMT, CATCH_BLOCK) }	TokenSet	BLOCK_ELEMENT_TYPES
if (element.getText.count(_ == '\n') > 1) element.replace(createDocWhiteSpace) else element	PsiElement	newElement
lastWs	ProjectContext	ctx
new RelativePoint(relativeTo, new Point(xPosition, yPosition))	RelativePoint	balloonPosition
lastWs.getParent	PsiElement	parent
lastWs.getPrevSibling	PsiElement	prev
inReadAction(FileDocumentManager.getInstance.getDocument(vFile))	Document	document
element	PsiElement	currentChild
currentChild.getPrevSibling	PsiElement	lastWhitespace
Option(element.getPsi).flatMap(_.getContainingFile.toOption)	Option[PsiFile]	psiFile
lastWhitespace	PsiElement	currentWs
0	Int	newlinesCount
trailingElement.getNextSiblingNotWhitespaceComment	PsiElement	next
node.getTextRange.getStartOffset - 1	Int	offset
0	Int	result
next != null && next.getNode.getElementType == ScalaTokenTypes.tCOMMA	Boolean	isCommaNext
trailingElement.getParent	PsiElement	parent
trailingElement.getProject	Project	project
ScalaPsiElementFactory.createComma(project)	PsiElement	newComma
block.commonSettings	CommonCodeStyleSettings	settings
block.getNode	ASTNode	node
CodeStyle.getSettings(project).getCustomSettings(classOf[ScalaCodeStyleSettings])	ScalaCodeStyleSettings	scalaSettings
node.getElementType	IElementType	nodeElementType
node.getTreeParent	ASTNode	nodeTreeParent
new JBTextField	JBTextField	configPathTextField
priority(elementOperation(parent).getText, assignments)	Int	parentPriority
getNode.getPsi	PsiElement	parent
range != file.getTextRange	Boolean	isSubrangeFormatting
externalFormatterSettingsPath.getButton	FixedSizeButton	button
ApplicationManager.getApplication.getMessageBus	MessageBus	bus
priority(elementOperation(psi).getText, assignments)	Int	childPriority
settings.getIndentSize(ScalaFileType.INSTANCE)	Int	indentSize
parentPriority != childPriority	Boolean	notSamePriority
nodeTreeParent.nullSafe.map(_.getElementType).get	IElementType	nodeTreeParentElementType
2	Int	ScalaFmtIndent
settings.BRACE_STYLE == CommonCodeStyleSettings.NEXT_LINE_SHIFTED	Boolean	braceShifted
child.getElementType	IElementType	childElementType
s"class $DummyWrapperClassName {\n"	String	DummyWrapperClassPrefix
block.parentBlock.suggestedWrap	Wrap	parentSuggestedWrap
settings.BRACE_STYLE == NEXT_LINE_SHIFTED	Boolean	isBraceNextLineShifted1
if (m.clauses.nonEmpty) Indent.getSpaceIndent(2 * indentSize) else if (braceShifted) Indent.getNoneIndent else Indent.getNormalIndent	Indent	indent
settings.BRACE_STYLE == NEXT_LINE_SHIFTED2	Boolean	isBraceNextLineShifted2
isBraceNextLineShifted1 || isBraceNextLineShifted2	Boolean	isBraceNextLineShifted
b.resultExpression.orElse(b.caseClauses).get.getNode.getTreePrev	ASTNode	nodeBeforeLast
if (parentSuggestedWrap != null) { Wrap.createChildWrap(parentSuggestedWrap, WrapType.byLegacyRepresentation(settings.CALL_PARAMETERS_WRAP), false) } else { Wrap.createWrap(settings.CALL_PARAMETERS_WRAP, false) }	Wrap	wrap
projectOpt.flatMap(ScalafmtDynamicConfigManager.absolutePathFromConfigPath(_, path))	Option[String]	absolutePath
parent.getNode	ASTNode	parentNode
parentNode.getPsi	PsiElement	parentPsi
dfsChildren(left.lastNode.nullSafe.getOrElse(left.getNode), _.getChildren(null).toList.reverse)	ASTNode	leftNode
nodeBeforeLast.getElementType == TokenType.WHITE_SPACE && nodeBeforeLast.textContains('\n')	Boolean	isLineBreak
new TextComponentAccessor[JTextField]() { override def setText(textField: JTextField, text: String): Unit = { textField.setText(text) updateConfigPath(text) } override def getText(textField: JTextField): String = { val path = textField.getText.toOption.filter(StringUtils.isNotBlank).getOrElse(DefaultConfigFilePath) val absolutePath = projectOpt.flatMap(ScalafmtDynamicConfigManager.absolutePathFromConfigPath(_, path)) absolutePath.getOrElse(DefaultConfigFilePath) } }	TextComponentAccessor[Any] { def setText(textField: Any, text: String): Unit def getText(textField: Any): String }	textAccessor
nodeTreeParent.nullSafe.map(_.getTreeParent).map(_.getPsi).get	PsiElement	nodeTreeParentParent
dfsChildren(right.getNode, _.getChildren(null).toList)	ASTNode	rightNode
block.getParent	PsiElement	blockParent
right.commonSettings	CommonCodeStyleSettings	settings
settings.KEEP_BLANK_LINES_IN_CODE	Int	keepBlankLinesInCode
settings.KEEP_LINE_BREAKS	Boolean	keepLineBreaks
settings.KEEP_BLANK_LINES_IN_DECLARATIONS	Int	keepBlankLinesInDeclarations
settings.KEEP_BLANK_LINES_BEFORE_RBRACE	Int	keepBlankLinesBeforeRBrace
left.settings.getCustomSettings(classOf[ScalaCodeStyleSettings])	ScalaCodeStyleSettings	scalaSettings
file.getViewProvider	FileViewProvider	viewProvider
viewProvider.getPsi(viewProvider.getBaseLanguage)	PsiFile	containingFile
new FocusListener { override def focusGained(e: FocusEvent): Unit = {} override def focusLost(e: FocusEvent): Unit = { val configPath = externalFormatterSettingsPath.getText if (StringUtils.isBlank(configPath)) { externalFormatterSettingsPath.setText(null) updateConfigPath(DefaultConfigFilePath) } else { updateConfigPath(configPath) } } }	{ def focusLost(e: Any): Unit def focusGained(e: Any): Unit }	focusListener
false	Boolean	isPanelEnabled
None	Option[Project]	projectOpt
None	Option[Any]	configText
leftNode.getPsi	PsiElement	leftPsi
rightNode.getPsi	PsiElement	rightPsi
leftNode.getPsi.getParent	PsiElement	leftPsiParent
rightNode.getPsi.getParent	PsiElement	rightPsiParent
deltas.iterator	Iterator[(Int, Int)]	iterator
(0, 0)	(Int, Int)	currentDelta
Key.create("alingnments.map")	Key[mutable.Map[getDummyBlocks.InterpolatedPointer, (Alignment, Alignment)]]	alignmentsMapKey
_	TextFieldWithBrowseButton	externalFormatterSettingsPath
fixRangeStartingOnPsiElement(file, range)	TextRange	rangeUpdated
Key.create("field.group.alignment.key")	Key[Alignment]	fieldGroupAlignmentKey
_	JBCheckBox	showScalaFmtInvalidCodeWarnings
_	JBCheckBox	useIntellijFormatterForRangeFormat
_	JBCheckBox	reformatOnFileSaveCheckBox
findWhiteSpaceToken(leafElement).getOrElse(TokenType.WHITE_SPACE)	IElementType	whiteSpaceToken
Key.create("multilevel.alignment")	Key[mutable.Map[IElementType, List[ElementPointerAlignmentStrategy]]]	multiLevelAlignmentKey
s".${File.separatorChar}${ScalafmtDynamicConfigManager.DefaultConfigurationFileName}"	String	DefaultConfigFilePath
EditorFactory.getInstance	EditorFactory	editorFactory
editorFactory.createDocument("")	Document	editorDocument
Alignment.createAlignment(true)	Alignment	myAlignment
editorFactory.createEditor(editorDocument) .asInstanceOf[EditorEx]	EditorEx	editor
node.getPsi()	PsiElement	psiElement
Language.findLanguageByID("HOCON")	Language	hoconLanguage
TokenSet.create( ScalaElementType.INFIX_EXPR, ScalaElementType.INFIX_PATTERN, ScalaElementType.INFIX_TYPE )	TokenSet	InfixElementsTokenSet
new LayeredLexerEditorHighlighter( getSyntaxHighlighter(hoconLanguage, null, null), new DefaultColorsScheme )	LayeredLexerEditorHighlighter	highlighter
TokenSet.orSet( TokenSet.create(tCOLON, tASSIGN), VAL_VAR_TOKEN_SET )	TokenSet	FieldGroupSubBlocksTokenSet
TokenSet.create( tFUNTYPE, tFUNTYPE_ASCII )	TokenSet	FunctionTypeTokenSet
{ val nodeBeforeLast = b.resultExpression.orElse(b.caseClauses).get.getNode.getTreePrev val isLineBreak = nodeBeforeLast.getElementType == TokenType.WHITE_SPACE && nodeBeforeLast.textContains('\n') val extraIndent = if (isLineBreak) getSubBlocks().size - newChildIndex else 0 val indentsCount = extraIndent + (if (braceShifted) 0 else 1) Indent.getSpaceIndent(indentsCount * indentSize) }	Indent	indent
StdArrangementSettingsToken.token(SCALA_GETTERS_AND_SETTERS_ID, SCALA_GETTERS_AND_SETTERS_UI, StdArrangementTokenType.GROUPING)	ArrangementSettingsToken	SCALA_GETTERS_AND_SETTERS
if (braceShifted) { Indent.getNoneIndent } else { Indent.getNormalIndent }	Indent	indent
StdArrangementSettingsToken.token(JAVA_GETTERS_AND_SETTERS_ID, JAVA_GETTERS_AND_SETTERS_UI, StdArrangementTokenType.GROUPING)	ArrangementSettingsToken	JAVA_GETTERS_AND_SETTERS
block.settings	CodeStyleSettings	settings
StdArrangementSettingsToken.token(SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_EXPRESSIONS_ID, SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_EXPRESSIONS_UI, StdArrangementTokenType.GROUPING)	ArrangementSettingsToken	SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_EXPRESSIONS
if (scope.getNode.getElementType == ScalaTokenTypes.tLBRACE && braceShifted) Indent.getNoneIndent else Indent.getNormalIndent	Indent	indent
StdArrangementSettingsToken.token(SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS_ID, SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS_UI, StdArrangementTokenType.GROUPING)	ArrangementSettingsToken	SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS
parent.getParent	PsiElement	grandParent
grandParent match { case _: ScCaseClause | _: ScFunctionExpr => Indent.getNormalIndent case _ => Indent.getNoneIndent }	Indent	indent
if (x.body.isDefined) Indent.getNoneIndent else if (settings.BRACE_STYLE == CommonCodeStyleSettings.NEXT_LINE_SHIFTED) Indent.getNoneIndent else Indent.getNormalIndent	Indent	indent
settings.getCustomSettings(classOf[ScalaCodeStyleSettings])	ScalaCodeStyleSettings	scalaSettings
node.getChildren(null)	Array[ASTNode]	children
immutable.HashMap(SCALA_GETTERS_AND_SETTERS.getId -> SCALA_GETTERS_AND_SETTERS, JAVA_GETTERS_AND_SETTERS.getId -> JAVA_GETTERS_AND_SETTERS, SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_EXPRESSIONS.getId -> SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_EXPRESSIONS, SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS.getId -> SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS)	HashMap[Nothing, Nothing]	scalaGroupingRules
immutable.ListMap("public" -> PUBLIC, "protected" -> PROTECTED, "private" -> PRIVATE)	ListMap[Nothing, Nothing]	scalaAccessModifiersByName
if (ss.ALIGN_IF_ELSE) Alignment.createAlignment else null	Alignment	alignment
immutable.HashMap(PUBLIC.getId -> PUBLIC, PROTECTED.getId -> PROTECTED, PRIVATE.getId -> PRIVATE)	HashMap[Nothing, Nothing]	scalaAccessModifiersById
StdArrangementSettingsToken.token(SEALED_ID, SEALED_UI, StdArrangementTokenType.MODIFIER)	ArrangementSettingsToken	SEALED
StdArrangementSettingsToken.token(IMPLICIT_ID, IMPLICIT_UI, StdArrangementTokenType.MODIFIER)	ArrangementSettingsToken	IMPLICIT
StdArrangementSettingsToken.token(CASE_ID, CASE_UI, StdArrangementTokenType.MODIFIER)	ArrangementSettingsToken	CASE
StdArrangementSettingsToken.token(OVERRIDE_ID, OVERRIDE_UI, StdArrangementTokenType.MODIFIER)	ArrangementSettingsToken	OVERRIDE
nodeTreeParent.nullSafe.map(_.getPsi).get	PsiElement	nodeTreeParentPsi
StdArrangementSettingsToken.token(LAZY_ID, LAZY_UI, StdArrangementTokenType.MODIFIER)	ArrangementSettingsToken	LAZY
immutable.ListMap(SEALED_UI -> SEALED, IMPLICIT_UI -> IMPLICIT, "abstract" -> ABSTRACT, CASE_UI -> CASE, "final" -> FINAL, OVERRIDE_UI -> OVERRIDE, LAZY_UI -> LAZY)	ListMap[Nothing, Nothing]	scalaOtherModifiersByName
Indent.getSpaceIndent(if (scalaSettings.USE_SCALADOC2_FORMATTING) 2 else 1)	Indent	indent
nodeTreeParent.nullSafe.map(_.getTreeParent).map(_.getPsi).get	PsiElement	nodeTreeParentParentPsi
new TextRange(0, fileText.length())	TextRange	fileTextRange
Indent.getSpaceIndent(scalaSettings.ALTERNATE_CONTINUATION_INDENT_FOR_PARAMS, false)	Indent	indent
if (scalaSettings.NOT_CONTINUATION_INDENT_FOR_PARAMS) Indent.getNormalIndent else Indent.getContinuationWithoutFirstIndent	Indent	indent
parent.getContainingFile	PsiFile	file
immutable.HashMap(SEALED.getId -> SEALED, IMPLICIT.getId -> IMPLICIT, ABSTRACT.getId -> ABSTRACT, FINAL.getId -> FINAL, OVERRIDE.getId -> OVERRIDE, LAZY.getId -> LAZY)	HashMap[Nothing, Nothing]	scalaOtherModifiersById
StdArrangementSettingsToken.token(TYPE_ID, TYPE_UI, StdArrangementTokenType.ENTRY_TYPE)	ArrangementSettingsToken	TYPE
StdArrangementSettingsToken.token(FUNCTION_ID, FUNCTION_UI, StdArrangementTokenType.ENTRY_TYPE)	ArrangementSettingsToken	FUNCTION
StdArrangementSettingsToken.token(VAL_ID, VAL_UI, StdArrangementTokenType.ENTRY_TYPE)	ArrangementSettingsToken	VAL
StdArrangementSettingsToken.token(MACRO_ID, MACRO_UI, StdArrangementTokenType.ENTRY_TYPE)	ArrangementSettingsToken	MACRO
if (cachedFileTimeStamp == file.getModificationStamp) moveRanges(cachedRange) else new TextRanges	ScalaFmtPreFormatProcessor.TextRanges	ranges
StdArrangementSettingsToken.token(OBJECT_ID, OBJECT_UI, StdArrangementTokenType.ENTRY_TYPE)	ArrangementSettingsToken	OBJECT
StdArrangementSettingsToken.tokenById(UNSEPARABLE_RANGE_ID, StdArrangementTokenType.ENTRY_TYPE)	ArrangementSettingsToken	UNSEPARABLE_RANGE
file.findElementAt(range.getStartOffset)	PsiElement	startElement
ScalafmtDynamicConfigManager.instanceIn(file.getProject)	ScalafmtDynamicConfigManager	configManager
getSpacing(keepBlankLinesInCode, spacesMin, 0)	Spacing	WITHOUT_SPACING
immutable.HashSet(TYPE, FUNCTION, CLASS, VAL, VAR, TRAIT, MACRO, CONSTRUCTOR, OBJECT)	HashSet[ArrangementSettingsToken]	scalaTypesValues
startElement != null && !startElement.isInstanceOf[PsiWhiteSpace] && startElement.getTextRange.getStartOffset == range.getStartOffset	Boolean	rangeStartsOnPsiElement
Spacing.createSpacing(spacesMin, spacesMin, 0, false, 0)	Spacing	WITHOUT_SPACING_NO_KEEP
PsiTreeUtil.prevLeaf(startElement, true)	PsiElement	prev
childPsi.isInstanceOf[ScExtendsBlock] && childPsi.getFirstChild.nullSafe.map(_.elementType).contains(ScalaTokenTypes.kEXTENDS)	Boolean	childIsExtends
PsiTreeUtil.getParentOfType(parentPsi, classOf[ScExtendsBlock])	ScExtendsBlock	e
e.earlyDefinitions match { case Some(z) => z case _ => e.templateParents match { case Some(tp) if tp.typeElements.nonEmpty => tp.typeElements.head case _ => null } }	PsiElement	first
if (shouldWrap) { wrap(elements) } else { val elementsText = elements.foldLeft("") { case (acc, element) => acc + element.getText } new WrappedCode(elementsText, wrapped = false, wrappedInHelperClass = false) }	ScalaFmtPreFormatProcessor.WrappedCode	wrappedCode
config.fmtReflect	ScalafmtReflect	scalaFmt
configManager.configForFile(file, FmtVerbosity.FailSilent, resolveFast = true)	Option[ScalafmtDynamicConfig]	configOpt
elements.head	PsiElement	firstElement
elements.last	PsiElement	lastElement
findPsiFileRoot(firstElement).copy().asInstanceOf[PsiFile]	PsiFile	rootNodeCopy
children.filter(isCorrectBlock)	Array[ASTNode]	correctChildren
findElementAtRange(rootNodeCopy, firstElement.getTextRange)	PsiElement	firstElementInCopy
findElementAtRange(rootNodeCopy, lastElement.getTextRange)	PsiElement	lastElementInCopy
(range: TextRange) => getDependentLFSpacing(keepBlankLinesInCode, spacesMin, range)	TextRange => Spacing	WITHOUT_SPACING_DEPENDENT
immutable.HashMap(TYPE.getId -> TYPE, FUNCTION.getId -> FUNCTION, CLASS.getId -> CLASS, VAL.getId -> VAL, VAR.getId -> VAR, TRAIT.getId -> TRAIT, MACRO.getId -> MACRO, CONSTRUCTOR.getId -> CONSTRUCTOR, OBJECT.getId -> OBJECT)	HashMap[Nothing, Nothing]	scalaTypesById
getSpacing(keepBlankLinesInCode, 1, 0)	Spacing	WITH_SPACING
Spacing.createSpacing(1, 1, 0, false, 0)	Spacing	WITH_SPACING_NO_KEEP
parent match { case _: ScParameterClause if newChildIndex != 0 => Indent.getSpaceIndent(indentDefn) case _: ScArguments if newChildIndex != 0 => Indent.getSpaceIndent(indentCall) case m: ScMatch if m.clauses.nonEmpty => Indent.getSpaceIndent(4) case _: ScBlock | _: ScTemplateBody | _: ScMatch | _: ScCaseClauses | _: ScCaseClause => Indent.getSpaceIndent(2) case _ if parent.getNode.getElementType == ScalaTokenTypes.kIF => Indent.getSpaceIndent(2) case _ => Indent.getNoneIndent }	Indent	indent
this.getElementsOfRange(firstElementInCopy, lastElementInCopy).toArray	Array[PsiElement]	elementsInCopy
(range: TextRange) => getDependentLFSpacing(keepBlankLinesInCode, 1, range)	TextRange => Spacing	WITH_SPACING_DEPENDENT
getSpacing(keepBlankLinesInCode, 0, 1)	Spacing	ON_NEW_LINE
firstElementInCopy.prependSiblings(createDocComment(StartMarker), createNewLine())	Seq[PsiElement]	startMarkers
getSpacing(keepBlankLinesInCode, 0, 2)	Spacing	DOUBLE_LINE
Spacing.createSpacing(0, 0, 0, true, 1)	Spacing	NO_SPACING_WITH_NEWLINE
lastElementInCopy.appendSiblings(createNewLine(), createDocComment(EndMarker))	Seq[PsiElement]	endMarkers
Spacing.createSpacing(spacesMin, spacesMin, 0, false, 0)	Spacing	NO_SPACING
Spacing.createSpacing(1, 1, 0, keepLineBreaks, 100)	Spacing	COMMON_SPACING
ScalaSpacingProcessor.getSpacing(child1.asInstanceOf[ScalaBlock], child2.asInstanceOf[ScalaBlock])	Spacing	spacing
Spacing.createSpacing(0, 0, 1, true, 100)	Spacing	IMPORT_BETWEEN_SPACING
node.getLastChildNode	ASTNode	lastChild
_	Wrap	_suggestedWrap
if (scalaSettings.SD_PRESERVE_SPACES_IN_TAGS) Spacing.createSpacing(0, Int.MaxValue, 0, false, 0) else WITH_SPACING	Spacing	tagSpacing
element.children.toArray	Array[PsiElement]	children
getGroupingRules(settings)	HashSet[ArrangementSettingsToken]	groupingRules
new ScalaArrangementParseInfo	ScalaArrangementParseInfo	existingInfo
new ScalaArrangementParseInfo	ScalaArrangementParseInfo	newInfo
wrapInHelperClass(text)	String	wrappedInHelper
scalaAccessModifiersByName.toSet.map((x: tokensType) => x._2)	IndexedSeq[ArrangementSettingsToken]	scalaAccessModifiersValues
new ScalaArrangementParseInfo	ScalaArrangementParseInfo	info
afterOpenBrace.nonEmpty && afterOpenBrace.head.getElementType == tLBRACE && afterOpenBrace.last.getElementType == tRBRACE	Boolean	hasValidTail
settings.getCommonSettings(ScalaLanguage.INSTANCE)	CommonCodeStyleSettings	codeStyleSettings
None	Option[String]	scalaDocPrevChildTag
Alignment.createAlignment(true)	Alignment	contextAlignment
mutable.Buffer[ScalaArrangementEntry]()	mutable.Buffer[ScalaArrangementEntry]	myEntries
target.innerEntryType.getOrElse(target.getType)	ArrangementSettingsToken	targetType
createAlignment(node)	Alignment	alignment
mutable.HashMap[ScFunction, ScalaArrangementEntry]()	mutable.HashMap[ScFunction, ScalaArrangementEntry]	methodToEntry
previous.innerEntryType.getOrElse(previous.getType)	ArrangementSettingsToken	previousType
immutable.HashSet[ArrangementSettingsToken]()	HashSet[ArrangementSettingsToken]	result
mutable.Buffer[ScalaArrangementDependency]()	mutable.Buffer[ScalaArrangementDependency]	dependencyRoots
mutable.Stack[ScalaArrangementEntry]()	mutable.Stack[ScalaArrangementEntry]	arrangementEntries
mutable.HashMap[ScFunction, immutable.HashSet[ScFunction]]()	mutable.HashMap[ScFunction, HashSet[ScFunction]]	methodDependencies
mutable.HashSet[ScFunction]()	mutable.HashSet[ScFunction]	currentMethodDependencyRoots
mutable.HashSet[ScFunction]()	mutable.HashSet[ScFunction]	currentDependentMethods
true	Boolean	rebuildMethodDependencies
scalaAccessModifiersValues ++ scalaOtherModifiersByName.toSet.map((x: tokensType) => x._2)	IndexedSeq[ArrangementSettingsToken]	scalaModifiers
ArrangementUtil.parseType(current)	ArrangementSettingsToken	tokenType
immutable.HashSet(StdArrangementTokens.Order.BY_NAME, StdArrangementTokens.Order.KEEP)	HashSet[ArrangementSettingsToken]	supportedOrders
groupingRules.contains(SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_EXPRESSIONS)	Boolean	splitBodyByExpressions
groupingRules.contains(SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS)	Boolean	splitBodyByImplicits
mutable.HashMap[(String/*property name*/, PsiElement/*PSI parent*/), ScalaPropertyInfo]()	mutable.HashMap[(String, PsiElement), ScalaPropertyInfo]	javaPropertiesData
mutable.HashMap[(String/*property name*/, PsiElement/*PSI parent*/), ScalaPropertyInfo]()	mutable.HashMap[(String, PsiElement), ScalaPropertyInfo]	scalaPropertiesData
mutable.HashMap[ScalaArrangementEntry /*parent*/ , mutable.Queue[ScalaArrangementEntry] /*Arrangement blocks*/ ]()	mutable.HashMap[ScalaArrangementEntry, mutable.Queue[ScalaArrangementEntry]]	unseparableRanges
childrenAdditionalContexts.map { case (_, context) => context.lastNode }.collect { case Some(x) => x }	IndexedSeq[ASTNode]	nodes1
scalaAccessModifiersValues + FINAL	String	commonModifiers
childrenAdditionalContexts.map { case (child, _) => child }	IndexedSeq[ASTNode]	nodes2
if (!methodDependencies.contains(caller)) { immutable.HashSet[ScFunction]() } else { methodDependencies(caller) }	HashSet[ScFunction]	callerDependent
new mutable.HashMap[ScFunction, ScalaArrangementDependency]	mutable.HashMap[ScFunction, ScalaArrangementDependency]	cache
dependency.getAnchorMethod	ScalaArrangementEntry	dependentEntry
mutable.Queue[ScalaArrangementDependency]()	mutable.Queue[ScalaArrangementDependency]	toProcess
p.getChildren.drop(1)	Array[PsiElement]	children
rightNode.getTextRange.getStartOffset	Int	nodeOffset
Option(child.getFirstChildNode).filter(_.getElementType == ScalaDocTokenType.DOC_TAG_NAME).map(_.getText)	Option[Nothing]	currentTag
scalaAccessModifiersByName ++ scalaOtherModifiersByName	ListMap[Nothing, Nothing]	scalaModifiersByName
nodes1 ++ nodes2 ++ additionalNodes	IndexedSeq[ASTNode]	nodes
elements.filter { case _: ScImportStmt | _: ScDocComment | _: PsiComment | _: PsiDocComment | _: PsiWhiteSpace => false case _ => true }	Seq[PsiElement]	elementsToConsider
right.getTextRange.contains(new TextRange(nodeOffset, nodeOffset + 3))	Boolean	magicCondition
buildMethodDependencyInfo(method, cache)	Option[ScalaArrangementDependency]	info
methodToEntry(method)	ScalaArrangementEntry	entry
new ScalaArrangementDependency(entry)	ScalaArrangementDependency	result
(child.getElementType match { case ScalaDocElementTypes.DOC_TAG => val currentTag = Option(child.getFirstChildNode).filter(_.getElementType == ScalaDocTokenType.DOC_TAG_NAME).map(_.getText) if (scalaDocPrevChildTag.isEmpty || scalaDocPrevChildTag != currentTag) { contextAlignment = Alignment.createAlignment(true) } scalaDocPrevChildTag = currentTag Some(contextAlignment) case _ => None }).map(a => new SubBlocksContext(alignment = Some(a)))	Option[SubBlocksContext]	context
List[(ScFunction, ScalaArrangementDependency)]()	List[(ScFunction, ScalaArrangementDependency)]	toProcess
Set.empty[ScFunction]	Set[ScFunction]	usedMethods
node.getPsi.asInstanceOf[ScDocTag]	ScDocTag	docTag
scalaAccessModifiersById ++ scalaOtherModifiersById ++ scalaTypesById	Map[Nothing, V1]	scalaTokensById
elements.filterNot(_.isInstanceOf[PsiWhiteSpace])	Seq[PsiElement]	elementsWithoutWs
immutable.List[ScalaArrangementDependency]()	List[ScalaArrangementDependency]	methodsInfo
if (cache.contains(dependentMethod)) { cache(dependentMethod) } else { new ScalaArrangementDependency(dependentEntry) }	ScalaArrangementDependency	dependentMethodInfo
toProcess.dequeue()	ScalaArrangementDependency	current
getNonWsSiblings(docTag.getFirstChild.getNode)	List[ASTNode]	childBlocks
dependencyInfo.getAnchorMethod	ScalaArrangementEntry	dependencyMethod
children.filter(isCorrectBlock)	Array[ASTNode]	childrenFiltered
new ArrangementCompositeMatchCondition	ArrangementCompositeMatchCondition	composite
psi.prevSibling match { case Some(prev@Whitespace(s)) => if (s.contains("\n")) None else prev.prevSibling case prev => prev }	Option[PsiElement]	prevNonWsNode
elementsWithoutWs.map(el => (el, formatInSingleFile(Seq(el), config, shouldWrap = true)))	IndexedSeq[(PsiElement, Option[ScalaFmtPreFormatProcessor.WrappedCode])]	elementsFormatted
{ val prevNonWsNode: Option[PsiElement] = psi.prevSibling match { case Some(prev@Whitespace(s)) => if (s.contains("\n")) None else prev.prevSibling case prev => prev } prevNonWsNode.map(_.elementType) match { case Some(`tLBRACE` | `tLPARENTHESIS`) if scalaSettings.KEEP_COMMENTS_ON_SAME_LINE => Indent.getNormalIndent case _ => Indent.getNoneIndent } }	Indent	indent
ScalaProjectSettings.getInstance(e.getProject)	ScalaProjectSettings	settings
EditorColors.BREADCRUMBS_CURRENT	TextAttributesKey	DEFAULT_COLOR
(EditorColors.BREADCRUMBS_DEFAULT, EditorColors.BREADCRUMBS_HOVERED)	(TextAttributesKey, TextAttributesKey)	BASE_COLORS_PAIR
EditorColors.GUTTER_BACKGROUND	ColorKey	BASE_BACKGROUND_COLOR
Array[Language](ScalaLanguage.INSTANCE)	Array[Language]	SCALA_LANG
150	Int	MAX_TEXT_LENGTH
25	Int	MAX_STRING_LENGTH
configManager.configForFile(file).orNull	ScalafmtDynamicConfig	config
file.getProject	Project	project
PsiDocumentManager.getInstance(project)	PsiDocumentManager	manager
immutable.List[ArrangementGroupingRule](new ArrangementGroupingRule(DEPENDENT_METHODS, DEPTH_FIRST), new ArrangementGroupingRule(JAVA_GETTERS_AND_SETTERS), new ArrangementGroupingRule(SCALA_GETTERS_AND_SETTERS), new ArrangementGroupingRule(SPLIT_INTO_UNARRANGEABLE_BLOCKS_BY_IMPLICITS))	List[ArrangementGroupingRule]	groupingRules
new JBColor(15790320, 3224373)	JBColor	DEFAULT_BACKGROUND_COLOR
manager.getDocument(file)	Document	document
file.getText	String	fileText
range.contains(file.getTextRange)	Boolean	rangeIncludesWholeFile
None	Option[ScalaFmtPreFormatProcessor.ScalafmtFormatError]	wholeFileFormatError
config.hasRewriteRules	Boolean	hasRewriteRules
if (hasRewriteRules) elements.flatMap(maybeRewriteElements(_, range)) else Seq.empty	Seq[PsiElement]	rewriteElements
immutable.List[ArrangementSectionRule]()	List[ArrangementSectionRule]	matchRules
getDefaultSettings	StdArrangementSettings	defaultSettings
new DefaultArrangementSettingsSerializer(new ScalaSettingsSerializerMixin(), defaultSettings)	DefaultArrangementSettingsSerializer	SETTINGS_SERIALIZER
attachFormattedCode(rewriteElements, config)	Seq[(PsiElement, ScalaFmtPreFormatProcessor.WrappedCode)]	rewriteElementsToFormatted
if (hasRewriteRules) config.withoutRewriteRules else config	ScalafmtDynamicConfig	noRewriteConfig
1.9	Double	THRESHOLD
0.075	Double	MIN_LUM
replaceWithFormatted(elements, formatted, rewriteElementsToFormatted, range)	Int	textRangeDelta
formatInSingleFile(elements, noRewriteConfig, wrap).map { formatted => val textRangeDelta = replaceWithFormatted(elements, formatted, rewriteElementsToFormatted, range) manager.commitDocument(document) textRangeDelta }	Option[Int]	result
immutable.HashMap(TYPE -> (commonModifiers + OVERRIDE), FUNCTION -> (commonModifiers + OVERRIDE + IMPLICIT), CLASS -> (commonModifiers + ABSTRACT + SEALED), TRAIT -> (commonModifiers + ABSTRACT + SEALED), VAL -> (commonModifiers + OVERRIDE + LAZY + ABSTRACT), VAR -> (commonModifiers + OVERRIDE), MACRO -> (commonModifiers + OVERRIDE), CONSTRUCTOR -> scalaAccessModifiersValues, OBJECT -> commonModifiers)	HashMap[ArrangementSettingsToken, Any]	tokensForType
elementsInRangeWrapped(file, range)	Seq[PsiElement]	elementsWrapped
createExpressionFromText("s" + literal.getText, literal.getContext) .asInstanceOf[ScInterpolatedStringLiteral]	ScInterpolatedStringLiteral	interpolated
wrapFile.findElementAt(text.indexOf(StartMarker)).getParent	PsiElement	startMarker
wrapFile.findElementAt(text.indexOf(EndMarker)).getParent	PsiElement	endMarker
startMarker.getParent	PsiElement	startMarkerParent
interpolated.getTextRange.getStartOffset + 1	Int	startOffset
startMarkerParent.isInstanceOf[ScMember] && startMarkerParent.getFirstChild == startMarker	Boolean	isCommentStuckToElement
startMarker.getNextSibling	PsiElement	sibling
if (!isCommentStuckToElement) startMarker else { val sibling = startMarker.getNextSibling startMarkerParent.deleteChildRange(startMarker, startMarker) sibling match { case ws: PsiWhiteSpace => // delete new line after doc comment as well ws.getWhitespaceAfterFirstNewLine match { case Some(wsNew) => ws.replace(wsNew) case None => ws.delete() } case _ => } startMarkerParent }	PsiElement	startMarkerFixed
newDef.constructorInvocation match { case None => "Object" case Some(c) if c.arguments.nonEmpty => s"${c.typeElement.getText}$PAR_HOLDER" case Some(c) => s"${c.typeElement.getText}" }	String	constructor
this.getElementsOfRange(startMarkerFixed, endMarker)	Seq[PsiElement]	result
new ArrayBuffer[PsiElement]	ArrayBuffer[PsiElement]	result
start	PsiElement	e
file.findElementAt(range.getEndOffset - 1)	PsiElement	endElement
getStringParts(interpolated)	Array[PsiElement]	parts
createMemberSelectionTable(memberInfo, abstractColumnHeader)	ScalaMemberSelectionTableBase[M, I]	myTable
myMemberInfos.get(rowIndex)	I	info
commonSettings.METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE || params.clauses.headOption.flatMap(_.parameters.headOption).forall(_.startsFromNewLine())	Boolean	firstParameterStartsFromNewLine
newDef.extendsBlock.templateParents.exists(_.typeElementsWithoutConstructor.nonEmpty)	Boolean	hasOtherTypes
if (startElement == endElement) Option(startElement.getParent) else Option(PsiTreeUtil.findCommonParent(startElement, endElement))	Option[PsiElement]	commonParent
s"new $constructor$otherTypesHolder"	String	text
myEditorTextField.getEditor	Editor	editor
getEntryForRange(fun.getParent, expandTextRangeToComment(fun), getTokenType(fun), fun.getName, canArrange = true)	ScalaArrangementEntry	entry
new MethodBodyProcessor(parseInfo, fun)	ScalaArrangementVisitor.this.MethodBodyProcessor	methodBodyProcessor
parent.children.toArray	Array[PsiElement]	childrenAll
rightElementType == ScalaTokenTypes.tLINE_COMMENT || FormatterUtil.isCommentGrabbingPsi(rightPsi) && rightPsi.getFirstChild.elementType == ScalaTokenTypes.tLINE_COMMENT	Boolean	rightIsLineComment
childrenAll.filter(_.getTextRange.intersects(range))	Array[PsiElement]	childrenFitRange
multiLevelAlignmentMap(rootPsi.getProject)	mutable.Map[IElementType, List[ElementPointerAlignmentStrategy]]	map
interpolated.startOffset	Int	start
getCurrentEntry	ScalaArrangementEntry	currentEntry
ElementPointerAlignmentStrategy.typeMultiLevelAlignment(rootPsi)	ElementPointerAlignmentStrategy	multiAlignment
{ node.getPsi match { case params: ScParameters => val firstParameterStartsFromNewLine = commonSettings.METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE || params.clauses.headOption.flatMap(_.parameters.headOption).forall(_.startsFromNewLine()) if (firstParameterStartsFromNewLine && !scalaSettings.INDENT_FIRST_PARAMETER) null else alignment case _: ScParameterClause => child.getElementType match { case `tRPARENTHESIS` | `tLPARENTHESIS` => null case _ => alignment } case _: ScArgumentExprList => child.getElementType match { case `tRPARENTHESIS` if cs.ALIGN_MULTILINE_PARAMETERS_IN_CALLS => alignment case `tRPARENTHESIS` | `tLPARENTHESIS` => null case ScCodeBlockElementType.BlockExpression if ss.DO_NOT_ALIGN_BLOCK_EXPR_PARAMS => null case _ if cs.ALIGN_MULTILINE_PARAMETERS_IN_CALLS => alignment case _ => null } case patt: ScPatternArgumentList => child.getElementType match { case `tRPARENTHESIS` if cs.ALIGN_MULTILINE_PARAMETERS_IN_CALLS && patt.missedLastExpr => alignment case `tRPARENTHESIS` | `tLPARENTHESIS` => null case ScCodeBlockElementType.BlockExpression if ss.DO_NOT_ALIGN_BLOCK_EXPR_PARAMS => null case _ if cs.ALIGN_MULTILINE_PARAMETERS_IN_CALLS => alignment case _ => null } case _: ScMethodCall | _: ScReferenceExpression => if (child.getElementType == tIDENTIFIER && child.getPsi.getParent.isInstanceOf[ScReferenceExpression] && child.getPsi.getParent.asInstanceOf[ScReferenceExpression].qualifier.isEmpty) null else if (child.getPsi.isInstanceOf[ScExpression]) null else alignment case _: ScXmlStartTag | _: ScXmlEmptyTag => child.getElementType match { case ScalaElementType.XML_ATTRIBUTE => alignment case _ => null } case _: ScXmlElement => child.getElementType match { case ScalaElementType.XML_START_TAG | ScalaElementType.XML_END_TAG => alignment case _ => null } case _: ScParameter => child.getElementType match { case `tCOLON` if ss.ALIGN_TYPES_IN_MULTILINE_DECLARATIONS => child.getPsi.nullSafe.map(_.getParent).map(_.getParent).map { rootPsi => val map = multiLevelAlignmentMap(rootPsi.getProject) map.get(tCOLON).flatMap(_.find(_.shouldAlign(child))) match { case Some(multiAlignment) => multiAlignment.getAlignment case None => val multiAlignment = ElementPointerAlignmentStrategy.typeMultiLevelAlignment(rootPsi) assert(multiAlignment.shouldAlign(child)) map.update(tCOLON, multiAlignment :: map.getOrElse(tCOLON, List())) multiAlignment.getAlignment } }.getOrElse(alignment) case _ => alignment } case literal: ScInterpolatedStringLiteral if child.getElementType == tINTERPOLATED_STRING_END => cachedAlignment(literal).map(_._1).orNull case _ => alignment } }	Alignment	childAlignment
new ScalaMoveMembersDialog(project, true, obj, member)	ScalaMoveMembersDialog	dialog
ScalaCodeFragment("", memberToMove.getContext, memberToMove)(project)	ScalaCodeFragment	targetObjectFragment
child.getFirstChildNode == null && child.getElementType == tINTERPOLATED_MULTILINE_STRING && ss.supportMultilineString	Boolean	needFlattenInterpolatedStrings
if (canArrange && document != null) { ArrangementUtil.expandToLineIfPossible(range, document) } else { range }	TextRange	newRange
new ScalaArrangementEntry(currentEntry, newRange, tokenType, name, canArrange && (parent.isInstanceOf[ScTemplateBody] || parent.isInstanceOf[PsiFile]), innerTokenType)	ScalaArrangementEntry	newEntry
targetClass.name	String	targetName
arrangementEntries.isEmpty || arrangementEntries.head.getType != UNSEPARABLE_RANGE || arrangementEntries.head.getStartOffset != entry.getStartOffset || arrangementEntries.head.getEndOffset != entry.getEndOffset	Boolean	newEntry
arrangementEntries.top	ScalaArrangementEntry	top
node.getChildren(null).filter(isCorrectBlock)	Array[ASTNode]	children
element.startOffset - start	Int	offset
nodePsi.getPrevSibling	PsiElement	prev
0	Int	breaks
ListBuffer[PsiElement]()	ListBuffer[PsiElement]	res
unseparableRanges.getOrElse(entry, mutable.Queue[ScalaArrangementEntry]())	mutable.Queue[ScalaArrangementEntry]	queue
null	ASTNode	prevChild
interpolated match { case ip: ScInterpolationPattern => ip.args.children.toArray case sl: ScInterpolatedStringLiteral => Option(sl.getFirstChild.getNextSibling).toArray }	Array[PsiElement]	children
TokenSet.create( ScalaTokenTypes.tINTERPOLATED_STRING, ScalaTokenTypes.tINTERPOLATED_MULTILINE_STRING )	TokenSet	acceptedInterpolatedTokens
pattern.bindings.map(b => b.name)	IndexedSeq[String]	vs
td.name	String	name
Key.create[PsiDirectory]("MoveDestination")	Key[PsiDirectory]	key
getChildAlignment(node, child)(getPrevGroupNode)(FunctionTypeTokenSet)	Alignment	childAlignment
child.getTextRange.getStartOffset	Int	childStart
usage.getElement	PsiElement	element
trimWhitespacesOrEmpty(childrenFitRange)	Seq[PsiElement]	children
isProperUpperLevelPsi(parent)	Boolean	parentIsProper
if (unseparable != null) { //process current child with regard to current block (insideBlock, childStart >= unseparable.getStartOffset, childStart >= unseparable.getEndOffset) match { case (false, true, false) => //entering arrange block arrangementEntries.push(unseparable) (true, unseparable) case (true, true, false) => (true, unseparable) //inside arrange block case (true, true, true) => //leaving arrange block arrangementEntries.pop() //check whether new current block is immediately adjucent to the previous //in such case leaving the previous means entering the current next() match { case Some(nextUnseparable) if childStart >= nextUnseparable.getStartOffset => arrangementEntries.push(nextUnseparable) (true, nextUnseparable) case Some(nextUnseparable) => (false, nextUnseparable) case _ => (false, null) } case _ => (false, unseparable) //outside arrange block } } else (false, unseparable)	(Boolean, ScalaArrangementEntry)	res
node.getPrevSibling	PsiElement	prev
node.getFirstChild	PsiElement	first
node	PsiElement	currentNode
if (first != null && first.isInstanceOf[PsiComment] && prev != null && (!prev.isInstanceOf[PsiWhiteSpace] || prev.isInstanceOf[PsiWhiteSpace] && !prev.getText.contains("\n") && prev.getPrevSibling != null)) { new TextRange(node.getTextRange.getStartOffset + first.getTextRange.getLength + 1, node.getTextRange.getEndOffset) } else { node.getTextRange }	TextRange	range
nonComment.getFirstChild	PsiElement	next
currentNode.getNextSibling match { case sibling: PsiWhiteSpace => if (!sibling.getText.contains("\n")) { sibling.getNextSibling match { case comment: PsiComment => range.union(sibling.getTextRange).union(comment.getTextRange) case nonComment: ScalaPsiElement => val next = nonComment.getFirstChild if (next != null && next.isInstanceOf[PsiComment]) { range.union(sibling.getTextRange).union(next.getTextRange) } else { range } case _ => range } } else { range } case comment: PsiComment => range.union(comment.getTextRange) case _ => range }	TextRange	res
commonParent match { case Some(parent: LeafPsiElement) => findProperParent(parent) case Some(parent@Parent(_: ScConstructorPattern)) => findProperParent(parent) case Some(parent@Parent(Parent(_: ScParameterizedTypeElement))) => findProperParent(parent) case Some(parent) => val childrenAll = parent.children.toArray val childrenFitRange = childrenAll.filter(_.getTextRange.intersects(range)) val children = trimWhitespacesOrEmpty(childrenFitRange) val parentIsProper = isProperUpperLevelPsi(parent) if (children.isEmpty) { Seq.empty } else if (selectChildren && children.forall(isProperUpperLevelPsi) && !parent.isInstanceOf[ScExpression]) { //for uniformity use the upper-most of embedded elements with same contents if (children.length == childrenAll.length && parentIsProper) { Seq(parent) } else { children } } else if (parentIsProper) { Seq(parent) } else { findProperParent(parent) } case _ => Seq.empty }	Seq[PsiElement]	res
ref.nameId	PsiElement	identifier
identifier.getPrevSibling	PsiElement	beforeId
method.getName	String	methodName
method.getParent	PsiElement	psiParent
PsiDocumentManager.getInstance(project).getDocument(targetObjectFragment)	Document	document
PsiTreeUtil.nextLeaf(ws, true)	PsiElement	next
PsiTreeUtil.prevLeaf(ws, true)	PsiElement	prev
scalaSettings.CALL_PARAMETERS_NEW_LINE_AFTER_LPAREN == ScalaCodeStyleSettings.NEW_LINE_ALWAYS || scalaSettings.CALL_PARAMETERS_NEW_LINE_AFTER_LPAREN == ScalaCodeStyleSettings.NEW_LINE_FOR_MULTIPLE_ARGUMENTS && leftPsiParent.asInstanceOf[ScArguments].getArgsCount > 1	Boolean	newLineAfterLParen
PsiDocumentManager.getInstance(scalaFile.getProject)	PsiDocumentManager	documentManager
if (prev == null) range.union(next.getTextRange) else prev.getTextRange.union(next.getTextRange)	TextRange	newRange
{ val document = PsiDocumentManager.getInstance(project).getDocument(targetObjectFragment) new EditorComboBox(document, project, ScalaFileType.INSTANCE) }	EditorComboBox	myTfTargetClassName
if (startOffset.isDefined) startOffset.get else child.getTextRange.getStartOffset	Int	newOffset
s"${targetClass.name}.${reference.refName}"	String	textWithQualifier
getChildAlignment(node, child)(getPrevGroupNode)(FieldGroupSubBlocksTokenSet)	Alignment	childAlignment
Alignment.createAlignment(true)	Alignment	alignment
element.children.toList	List[PsiElement]	children
name.length	Int	length
getPrevGroupNode(node.getPsi)	ASTNode	prev
method.getName	String	name
method.name	String	name
PsiTreeUtil.getDeepestLast(left.lastNode.nullSafe.map(_.getPsi).getOrElse(leftPsi))	PsiElement	deepestLast
prevChild.getPsi.getUserData(fieldGroupAlignmentKey) match { case null => createNewAlignment case alignment => alignment }	Alignment	newAlignment
if (moveCompanion) definition.baseCompanionModule else None	Option[ScTypeDefinition]	maybeCompanion
extBlock.getFirstChild	PsiElement	firstChild
element match { case c: PsiClass => Seq(c) case f: ScalaFile => f.typeDefinitions case p: ScPackage => p.getClasses.toSeq case _ => Seq.empty }	Seq[PsiClass]	classes
extBlock.templateBody	Option[ScTemplateBody]	tempBody
reference match { case _: ScReferenceExpression => createExpressionFromText(textWithQualifier) case _: ScStableCodeReference => createReferenceFromText(textWithQualifier) case _ => return false }	ScalaPsiElement	qualified
deepestLast.getNode.nullSafe.exists(_.getElementType == tLINE_COMMENT)	Boolean	leftLineComment
definition match { case _: ScClass => SCALA_CLASS case _: ScTrait => SCALA_TRAIT case _: ScObject => SCALA_OBJECT }	String	template
tempBody.map(_.getPrevSiblingNotWhitespace).getOrElse(extBlock.getLastChild)	PsiElement	lastChild
if (ss.ALIGN_EXTENDS_WITH == ScalaCodeStyleSettings.ALIGN_TO_EXTENDS) Alignment.createAlignment(false) else null	Alignment	alignment
rightPsi match { case e: ScExtendsBlock => e case t: ScEarlyDefinitions => t.getParent case t: ScTemplateBody => t.getParent }	PsiElement	extendsBlock
collectDataForElement(scMember)	Associations	associations
scMember.copy()	PsiElement	memberCopy
if (lParen.getElementType == tLPARENTHESIS) tRPARENTHESIS else tRBRACE	IElementType	closingType
targetClass.add(memberCopy)	PsiElement	movedMember
util.ScalaDirectoryService.createClassFromTemplate(directory, definition.name, template, askToDefineVariables = false)	PsiClass	created
movedMember(targetClass)	PsiElement	movedElement
tail.dropWhile(_.getElementType != closingType)	List[ASTNode]	afterlosingParent
tail.head	ASTNode	enumerators
Alignment.createAlignment()	Alignment	alignment
extendsBlock.getParent match { case b: ScTypeDefinition => b.nameId case _: ScTemplateDefinition => extendsBlock case b => b }	PsiElement	startElement
startElement.getTextRange.getStartOffset	Int	startOffset
if (formattedCode.wrapped) unwrap(wrapFile) else Seq(wrapFile)	Seq[PsiElement]	elementsUnwrapped
new TextRange(startOffset, rightPsi.getTextRange.getStartOffset)	TextRange	range
unwrapPsiFromFormattedFile(formattedCode)	Seq[PsiElement]	unwrapped
unwrapPsiFromFormattedFile(formattedCode)	Seq[PsiElement]	elementsUnwrapped
elements.zip(elementsUnwrapped)	Seq[(PsiElement, PsiElement)]	elementsToTraverse
unwrapPsiFromFormattedElements(rewriteToFormatted)	Seq[(PsiElement, Seq[PsiElement])]	rewriteElementsToTraverse
if (formattedCode.wrappedInHelperClass) -ScalaFmtIndent else 0	Int	additionalIndent
elements.filter(_.getLanguage.isKindOf(ScalaLanguage.INSTANCE))	Array[PsiElement]	scalaElements
MoveClassesOrPackagesImpl.getInitialTargetPackageName(initialTargetElement, adjustedElements)	String	initialTargetPackageName
MoveClassesOrPackagesImpl.getInitialTargetDirectory(initialTargetElement, adjustedElements)	PsiDirectory	initialTargetDirectory
if (commonSettings.ALIGN_MULTILINE_FOR && !enumerators.getPsi.startsFromNewLine()) { val alignment = Alignment.createAlignment() Some(SubBlocksContext(Map(rParent -> alignment, enumerators -> alignment))) } else { None }	Option[SubBlocksContext]	context
adjustedElements.exists(TextOccurrencesUtil.isSearchTextOccurrencesEnabled)	Boolean	searchTextOccurences
node.getFirstChildNode	ASTNode	firstChildNode
firstChildNode	ASTNode	child
JavaRefactoringSettings.getInstance.MOVE_SEARCH_IN_COMMENTS	Boolean	searchInComments
directory.findFile(file.getName) match { case fileWithOldFileName: PsiFile if directory != file.getContainingDirectory && classCanBeAdded(file, clazz) => // moving second of two classes which were in the same file to a different directory (IDEADEV-3089) fileWithOldFileName.add _ case _ => //moving class to the existing file with the same name directory.findFile(fileName(definition)) match { case fileWithClassName: PsiFile if classCanBeAdded(fileWithClassName, clazz) => fileWithClassName.add _ case _ => //create new file with template import actions.ScalaFileTemplateUtil._ val template: String = definition match { case _: ScClass => SCALA_CLASS case _: ScTrait => SCALA_TRAIT case _: ScObject => SCALA_OBJECT } val created = util.ScalaDirectoryService.createClassFromTemplate(directory, definition.name, template, askToDefineVariables = false) if (definition.getDocComment == null) { created.getDocComment match { case null => case createdComment => definition.addAfter(createdComment, null) Associations.shiftFor(definition, createdComment.getTextLength) } } created.replace _ } }	PsiElement => PsiElement	createNewClass
JavaRefactoringSettings.getInstance.MOVE_SEARCH_FOR_TEXT	Boolean	searchForTextOccurences
ScalaMoveMembersDialog.createProcessor(obj, memberToMove)	MoveMembersProcessor	processor
buildChangesList(elementsToTraverse, rewriteElementsToTraverse, range, additionalIndent)	Seq[PsiChange]	changes
new MoveClassesOrPackagesDialog( project, searchTextOccurences, adjustedElements, initialTargetElement, moveCallback, initialTargetPackageName, initialTargetDirectory, searchInComments, searchForTextOccurences) { override def createCenterPanel(): JComponent = { addMoveCompanionChb(super.createCenterPanel(), adjustedElements) } override def createMoveToPackageProcessor(destination: MoveDestination, elementsToMove: Array[PsiElement], callback: MoveCallback): MoveClassesOrPackagesProcessor = { new MoveClassesOrPackagesProcessor(project, elementsToMove, destination, isSearchInComments, searchTextOccurences, callback) } }	MoveClassesOrPackagesDialog	moveDialog
if (rightPsi.isInstanceOf[ScImportSelectors]) WITHOUT_SPACING else if (leftPsiParent.isInstanceOf[ScParenthesisedTypeElement]) WITHOUT_SPACING else if (rightPsi.is[ScExtendsBlock, ScEarlyDefinitions, ScTemplateBody]) { settings.CLASS_BRACE_STYLE match { case CommonCodeStyleSettings.END_OF_LINE => val deepestLast = PsiTreeUtil.getDeepestLast(left.lastNode.nullSafe.map(_.getPsi).getOrElse(leftPsi)) val leftLineComment = deepestLast.getNode.nullSafe.exists(_.getElementType == tLINE_COMMENT) if (settings.SPACE_BEFORE_CLASS_LBRACE) if (leftLineComment) WITH_SPACING else WITH_SPACING_NO_KEEP else if (leftLineComment) WITHOUT_SPACING else WITHOUT_SPACING_NO_KEEP case CommonCodeStyleSettings.NEXT_LINE_IF_WRAPPED => val extendsBlock = rightPsi match { case e: ScExtendsBlock => e case t: ScEarlyDefinitions => t.getParent case t: ScTemplateBody => t.getParent } val startElement = extendsBlock.getParent match { case b: ScTypeDefinition => b.nameId case _: ScTemplateDefinition => extendsBlock case b => b } val startOffset = startElement.getTextRange.getStartOffset val range = new TextRange(startOffset, rightPsi.getTextRange.getStartOffset) if (settings.SPACE_BEFORE_CLASS_LBRACE) WITH_SPACING_DEPENDENT(range) else WITHOUT_SPACING_DEPENDENT(range) case _ => ON_NEW_LINE } } else rightPsiParent match { case _: ScBlock | _: ScEarlyDefinitions | _: ScTemplateBody | _: ScalaFile => ON_NEW_LINE case _: ScArgumentExprList if rightPsi.isInstanceOf[ScBlock] => WITH_SPACING //don't add/remove newlines for partial function arguments case parent => val (needSpace, braceStyle, startElement) = parent match { case fun: ScFunction => (settings.SPACE_BEFORE_METHOD_LBRACE, settings.METHOD_BRACE_STYLE, fun.nameId) case _: ScMethodCall if rightPsi.isInstanceOf[ScArguments] => (scalaSettings.SPACE_BEFORE_BRACE_METHOD_CALL, settings.BRACE_STYLE, parent) case _ => (true, settings.BRACE_STYLE, parent) } braceStyle match { case CommonCodeStyleSettings.END_OF_LINE => if (needSpace) WITH_SPACING_NO_KEEP else WITHOUT_SPACING_NO_KEEP case CommonCodeStyleSettings.NEXT_LINE_IF_WRAPPED => val startOffset = startElement.getTextRange.getStartOffset val range = new TextRange(startOffset, rightPsi.getTextRange.getStartOffset) if (needSpace) WITH_SPACING_DEPENDENT(range) else WITHOUT_SPACING_DEPENDENT(range) case _ => ON_NEW_LINE } }	Spacing	result
elements.exists { case definition: ScTypeDefinition => definition.baseCompanionModule.isDefined case _ => false }	Boolean	companionsExist
createNewClass(clazz).asInstanceOf[PsiClass]	PsiClass	newClass
if (leftPsi.isInstanceOf[ScStableCodeReference] || leftElementType == tLBRACE) Spacing.createSpacing(0, 0, 1, keepLineBreaks, keepBlankLinesInCode) else if (leftPsi.isInstanceOf[PsiComment] && leftPsi.getPrevSiblingNotWhitespaceComment.isInstanceOf[ScStableCodeReference]) ON_NEW_LINE else Spacing.createSpacing(0, 0, settings.BLANK_LINES_BEFORE_PACKAGE + 1, keepLineBreaks, keepBlankLinesInCode)	Spacing	result
clazz.getContainingFile.asInstanceOf[ScalaFile]	ScalaFile	file
space.withAdditionalIndent(additionalIndent)(project)	PsiElement	replacer
file.typeDefinitions match { case Seq(`clazz`) if !(file.isScriptFile || file.isWorksheetFile) => file case _ => clazz }	ScalaPsiElement with PsiNamedElement with NavigatablePsiElement	elementToDelete
name	String	result
1	Int	i
settings.ScalaApplicationSettings.getInstance()	ScalaApplicationSettings	applicationSettings
subBlock(firstChildNode, child, alignment)	ScalaBlock	firstBlock
child.getTreeNext	ASTNode	firstChild
if (scalaSettings.MULTILINE_STRING_ALIGN_DANGLING_CLOSING_QUOTES) Alignment.createAlignment() else null	Alignment	quotesAlignment
Alignment.createAlignment(true)	Alignment	marginAlignment
leftElementType == ScalaTokenTypes.tSEMICOLON && leftPsi.getPrevSiblingNotWhitespace.isInstanceOf[ScImportStmt]	Boolean	leftIsImport
MultiMap.createSet[PsiElement, String]()	MultiMap[PsiElement, String]	result
getText(original)	String	originalElementText
getElementIndent(original)	Int	originalIndent
getElementIndent(formatted)	Int	formattedIndent
util.ScalaNamesUtil.scalaName(clazz)	String	className
new ConflictsDialog(project, result, null, true, false)	ConflictsDialog	conflictsDialog
JavaPsiFacade.getInstance(project)	JavaPsiFacade	psiFacade
TemplateBuilderFactory.getInstance(). createTemplateBuilder(parent).asInstanceOf[TemplateBuilderImpl]	TemplateBuilderImpl	builder
psiFacade.findPackage(packageName)	PsiPackage	aPackage
formattedElementText == originalElementText && formattedIndent == originalIndent && rewriteElement.isEmpty	Boolean	nothingChanged
0	Int	formattedIndex
0	Int	originalIndex
aPackage.getDirectories.exists(!isUnderRefactoring(_, directoriesToMove))	Boolean	remainsNothing
Seq(left, right)	Seq[ScTypeDefinition]	classes
leftPsi.isInstanceOf[PsiComment] && leftPsi.getPrevSiblingNotWhitespaceComment.isInstanceOf[ScImportStmt]	Boolean	leftIsCommentInsideImport
Option(PsiTreeUtil.getParentOfType(node.getPsi, classOf[ScInterpolatedStringLiteral]))	Option[Nothing]	interpolatedOpt
mutable.ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	primaries
enclosingContainer(allOcc)	PsiElement	container
formatted.children.toArray	Array[PsiElement]	formattedChildren
mutable.HashMap[PsiElement, String]()	mutable.HashMap[PsiElement, String]	primaryNames
rightPsi.getNextSiblingNotWhitespaceComment	PsiElement	pseudoRightPsi
rightNode.getTreeParent	ASTNode	rightTreeParent
Wrap.createWrap(WrapType.NONE, true)	Wrap	wrap
mutable.HashMap[PsiElement, Seq[String]]()	mutable.HashMap[PsiElement, Seq[String]]	dependentNames
MultilineStringUtil.getMarginChar(node.getPsi)	Char	marginChar
mutable.ArrayBuffer.empty[(PsiNamedElement, String)]	ArrayBuffer[(PsiNamedElement, String)]	result
scalaSettings.KEEP_ONE_LINE_LAMBDAS_IN_ARG_LIST && leftPsi.isInstanceOf[PsiComment]	Boolean	checkKeepOneLineLambdas
original.children.toArray	Array[PsiElement]	originalChildren
parent.getProject	Project	project
originalChildren(originalIndex)	PsiElement	originalElement
formattedChildren(formattedIndex)	PsiElement	formattedElement
originalElement.getTextRange.intersectsStrict(range)	Boolean	isInRange
PsiDocumentManager.getInstance(project).getDocument(file)	Document	document
EditorFactory.getInstance.getEditors(document)(0)	Editor	editor
Indent.getSpaceIndent(ss.MULTILINE_STRING_MARGIN_INDENT + interpolatedRefLength(node), true)	Indent	marginIndent
formattedElements.length == 1	Boolean	isOneToOneReplacement
0	Int	acc
scalaSettings.SPACES_IN_ONE_LINE_BLOCKS && rightTreeParent.getTreeParent.nullSafe.exists(_.isInstanceOf[ScFunction])	Boolean	inMethod
ListBuffer[PsiChange]()	ListBuffer[PsiChange]	changes
ListBuffer(elementsToTraverse: _*)	ListBuffer[(PsiElement, PsiElement)]	elementsBuffer
primary match { case named: PsiNamedElement => new MyLookupExpression(newName, names, named, parent, false, null) case _ => new TextExpression(newName) }	Expression	lookupExpr
conflicts.map(_._2).toSet	Set[String]	messages
JBPopupFactory.getInstance	JBPopupFactory	popupFactory
mutable.ArrayBuffer[String]()	ArrayBuffer[String]	depNames
newName + "_" + index	String	dependentName
popupFactory.guessBestPopupLocation(editor)	RelativePoint	bestLocation
builder.buildInlineTemplate().asInstanceOf[TemplateImpl]	TemplateImpl	template
screenPoint.y - editor.getLineHeight * 2	Int	y
scalaSettings.SPACE_INSIDE_SELF_TYPE_BRACES && leftPsiParent.getFirstChild.getNextSiblingNotWhitespace.isInstanceOf[ScSelfTypeElement]	Boolean	inSelfTypeBraces
named.name match { case null | "" => qualifiedName case name => qualifiedName + "." + name }	String	result
rewriteElementsToTraverse.find(original == _._1).map(_._2)	Option[Seq[PsiElement]]	rewriteElement
o.namedElements	Seq[PsiNamedElement]	oldElems
editor.getSelectionModel.getSelectionStart	Int	start
editor.getSelectionModel.getSelectionEnd	Int	end
MoveClassesOrPackagesUtil.doMoveClass(clazz, moveDestination)	PsiClass	newClass
rightTreeParent.getTreeParent.nullSafe .exists(_.getElementType == ScalaElementType.InterpolatedString)	Boolean	insideInterpString
new BaseProcessor(ValueSet(ResolveTargets.CLASS)) { override protected def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean = { for { msg <- message(namedElement, name) } result += namedElement -> msg true } }	BaseProcessor { def execute(namedElement: PsiNamedElement) (implicit state: ResolveState): Boolean }	processor
qualName.lastIndexOf('.')	Int	dotIdx
newClass.namedElements	Seq[PsiNamedElement]	newElems
builder.setFadeoutTime(-1).setShowCallout(false).createBalloon	Balloon	balloon
Logger.getInstance("#org.jetbrains.plugins.scala.lang.refactoring.move.ScalaDirectoryService")	Logger	LOG
FileTemplateManager.getInstance(dir.getProject)	FileTemplateManager	templateManager
prevWsFormatted.getIndentSize	Int	indentFormatted
prevWsOriginal.withIndent(indentFormatted + additionalIndent) match { case Some(prevWsOriginalFixed) => new Replace(prevWsOriginal, prevWsOriginalFixed) case None => new Remove(prevWsOriginal) }	PsiChange	change
original.getNode	ASTNode	originalNode
Key.create[PsiElement]("moved.element")	Key[PsiElement]	key
formatted.getNode	ASTNode	formattedNode
relativeRange(linePrefixLength, linePrefixLength + 1, acc)	TextRange	marginRange
MovedElementData(target)	PsiElement	moved
scalaSettings.SPACE_INSIDE_CLOSURE_BRACES && (leftElementType match { case ScalaElementType.FUNCTION_EXPR => true case ScalaElementType.CASE_CLAUSES => block.getParent.is[ScArgumentExprList, ScInfixExpr] case _ => val insideInterpString = rightTreeParent.getTreeParent.nullSafe .exists(_.getElementType == ScalaElementType.InterpolatedString) scalaSettings.KEEP_ONE_LINE_LAMBDAS_IN_ARG_LIST && (leftPsi.is[ScFunctionExpr, ScCaseClauses] || block.isInstanceOf[ScBlockExpr] && !insideInterpString) })	Boolean	inClosure
changes.filter(_.isInRange(range)).filter(_.isValid).sorted(Ordering.fromLessThan[PsiChange] { case (_: Insert, _) => true case (_, _: Insert) => false case (left, right) => left.getStartOffset < right.getStartOffset })	Seq[PsiChange]	changesFinal
relativeRange(linePrefixLength + 1, lineLength, acc)	TextRange	contentRange
relativeRange(0, 3)	TextRange	range
new StringLineScalaBlock(range, node, block, quotesAlignment, Indent.getNoneIndent, null, settings)	getDummyBlocks.StringLineScalaBlock	marginBlock
if (ApplicationManager.getApplication.isUnitTestMode) templateForUnitTest(templateName, name) else templateManager.getInternalTemplate(templateName)	FileTemplate	template
changesFinal.zipAll(changesFinal.drop(1), null, null)	IndexedSeq[(PsiChange, PsiChange)]	changesWithNext
original.getPsi.asInstanceOf[ScReference].bind	Option[ScalaResolveResult]	res
name	String	fileName
change.applyAndGetDelta(nextChange)	Int	delta
try { if (askToDefineVariables) new CreateFromTemplateDialog(dir.getProject, dir, template, null, properties).create else FileTemplateUtil.createFromTemplate(template, fileName, properties, dir) } catch { case e: IncorrectOperationException => throw e case e: Exception => LOG.error(e) return null }	PsiElement	element
false	Boolean	failSilent
element.getContainingFile.asInstanceOf[ScalaFile]	ScalaFile	file
if (parentAlignment != null) parentAlignment else createAlignment(node)	Alignment	alignment
if (cs.ALIGN_MULTILINE_CHAINED_METHODS) Alignment.createAlignment() else null	Alignment	dotAlignment
name + " {\n\n}"	String	nameAndBraces
block.suggestedWrap	Wrap	dotWrap
leftBlockString == "{" || getText(block.getNode, fileText).contains('\n')	Boolean	isOneLineEmpty
SourceTreeToPsiMap.treeElementToPsi(element).asInstanceOf[ScReference]	ScReference	ref
{ lazy val inMethod = scalaSettings.SPACES_IN_ONE_LINE_BLOCKS && rightTreeParent.getTreeParent.nullSafe.exists(_.isInstanceOf[ScFunction]) lazy val inSelfTypeBraces = scalaSettings.SPACE_INSIDE_SELF_TYPE_BRACES && leftPsiParent.getFirstChild.getNextSiblingNotWhitespace.isInstanceOf[ScSelfTypeElement] lazy val inClosure = scalaSettings.SPACE_INSIDE_CLOSURE_BRACES && (leftElementType match { case ScalaElementType.FUNCTION_EXPR => true case ScalaElementType.CASE_CLAUSES => block.getParent.is[ScArgumentExprList, ScInfixExpr] case _ => val insideInterpString = rightTreeParent.getTreeParent.nullSafe .exists(_.getElementType == ScalaElementType.InterpolatedString) scalaSettings.KEEP_ONE_LINE_LAMBDAS_IN_ARG_LIST && (leftPsi.is[ScFunctionExpr, ScCaseClauses] || block.isInstanceOf[ScBlockExpr] && !insideInterpString) }) val isOneLineEmpty = leftBlockString == "{" || getText(block.getNode, fileText).contains('\n') !isOneLineEmpty && (scalaSettings.SPACES_IN_ONE_LINE_BLOCKS || inMethod || inSelfTypeBraces || inClosure) }	Boolean	checkOneLineSpaces
checkKeepOneLineLambdas || checkOneLineSpaces	Boolean	needsSpace
if (needsSpace) 1 else 0	Int	spaces
leftNode.getTreeParent.getTextRange	TextRange	refRange
leftNode.getTreeParent.getPsi	PsiElement	b
element.getCopyableUserData(ScalaChangeUtilSupport.REFERENCED_MEMBER_KEY)	PsiNamedElement	named
ref.resolve	PsiElement	res
s"""Scalafmt parse error (${fileLink(fileName, offset)}):<br>$message"""	String	errorMessage
Key.create("REFERENCED_MEMBER_KEY")	Key[PsiNamedElement]	REFERENCED_MEMBER_KEY
new FileTemplateBase { def setExtension(extension: String) {} def setName(name: String) {} def getName: String = templateName def isDefault: Boolean = true def getDescription: String = "" def getExtension: String = "scala" }	FileTemplateBase { def setName(name: String): Unit def getExtension: String def isDefault: Boolean def getName: String def getDescription: String def setExtension(extension: String): Unit }	template
fileLinkListener(project, file, offset)	NotificationListener	listener
new ArrayBuffer[(PsiNamedElement, String)]	ArrayBuffer[(PsiNamedElement, String)]	buf
scalaSettings.SPACES_IN_ONE_LINE_BLOCKS && !getText(b.getNode, fileText).contains('\n')	Boolean	spaceInsideOneLineBlock
if (scalaSettings.SPACE_INSIDE_CLOSURE_BRACES || spaceInsideOneLineBlock) WITH_SPACING else WITHOUT_SPACING	Spacing	spacing
node.getChildren(null).filter(isCorrectBlock).toList	List[ASTNode]	childrenAll
s"Scalafmt error (${fileLink(fileName)}):<br>failed to find correct surrounding code " + s"to pass for scalafmt, no formatting will be performed"	String	errorMessage
enclosingContainerAll match { case directory: PsiDirectory => findFilesForDownConflictFindings(directory, name) case _ => Seq.empty }	Seq[PsiFile]	filesToSearchIn
fileLinkListener(project, file, 0)	NotificationListener	listener
new ArrayBuffer[PsiFile]()	ArrayBuffer[PsiFile]	buffer
enclosingContainer(commonParent(file, occurrences))	PsiElement	container
enclosingContainer(element)	PsiElement	containerOne
ranges.filter(_.intersects(range))	Seq[TextRange]	intersections
new Processor[PsiFile] { override def process(file: PsiFile): Boolean = { buffer += file true } }	Processor[PsiFile] { def process(file: PsiFile): Boolean }	processor
delegatedContext.values.flatMap(_.additionalNodes).toSet	Set[ASTNode]	filterOutNodes
PsiSearchHelper.getInstance(directory.getProject)	PsiSearchHelper	helper
container	PsiElement	cl
if (c.isInstanceOf[ScTypeDefinition]) settings.BLANK_LINES_AFTER_CLASS_HEADER else settings.BLANK_LINES_AFTER_ANONYMOUS_CLASS_HEADER	Int	minLineFeeds
if (scalaSettings.SPACES_IN_ONE_LINE_BLOCKS) 1 else 0	Int	spaces
block.getPrevSibling	PsiElement	prev
if (intersections.isEmpty) { ranges :+ range } else { ranges.filter(!_.intersects(range)) :+ intersections.foldLeft(range)((acc, nextRange) => acc.union(nextRange)) }	IndexedSeq[TextRange]	newRanges
Key.create("scala.fmt.formatted.ranges")	Key[(ScalaFmtPreFormatProcessor.TextRanges, Long, Option[Long])]	FORMATTED_RANGES_KEY
mutable.WeakHashMap[PsiFile, mutable.TreeSet[(Int, Int)]]()	mutable.Map[PsiFile, mutable.TreeSet[(Int, Int)]]	rangesDeltaCache
{ // using Set we imply that ASTNode equals and hashCode methods are lightweight (default implementation) val filterOutNodes = delegatedContext.values.flatMap(_.additionalNodes).toSet sorted(delegatedChildren.filterNot(filterOutNodes.contains)) }	Seq[ASTNode]	idAdditionalNodes
containsOnlyPrivates(psiClass)	Boolean	justPrivates
getUsageInsideDeletedFilter(allElementsToDelete)	Condition[PsiElement]	insideDeletedCondition
SubBlocksContext(id, idAdditionalNodes, Some(dotAlignment), delegatedContext)	SubBlocksContext	context
childrenAll.tail.takeWhile(isComment)	List[ASTNode]	commentsBeforeDot
if (comment.getPsi.startsFromNewLine()) dotAlignment else null	Alignment	commentAlign
unparExpr(expr)	ScExpression	e
false	Boolean	hasNlToken
parent.getParent	PsiElement	pparent
e.projectContext	ProjectContext	projectContext
rangesDeltaCache.getOrElseUpdate(containingFile, mutable.TreeSet[(Int, Int)]())	mutable.TreeSet[(Int, Int)]	cache
(leftPsi, rightPsi) match { case (_: ScFunction, _: ScValueOrVariable) | (_: ScValueOrVariable, _: ScFunction) | (_: ScTypeAlias, _: ScFunction) | (_: ScFunction, _: ScTypeAlias) => if (p.isInstanceOf[ScTrait]) math.max(settings.BLANK_LINES_AROUND_FIELD_IN_INTERFACE, settings.BLANK_LINES_AROUND_METHOD_IN_INTERFACE) else math.max(settings.BLANK_LINES_AROUND_FIELD, settings.BLANK_LINES_AROUND_METHOD) case (_: ScFunction, _) | (_, _: ScFunction) => if (p.isInstanceOf[ScTrait]) settings.BLANK_LINES_AROUND_METHOD_IN_INTERFACE else settings.BLANK_LINES_AROUND_METHOD case _ => if (p.isInstanceOf[ScTrait]) settings.BLANK_LINES_AROUND_FIELD_IN_INTERFACE else settings.BLANK_LINES_AROUND_FIELD }	Int	setting
if (allOcc) { selectedElement //todo: } else { selectedElement }	PsiElement	parent
{ var parent: PsiElement = if (allOcc) { selectedElement //todo: } else { selectedElement } if (PsiTreeUtil.isAncestor(container, parent, true)) while (parent.getParent != null && parent.getParent != container) parent = parent.getParent else parent = container.getFirstChild parent }	PsiElement	from
from.getPrevSibling	PsiElement	fromDoubles
dot.getPsi.followedByNewLine()	Boolean	dotFollowedByNewLine
if (dotFollowedByNewLine) dotAlignment else alignment	Alignment	actualAlignment
ref.multiResolveScala(false)	Array[ScalaResolveResult]	results
SubBlocksContext(typeArgs, sorted(delegatedChildren))	SubBlocksContext	context
SubBlocksContext(expr, delegatedChildren)	SubBlocksContext	context
x.declaredElements	Seq[ScBindingPattern]	elems
x.declaredElements	Seq[ScTypedDefinition]	elems
new ArrayBuffer[PsiElement]	ArrayBuffer[PsiElement]	children
value.getNextSibling	PsiElement	psiElement
children ++ delegatedChildren	IndexedSeq[ASTNode]	childrenWithDelegated
usage.getReference.getElement match { case Parent(call: ScMethodCall) if call.argumentExpressions.isEmpty => replace(call, referenced) case Parent(call: ScMethodCall) => replaceFunctionCall(call, referenced) case expr: ScExpression => replace(expr, referenced) case Parent(typeElement: ScTypeElement) => replace(typeElement, referenced) case _ => None }	Option[PsiElement]	newValue
Option(findElementOfClassAtRange(file, startOffset, endOffset, classOf[ScTypeElement]))	Option[Nothing]	maybeTypeElement
editor.getDocument.createRangeMarker(elementToRename.getTextRange)	RangeMarker	elementRange
new ArrayBuffer[ScTypeParametersOwner]()	ArrayBuffer[ScTypeParametersOwner]	ownersArray
replacementForCall(call, function)	ScExpression	replacement
ScalaNamesUtil.scalaName(elementToRename)	String	stringToSearch
block.getChildBlockLastNode(child)	ASTNode	lastNode
PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument)	PsiFile	currentFile
(leftPsi, rightPsi) match { case (_: ScFunction, _: ScValueOrVariable) | (_: ScValueOrVariable, _: ScFunction) | (_: ScTypeAlias, _: ScFunction) | (_: ScFunction, _: ScTypeAlias) => math.max(scalaSettings.BLANK_LINES_AROUND_FIELD_IN_INNER_SCOPES, scalaSettings.BLANK_LINES_AROUND_METHOD_IN_INNER_SCOPES) case (_: ScFunction, _) | (_, _: ScFunction) => scalaSettings.BLANK_LINES_AROUND_METHOD_IN_INNER_SCOPES case _ => scalaSettings.BLANK_LINES_AROUND_FIELD_IN_INNER_SCOPES }	Int	setting
block.getCustomAlignment(child).orNull	Alignment	alignment
mutable.ArrayBuffer[RangeHighlighter]()	ArrayBuffer[RangeHighlighter]	myHighlighters
element match { case null => false case _: PsiMethodWrapper[_] | _: PsiClassWrapper => true case _ => element.getLanguage.isKindOf(ScalaLanguage.INSTANCE) }	Boolean	isScalaElement
block.subBlocksContext.flatMap(_.childrenAdditionalContexts.get(child))	Option[SubBlocksContext]	context
mutable.HashMap[RangeMarker, TextAttributes]()	mutable.HashMap[RangeMarker, TextAttributes]	rangesToHighlight
node	ASTNode	child
function.body match { case Some(body) => ScalaPsiElementFactory.createExpressionWithContextFromText(body.getText, function, body) case _ => return call }	ScExpression	funBodyCopy
EditorColorsManager.getInstance	EditorColorsManager	colorsManager
TemplateManagerImpl.getTemplateState(editor)	TemplateState	templateState
if (isScalaElement) RenamePsiElementProcessor.forElement(element) else null	RenamePsiElementProcessor	processor
(psi, p) match { case (_: ScFunction, _: ScTrait) => settings.BLANK_LINES_AROUND_METHOD_IN_INTERFACE case (_: ScFunction, _) => settings.BLANK_LINES_AROUND_METHOD case (_, _: ScTrait) => settings.BLANK_LINES_AROUND_FIELD_IN_INTERFACE case _ => settings.BLANK_LINES_AROUND_FIELD }	Int	setting
primaries(groupIndex)	PsiElement	primary
templateState.getSegmentRange(i)	TextRange	segmentRange
document.createRangeMarker(segmentRange)	RangeMarker	segmentMarker
getOwner(x)	ScTypeParametersOwner	owner
template.getSegmentName(i)	String	name
if (name == primaryNames(primary)) colorsManager.getGlobalScheme.getAttributes(EditorColors.WRITE_SEARCH_RESULT_ATTRIBUTES) else if (dependentNames(primary) contains name) colorsManager.getGlobalScheme.getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES) else null	TextAttributes	attributes
typeElement.getFirstChild	PsiElement	firstChild
HighlightManager.getInstance(project)	HighlightManager	highlightManager
node.getTreeParent.nullSafe.exists(_.getElementType == ScalaDocElementTypes.DOC_TAG) && node.getPsi.isInstanceOf[PsiErrorElement]	Boolean	insideIncompleteScalaDocTag
highlightOccurrences(refs.map(_.getElement))(element.getProject, editor)	Seq[RangeHighlighter]	occurrenceHighlighters
results.map(_.getElement).filterNot(isSyntheticObject)	IndexedSeq[PsiNamedElement]	nonSyntheticTargets
ArrayBuffer[ASTNode]()	ArrayBuffer[ASTNode]	children
new InlineHandler.Settings { def isOnlyOneReferenceToInline: Boolean = false }	InlineHandler.Settings { def isOnlyOneReferenceToInline: Boolean }	settings
leftElementType == ScalaTokenTypes.kELSE && (rightPsi.isInstanceOf[ScIf] || rightElementType == ScalaTokenTypes.kIF)	Boolean	isElseIf
refs.size match { case 1 => "(1 occurrence)" case n => s"($n occurrences)" }	String	occurences
node.getElementType match { case ScalaDocTokenType.DOC_TAG_VALUE_TOKEN => subBlocks.add(subBlock(node, indent = Some(Indent.getNoneIndent))) node.getTreeNext case _ => node }	ASTNode	scaladocNode
block.parentBlock.subBlocksContext.flatMap(_.alignment) .getOrElse(Alignment.createAlignment(true))	Alignment	normalAlignment
node.getTreeParent.getFirstChildNode	ASTNode	firstSibling
Option(leftPsi.getNextSiblingNotWhitespace).exists(_.isInstanceOf[PsiComment])	Boolean	isCommentAfterElse
left.lastNode	ASTNode	lastNode
getTypeAlias(te)	ScTypeAlias	ta
{ case node if node.getElementType == tAT && node.getTreeParent != null && node.getTreeParent.getElementType == ScalaElementType.NAMING_PATTERN => if (scalaSettings.SPACES_AROUND_AT_IN_PATTERNS) WITH_SPACING else WITHOUT_SPACING }	PartialFunction[ASTNode, Spacing]	atProcessor
subst.getContainingFile.getVirtualFile	VirtualFile	file
call.matchedParameters.flatMap { case (expr, p) => p.paramInCode.map((_, expr)) }	IndexedSeq[(ScParameter, ScExpression)]	paramToReplacement
new LocalSearchScope(funBodyCopy)	LocalSearchScope	scope
ScalaNamesUtil.scalaName(substituted)	String	name
getOwner(ta)	ScTypeParametersOwner	owner
ScalaRefactoringUtil.RevertInfo(editor.getDocument.getText, editor.getCaretModel.getOffset)	ScalaRefactoringUtil.RevertInfo	revertInfo
tp.nameId.getNode	ASTNode	tpNode
tpNode.getTreeNext	ASTNode	tpNodeNext
tpNode.eq(leftNode)	Boolean	isLeadingContextBound
PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument)	PsiFile	file
tpNodeNext.eq(leftNode) && tpNodeNext != null && tpNodeNext.getElementType == ScalaElementType.TYPE_PARAM_CLAUSE	Boolean	isLeadingContextBoundHK
TargetElementUtil.adjustOffset(file, editor.getDocument, editor.getCaretModel.getOffset)	Int	offset
file.findElementAt(offset).getTextRange	TextRange	range
leftNode	ASTNode	left
editor.getUserData(ScalaMemberInplaceRenamer.REVERT_INFO)	ScalaRefactoringUtil.RevertInfo	revertInfo
myEditor.getDocument	Document	document
revertInfo.caretOffset	Int	offset
ownres.filter((value: ScTypeParametersOwner) => value.getContainingFile == currentFile)	Array[ScTypeParametersOwner]	filtered
editor.getSelectionModel	SelectionModel	selectionModel
child.getElementType	IElementType	childType
left.getElementType == ScalaTokenTypes.tIDENTIFIER && isIdentifier(getText(left, fileText) + ":")	Boolean	colonCanStickToLeftIdentifier
s"Inline $inlineDescriptionSuffix ${ psiNamedElement.name }? $occurences"	String	question
new RefactoringMessageDialog( inlineTitle, question, HelpID.INLINE_VARIABLE, "OptionPane.questionIcon", true, element.getProject)	RefactoringMessageDialog	dialog
rightPsiParent match { case tp: ScTypeParam => val tpNode = tp.nameId.getNode val tpNodeNext = tpNode.getTreeNext val isLeadingContextBound = tpNode.eq(leftNode) val isLeadingContextBoundHK = tpNodeNext.eq(leftNode) && tpNodeNext != null && tpNodeNext.getElementType == ScalaElementType.TYPE_PARAM_CLAUSE if (isLeadingContextBound) { withSpacingIf(scalaSettings.SPACE_BEFORE_TYPE_PARAMETER_LEADING_CONTEXT_BOUND_COLON) } else if (isLeadingContextBoundHK) { withSpacingIf(scalaSettings.SPACE_BEFORE_TYPE_PARAMETER_LEADING_CONTEXT_BOUND_COLON_HK) } else { withSpacingIf(scalaSettings.SPACE_BEFORE_TYPE_PARAMETER_REST_CONTEXT_BOUND_COLONS) } case _ => if (scalaSettings.SPACE_BEFORE_TYPE_COLON) { WITH_SPACING } else { // For operations like `var Object_!= : Symbol = _` var left = leftNode while (left != null && left.getLastChildNode != null) { left = left.getLastChildNode } val colonCanStickToLeftIdentifier = left.getElementType == ScalaTokenTypes.tIDENTIFIER && isIdentifier(getText(left, fileText) + ":") withSpacingIf(colonCanStickToLeftIdentifier) } }	Spacing	result
node.getTreeParent.getElementType == ScalaDocElementTypes.DOC_TAG && childType != ScalaDocTokenType.DOC_WHITESPACE && childType != ScalaDocTokenType.DOC_COMMENT_LEADING_ASTERISKS && child != firstSibling && firstSibling.getElementType == ScalaDocTokenType.DOC_TAG_NAME && child.getText.trim.length > 0	Boolean	isDataInsideDocTag
rightNode.getTreeParent.getPsi.isInstanceOf[ScalaFile]	Boolean	rightTreeParentIsFile
docTagName match { case _ if childType == ScalaDocTokenType.DOC_INNER_CODE => null case _ if childType == ScalaDocTokenType.DOC_INNER_CLOSE_CODE_TAG => null case _ if childType == ScalaDocTokenType.DOC_INNER_CODE_TAG => null case "@param" | "@tparam" => if (ss.SD_ALIGN_PARAMETERS_COMMENTS) normalAlignment else null case "@return" => if (ss.SD_ALIGN_RETURN_COMMENTS) normalAlignment else null case "@throws" => if (ss.SD_ALIGN_EXCEPTION_COMMENTS) normalAlignment else null case _ => if (ss.SD_ALIGN_OTHER_TAGS_COMMENTS) normalAlignment else null }	Alignment	alignment
rightPsiParent.getParent.isInstanceOf[ScFor]	Boolean	rightPsiParentIsFor
ReferencesSearch.search(named, named.getUseScope)	Query[PsiReference]	allReferences
!rightTreeParentIsFile && rightPsiParentIsFor	Boolean	magicCondition
Wrap.createWrap(WrapType.NONE, false)	Wrap	noWrap
ref => member.containingClass != null && !PsiTreeUtil.isAncestor(member.containingClass, ref.getElement, true)	Condition[PsiReference]	notInSameClass
renameProcessor(element)	RenamePsiElementProcessor	processor
new FilteredQuery[PsiReference](allReferences, notInSameClass)	FilteredQuery[PsiReference]	notInSameClassQuery
ss.ALIGN_EXTENDS_WITH	Int	alignSetting
new LocalSearchScope(fun.containingClass.toOption.getOrElse(fun.getContainingFile))	LocalSearchScope	scope
if (alignSetting == ALIGN_TO_EXTENDS) block.getAlignment else Alignment.createAlignment(true)	Alignment	alignment
(child.getElementType, alignSetting) match { case (_, DO_NOT_ALIGN) => null case (`kWITH` | `kEXTENDS`, ON_FIRST_ANCESTOR) => null case _ => alignment }	Alignment	actualAlignment
ReferencesSearch.search(fun, scope)	Query[PsiReference]	allReferences
ref => !ref.getElement.getParent.isInstanceOf[ScMethodCall]	Condition[PsiReference]	notCall
leftPsi match { case ref: ScReferenceExpression => ScalaNamesUtil.isOperatorName(ref.refName) case _ => false }	Boolean	isOperator
TargetElementUtil.findTargetElement(myEditor, TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED | TargetElementUtil.ELEMENT_NAME_ACCEPTED)	PsiElement	element
if (scalaSettings.SPACE_BEFORE_INFIX_METHOD_CALL_PARENTHESES || isOperator) WITH_SPACING else if (scalaSettings.SPACE_BEFORE_INFIX_OPERATOR_LIKE_METHOD_CALL_PARENTHESES && rightPsi.is[ScParenthesisedExpr]) WITH_SPACING else WITHOUT_SPACING	Spacing	result
substituted.getTextRange.getStartOffset	Int	substitutorOffset
super.getSubstituted	PsiElement	subst
PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument)	PsiFile	psiFile
new FilteredQuery[PsiReference](allReferences, notCall)	FilteredQuery[PsiReference]	noCallUsages
getVariable	PsiNamedElement	element
getSubstituted	PsiElement	subst
s"""Could not perform inplace rename: |element to rename: $element ${element.getName} |substituted: $subst |around caret: $aroundCaret""".stripMargin	String	message
editor.getCaretModel.getOffset	Int	caretOffset
new Key("RevertInfo")	Key[ScalaRefactoringUtil.RevertInfo]	REVERT_INFO
getElementAtCaret(editor) .nonStrictParentOfType(Seq(classOf[ScReference], classOf[ScNamedElement]))	Option[PsiElement]	selected
indent.getOrElse(ScalaIndentProcessor.getChildIndent(block, node))	Indent	indentFinal
selected.collect { case ref: ScReference => ref.nameId case named: ScNamedElement => named.nameId }.orNull	PsiElement	nameId
f.name match { case "apply" | "unapply" | "unapplySeq" => true case _ => false }	Boolean	hasSpecialName
wrap.getOrElse(arrangeSuggestedWrapForChild(block, node, block.suggestedWrap))	Wrap	wrapFinal
result.isRenamed	Option[String]	renamed
CommonDataKeys.EDITOR.getData(dataContext)	Editor	editor
CommonDataKeys.PSI_FILE.getData(dataContext)	PsiFile	file
createOptionExpressionFromText(rangeText)(file.getManager)	Option[ScExpression]	expr
if (elements(0) == null || !elements(0).getParent.isInstanceOf[ScXmlPairedTag]) return else elements(0).getParent.asInstanceOf[ScXmlPairedTag]	ScXmlPairedTag	element
expression.operation	ScReferenceExpression	op1
None	Option[(ScExpression, Array[ScType])]	res
element.getTagName	String	elementStartName
element.getMatchedTag.getTagNameElement.getTextRange	TextRange	matchedRange
EditorColorsManager.getInstance()	EditorColorsManager	colorsManager
colorsManager.getGlobalScheme.getAttributes(EditorColors.WRITE_SEARCH_RESULT_ATTRIBUTES)	TextAttributes	attributes
buildTemplate()	Template	template
referenced match { case bp: ScBindingPattern => PsiTreeUtil.getParentOfType(bp, classOf[ScDeclaredElementsHolder]) match { case v@ScPatternDefinition.expr(e) if v.declaredElements == Seq(bp) => Some(unparExpr(e)) case v@ScVariableDefinition.expr(e) if v.declaredElements == Seq(bp) => Some(unparExpr(e)) case _ => None } case funDef: ScFunctionDefinition if funDef.parameters.isEmpty => funDef.body.map(unparExpr) case funDef: ScFunctionDefinition => unparExpr(expr).asOptionOf[ScMethodCall] .map(replacementForCall(_, funDef)) case _ => None }	Option[ScExpression]	replacementExpr
getExpressionWithTypes(file, startOffset, endOffset + 2)	Option[(ScExpression, Array[ScType])]	newOpt
new TemplateBuilderImpl(element.getParent)	TemplateBuilderImpl	builder
inf.operation	ScReferenceExpression	op2
withInjectionsReplaced(intrp, Map(expr -> replacement))	ScExpression	newLiteral
ref.multiResolveScala(false)	Array[ScalaResolveResult]	multiResolve
mutable.Set.empty	mutable.Set[PsiElement]	superMembersToRename
ScalaNamesUtil.toJavaName(newName)	String	encodedName
u.getReference.getElement	PsiElement	ref
element match { case ref: ScStableCodeReference => val results = ref.multiResolveScala(false) def isSyntheticObject(e: PsiElement) = e.asOptionOf[ScObject].exists(_.isSyntheticObject) val nonSyntheticTargets = results.map(_.getElement).filterNot(isSyntheticObject) nonSyntheticTargets.toSet subsetOf allElementsToDelete.toSet case _ => true }	Boolean	shouldDelete
injections.groupBy(_._1.getParent.asInstanceOf[ScExpression]).map { case (intrp, map) => (intrp, withInjectionsReplaced(intrp, map)) }	IndexedSeq[(ScExpression, ScExpression)]	injectionReplacements
{ u => val ref = u.getReference.getElement !ref.getLanguage.isKindOf(ScalaLanguage.INSTANCE) //todo more concise condition? }	UsageInfo => Boolean	needEncodedName
Key.create("rename.all.marker")	Key[ScObject]	renameAllKey
s"$prefix$quote$rangeText$quote"	String	text
null	PsiNamedElement	chosen
originalElement(element)	PsiElement	orig
RenamePsiElementProcessor.forElement(orig)	RenamePsiElementProcessor	processor
new PsiElementProcessor[PsiNamedElement]() { def execute(element: PsiNamedElement): Boolean = { chosen = element false } }	PsiElementProcessor[PsiNamedElement] { def execute(element: PsiNamedElement): Boolean }	processor
if (shouldDelete) { val isInImport = PsiTreeUtil.getParentOfType(element, classOf[ScImportStmt]) != null if (isInImport) Seq(new SafeDeleteReferenceJavaDeleteUsageInfo(element, psiClass, true)) // delete without review else Seq(new SafeDeleteReferenceJavaDeleteUsageInfo(element, psiClass, false)) // delete with review } else Seq()	Seq[SafeDeleteReferenceJavaDeleteUsageInfo]	usagesToAdd
typeParameter.getOwner	PsiTypeParameterListOwner	owner
owner.getTypeParameterList.getTypeParameterIndex(typeParameter)	Int	index
usagez.groupBy(u => setterSuffix(u.getElement.getText))	Map[String, Array[UsageInfo]]	grouped
referenceElement.getParameterList.getTypeParameterElements	Array[PsiTypeElement]	typeArgs
parts.map { case Injection(ref: ScReferenceExpression, s) => Injection(refToReplacement.getOrElse(ref, ref), s) case p => p }	IndexedSeq[StringPart]	newParts
td.getContainingFile	PsiFile	file
ScalaOverridingMemberSearcher.search(psiMethod)	Array[PsiNamedElement]	overridingElements
named match { case _: ScTypeAlias => allSuperTypes(named, withSelfType = false) case _ => allSuperMembers(named, withSelfType = false) }	Seq[PsiNamedElement]	superMembers
encodeNames(UsagesWithName(newName, usages))	Seq[UsagesWithName]	encoded
overridingElements.filterNot(x => allElementsToDelete.contains(x))	Array[PsiNamedElement]	overridingMethods
findMaxSuperMembers(superMembers)	Seq[PsiNamedElement]	maxSuperMembers
InterpolatedStringFormatter.format(newParts)	String	newText
ScalaRenameUtil.findSubstituteElement(element)	PsiNamedElement	guess
newValue.getProject	Project	project
newExpr.getTypeWithoutImplicits(ignoreBaseType = true).getOrAny	ScType	tpe
FileEditorManager.getInstance(project).getSelectedTextEditor	Editor	editor
Option(psiElement).collect { case definition: ScTypeDefinition => definition }.flatMap { _.baseCompanionModule }	Option[ScTypeDefinition]	companion
element match {case named: ScNamedElement => named; case _ => return}	ScNamedElement	named
namedElement match { case _: ScObject => encoded.flatMap(modifyScObjectName) case _: PsiTypedDefinitionWrapper | _: FakePsiMethod => encoded.flatMap(modifySetterName) case fun: ScFunction if setterSuffix(fun.name) != "" => encoded.flatMap(modifySetterName) case _: ScReferencePattern => encoded.flatMap(modifySetterName) case _ => encoded }	Seq[UsagesWithName]	modified
new SafeDeleteUsageInfo(x, psiMethod)	SafeDeleteUsageInfo	info
element match {case x: ScFunction => x case _ => return}	ScFunction	function
Option(ScalaRenameUtil.findSubstituteElement(element)).map(_.getTextRange)	Option[TextRange]	newElemRange
new ArrayBuffer[PsiNamedElement]	ArrayBuffer[PsiNamedElement]	buff
getOverridingConstructorOfSuperCall(reference.getElement)	PsiMethod	overridingConstructor
ScalaPsiUtil.elementsAtRange[ScExpression](file, startOffset, endOffset)	Seq[ScExpression]	elementsAtRange
constructor.getBody	PsiCodeBlock	body
superMembers :+ element	IndexedSeq[PsiNamedElement]	allElements
getGetterOrSetterFunction(function) match { case Some(function2) => buff += function2 Some(function2) case _ => None }	Option[ScFunction]	getterOrSetter
ScalaRenameUtil.setterSuffix(newName)	String	newSuffix
elementsAtRange.find(canBeIntroduced).orNull	ScExpression	expression
false	Boolean	anyNewBadRefs
ScalaRenameUtil.setterSuffix(oldName)	String	oldSuffix
false	Boolean	anyOverridingRefs
typeWithoutExpected(expression)	ScType	typeNoExpected
overridingReference.getElement	PsiElement	element
s"def __dummyFunction__ = {\n ${expression.getText} \n}"	String	dummyFunctionText
ScalaNamesUtil.scalaName(elem)	String	oldName
new WarningDialog(function.getProject, ScalaBundle.message("rename.getters.and.setters.title"))	PrepareRenameScalaMethodProcessor.this.WarningDialog	dialog
canBePrivate(method, methodToReferences.get(method), validOverriding, allElementsToDelete)	Boolean	methodCanBePrivate
f.name	String	name
method.findSuperMethods	Array[PsiMethod]	methods
method.containingClass	PsiClass	containingClass
method.getManager	PsiManager	manager
JavaPsiFacade.getInstance(manager.getProject)	JavaPsiFacade	facade
facade.getElementFactory	PsiElementFactory	factory
null	PsiModifierList	privateModifierList
factory.createMethod("x3", PsiType.VOID)	PsiMethod	newMethod
createMethodWithContext(dummyFunctionText, expression.getContext, expression).asInstanceOf[ScFunctionDefinition]	ScFunctionDefinition	definitionWithoutType
getUsageInsideDeletedFilter(allElementsToDelete)	Condition[PsiElement]	isInsideDeleted
file.getVirtualFile	VirtualFile	virtualFile
ReadonlyStatusHandler.getInstance(project)	ReadonlyStatusHandler	readonlyStatusHandler
reference.getRangeInElement	TextRange	range
parameter.getDeclarationScope.asInstanceOf[PsiMethod]	PsiMethod	method
method.getParameterList.getParameterIndex(parameter)	Int	index
element match {case x: PsiNamedElement => x case _ => return}	PsiNamedElement	namedElement
readonlyStatusHandler.ensureFilesWritable(Collections.singletonList(virtualFile))	ReadonlyStatusHandler.OperationStatus	operationStatus
null	PsiCall	call
unparExpr(expression)	ScExpression	element
call.getArgumentList	PsiExpressionList	argList
literal.getTextRange.getStartOffset	Int	litStart
0	Int	fromIdx
0	Int	indexOf
element match { case named: ScNamedElement => named case _ => return }	ScNamedElement	named
litStart + indexOf	Int	start
argList.getExpressions	Array[PsiExpression]	args
element match { case x: ScTypeAlias => x case _ => return }	ScTypeAlias	typeAlias
start + text.length	Int	end
mutable.ArrayBuffer[TextRange]()	ArrayBuffer[TextRange]	result
intrp.referenceName	String	prefix
element.getReference.asInstanceOf[PsiDocMethodOrFieldRef#MyReference]	PsiDocMethodOrFieldRef#MyReference	javadocMethodReference
superMembers.size == 1	Boolean	oneSuperClass
PsiTreeUtil.getParentOfType(element, classOf[PsiDocTag])	PsiDocTag	docTag
file.findElementAt(offset)	PsiElement	element
false	Boolean	isSafeDelete
if (oneSuperClass) Nil else Seq((renameAllMarker(element), null))	Seq[(ScObject, Null)]	additional
call.getMethodExpression	PsiReferenceExpression	methodExpression
intrp.contentRange	TextRange	contentRange
call.resolveMethod	PsiMethod	superMethod
ancestor.asInstanceOf[PsiClass]	PsiClass	aClass
Logger.getInstance("#com.intellij.refactoring.safeDelete.JavaSafeDeleteProcessor")	Logger	LOG
targetClass.projectContext	ProjectContext	projectContext
targetClass.extendsBlock	ScExtendsBlock	extendsBlock
new PsiElementProcessor[PsiClass] { def execute(aClass: PsiClass): Boolean = { if (aClass != renameAllMarker(aClass)) action(classesToNamed(aClass)) else { val mainOne = classesToNamed(classes.head) superMembersToRename.clear() superMembersToRename ++= classes.dropRight(1).drop(1).map(classesToNamed) action(mainOne) } false } }	PsiElementProcessor[PsiClass] { def execute(aClass: PsiClass): Boolean }	processor
mutable.Map[ExtractMethodParameter, ScExpression]()	mutable.Map[ExtractMethodParameter, ScExpression]	parameterValues
mutable.Map[ScTypedDefinition, ScTypedDefinition]()	mutable.Map[ScTypedDefinition, ScTypedDefinition]	definitionCorrespondence
ScalaNamesUtil.scalaName(superMembers.last)	String	name
filtered(subPatterns)	Seq[PsiElement]	filteredP
filtered(subCandidates)	Seq[PsiElement]	filteredC
PsiTreeUtil.findCommonParent(elements: _*)	PsiElement	parent
mutable.HashMap[String, PsiElement]()	mutable.HashMap[String, PsiElement]	refNameToResolved
extendsBlock.templateBody match { case Some(tb) => tb case None => extendsBlock.add(createTemplateBody) }	PsiElement	templateBody
templateBody.getLastChild	PsiElement	anchor
pattern.paramOccurences(ref)	ExtractMethodParameter	p
ScalaPsiUtil.getParents(element, file).collect { case t: ScTemplateDefinition if isSuitableClass(t) => t }.toArray[PsiClass]	Array[PsiClass]	classes
classes(0)	PsiClass	selection
parameterValues.getOrElseUpdate(p, expr)	ScExpression	paramValue
{ case toCheck: ScInterpolatedStringLiteral => toCheck.referenceName == prefix && toCheck.depthFirst().forall { case ref: ScReferenceExpression => refNameToResolved.get(ref.refName).contains(ref.resolve()) case _ => true } case _ => false }	ScLiteral => Boolean	filter
mutable.ArrayBuffer.empty[ScMember]	ArrayBuffer[ScMember]	movedDefinitions
collectParamOccurences()	Map[ScReferenceExpression, ExtractMethodParameter]	paramOccurences
lit.getValue.asInstanceOf[String]	String	text
collectDefinitions()	Seq[ScTypedDefinition]	definitions
ListBuffer[ScTypedDefinition]()	ListBuffer[ScTypedDefinition]	buffer
if (oneSuperClass) { val overimpl = ScalaPsiUtil.nameContext(superMembers(0)) match { case _: ScDeclaration => "implements" case _ => "overrides" } val qualName = classes(0) match { case td: ScTypeDefinition => td.qualifiedName case cl => cl.getQualifiedName } s"$name $overimpl member of $qualName" } else ScalaBundle.message("rename.has.multiple.base.members", name)	String	title
new PsiElementProcessor[PsiClass] { def execute(aClass: PsiClass): Boolean = { action false } }	PsiElementProcessor[PsiClass] { def execute(aClass: PsiClass): Boolean }	processor
{ case _: ScInterpolatedStringLiteral if text.contains('$') => false case l => l.isString }	ScLiteral => Boolean	filter
typeToExtend.name	String	name
templateBody.addBefore(memberCopy, anchor).asInstanceOf[ScMember]	ScMember	added
mutable.ArrayBuffer[ScExpression]()	ArrayBuffer[ScExpression]	occurrences
name + parameters	String	text
CodeStyleManager.getInstance(project)	CodeStyleManager	csManager
clazz.extendsBlock	ScExtendsBlock	oldExtBlock
clazz.projectContext	ProjectContext	projectContext
documentManager.getDocument(targetClass.getContainingFile)	Document	targetDocument
new ArrayBuffer[ScTypeElement]()	ArrayBuffer[ScTypeElement]	occurrences
new ScalaRecursiveElementVisitor { override def visitFunctionDefinition(fun: ScFunctionDefinition): Unit = { buffer += fun super.visitFunctionDefinition(fun) } override def visitPatternDefinition(pat: ScPatternDefinition): Unit = { pat.bindings.foreach(buffer += _) super.visitPatternDefinition(pat) } override def visitVariableDefinition(varr: ScVariableDefinition): Unit = { varr.bindings.foreach(buffer += _) super.visitVariableDefinition(varr) } }	ScalaRecursiveElementVisitor { def visitFunctionDefinition(fun: ScFunctionDefinition): Unit def visitPatternDefinition(pat: ScPatternDefinition): Unit def visitVariableDefinition(varr: ScVariableDefinition): Unit }	visitor
documentManager.getDocument(sourceClass.getContainingFile)	Document	sourceDocument
mutable.Map[ScReferenceExpression, ExtractMethodParameter]()	mutable.Map[ScReferenceExpression, ExtractMethodParameter]	buffer
s"${tp.getText} with $text"	String	tpText
element.nextSiblings	Iterator[PsiElement]	siblingIterator
new ScalaRecursiveElementVisitor { override def visitReferenceExpression(ref: ScReferenceExpression): Unit = { parameters.find(_.fromElement == ref.resolve) .foreach(p => buffer += (ref -> p)) super.visitReferenceExpression(ref) } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	visitor
new DuplicateMatch(this, cands)	DuplicateMatch	mtch
ListBuffer[DuplicateMatch]()	ListBuffer[DuplicateMatch]	result
decl.copy().asInstanceOf[ScMember]	ScMember	member
ScalaPsiUtil.nameContext(named) match { case m: ScMember => m case _ => return Seq.empty }	ScMember	member
member.containingClass	ScTemplateDefinition	aClass
m.copy().asInstanceOf[ScMember]	ScMember	copy
mutable.Set[PsiElement]()	mutable.Set[PsiElement]	seen
oldExtBlock.templateParents match { case Some(tp: ScTemplateParents) => val tpText = s"${tp.getText} with $text" val (_, newTp) = createClassTemplateParents(tpText) tp.replace(newTp).asInstanceOf[ScTemplateParents] case None => val (extKeyword, newTp) = createClassTemplateParents(text) oldExtBlock.addRangeBefore(extKeyword, newTp, oldExtBlock.getFirstChild) oldExtBlock.templateParents.get }	ScTemplateParents	templParents
clazz.getContainingFile.getVirtualFile	VirtualFile	sourceFile
new ScalaRecursiveElementVisitor { override def visitScalaElement(element: ScalaPsiElement): Unit = { if (isSignificant(element)) { isDuplicateStart(element) match { case Some(mtch) if !seen(mtch.candidates(0)) => result += mtch seen += mtch.candidates(0) case _ => super.visitScalaElement(element) } } } }	ScalaRecursiveElementVisitor { def visitScalaElement(element: ScalaPsiElement): Unit }	visitor
element +: siblingIterator.withFilter(isSignificant).take(size - 1).toSeq	IndexedSeq[PsiElement]	siblings
ProjectRootManager.getInstance(clazz.getProject).getFileIndex	ProjectFileIndex	fileIndex
fileIndex.getSourceRootForFile(sourceFile)	VirtualFile	sourceRoot
JavaPsiFacade.getInstance(sourceClass.getProject).findPackage(targetPackageName)	PsiPackage	pckg
getTypeElementOccurrencesHelper(inElement, inEnclosingContainer)	Array[ScTypeElement]	result
GlobalSearchScope.allScope(currentElement.getProject)	GlobalSearchScope	scope
output.returnType	ScType	tp
b.`type`() match { case Right(t) => s": ${t.canonicalCodeText}" case _ => "" }	String	typeText
pckg.getDirectories	Array[PsiDirectory]	dirs
ExtractSuperUtil.getDirUnderSameSourceRoot(sourceClass, dirs)	PsiDirectory	dir
RefactoringMessageUtil.checkCanCreateFile(dir, targetClassName + ".scala")	String	cantCreateFile
if (canonTextForTypes) tp.canonicalCodeText else tp.codeText	String	typeText
funDef.copy().asInstanceOf[ScFunctionDefinition]	ScFunctionDefinition	copy
if (withSelfType) TypeDefinitionMembers.getSelfTypeSignatures(aClass) else TypeDefinitionMembers.getSignatures(aClass)	TypeDefinitionMembers.TermNodes.Map	signatures
ScalaInheritors.directInheritorCandidates(currentElement, scope)	Seq[ScTemplateDefinition]	inheritors
signatures.forName(named.name)	MixinNodes.AllNodes[TermSignature]	allSigns
t.getTypedDefinitionWrapper(isStatic = false, isAbstract = false, r, None)	PsiTypedDefinitionWrapper	wrapper
ScalaPsiUtil.nameContext(named) match { case t: ScTypeAlias => t case _ => return Seq() }	ScTypeAlias	typeAlias
ScalaExtractMethodUtils.typedName(output.paramName, typeText)(output.fromElement.getProject)	String	typed
new DuplicatePattern(filtered(settings.elements), settings.parameters)(settings.projectContext)	DuplicatePattern	pattern
typeAlias.containingClass	ScTemplateDefinition	aClass
getTypeElementOccurrences(typeElement, classObject)	Array[ScTypeElement]	occurrences
te.calcType	ScType	tpe
duplicate.textRange	TextRange	range
editor.offsetToLogicalPosition(range.getStartOffset)	LogicalPosition	logicalPosition
false	Boolean	replaceAll
false	Boolean	cancelled
valDef.copy().asInstanceOf[ScPatternDefinition]	ScPatternDefinition	copy
varDef.copy().asInstanceOf[ScVariableDefinition]	ScVariableDefinition	copy
outputs.map(paramText).mkString("(", ", ", ")")	String	paramsText
if (withSelfType) TypeDefinitionMembers.getSelfTypeTypes(aClass) else TypeDefinitionMembers.getTypes(aClass)	TypeDefinitionMembers.TypeNodes.Map	types
types.forName(named.name)	MixinNodes.AllNodes[TypeSignature]	forName
ScalaPsiUtil.nameContext(fromElement) match { case _: ScValue | _: ScFunction => true case _ => false }	Boolean	isVal
ScalaTypeValidator(typeElement, classObject, occurrences.isEmpty)	ScalaTypeValidator	validator
new ExtractInfo(clazz, memberInfos)	ScalaExtractTraitHandler.this.ExtractInfo	extractInfo
ta.copy().asInstanceOf[ScTypeAliasDefinition]	ScTypeAliasDefinition	copy
mutable.MutableList()	mutable.MutableList[Array[ScTypeElement]]	collectedOccurrences
mutable.MutableList()	mutable.MutableList[ScalaTypeValidator]	collectedValidators
showPromptDialog(settings.methodName, idx + 1, duplicates.size, project)	ReplacePromptDialog	dialog
variableData.element	ScTypedDefinition	element
collectedOccurrences.foldLeft(Array[ScTypeElement]())((a, b) => a ++ b)	Array[ScTypeElement]	occurrences
collectedValidators.toArray	Array[ScalaTypeValidator]	validators
new ReplacePromptDialog(false, title, project)	ReplacePromptDialog	dialog
createTemplateDefinitionFromText(traitText, clazz.getContext, clazz)	ScTemplateDefinition	newTrt
elements.flatMap(elementWithContainingClass).toMap	Map[PsiClass, PsiNamedElement]	classToElement
classToElement.keys	Iterable[PsiClass]	classes
classes.filter(maxClass => !classes.exists(maxClass.isInheritor(_, /*deep = */ true)))	Iterable[PsiClass]	maxClasses
duplicates.head	DuplicateMatch	duplicate
EditorColorsManager.getInstance.getGlobalScheme	EditorColorsScheme	colorsScheme
CodeFoldingManager.getInstance(project).getFoldRegionsAtOffset(editor, textRange.getStartOffset)	Array[FoldRegion]	foldRegions
foldRegions.exists(!_.isExpanded)	Boolean	anyCollapsed
colorsManager.getGlobalScheme.getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES)	TextAttributes	attributes
fromElement match { case fun: ScFunction => fun.parameters.length == 0 case _ => false }	Boolean	isEmptyParamFunction
ScalaPsiUtil.nameContext(fromElement) match { case v: ScValue if v.hasModifierProperty("lazy") => true case p: ScParameter if p.isCallByNameParameter => true case _ => false }	Boolean	isCallByNameParameter
colorsScheme.getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES)	TextAttributes	attributes
fromElement.isInstanceOf[ScFunction]	Boolean	isFunction
editor.getColorsScheme	EditorColorsScheme	scheme
new ScalaExtractTraitDialog(project, clazz)	ScalaExtractTraitDialog	dialog
new TextAttributes	TextAttributes	textAttributes
null	RangeHighlighter	selectionHighlighter
editor.getMarkupModel	MarkupModel	markupModel
new Selection	Selection	selection
new ScopeHighlighter(editor)	ScopeHighlighter	highlighter
nextSibling.getTextRange	TextRange	nextRange
elements.apply(0)	PsiElement	elem
settings.visibility	String	accessMod
settings.methodName	String	methodName
value.asInstanceOf[T]	T	element
elem.name	String	overriderName
ExtractSuperClassUtil.showConflicts(dialog, extractInfo.conflicts, clazz.getProject)	Boolean	isOk
parent.getTextRange	TextRange	range
{ val nextRange = nextSibling.getTextRange val elem: PsiElement = elements.apply(0) elem.parentsInFile .takeWhile { parent => parent != null && ! { val range = parent.getTextRange range != null && range.contains(nextRange) && !range.equalsToRange(nextRange.getStartOffset, nextRange.getEndOffset) } } .collect { case tpo: ScTypeParametersOwner => tpo} .flatMap(_.typeParameters) .toSeq .reverse }	Seq[ScTypeParam]	typeParameters
toHighlight(element)	PsiElement	psi
namedElement.name	String	baseName
createTraitFromTemplate(name, packName, clazz)	ScTrait	newTrait
list.getSelectedIndex	Int	index
model.get(index).asInstanceOf[T]	T	element
ScalaApplicationSettings.getInstance()	ScalaApplicationSettings	scalaSettings
extractInfo.memberInfos	Seq[ScalaExtractMemberInfo]	memberInfos
scalaSettings.INTRODUCE_FIELD_IS_VAR	Boolean	isVar
element match { case expr: ScExpression => getOccurrenceRanges(expr, aClass.extendsBlock) case _ => null }	Seq[TextRange]	occurrences
extractInfo.clazz	ScTemplateDefinition	clazz
scalaSettings.INTRODUCE_FIELD_REPLACE_ALL	Boolean	replAll
new ScalaPullUpProcessor(clazz.getProject, clazz, trt, memberInfos)	ScalaPullUpProcessor	pullUpProcessor
scalaSettings.INTRODUCE_FIELD_EXPLICIT_TYPE	Boolean	explType
scalaSettings.INTRODUCE_FIELD_INITIALIZE_IN_DECLARATION	Boolean	initInDecl
true	Boolean	initInDeclEn
ScalaVariableValidator(file, element, occurrences)	ScalaVariableValidator	validator
true	Boolean	initLocEn
ifc.occurrences.length > 1	Boolean	replaceAllChbEnabled
new ValidationReporter(project, new DialogConflictsReporter {}, validator)	ValidationReporter	reporter
true	Boolean	defineVarChbEnabled
ScalaBundle.message("extract.method.title")	String	REFACTORING_NAME
element match { case expr: ScExpression => canBeInitializedInDeclaration(expr, aClass) case _ => throw new IntroduceException }	Boolean	canBeInitInDecl
toHighlight(element)	PsiElement	psiElement
true	Boolean	explicitTypeChbEnabled
ifc.canBeInitInDecl	Boolean	canBeInitInDeclaration
ifc.canBeInitLocally(replaceAll = true)	Boolean	canBeInitLocalIfReplaceAll
ifc.canBeInitLocally(replaceAll = false)	Boolean	canBeInitLocalOneOccurrence
canBeInitLocalIfReplaceAll || canBeInitLocalOneOccurrence	Boolean	canBeInitLocally
ifc.possibleNames.iterator().next()	String	name
s"trait ${trt.name} {\n$selfTpe\n}"	String	traitText
ifc.types(0)	ScType	scType
"Or"	String	separator
"To"	String	separator
Seq.empty[RangeHighlighter]	Seq[RangeHighlighter]	occurrenceHighlighters
createTemplateDefinitionFromText(traitText, trt.getParent, trt)	ScTemplateDefinition	dummyTrait
typeParametersText(settings)	String	typeParamsText
ifc.project	Project	project
dummyTrait.extendsBlock.selfTypeElement.get	ScSelfTypeElement	selfTypeElem
trt.extendsBlock	ScExtendsBlock	extendsBlock
new JBPopupAdapter { override def beforeShown(event: LightweightWindowEvent): Unit = { selection.addHighlighter() } override def onClosed(event: LightweightWindowEvent) { highlighter.dropHighlight() selection.removeHighlighter() } }	JBPopupAdapter { def onClosed(event: LightweightWindowEvent): Unit def beforeShown(event: LightweightWindowEvent): Unit }	highlighterAdapter
ifc.editor	Editor	editor
ExtensionPointName.create("org.intellij.scala.genericTypeNamesProvider")	ExtensionPointName[GenericTypeNamesProvider]	EP_NAME
templateBody.getFirstChild	PsiElement	lBrace
new IntroduceFieldSettings(ifc)	IntroduceFieldSettings[ScExpression]	settings
templateBody.addAfter(selfTypeElem, lBrace)	PsiElement	ste
expressionToIntroduce(ifc.element)	ScExpression	expression
settings.parameters.filter(_.passAsParameter).map(paramText)	IndexedSeq[String]	parameters
if (parameters.nonEmpty) parameters.mkString("(", ", ", ")") else ""	String	paramsText
ifc.occurrences.filter(_.getStartOffset == editor.getSelectionModel.getSelectionStart)	Seq[TextRange]	mainOcc
if (settings.replaceAll) ifc.occurrences else mainOcc	Seq[TextRange]	occurrencesToReplace
Map( "_root_.scala.Option" -> "maybe", "_root_.scala.Some" -> "some", "_root_.scala.concurrent.Future" -> "eventual", "_root_.scala.concurrent.Promise" -> "promised", "_root_.scala.util.Try" -> "tried" )	Map[Nothing, Nothing]	needPrefix
settings.elements(0).getProject	Project	project
ifc.aClass	ScTemplateDefinition	aClass
createTypeParameterClauseFromTextWithContext(typeParamsText, trt, trt.nameId)	ScTypeParamClause	clause
ExtractSuperUtil.packageName(clazz)	String	currentPackageName
ScalaCodeStyleSettings.getInstance(project)	ScalaCodeStyleSettings	codeStyleSettings
ScalaPsiUtil.getParents(elem, file).collect { case t: ScTemplateDefinition if isSuitableClass(elem, t) => t }.toArray[PsiClass]	Array[PsiClass]	classes
anchorForNewDeclaration(expression, occurrencesToReplace, aClass)	PsiElement	checkAnchor
aClass.projectContext	ProjectContext	projectContext
"function"	String	default
ElementScope(clazz.getProject)	ElementScope	scope
settings.name	String	name
if ((settings.addReturnType == ScalaApplicationSettings.ReturnTypeLevel.REMOVE) || (settings.addReturnType == ScalaApplicationSettings.ReturnTypeLevel.BY_CODE_STYLE && !isTypeAnnotationRequiredFor(settings, settings.visibility))) " = " else if (settings.calcReturnTypeIsUnit && !codeStyleSettings.ENFORCE_FUNCTIONAL_SYNTAX_FOR_UNIT) "" else s": ${settings.calcReturnTypeText} ="	String	retType
ScalaPsiUtil.functionArrow(f.getProject)	String	arrow
new PsiElementProcessor[PsiClass] { def execute(aClass: PsiClass): Boolean = { action(new IntroduceFieldContext[T](project, editor, file, elem, types, aClass.asInstanceOf[ScTemplateDefinition])) false } }	PsiElementProcessor[PsiClass] { def execute(aClass: PsiClass): Boolean }	processor
maybeWritableScalaFile(file, REFACTORING_NAME) .getOrElse(return)	ScalaFile	scalaFile
selectedElements(editor, scalaFile, trimComments = false)	Seq[PsiElement]	elements
argument match { case IsTraversable(_, _) => Seq.empty case _ => pluralizeNames(argument) }	Seq[String]	argumentNames
n.extendsBlock.superTypes	List[ScType]	types
occurrences.map(_.getStartOffset).min	Int	firstOccOffset
this.firstNames(designator, arguments)	Seq[String]	firstNames
t.exprs	Seq[ScExpression]	exprs
this.secondNames(designator, arguments)	Seq[String]	secondNames
""	String	separator
JavaPsiFacade.getInstance(clazz.getProject).findPackage(packageName)	PsiPackage	pckg
statementsAndMembersInClass(aClass).find(_.getTextRange.getEndOffset >= firstOccOffset)	Option[PsiElement]	anchor
if (packageName == currentPackageName) clazz.getContainingFile.getContainingDirectory else { val pckg = JavaPsiFacade.getInstance(clazz.getProject).findPackage(packageName) if (pckg == null || pckg.getDirectories.isEmpty) throw new IllegalArgumentException("Cannot find directory for new trait") else pckg.getDirectories()(0) }	PsiDirectory	dir
Option(settings.scType).map(_.canonicalCodeText).getOrElse("")	String	typeName
Option(editor.getSelectionModel.getSelectionEndPosition.getLine) .getOrElse(editor.getCaretModel.getLogicalPosition.line)	Int	lineNumber
mutable.Set[PsiClass]()	mutable.Set[PsiClass]	classesForSelfType
statementsAndMembersInClass(aClass)	Seq[PsiElement]	stmtsAndMmbrs
editor.visualToLogicalPosition(new VisualPosition(lineNumber, 0))	LogicalPosition	lineStart
if (replaceAll) ifc.occurrences else Seq(ifc.element.getTextRange)	Seq[TextRange]	occurrences
editor.visualToLogicalPosition(new VisualPosition(lineNumber + 1, 0))	LogicalPosition	nextLineStart
findParentExpr(commonParent(ifc.file, occurrences))	ScExpression	parExpr
editor.logicalPositionToOffset(lineStart)	Int	start
memberInfos.map(_.getMember)	IndexedSeq[ScMember]	selected
editor.logicalPositionToOffset(nextLineStart)	Int	end
statementsAndMembersInClass(ifc.aClass)	Seq[PsiElement]	stmtsAndMmbrs
null	String	currentMemberName
typedName(oldName, tp.canonicalCodeText)(fromElement.getProject)	String	nameAndType
mutable.Set[ScTypeParam]()	mutable.Set[ScTypeParam]	typeParams
new MultiMap[PsiElement, String]	MultiMap[PsiElement, String]	conflicts
settings.parameters.filter(p => !p.passAsParameter).map { case ExtractMethodParameter(oldName, _, fromElement, tp, _) => val nameAndType = typedName(oldName, tp.canonicalCodeText)(fromElement.getProject) s"val $nameAndType = ???\n" }	IndexedSeq[String]	notPassedParams
string(0)	Char	character
clazz.extendsBlock.selfType	Option[ScType]	selfTypeOfClazz
notPassedParams.mkString	String	notPassedParamsText
replaceOccurrences(occurrencesToReplace, name, ifc.file)	Seq[TextRange]	replacedOccurences
file.findElementAt(offset) match { case whiteSpace: PsiWhiteSpace if whiteSpace.getTextRange.getStartOffset == offset && whiteSpace.getText.contains("\n") => file.findElementAt(offset - 1) case element => element }	PsiElement	selectedElement
settings.elements.toSeq match { case Seq(x: ScBlockExpr) => x.children.toSeq.drop(1).dropRight(1).toIterator // drop '{' and '}' case x => x.toIterator }	Iterator[PsiElement]	elementsToAdd
suggestedNames(element)	Seq[String]	names
mutable.ArrayBuffer[ScTypeElement]()	ArrayBuffer[ScTypeElement]	result
anchorForNewDeclaration(expression, replacedOccurences, aClass)	PsiElement	anchor
settings.initInDeclaration	Boolean	initInDecl
elementsToAdd.map(_.getText).mkString("")	String	elementsText
null	PsiElement	createdDeclaration
settings.innerClassSettings	InnerClassSettings	ics
new ScalaRecursiveElementVisitor { override def visitReturn(ret: ScReturn) { val newFun = PsiTreeUtil.getParentOfType(ret, classOf[ScFunctionDefinition]) if (newFun == fun) { result = Some(fun.returnType.getOrElse(Unit)) } } }	ScalaRecursiveElementVisitor { def visitReturn(ret: ScReturn): Unit }	visitor
selectedElement	ScTypeElement	parent
createExpressionFromText("_")	ScExpression	underscore
returnType	Option[ScType]	hasReturn
container(parExpr).getOrElse(ifc.file) .withParentsInFile .exists(stmtsAndMmbrs.contains(_))	Boolean	containerIsLocal
element.getTextRange	TextRange	textRange
findScopeBound(elements).getOrElse(file)	PsiElement	stopAtScope
occurrences.head	TextRange	firstRange
getSiblings(elements.head, stopAtScope)	Array[PsiElement]	siblings
elements.toArray	Array[PsiElement]	array
function.getProject	Project	project
anchorForInit.getParent	PsiElement	parent
ElementScope(project)	ElementScope	elementScope
function	PsiMethod	myMethod
Option(dataContext).map(_.getData("chosenTargetScope").asInstanceOf[Int])	Option[Int]	targetOffset
findParentExpr(commonParent(file, occurrences))	ScExpression	parExpr
createExpressionFromText(s"$name = ${expression.getText}")	ScExpression	assignStmt
None	Option[ScalaIntroduceParameterData]	introducedParameterData
!parExpr.isInstanceOf[ScBlock]	Boolean	isNotBlock
function match { case ScalaConstructor.in(c) => c.name case fun: ScFunction => fun.name case _ => newName }	String	getOldName
getOldName != newName	Boolean	isNameChanged
false	Boolean	isGenerateDelegate
ScalaLanguage.INSTANCE	Language	getLanguage
function match { case f: ScFunction => f.returnType.toOption.map(_.canonicalText) != Option(newType).map(_.canonicalText) case _ => false }	Boolean	isReturnTypeChanged
createModifierFromText(other)	PsiElement	modifier
targetOffset flatMap smallestScopeEnclosingTarget(siblings) getOrElse siblings(0)	PsiElement	targetScope
new ScalaRecursiveElementVisitor { override def visitReference(ref: ScReference): Unit = { ref.resolve() match { case tp: ScTypeParam => typeParams += tp case _ => } } }	ScalaRecursiveElementVisitor { def visitReference(ref: ScReference): Unit }	visitor
if (isNotBlock && needBraces(parExpr, nextParent(parExpr, file))) { firstRange = firstRange.shiftRight(1) parExpr.replaceExpression(createExpressionFromText(s"{${parExpr.getText}}")(file.getManager), removeParenthesis = false) } else container(parExpr).getOrElse(file)	PsiElement	parent
expression.`type`().toOption ++ expression.getTypeWithoutImplicits().toOption ++ expression.getTypeIgnoreBaseType.toOption	IndexedSeq[ScType]	types
new ScalaRecursiveElementVisitor { override def visitReference(ref: ScReference) { val resolve = ref.resolve() collectForSelfType(resolve) collectConflicts(ref, resolve) collectTypeParameters(resolve) } }	ScalaRecursiveElementVisitor { def visitReference(ref: ScReference): Unit }	visitor
Ordering.by[PsiElement, Int] { _.getContext.getTextLength }	Ordering[PsiElement]	byScopeLength
extBl.addEarlyDefinitions()	ScEarlyDefinitions	earlyDef
new ArrayBuffer[PsiElement]	ArrayBuffer[PsiElement]	res
ifc.occurrences.length	Int	occCount
new ScalaIntroduceFieldDialog(ifc, settings)	ScalaIntroduceFieldDialog	dialog
element	PsiElement	prev
ScalaParameterInfo.allForMethod(function)	Seq[Seq[ScalaParameterInfo]]	oldParameters
PsiTreeUtil.findCommonParent(elements: _*)	PsiElement	commonParent
clazz.extendsBlock.selfTypeElement.fold("this")(_.name)	String	alias
oldParameters.flatten.toArray	Array[ScalaParameterInfo]	oldParametersArray
ref.qualifier match { case Some(thisRef: ScThisReference) => thisRef.refTemplate case Some(_) => return None case None => None }	Option[ScTemplateDefinition]	fromThisRef
oldParametersArray.map(_.name)	Array[String]	oldParameterNames
oldParametersArray.map(_.getTypeText)	Array[String]	oldParameterTypes
fromThisRef.orElse { ref.resolve() match { case primConstr: ScPrimaryConstructor => primConstr.containingClass match { case clazz: ScClass => if (clazz.isLocal) clazz.parent else clazz.containingClass.toOption case _ => None } case member: ScMember if !member.isLocal => member.containingClass.toOption case td: ScTypeDefinition => td.parent case ScalaPsiUtil.inNameContext(varDef: ScVariableDefinition) if ScalaPsiUtil.isLValue(ref) && !elements.exists(_.isAncestorOf(varDef)) => varDef.parent case member: PsiMember => member.containingClass.toOption case _ => return None } }	Option[PsiElement]	defScope
oldParametersArray.zipWithIndex.map { case (_, i) => !newParameters.exists(_.oldIndex == i) }	Array[Boolean]	toRemoveParm
commonParent.getContainingFile	PsiElement	result
{ oldParameters.map(_.length) != newParams.map(_.length) || newParameters.zipWithIndex.exists {case (p, i) => p.oldIndex != i} }	Boolean	isParameterSetOrOrderChanged
newParameters.zipWithIndex.exists { case (p, i) => p.oldIndex == i && p.getName != getOldParameterNames(i) }	Boolean	isParameterNamesChanged
s"This method has java overriders, by-name parameters of value classes cannot be used."	String	message
newParameters.zipWithIndex.exists { case (p, i) => (p.oldIndex == i) && (p.getTypeText != getOldParameterTypes(i) || p.isRepeatedParameter != oldParametersArray(i).isRepeatedParameter || p.isByName != oldParametersArray(i).isByName) }	Boolean	isParameterTypesChanged
false	Boolean	wasVararg
false	Boolean	isObtainsVarags
if (settings.lastReturn) "" else { def params = settings.outputs.map(_.paramName).mkString("(", ", ", ")") def multipleReturnText = { val ics = settings.innerClassSettings if (!ics.needClass) params //tuple else if (ics.isCase) s"${ics.className}$params" else s"new ${ics.className}$params" } settings.returnType match { case Some(t) if t.isUnit => byOutputsSize( "\nfalse", s"\nSome$params", s"\nSome($multipleReturnText)") case Some(_) => byOutputsSize( "\nNone", s"\nRight$params", s"\nRight($multipleReturnText)") case _ => byOutputsSize( "", s"\n${settings.outputs(0).paramName}", s"\n$multipleReturnText") } }	String	returnText
false	Boolean	isRetainsVarargs
false	Boolean	isArrayToVarargs
new ScalaRecursiveElementVisitor { override def visitReference(ref: ScReference) { scopeBound(ref) match { case Some(bound: PsiElement) if PsiTreeUtil.isAncestor(result, bound, true) => result = bound case _ => } } }	ScalaRecursiveElementVisitor { def visitReference(ref: ScReference): Unit }	visitor
namedElement match { case fun: ScFunction => Some(fun.paramClauses) case cl: ScClass => cl.clauses case _ => None }	Option[ScParameters]	paramClauses
paramClauses.toSeq.flatMap(_.params)	Seq[ScParameter]	scParams
s"${accessMod}def $methodName$typeParamsText$paramsText$retType {\n$notPassedParamsText"	String	firstPart
scParams.map(Parameter(_))	Seq[Parameter]	parameters
classesForSelfType.map { case obj: ScObject => s"${obj.qualifiedName}.type" case cl: ScTypeDefinition => cl.qualifiedName case cl: PsiClass => cl.getQualifiedName }.mkString(" with ")	String	typeText
mutable.LinkedHashSet(names: _*).map { case "class" => "clazz" case name => name }.filter(isIdentifier)	IndexedSeq[String]	filteredNames
firstPart.length	Int	offset
scParams.map(_.getActualDefaultExpression.map(_.getText))	Seq[Option[String]]	defaultValues
s"$elementsText$returnText\n}"	String	secondPart
ScalaPsiUtil.functionArrow(clazz.getProject)	String	arrow
Option(file.findElementAt(startOffset)) .flatMap(element => Option(getParentOfType(element, classOf[ScExtendsBlock], classOf[PsiFile])))	Option[Nothing]	maybeElement
filteredNames.toSeq match { case Seq() => Seq(DefaultName) case seq => seq.reverse }	Seq[String]	collected
ScalaNamesUtil.toJavaName(c.name)	String	className
mutable.Map.empty[String, Int].withDefaultValue(-1)	mutable.Map[String, Int]	counter
typeParams.toSeq.sortBy(_.getTextRange.getStartOffset).map(_.getText)	IndexedSeq[Nothing]	paramTexts
named match { case isWrapper(elem) => elem case _ => named }	PsiNamedElement	unwrapped
names.headOption.getOrElse(defaultName)	String	name
parametersInner	Seq[Seq[ScalaParameterInfo]]	parameters
ReachingDefinitionsCollector.collectVariableInfo(elements, sibling)	FragmentVariableInfos	info
member.containingClass.qualifiedName	String	className
info.inputVariables	Iterable[VariableInfo]	input
typeParams.toSeq.sortBy(_.getTextRange.getStartOffset).map(_.name)	IndexedSeq[String]	names
info.outputVariables	Iterable[VariableInfo]	output
createMethodFromText(firstPart + secondPart)(settings.elements.apply(0).getManager)	ScFunction	method
new ScalaExtractMethodDialog(project, elements, hasReturn, lastReturn, sibling, input.toArray, output.toArray, lastExprType)	ScalaExtractMethodDialog	dialog
s"Method is overridden in a composite $kind in $className. " + "Converting it to function definition is not supported."	String	message
pc.containingClass.asInstanceOf[ScClass]	ScClass	namedElement
defaultValue	String	defaultForJava
false	Boolean	useAnySingleVariable
textRanges.map(_.getStartOffset) ++ textRanges.map(_.getEndOffset - 1)	IndexedSeq[Int]	offsets
scType match { case JavaArrayType(_) => true case _ => false }	Boolean	wasArrayType
false	Boolean	isVarargType
Option(commonParent(file, textRange))	Option[PsiElement]	maybeParent
Option(ref).flatMap(_.bind())	Option[ScalaResolveResult]	resolveResult
ret.expr.map(_.getText).mkString	String	retExprText
output.map(ScalaExtractMethodUtils.convertVariableData(_, elements)).map(ExtractMethodOutput.from)	IndexedSeq[ExtractMethodOutput]	out
cp.containingClass.qualifiedName	String	className
new ItemListener { def itemStateChanged(e: ItemEvent) { stateModified() } }	{ def itemStateChanged(e: Any): Unit }	listener
settings.returnType match { case Some(t) if t.isUnit => byOutputsSize( "true", "None", "None" ) case Some(_) => byOutputsSize( s"Some($retExprText)", s"Left($retExprText)", s"Left($retExprText)" ) case None => "" //should not occur }	String	newText
resolveResult.map(_.substitutor)	Option[ScSubstitutor]	substitutor
s"Method is overridden by class parameter of $className. " + "Converting it to a function definition is not supported."	String	message
call	ScMethodCall	expr
{ val text = editor.getDocument.getImmutableCharSequence val isCase = text.startsWith("//case class") val isInner = text.startsWith("//inner class") val out = output.map(ScalaExtractMethodUtils.convertVariableData(_, elements)).map(ExtractMethodOutput.from) InnerClassSettings(isCase || isInner, "TestMethodNameResult", out.toArray, isCase) }	InnerClassSettings	innerClassSettings
if (!ApplicationManager.getApplication.isUnitTestMode) { val dialog = new ScalaExtractMethodDialog(project, elements, hasReturn, lastReturn, sibling, input.toArray, output.toArray, lastExprType) dialog.show() if (!dialog.isOK) return dialog.getSettings } else { val innerClassSettings = { val text = editor.getDocument.getImmutableCharSequence val isCase = text.startsWith("//case class") val isInner = text.startsWith("//inner class") val out = output.map(ScalaExtractMethodUtils.convertVariableData(_, elements)).map(ExtractMethodOutput.from) InnerClassSettings(isCase || isInner, "TestMethodNameResult", out.toArray, isCase) } new ScalaExtractMethodSettings("testMethodName", ScalaExtractMethodUtils.getParameters(input.toArray, elements), ScalaExtractMethodUtils.getReturns(output.toArray, elements), "", sibling, elements, hasReturn, ScalaApplicationSettings.ReturnTypeLevel.BY_CODE_STYLE, lastReturn, lastExprType, innerClassSettings) }	ScalaExtractMethodSettings	settings
createExpressionFromText(s"return $newText")(ret.getManager)	ScExpression	retElem
new ScalaRecursiveElementVisitor { override def visitReturn(ret: ScReturn) { if (!ret.method.contains(method)) return val retExprText = ret.expr.map(_.getText).mkString val newText = settings.returnType match { case Some(t) if t.isUnit => byOutputsSize( "true", "None", "None" ) case Some(_) => byOutputsSize( s"Some($retExprText)", s"Left($retExprText)", s"Left($retExprText)" ) case None => "" //should not occur } val retElem = createExpressionFromText(s"return $newText")(ret.getManager) ret.replace(retElem) } }	ScalaRecursiveElementVisitor { def visitReturn(ret: ScReturn): Unit }	returnVisitor
DuplicatesUtil.findDuplicates(settings)	Seq[DuplicateMatch]	duplicates
null	DefaultValuesUsagePanel	defaultValuesUsagePanel
ScalaExtractMethodUtils.createMethodFromSettings(settings)	ScFunction	method
defaultValueContext.getProject	Project	project
methodDescriptor.parameters	Seq[Seq[ScalaParameterInfo]]	initialParams
nextSibling.getParent.addBefore(elem, nextSibling)	PsiElement	added
ics.classText(canonTextForTypes = true)	String	classText
ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	codeFragments
createTemplateDefinitionFromText(classText, anchorNext.getContext, anchorNext)	ScTemplateDefinition	clazz
OldArgsInfo(allArgs(call), method)	OldArgsInfo	argsInfo
if (isByName) FunctionType(scType, Seq()) else if (isRepeatedParameter) scType.tryWrapIntoSeqType else scType	ScType	resultType
null	PsiElement	insertedMethod
refExpr	ScReferenceExpression	expr
Option(parameterInfo).getOrElse(ScalaParameterInfo(project))	ScalaParameterInfo	info
refExpr	ScReferenceExpression	ref
OldArgsInfo(Seq.empty, method)	OldArgsInfo	argsInfo
`type`.name	String	typeName
named.name	String	oldName
infix	ScInfixExpr	expr
method.projectContext	ProjectContext	projectContext
infix.operation	ScReferenceExpression	ref
s.getNextSiblingNotWhitespaceComment	PsiElement	nextSibling
insertMethod()	PsiElement	method
`type` match { case Char | Byte | Int | Long | Double => 1 case Short | Float => 2 case Boolean => 4 case _ => typeName.length }	Int	length
if (defaultForJava.contains("$default$")) { val qual = expr match { case mc: PsiMethodCallExpression => mc.getMethodExpression.getQualifierExpression match { case _: PsiSuperExpression => "" case null => "" case q => q.getText + "." } case _ => "" } qual + defaultForJava } else defaultForJava	String	defaultText
OldArgsInfo(infix.argumentExpressions, method)	OldArgsInfo	argsInfo
postfix	ScPostfixExpr	expr
postfix.operation	ScReferenceExpression	ref
OldArgsInfo(postfix.argumentExpressions, method)	OldArgsInfo	argsInfo
maybeParent.flatMap(element => Option(getParentOfType(element, classOf[ScLiteralPattern])))	Option[Nothing]	maybePattern
SuperMethodWarningUtil.checkSuperMethod(method, RefactoringBundle.message("to.refactor"))	PsiMethod	newMethod
JavaPsiFacade.getElementFactory(project).createExpressionFromText(defaultText, expr)	PsiExpression	expression
s"new ${constrInvocation.getText}"	String	newText
ScalaCodeFragment(info.typeText(typeContext), typeContext.getParent, typeContext)	ScalaCodeFragment	paramTypeCodeFragment
Option(scType).fold("")(_.codeText)	String	baseText
ScalaCodeFragment(info.getDefaultValue, defaultValueContext.getParent, defaultValueContext)	ScalaCodeFragment	defaultValueCodeFragment
p.nameId	PsiElement	nameId
Seq(paramTypeCodeFragment, defaultValueCodeFragment)	Seq[ScalaCodeFragment]	fragments
definition.constructorInvocation.toSeq .flatMap(_.matchedParameters)	IndexedSeq[(ScExpression, Parameter)]	parameters
createExpressionFromText(param.newName)	ScExpression	newRef
p.children.takeWhile(_ != nameId)	Iterator[PsiElement]	elems
{ val newText = s"new ${constrInvocation.getText}" createExpressionFromText(newText)(constrInvocation.getManager) }	ScExpression	expr
initialParams.flatMap(_.headOption).drop(1)	IndexedSeq[ScalaParameterInfo]	newClauseParams
newClauseParams.contains(parameterInfo)	Boolean	startsNewClause
createExpressionFromText(s"${param.newName}()")	ScExpression	newRef
new ScalaRecursiveElementVisitor() { override def visitReference(ref: ScReference) { ref.bind() match { case Some(ScalaResolveResult(named: PsiNamedElement, _: ScSubstitutor)) => if (named.getContainingFile == method.getContainingFile && named.getTextOffset < offset && !named.name.startsWith("_")) { val oldName = named.name var break = false for (param <- settings.parameters if !break) { if (param.oldName == oldName) { implicit val projectContext = method.projectContext def tail() { if (param.oldName != param.newName) { val newRef = createExpressionFromText(param.newName) ref.getParent.getNode.replaceChild(ref.getNode, newRef.getNode) } } ref.getParent match { case sect: ScUnderscoreSection if param.isFunction => val newRef = createExpressionFromText(param.newName) sect.getParent.getNode.replaceChild(sect.getNode, newRef.getNode) case _ if param.isEmptyParamFunction => ref.getParent match { case ref: ScReference if ref.refName == "apply" => tail() case _: ScMethodCall => tail() case _ => ref.asInstanceOf[ScExpression].expectedType() match { case Some(FunctionType(_, params)) if params.isEmpty => tail() case _ => //we need to replace by method call val newRef = createExpressionFromText(s"${param.newName}()") ref.getParent.getNode.replaceChild(ref.getNode, newRef.getNode) } } case _ => tail() } break = true } } } case _ => } super.visitReference(ref) } }	ScalaRecursiveElementVisitor { def visitReference(ref: ScReference): Unit }	visitor
generateTypeText(parameter)	String	typeText
new ArrayBuffer[(PsiNamedElement, String)]	ArrayBuffer[(PsiNamedElement, String)]	bindTo
expression.getContext match { case x: ScAssignment => x.referenceName case x: ScArgumentExprList => x.matchedParameters.collectFirst { case (matchedExpression, parameter) if matchedExpression == expression => parameter }.map(_.name) case _ => None }	Option[String]	maybeName
Option(findTargetMember(file, editor)) .getOrElse(CommonDataKeys.PSI_ELEMENT.getData(dataContext))	PsiElement	element
if (dataContext != null) CommonDataKeys.EDITOR.getData(dataContext) else null	Editor	editor
new ScalaRecursiveElementVisitor() { override def visitScalaElement(element: ScalaPsiElement) { element match { case named: PsiNamedElement if named != method && named.getTextOffset < offset => settings.parameters.find(p => p.oldName == named.name) .filter(p => p.oldName != p.newName) .foreach(p => bindTo += ((named, p.newName))) case _ => } super.visitScalaElement(element) } }	ScalaRecursiveElementVisitor { def visitScalaElement(element: ScalaPsiElement): Unit }	newVisitor
OldArgsInfo(constrInvocation.arguments.flatMap(_.exprs), method)	OldArgsInfo	argsInfo
named.asInstanceOf[ScNamedElement].nameId	PsiElement	id
variable.element.asInstanceOf[ScTypedDefinition]	ScTypedDefinition	definition
elements(0).getTextRange.getStartOffset	Int	startOffset
jc.getMethod	PsiMethod	method
elements(elements.length - 1).getTextRange.getEndOffset	Int	endOffset
dialog.project	Project	project
jc.getNewReturnType.getType(method.getParameterList, method.getManager)	PsiType	psiType
if (elements.length > 0) { val startOffset = elements(0).getTextRange.getStartOffset val endOffset = elements(elements.length - 1).getTextRange.getEndOffset definition.getTextOffset >= startOffset && definition.getTextOffset < endOffset } else false	Boolean	isInside
dialog.getFileType	LanguageFileType	fileType
dialog.signatureUpdater	ChangeSignatureDialogBase[ScalaParameterInfo, ScFunction, String, ScalaMethodDescriptor, ScalaParameterTableModelItem, ScalaParameterTableModel]#UpdateSignatureListener	signatureUpdater
definition.`type`().getOrNothing	ScType	retType
parameters.collect { case (expression, parameter) if parameter.name == "name" => expression }.flatMap(namesByExpression)	IndexedSeq[String]	namesByParameters
definition.elementScope	ElementScope	elementScope
dialog.parametersTable	JBTable	table
definition match { case fun: ScFunction if fun.paramClauses.clauses.isEmpty => implicit val elementScope = definition.elementScope FunctionType(retType, Seq.empty) case _ => retType }	ScType	tp
settings.elements(0)	TypePresentationContext	context
settings.returnType	Option[ScType]	returnStmtType
PsiDocumentManager.getInstance(project).getDocument(item.typeCodeFragment)	Document	typeDoc
settings.outputs	Array[ExtractMethodOutput]	outputs
settings.lastExprType	Option[ScType]	lastExprType
namesByTypes(types)	Seq[String]	names
name match { case _ if name.startsWith("get") => 3 case _ if name.startsWith("set") => 3 case _ if name.startsWith("is") => 2 case _ => 0 }	Int	beginIndex
new EditorTextField(typeDoc, project, fileType)	EditorTextField	myTypeEditor
new EditorTextField(item.parameter.getName, project, fileType)	EditorTextField	myNameEditor
outputTypeText(settings)	String	outputType
ScalaPsiUtil.functionArrow(typeCodeFragment.getProject)	String	funArrow
PsiDocumentManager.getInstance(project).getDocument(item.defaultValueCodeFragment)	Document	defaultValueDoc
if (trimmed.startsWith("=>")) "=>" else if (trimmed.startsWith(funArrow)) funArrow else ""	String	arrow
new EditorTextField(defaultValueDoc, project, fileType)	EditorTextField	myDefaultValueEditor
new ArrayBuffer[VariableData]	ArrayBuffer[VariableData]	buffer
if (parameter.isByName) ScalaPsiUtil.functionArrow(typeCodeFragment.getProject) else ""	String	arrow
ScalaExtractMethodUtils.convertVariableData(input, elements)	VariableData	d
buffer.toArray	Array[VariableData]	data
change match { case sc: ScalaChangeInfo => sc.newType case jc: JavaChangeInfo => val method = jc.getMethod val psiType = jc.getNewReturnType.getType(method.getParameterList, method.getManager) psiType.toScType()(method.projectContext) case _ => return None }	ScType	newType
expr match { case block: ScBlock if !block.hasRBrace => ScalaBundle.message("cannot.refactor.not.expression") case (_: ScReferenceExpression) childOf (a: ScAssignment) if a.leftExpression == expr => ScalaBundle.message("cannot.refactor.named.arg") case (_: ScAssignment) childOf (_: ScArgumentExprList) => ScalaBundle.message("cannot.refactor.named.arg") case ElementType(ScalaElementType.INTERPOLATED_PREFIX_LITERAL_REFERENCE) => ScalaBundle.message("cannot.refactor.interpolated.string.prefix") case _: ScConstrExpr => ScalaBundle.message("cannot.refactor.constr.expression") case _: ScSelfInvocation => ScalaBundle.message("cannot.refactor.self.invocation") case _ => null }	Null	byExpression
new ArrayBuffer[ExtractMethodParameter]	ArrayBuffer[ExtractMethodParameter]	list
list.toArray	Array[ExtractMethodParameter]	res
ScalaExtractMethodUtils.convertVariableData(info, elements)	ScalaVariableData	data
me.getPoint.getX	Double	x
Option(parameter.scType).map(_.codeText)	Option[String]	text
substitutor(usage)(newType)	ScType	substType
ArrayBuffer[JComponent]()	ArrayBuffer[Any]	focusable
expr.getParent match { case ScInfixExpr(_, operation, _) if operation == expr => ScalaBundle.message("cannot.refactor.not.expression") case ScPostfixExpr(_, operation) if operation == expr => ScalaBundle.message("cannot.refactor.not.expression") case _: ScGenericCall => ScalaBundle.message("cannot.refactor.under.generic.call") case _: ScLiteralPattern => ScalaBundle.message("cannot.refactor.literal.pattern") case par: ScClassParameter => par.containingClass match { case clazz: ScClass if clazz.isTopLevel => ScalaBundle.message("cannot.refactor.class.parameter.top.level") case _ => null } case _ => null }	Null	byParent
PsiDocumentManager.getInstance(file.getProject)	PsiDocumentManager	documentManager
splittedItems.map(_.map(_.parameter))	IndexedSeq[IndexedSeq[ScalaParameterInfo]]	parameters
documentManager.getDocument(file)	Document	document
0	Int	shift
textRange.getStartOffset	Int	start
new TextRange(start, start + newString.length)	TextRange	newRange
file.findElementAt(start)	PsiElement	leaf
ScalaPsiUtil.functionArrow + " "	String	arrow
if (byName) arrow else ""	String	byNameArrow
{ args.groupBy(a => ScalaPsiUtil.parameterOf(a).fold(-1)(_.index)) .updated(-1, Seq.empty) }	Map[Int, Seq[ScExpression]]	byOldParameterIndex
settings.elements match { case Array(expression: ScExpression) => Some(Expression(expression)) case _ => None }	Option[Expression]	implementation
settings.elements(0)	PsiElement	element
true	Boolean	result
usage match { case ScalaNamedElementUsageInfo(scUsage) => scUsage.namedElement.nameId case MethodCallUsageInfo(ref, _) => ref.nameId case RefExpressionUsage(r) => r.nameId case InfixExprUsageInfo(i) => i.operation.nameId case PostfixExprUsageInfo(p) => p.operation.nameId case AnonFunUsageInfo(_, ref) => ref.nameId case ImportUsageInfo(ref) => ref.nameId case _ => null }	PsiElement	nameId
if (ics.needClass) s"${ics.classText(canonTextForTypes = false)}\n\n" else ""	String	classText
settings.visibility	String	visibility
pars.getTextRange	TextRange	textRange
s"${visibility}def $methodName"	String	prefix
file.findElementAt(textRange.getStartOffset - 1).getNode.getElementType	IElementType	prevElemType
ArrayBuffer[UsageInfo]()	ArrayBuffer[UsageInfo]	results
ScalaChangeInfo(getVisibility, method.fun, getMethodName, returnType, parameters, isAddDefaultArgs, Some(mySpecifyTypeChb.isSelected))	ScalaChangeInfo	changeInfo
jInfo.getMethod	PsiMethod	method
textRange.getStartOffset > 0 && { val prevElemType = file.findElementAt(textRange.getStartOffset - 1).getNode.getElementType ScalaTokenTypes.IDENTIFIER_TOKEN_SET.contains(prevElemType) || ScalaTokenTypes.KEYWORDS.contains(prevElemType) }	Boolean	afterWord
parent.getTextRange	TextRange	textRange
lit match { case intrp: ScInterpolatedStringLiteral => intrp.referenceName case _ => "" }	String	prefix
Seq("s", "raw").contains(prefix)	Boolean	replaceAsInjection
null	ScopeItem	currentScope
null	TextRange	initialTypeElement
null	Array[ScopeItem]	possibleScopes
settings.parameters .filter(_.passAsParameter) .map(p => nameAndType(p)) .mkString("(", s", ", ")")	String	paramsText
s"$classText$prefix$typeParamsText$paramsText"	String	base
ScalaBundle.message("introduce.variable.title")	String	INTRODUCE_VARIABLE_REFACTORING_NAME
null	(PsiFile, TextRange)	typeAliasInfo
false	Boolean	isCallModalDialogInProgress
ScalaBundle.message("introduce.type.alias.title")	String	INTRODUCE_TYPEALIAS_REFACTORING_NAME
editor.getUserData(IntroduceTypeAlias.REVERT_TYPE_ALIAS_INFO)	IntroduceTypeAliasData	currentDataObject
new DocumentListener() { override def documentChanged(e: DocumentEvent) { val ed: TableCellEditor = parametersTable.getCellEditor if (ed != null) { val editorValue: AnyRef = ed.getCellEditorValue myParametersTableModel.setValueAtWithoutUpdate(editorValue, row, column) updateSignature() } } }	DocumentListener	listener
currentDataObject.possibleScopes	Array[ScopeItem]	possibleScopes
method.returnTypeText	String	text
method.fun	ScMethodLike	child
if (settings.addReturnType == ScalaApplicationSettings.ReturnTypeLevel.ADD) base + ": " + calcReturnType(settings) else base	String	returnTypeText
ScalaPsiUtil.nameContext(usage.namedElement) match { case cl: ScClass => cl.constructor.getOrElse(return) case m: ScModifierListOwner => m case _ => return }	ScModifierListOwner	member
settings.projectContext	ProjectContext	projectContext
simpleScope.revalidate(enteredName)	ScopeItem	newScope
elements.find(elem => elem.isInstanceOf[ScalaPsiElement]).getOrElse(return)	PsiElement	element
currentDataObject.initialTypeElement	TextRange	range
ScalaCodeFragment(text, child.getParent, child)	ScalaCodeFragment	fragment
false	Boolean	includePrefixImports
new CompletionProcessor(StdKinds.refExprLastRef, element) { override val includePrefixImports: Boolean = false }	CompletionProcessor { val includePrefixImports : Boolean }	processor
currentElement.getContainingFile.asInstanceOf[ScalaFile].isScriptFile	Boolean	isScriptFile
item match { case si: ScalaParameterTableModelItem => si case _ => throw new IllegalArgumentException }	ScalaParameterTableModelItem	scalaItem
method.fun	ScMethodLike	element
getVisibility	String	visibility
new mutable.HashSet[String]()	mutable.HashSet[String]	allNames
s	String	freshName
generateFreshName(settings.methodName + "Result")	String	mFreshName
ScalaRefactoringUtil.getTypeParameterOwnerList(currentElement) ++ ScalaRefactoringUtil.getTypeAliasOwnersList(currentElement)	IndexedSeq[ScTypeParametersOwner]	owners
method.fun match { case fun: ScFunction => val name = if (!fun.isConstructor) getMethodName else "this" s"$visibility def $name" case pc: ScPrimaryConstructor => s"class ${pc.getClassNameText} $getVisibility" case _ => "" }	String	prefix
getParent(currentElement, isScriptFile)	PsiElement	parent
owners.exists(!_.isInstanceOf[ScTemplateDefinition])	Boolean	noContinue
isIdentifier(withNextChar) && withNextChar.last != '$'	Boolean	needBraces
mutable.ArrayBuffer.empty[ScopeItem]	ArrayBuffer[ScopeItem]	result
Array[ScTypeElement]()	Array[ScTypeElement]	occInCompanionObj
te.replace(createTypeElementFromText(substType.canonicalCodeText)(element.getManager))	PsiElement	replaced
usage.namedElement	ScNamedElement	element
if (needBraces) s"$${$newString}" else s"$$$newString"	String	text
lit.contentRange	TextRange	contentRange
newRange.getStartOffset == contentRange.getStartOffset	Boolean	isStart
newRange.getEndOffset == contentRange.getEndOffset	Boolean	isEnd
splittedItems.map(_.map(itemText).mkString("(", ", ", ")")).mkString	String	paramsText
returnTypeText	String	retTypeText
if (!isStart) s"$quote + " else ""	String	firstPart
parent match { case fileType: ScalaFile => Some("file " + fileType.getName) case _ => getParentOfType(parent, classOf[ScTemplateDefinition]) match { case classType: ScClass => Some("class " + classType.name) case objectType: ScObject => occInCompanionObj = getOccurrencesFromCompanionObject(currentElement, objectType) Some("object " + objectType.name) case traitType: ScTrait => Some("trait " + traitType.name) case _ => None } }	Option[Nothing]	containerName
if (retTypeText.isEmpty || !needType) "" else s": $retTypeText"	String	typeAnnot
ScalaRefactoringUtil.getTypeElementOccurrences(currentElement, parent)	Array[ScTypeElement]	occurrences
settings.parameters.filter(_.passAsParameter) .map(param => parameterText(param) + (if (param.isFunction) " _" else ""))	IndexedSeq[String]	params
if (!isEnd) s" + $prefix$quote" else ""	String	lastPart
parameterItems	Seq[ScalaParameterTableModelItem]	paramItems
if (params.nonEmpty) params.mkString("(", ", ", ")") else ""	String	paramsText
mutable.ListBuffer.empty[String]	ListBuffer[String]	problems
s"$firstPart$newString$lastPart"	String	text
s"${settings.methodName}$paramsText"	String	methodCallText
false	Boolean	needExtractorsFromMultipleReturn
lit.getTextRange	TextRange	literalRange
paramItems.map(_.parameter.name)	IndexedSeq[String]	paramNames
if (isStart) literalRange.getStartOffset else newRange.getStartOffset	Int	startOffset
ScalaTypeValidator(currentElement, parent, occurrences.isEmpty)	ScalaTypeValidator	validator
if (isEnd) literalRange.getEndOffset else newRange.getEndOffset	Int	endOffset
start + shift	Int	newStart
(Seq(clazz) ++ clazz.baseCompanionModule).flatMap { _.syntheticMethods }	IndexedSeq[ScFunction]	inExistingClasses
if (myNameField.isEnabled) getMethodName +: paramNames else paramNames	IndexedSeq[String]	names
element match { case fun: ScFunction => fun.returnTypeElement case ScalaPsiUtil.inNameContext(pd: ScPatternDefinition) => pd.typeElement case ScalaPsiUtil.inNameContext(vd: ScVariableDefinition) => vd.typeElement case cp: ScClassParameter => cp.typeElement case _ => None }	Option[ScTypeElement]	oldTypeElem
newStart + newString.length	Int	newEnd
paramNames.zipWithIndex	IndexedSeq[(String, Int)]	namesWithIndices
fileEncloser(file, startOffset).toSeq.flatMap { getOccurrenceRanges(expr, _) }	IndexedSeq[TextRange]	occurrences
ScalaVariableValidator(file, expr, occurrences)	ScalaVariableValidator	validator
s"Default value is missing. $stuff will contain blanks instead of the new parameter value."	String	message
change match { case scalaInfo: ScalaChangeInfo => scalaInfo.addTypeAnnotation case _ => Some(true) }	Option[Boolean]	addTypeAnnotationOption
NameSuggester.suggestNamesByType(currentElement.calcType, validator)	Seq[String]	possibleNames
change match { case j: JavaChangeInfo => j case _ => return }	JavaChangeInfo	jChange
items.tail.indexWhere(_.startsNewClause)	Int	index
SuggestedNames(expr, types, validator)	IntroduceExpressions.SuggestedNames	suggestedNames
settings.outputs.map(o => ScalaExtractMethodUtils.typedName(outputName(o), o.returnType.canonicalCodeText)(o.fromElement.getProject))	IndexedSeq[String]	outputTypedNames
parametersTable	JBTable	table
usage.expr	ScExpression	expr
createExpressionFromText(text)	ScExpression	expr
expr.`type`() match { case Right(FunctionType(_, pTypes)) => pTypes case _ => Seq.empty }	Seq[ScType]	paramTypes
ScalaPsiUtil.functionArrow	String	arrow
Seq[String]()	Seq[String]	paramsBuf
OccurrencesInFile(file, new TextRange(startOffset, endOffset), occurrences)	IntroduceExpressions.OccurrencesInFile	occurrencesInFile
getAllAvailablePackages(scPackage.fullPackageName, currentElement)	Array[(PsiPackage, PsiDirectory)]	allPackages
OccurrenceData(inTypeElement, isReplaceAllUsual = true, isReplaceOccurrenceIncompanionObject = false, isReplaceOccurrenceInInheritors = false, scopeItem )	OccurrenceData	allOccurrences
NameSuggester.suggestNamesByType(currentElement.calcType).map(_.capitalize).head	String	suggested
editingColumn(table)	Option[Nothing]	editedColumn
objectType.getParent	PsiElement	parent
if (!param.name.isEmpty) param.name else param.nameInCode match { case Some(n) => n case None => NameSuggester.suggestNamesByType(param.paramType).head }	String	paramName
objectType.name	String	name
jChange.getOldParameterNames.toSeq	Seq[Nothing]	paramNames
ReplaceChoice.NO != replaceChoice	Boolean	replaceAll
parent.getChildren.find({ case classType: ScClass if classType.name == name => true case traitType: ScTrait if traitType.name == name => true case _ => false })	Option[PsiElement]	companion
inWriteAction { runRefactoringInside(occurrences, expression, names.head, types.head, replaceAll, isVariable = false, fromDialogMode = false) }	SmartPsiElementPointer[PsiElement]	reference
paramNames.mkString("(", ", ", ")")	String	argText
mutable.ArrayBuffer.empty[PsiDirectory]	ArrayBuffer[PsiDirectory]	result
Option(newExpr).orElse(Option(newPattern)) .map(elem => document.createRangeMarker(elem.getTextRange)) .getOrElse(throw new IntroduceException)	RangeMarker	rangeMarker
(replaceChoice: ReplaceChoice) => { val replaceAll = ReplaceChoice.NO != replaceChoice executeWriteActionCommand(INTRODUCE_VARIABLE_REFACTORING_NAME) { val SuggestedNames(expression, types, names) = suggestedNames val reference: SmartPsiElementPointer[PsiElement] = inWriteAction { runRefactoringInside(occurrences, expression, names.head, types.head, replaceAll, isVariable = false, fromDialogMode = false) } performInplaceRefactoring(reference.getElement, types.headOption, replaceAll, forceInferType(expression), names) } }	Pass[OccurrencesChooser.ReplaceChoice]	callback
Option(namedElementReference.getElement).collect { case typeAlias: ScTypeAliasDefinition => typeAlias }	Option[ScTypeAliasDefinition]	maybeTypeAlias
file.getContainingDirectory	PsiDirectory	parent
currentDataObject.currentScope	ScopeItem	currentScope
typeElement.getContainingFile	PsiFile	containingFile
containingFile.getProject	Project	project
TemplateManagerImpl.getTemplateState(InjectedLanguageUtil.getTopLevelEditor(editor))	TemplateState	templateState
new OccurrencesChooser[TextRange](editor) { override def getOccurrenceRange(occurrence: TextRange): TextRange = occurrence }	OccurrencesChooser[TextRange] { def getOccurrenceRange(occurrence: TextRange): TextRange }	chooser
currentDataObject.getNamedElement.getName	String	enteredName
occurrences.reverseMap(replaceOccurrence(_, newString, file))	IndexedSeq[RangeMarker]	reversedRangeMarkers
aClass.extendsBlock	ScExtendsBlock	extendsBlock
occurrences.occurrences	Seq[TextRange]	occurrences_
extendsBlock.templateBody	Option[ScTemplateBody]	body
suggestedNames.validator	ScalaVariableValidator	validator
new ValidationReporter(project, this, validator)	ValidationReporter	reporter
extendsBlock.earlyDefinitions	Option[ScEarlyDefinitions]	earlyDefs
new ScalaIntroduceVariableDialog(project, types, occurrences_.length, reporter, names, expression)	ScalaIntroduceVariableDialog	dialog
nextParent match { case _: ScBlock => true case forSt: ScFor if forSt.body.orNull == parExpr => false //in this case needBraces == true case _: ScFor => true case _ => false }	Boolean	result
typeElement.calcType.canonicalCodeText	String	mtext
getTypeElement(file).orElse(getExpression(file))	Option[ScalaPsiElement with Typeable]	maybeSelectedElement
file.findElementAt(offset) match { case w: PsiWhiteSpace if w.getTextRange.getStartOffset == offset => 1 case _ => 0 }	Int	diff
offset - diff	Int	realOffset
ScalaExtractMethodUtils.outputTypeText(settings)	String	typeText
if (paramTypes.size == names.size) names.zip(paramTypes).map { case (name, tpe) => ScalaExtractMethodUtils.typedName(name, tpe.canonicalCodeText)(expr.getProject) } else names	Seq[String]	params
myParametersTableModel.getItem(selected)	ScalaParameterTableModelItem	item
new AnActionButton("Add parameter clause", null, Icons.ADD_CLAUSE) { override def actionPerformed(e: AnActionEvent): Unit = { val table = parametersTable val editedColumn = editingColumn(table) TableUtil.stopEditing(table) val selected = table.getSelectedRow if (selected > 0) { val item = myParametersTableModel.getItem(selected) item.startsNewClause = true myParametersTableModel.fireTableDataChanged() } finishAndRestoreEditing(editedColumn) } }	AnActionButton { def actionPerformed(e: AnActionEvent): Unit }	addClauseButton
params.mkString("(", ", ", ")")	String	clause
maybeSelectedElement match { case Some(typeElement: ScTypeElement) => Some(typeElement) case _ if !selectionModel.hasSelection => getTypeElementAtOffset case _ => None }	Option[ScTypeElement]	maybeTypeElement
ScalaPsiElementFactory .createTypeAliasDefinitionFromText(s"type $typeName = $mtext", typeElement.getContext, typeElement)	ScTypeAliasDefinition	definition
s"$clause => $exprText"	String	newFunExprText
Option(PsiTreeUtil.getParentOfType(elem, classOf[ScInterpolatedStringLiteral], false))	Option[Nothing]	interpolated
occurrences.length > 1	Boolean	multipleOccurrences
Option(containingFile.getVirtualFile) .flatMap(ScalaUtil.getModuleForFile(_)(project)) .getOrElse(project.anyScalaModule.get)	Module	module
{ val project = containingFile.getProject val module = Option(containingFile.getVirtualFile) .flatMap(ScalaUtil.getModuleForFile(_)(project)) .getOrElse(project.anyScalaModule.get) GlobalSearchScope.moduleScope(module) }	GlobalSearchScope	scope
newDeclaration match { case holder: ScDeclaredElementsHolder => holder.declaredElements.headOption case forBinding: ScForBinding => forBinding.pattern.bindings.headOption case _ => None }	Option[PsiNamedElement]	maybeNamedElement
expr.replaceExpression(createExpressionFromText(newFunExprText)(expr.getManager), removeParenthesis = true) .asInstanceOf[ScFunctionExpr]	ScFunctionExpr	replaced
usage.namedElement	ScNamedElement	named
getDirectoriesContainigfile(containingFile)	Array[PsiDirectory]	dirContainingFile
nextParent(expr, elem.getContainingFile)	PsiElement	nextPar
newDeclaration match { case ScVariableDefinition.expr(x) => x case ScPatternDefinition.expr(x) => x case ScForBinding.expr(x) => x case _ => null }	ScExpression	newExpr
currentPackage.getSubPackages(scope)	Array[PsiPackage]	subPackages
currentPackage.getFiles(scope)	Array[PsiFile]	filesNoRecursive
ScalaPsiUtil.addTypeAliasBefore(definition, parent, getAhchor(parent, typeElement))	ScTypeAlias	resultTypeAlias
ScalaRefactoringUtil.RevertInfo(file.getText, editor.getCaretModel.getOffset)	ScalaRefactoringUtil.RevertInfo	revertInfo
createExpressionFromText(ref.getText, position).asInstanceOf[ScReferenceExpression]	ScReferenceExpression	newRef
named match { case _: ScFunction | _: ScClass => None case ScalaPsiUtil.inNameContext(pd: ScPatternDefinition) if pd.isSimple => Some(pd.keywordToken) case ScalaPsiUtil.inNameContext(vd: ScVariableDefinition) if vd.isSimple => Some(vd.keywordToken) case _ => return }	Option[PsiElement]	keywordToChange
new ScalaRecursiveElementVisitor() { override def visitReferenceExpression(ref: ScReferenceExpression) { ref.getParent match { case ScInfixExpr(_, `ref`, _) => case ScPostfixExpr(_, `ref`) => case ScPrefixExpr(`ref`, _) => case _ => val newRef = createExpressionFromText(ref.getText, position).asInstanceOf[ScReferenceExpression] result &= ref.resolve() == newRef.resolve() } super.visitReferenceExpression(ref) } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	visitor
if (replaceAllOccurrences) occurrences_ else Seq(mainRange)	Seq[TextRange]	occurrences
occurrences.indexWhere(range => range.contains(mainRange) || mainRange.contains(range))	Int	mainOccurence
expressionToIntroduce(expression)	ScExpression	copy
forceInferType(copy)	Boolean	forceType
scope match { case simpleScope: SimpleScopeItem => simpleScope.fileEncloser case packageScope: PackageScopeItem => packageScope.fileEncloser match { case suggestedDirectory: PsiDirectory => createAndGetPackageObjectBody(typeElement, suggestedDirectory, packageScope.needDirectoryCreating, scope.name) case _ => packageScope.fileEncloser } }	PsiElement	parent
Option(varType).map(_.canonicalCodeText)	Option[String]	maybeTypeText
createMethodFromText("def foo {}")(named.getManager).children.find(_.getText == "def").get	PsiElement	defKeyword
addTypeAliasDefinition(typeName, occurrences.getAllOccurrences(0), parent)	ScTypeAlias	typeAlias
RevertInfo(file.getText, editor.getCaretModel.getOffset)	ScalaRefactoringUtil.RevertInfo	revertInfo
parameterListText(change, usage)	String	paramsText
named.nameId	PsiElement	nameId
occurrences.getUsualOccurrences.indexWhere(_ == typeElement)	Int	typeElementIdx
replaceTypeElements(occurrences.getUsualOccurrences, typeName, typeAlias)	Array[ScTypeElement]	usualOccurrences
clazz.fakeCompanionModule.toSeq.flatMap { obj => obj.membersWithSynthetic }	IndexedSeq[ScMember]	inFakeCompanion
selectedExpression(file, editor) match { case None => false case Some(expr) => occurrences.length == 1 && isBlockLike(expr.getParent) && !isLastInNonUnitBlock(expr) }	Boolean	fastDefinition
replaceOccurrences(occurrences, varName, file)	Seq[TextRange]	replacedOccurrences
currentPackage.getDirectories(scope) .intersect(dirContainingFile) .headOption .getOrElse(containingFile.getContainingDirectory)	PsiDirectory	resultDirectory
mutable.ArrayBuffer.empty[ScalaFile]	ArrayBuffer[ScalaFile]	buffer
replacedOccurrences.head	TextRange	firstRange
findParentExpr(file, firstRange)	ScExpression	firstElement
new Processor[PsiFile] { override def process(file: PsiFile): Boolean = { file match { case scalaFile: ScalaFile => buffer += scalaFile } true } }	Processor[PsiFile] { def process(file: PsiFile): Boolean }	processor
PsiSearchHelper.getInstance(typeElement.getProject)	PsiSearchHelper	helper
method match { case ScPrimaryConstructor.ofClass(clazz) if clazz.isCase => val inExistingClasses = (Seq(clazz) ++ clazz.baseCompanionModule).flatMap { _.syntheticMethods } val inFakeCompanion = clazz.fakeCompanionModule.toSeq.flatMap { obj => obj.membersWithSynthetic } inExistingClasses ++ inFakeCompanion case _ => Seq.empty }	Seq[ScMember]	synthetics
new AnActionButton("Remove parameter clause", null, Icons.REMOVE_CLAUSE) { override def actionPerformed(e: AnActionEvent): Unit = { val table = parametersTable val editedColumn = editingColumn(table) TableUtil.stopEditing(table) val selected = table.getSelectedRow if (selected > 0) { val item = myParametersTableModel.getItem(selected) item.startsNewClause = false myParametersTableModel.fireTableDataChanged() } finishAndRestoreEditing(editedColumn) } }	AnActionButton { def actionPerformed(e: AnActionEvent): Unit }	removeClauseButton
if (typeElementIdx == -1) { replaceTypeElements(Array(typeElement), typeName, typeAlias).apply(0) } else { usualOccurrences.apply(typeElementIdx) }	ScTypeElement	resultTypeElement
SmartPointerManager.getInstance(file.getProject)	SmartPointerManager	manager
named match { case cl: ScClass => createClassParamClausesWithContext(paramsText, cl) case _ => createParamClausesWithContext(paramsText, named, nameId) }	ScParameters	newClauses
ScalaPsiElementFactory.createTypeElementFromText(inName, typeElement.getContext, typeElement)	ScTypeElement	replacement
typeElement.calcType.codeText	String	typeName
0	Int	myDeclarationStartOffset
usage.paramClauses match { case Some(p) => p.replace(newClauses) case None => nameId.getParent.addAfter(newClauses, nameId) }	PsiElement	result
createExpressionFromText(exprText)	ScExpression	expr
usage.infix	ScInfixExpr	infix
occurrences.map(replaceHelper(_, name))	IndexedSeq[ScTypeElement]	replaced
ScalaNamedElementUsageInfo(named)	UsageInfo with ScalaNamedElementUsageInfo	usageInfo
argsText(change, usage)	String	tupleText
myEditor.getProject	Project	myProject
mutable.ArrayBuffer.empty[mutable.ArrayBuffer[ScalaFile]]	ArrayBuffer[ArrayBuffer[ScalaFile]]	resultBuffer
_	RangeHighlighter	selectionHighlighter
resultBuffer(0)	ArrayBuffer[ScalaFile]	intersectionResult
Seq(classOf[ScalaFile], classOf[ScBlock], classOf[ScTemplateBody], classOf[ScCaseClause], classOf[ScEarlyDefinitions])	Seq[(Class[_ >: ScEarlyDefinitions <: _$1]) forSome {type _$1 >: ScBlock <: _$1; type _$1 >: ScalaFile <: _$1; type _$1 >: ScCaseClause with ScTemplateBody <: ScalaPsiElement}]	classes
myEditor.getUserData(ScalaIntroduceVariableHandler.REVERT_INFO)	ScalaRefactoringUtil.RevertInfo	revertInfo
file.findElementAt(editor.getSelectionModel.getSelectionStart)	PsiElement	startElement
file.findElementAt(editor.getSelectionModel.getSelectionEnd - 1)	PsiElement	endElement
if (occurrences.length == 1) { firstElement match { case _ childOf ((block: ScBlock) childOf (_ childOf (call: ScMethodCall))) if forceType && block.statements.size == 1 => Seq(call) case _ childOf ((block: ScBlock) childOf (infix: ScInfixExpr)) if forceType && block.statements.size == 1 => Seq(infix) case expr => Seq(expr) } } else { replacedOccurrences.map(findParentExpr(file, _)) }	Seq[ScExpression]	parentExprs
PsiTreeUtil.findCommonParent(parentExprs: _*)	PsiElement	commonParent
PsiDocumentManager.getInstance(myEditor.getProject).getPsiFile(myEditor.getDocument)	PsiFile	myFile
nextParent(commonParent, file)	PsiElement	nextParentInFile
forStmt.enumerators.orNull	ScEnumerators	parent
createExpressionWithContextFromText(tupleText, infix, t)	ScExpression	newTuple
ScalaPsiUtil.nameContext(namedInfo.namedElement)	PsiElement	element
ScPackageImpl.findPackage(typeElement.getProject, inPackageName)	ScPackageImpl	inPackage
GlobalSearchScope.projectScope(typeElement.getProject)	GlobalSearchScope	projectSearchScope
new JBPopupAdapter { override def beforeShown(event: LightweightWindowEvent): Unit = { selection.addHighlighter() } override def onClosed(event: LightweightWindowEvent) { highlighter.dropHighlight() selection.removeHighlighter() } }	JBPopupAdapter { def onClosed(event: LightweightWindowEvent): Unit def beforeShown(event: LightweightWindowEvent): Unit }	highlightingListener
parent.prevSiblings.toList.exists(_.getNode.getElementType == ScalaTokenTypes.tLPARENTHESIS)	Boolean	inParentheses
s"$qualText.${operation.refName}${argsText(change, usage)}"	String	newCallText
if (needCreateDirectory) { inNewDirectoryName } else { "package" }	String	newDirectoryName
ScalaPsiElementFactory.createDefinitionWithContext(text, element.getContext, element)	ScMember	newElement
suggestedDirectory	PsiDirectory	currentDirectory
createExpressionWithContextFromText(newCallText, infix.getContext, infix)	ScExpression	methodCall
createDeclaration(pattern, "", isVariable = !isVal, expr)	ScValueOrVariable	declaration
ScalaPsiUtil.getElementsRange(startElement, endElement) match { case Seq(b: ScBlock) if !b.hasRBrace => b.children.toSeq case elems => elems }	Seq[PsiElement]	elements
elements.head.replace(declaration)	PsiElement	result
element	PsiElement	lastElem
ScalaPsiElementFactory.createDeclarationFromText(text, element.getContext, element)	ScDeclaration	newElement
arguments(change, usage).headOption match { case Some(Seq(text)) if text.trim.isEmpty => "()" case Some(Seq(text)) => text case _ => "()" }	String	argText
createExpressionWithContextFromText(argText, infix, argument)	ScExpression	expr
usage.constrInvocation	ScConstructorInvocation	constr
constr.typeElement	ScTypeElement	typeElem
changeInfo match { case sc: ScalaChangeInfo => sc.newParams case _ => return }	Seq[Seq[ScalaParameterInfo]]	newParams
inPackage.findPackageObject(projectSearchScope)	Option[ScObject]	maybePackageObject
createForBinding(varName, expression, typeTextIfNeeded(parent))	ScForBinding	created
if (needCreateDirectory) { currentDirectory.createSubdirectory(newDirectoryName) } else { currentDirectory }	PsiDirectory	newDir
ScalaDirectoryService.createClassFromTemplate(newDir, newDirectoryName, "Package Object", askToDefineVariables = false) .asInstanceOf[ScTypeDefinition]	ScTypeDefinition	packageObject
createConstructorFromText(text, constr.getContext, constr)	ScConstructorInvocation	newConstr
usage.refExpr	ScReferenceExpression	ref
newParams.scanLeft(0)(_ + _.size)	IndexedSeq[Int]	cumulSize
createExpressionWithContextFromText(text, ref.getContext, ref)	ScExpression	call
parent.getChildren.filter(_.getTextRange.contains(firstRange)).head	PsiElement	elem
usage.postfix	ScPostfixExpr	postfix
null	ScForBinding	result
true	Boolean	needSemicolon
elem.getPrevSibling	PsiElement	sibling
elements.flatMap(errors).distinct	IndexedSeq[String]	messages
if (ret.needNewDefinition) createDeclaration(ret.returnType, ret.paramName, !ret.isVal, extrText, isPresentableText = false) else createExpressionFromText(ret.paramName + " = " + extrText)	ScBlockStatement with Typeable	stmt
createEquivQualifiedReference(postfix)	ScReferenceExpression	qualRef
parent.addBefore(createSemicolon, elem)	PsiElement	semicolon
createExpressionWithContextFromText(text, postfix.getContext, postfix)	ScExpression	call
usage.call	ScMethodCall	call
createDeclaration(varName, typeTextIfNeeded(firstElement), isVariable, expression)	ScValueOrVariable	declaration
firstRange.getStartOffset	Int	start
createExpressionWithContextFromText(newText, call.getContext, call)	ScExpression	newCall
change match { case c: ScalaChangeInfo => c.isAddDefaultArgs case c: JavaChangeInfo => c.isGenerateDelegate case _ => true }	Boolean	isAddDefault
change.getMethod.getManager	PsiManager	manager
methodUsage.argsInfo	OldArgsInfo	oldArgsInfo
false	Boolean	needNamed
new ListBuffer[String]	ListBuffer[String]	buffer
clause.last	ParameterInfo	param
settings.outputs.forall(_.isVal)	Boolean	allVals
param.getOldIndex	Int	oldIndex
maybePackageObject.fold(containingDirectory: PsiElement) { packageObject => getChildOfType(getChildOfType(packageObject, classOf[ScExtendsBlock]), classOf[ScTemplateBody]) }	PsiElement	fileEncloser
mainScope match { case simpleScope: SimpleScopeItem => simpleScope.usualOccurrences.toSeq.map(_.getTextRange) case _: PackageScopeItem => Seq.empty[TextRange] }	Seq[TextRange]	occurrences
new ScalaIntroduceTypeAliasDialog(project, typeElement, possibleScopes, mainScope, this, editor)	ScalaIntroduceTypeAliasDialog	dialog
myParametersTableModel.getItem(selected + 1)	ScalaParameterTableModelItem	itemBelow
mutable.MutableList.empty[Array[ScTypeElement]]	mutable.MutableList[Array[ScTypeElement]]	allOccurrences
mutable.MutableList.empty[ScalaTypeValidator]	mutable.MutableList[ScalaTypeValidator]	allValidators
settings.outputs.forall(!_.isVal)	Boolean	allVars
outputTypedNames.mkString("(", ", ", ")")	String	patternArgsText
ScalaRefactoringUtil.getTypeElementOccurrences(typeElement, file)	Array[ScTypeElement]	occurrences
ScalaExtractMethodUtils.typedName(expr.getText, "_*")(expr.getProject)	String	typedText
OccurrenceData(typeElement, dialog.isReplaceAllOccurrences, dialog.isReplaceOccurrenceIncompanionObject, dialog.isReplaceOccurrenceInInheritors, dialog.getSelectedScope )	OccurrenceData	occurrences
new Key("RevertTypeAliasInfo")	Key[IntroduceTypeAliasData]	REVERT_TYPE_ALIAS_INFO
ics.className + patternArgsText	String	patternText
createExpressionFromText(mFreshName)	ScExpression	expr
createDeclaration(patternText, "", isVariable = allVars, expr)	ScValueOrVariable	stmt
false	Boolean	needFormatting
getFilesToSearchIn(containingDirectory)	Array[ScalaFile]	collectedFiles
change match { case sc: ScalaChangeInfo => sc.newParams.filter(_.nonEmpty) case _ => Seq(change.getNewParameters.toSeq) }	Seq[Seq[ParameterInfo]]	clauses
arguments(change, methodUsage)	Seq[Seq[String]]	args
newParam.getOldIndex	Int	oldIdx
!commonParent.isInstanceOf[ScBlock] && ScalaRefactoringUtil.needBraces(commonParent, nextParentInFile)	Boolean	needBraces
inPackage.getDirectories.isEmpty	Boolean	needNewDir
inPackage.getClasses	Array[PsiClass]	classes
s"$mFreshName.${ret.paramName}"	String	exprText
commonParent.replace(createExpressionFromText("{" + commonParent.getText + "}"))	PsiElement	replaced
s"$mFreshName._$count"	String	exprText
if (named) s"${newParam.getName} = $withoutName" else withoutName	String	argText
elements.dropWhile(!_.isValid)	Seq[PsiElement]	valid
elem	ProjectContext	ctx
insertCallStmt()	PsiElement	stmt
commonParent match { case inExtendsBlock(extBl) => needFormatting = true extBl.addEarlyDefinitions() case _ => val needBraces = !commonParent.isInstanceOf[ScBlock] && ScalaRefactoringUtil.needBraces(commonParent, nextParentInFile) if (needBraces) { firstRange = firstRange.shiftRight(1) val replaced = commonParent.replace(createExpressionFromText("{" + commonParent.getText + "}")) replaced.getPrevSibling match { case ws: PsiWhiteSpace if ws.getText.contains("\n") => ws.delete() case _ => } replaced } else { container(commonParent).getOrElse(file) } }	PsiElement	parent
ScalaRefactoringUtil.getTypeElementOccurrences(typeElement, clazz)	Array[ScTypeElement]	occurrences
exprs.take(numberOfParamsToAdd(idx))	Array[PsiExpression]	exprsToAdd
parent.getChildren.find(_.getTextRange.contains(firstRange)).getOrElse(parent.getLastChild)	PsiElement	anchor
createIdentifier(newName).getPsi	PsiElement	newId
JavaPsiFacade.getInstance(jRef.getProject).getElementFactory	PsiElementFactory	factory
factory.createIdentifier(newName)	PsiIdentifier	newNameIdentifier
change.getMethod.getProject	Project	project
createDeclaration(varName, typeTextIfNeeded(anchor), isVariable, expression)	ScValueOrVariable	created
change.getMethod	PsiElement	method
JavaPsiFacade.getElementFactory(call.getProject).createExpressionFromText(text, defaultArg.getContext)	PsiExpression	newDefaultArg
UsageUtil.substitutor(usage)(sInfo.scType).canonicalCodeText	String	text
findDeclaration(namedElement)	Option[PsiElement]	newDeclaration
None	Option[DocumentListener]	myCheckIdentifierListener
refUsages.get()	Array[UsageInfo]	usages
namedElement.getContainingFile	PsiFile	myFile
new MultiMap[PsiElement, String]()	MultiMap[PsiElement, String]	result
if (sInfo.isByName) ScalaPsiUtil.functionArrow + " " else ""	String	`=> `
ScalaPsiUtil.addStatementBefore(created.asInstanceOf[ScBlockStatement], parent, Some(anchor))	ScBlockStatement	result
isIntroduceForBinding(commonParent, nextParentInFile, firstRange) match { case Some(forStmt) => createForBindingIn(forStmt) case _ => createVariableDefinition() }	PsiElement	createdDeclaration
ref.getElement	PsiElement	refElem
true	Boolean	nameIsValid
newDeclaration.exists(_.isInstanceOf[ScForBinding])	Boolean	isForBinding
jInfo.createType(method, method.getManager)	PsiType	javaType
myParametersTableModel.getItem(selected - 1)	ScalaParameterTableModelItem	itemAbove
ScalaNamesUtil.scalaName(namedElement)	String	initialName
{ ref: PsiReference => val refElem = ref.getElement refElem match { case isAnonFunUsage(anonFunUsageInfo) => results += anonFunUsageInfo case (scRef: ScReference) childOf(_: ScImportSelector | _: ScImportExpr) => results += ImportUsageInfo(scRef) case (refExpr: ScReferenceExpression) childOf (mc: ScMethodCall) => results += MethodCallUsageInfo(refExpr, fullCall(mc)) case ChildOf(infix @ ScInfixExpr(_, `refElem`, _)) => results += InfixExprUsageInfo(infix) case ChildOf(postfix @ ScPostfixExpr(_, `refElem`)) => results += PostfixExprUsageInfo(postfix) case ref @ ScConstructorInvocation.byReference(constr) => results += ConstructorUsageInfo(ref, constr) case refExpr: ScReferenceExpression => results += RefExpressionUsage(refExpr) case ChildOf(cp: ScConstructorPattern) if cp.ref == refElem => results += ConstructorPatternUsageInfo(cp) case ChildOf(ip: ScInfixPattern) if ip.operation == refElem => results += InfixPatternUsageInfo(ip) case ref: PsiReferenceExpression if searchInJava => results += new JavaCallUsageInfo(ref, true, false) case _ => } true }	PsiReference => Boolean	process
_	EditorTextField	paramNameField
param.getUseScope	SearchScope	scope
UsageUtil.substitutor(usage)(javaType.toScType())	ScType	scType
(ref: PsiReference) => { ref.getElement match { case refElem: ScReference => results += ParameterUsageInfo(oldIndex, newName, refElem) case refElem: PsiReferenceExpression => results += new ChangeSignatureParameterUsageInfo(refElem, param.name, newName) case _ => } true }	PsiReference => Boolean	process
paramInfo.getOldIndex	Int	oldIdx
p.getOldIndex	Int	oldIdx
_	ComboBox[String]	typeCombobox
usage.parameters(oldIdx).name	String	oldNameOfCurrent
_	DefaultValuesUsagePanel	defaultValuesUsagePanel
_	EditorTextField	defaultForIntroducedTextField
needsTypeAnnotation(namedElement, expr, forceInferType)	Boolean	needTypeDefault
new TextRange(myCaretRangeMarker.getStartOffset, myCaretRangeMarker.getEndOffset)	TextRange	range
element match { case statement: ScFor if statement.body.contains(parent) => None case statement: ScFor => Some(statement) case _: ScForBinding | _: ScGenerator => Option(element.getParent.getParent) case guard: ScGuard if guard.getParent.isInstanceOf[ScEnumerators] => Option(element.getParent.getParent) case _ => Some(parent) }	Option[PsiElement]	maybeParent
editor.getSelectionModel	SelectionModel	model
allOccurrences.foldLeft(Array[ScTypeElement]())((a, b) => a ++ b)	Array[ScTypeElement]	occurrences
findDeclarationAt(range.getStartOffset + numberOfSpaces)	Option[PsiElement]	maybeDeclaration
namedElement(maybeDeclaration)	Option[ScNamedElement]	named
mutable.WeakHashMap[RangeHighlighter, Boolean]()	mutable.WeakHashMap[RangeHighlighter, Boolean]	greedyToRight
myEditor.getMarkupModel.getAllHighlighters	Array[RangeHighlighter]	highlighters
ScalaCompositeTypeValidator(allValidators.toList, conflictsReporter, project, typeElement, occurrences.isEmpty, containingDirectory, containingDirectory)	ScalaCompositeTypeValidator	validator
validator.validateName(inputName)	String	possibleName
ScalaExtractMethodUtils.typedName(newParamName(p), paramType(p))	String	typedName
namedElement(getDeclaration)	Option[ScNamedElement]	named
named.get.getNameIdentifier.getTextRange	TextRange	nameRange
p match { case spi: ScalaParameterInfo => spi.keywordsAndAnnotations case _ => "" }	String	keywordsAndAnnots
PackageScopeItem(inPackage.getName, fileEncloser, needNewDir, ju.Collections.singleton(possibleName))	PackageScopeItem	result
Array[ScTypeElement]()	Array[ScTypeElement]	occurrencesFromInheritors
usualOccurrences.map((x: ScTypeElement) => (x.getTextRange, x.getContainingFile))	Array[(TextRange, PsiFile)]	usualOccurrencesRanges
declaration.copy.asInstanceOf[ScalaPsiElement]	ScalaPsiElement	declarationCopy
(fileEncloser.getTextRange, fileEncloser.getContainingFile)	(TextRange, PsiFile)	fileEncloserRange
TypeAnnotationUtil.createTypeAnnotationsHLink(project, ScalaBundle.message("default.ta.settings"))	HyperlinkLabel	link
ScalaChangeInfo(getVisibility, method.fun, getMethodName, returnType, parameters, isAddDefaultArgs, None)	ScalaChangeInfo	changeInfo
getRowItem(row)	ScalaParameterTableModelItem	item
createDeclaration(selectedType, "x", isVariable = false, "", isPresentableText = false)	ScValueOrVariable	fakeDeclaration
nameText(item)	String	name
typeText(item)	String	typeTxt
fakeDeclaration.findFirstChildByType(ScalaTokenTypes.tCOLON)	PsiElement	first
fakeDeclaration.findFirstChildByType(ScalaTokenTypes.tASSIGN)	PsiElement	last
declarationCopy.findFirstChildByType(ScalaTokenTypes.tASSIGN)	PsiElement	assign
usualOccurrencesRanges.map { case (range, containingFile) => PsiTreeUtil.findElementOfClassAtRange(containingFile, range.getStartOffset, range.getEndOffset, classOf[ScTypeElement]) }	IndexedSeq[Nothing]	revalidatedOccurrences
if (name == "" && typeTxt == "") "" else ScalaExtractMethodUtils.typedName(name, typeTxt)	String	nameAndType
declaration.replace(declarationCopy)	PsiElement	replaced
availableNames.asScala.toSet ++ (newName match { case "" => Set.empty case n if availableNames.contains(n) => Set.empty case n => Set(n) })	Set[String]	newNames
defaultText(item)	String	defText
s"$nameAndType $defText"	String	text
holder.findFirstChildByType(ScalaTokenTypes.tCOLON)	PsiElement	colon
new ScalaTypeValidator(typeValidator.selectedElement, typeValidator.noOccurrences, updatedFileEncloser, updatedFileEncloser)	ScalaTypeValidator	updatedValidator
Array[ScTypeElement]()	Array[ScTypeElement]	occurrences
_	ScalaCompositeTypeValidator	validator
holder.findFirstChildByType(ScalaTokenTypes.tASSIGN)	PsiElement	assign
myFile.getManager	PsiManager	manager
createExpressionFromText("1 + 1").findElementAt(1)	PsiElement	whiteSpace
holder.addBefore(whiteSpace, assign)	PsiElement	newWhiteSpace
data.methodToSearchFor.getContainingFile	PsiFile	file
introduceData.copy(paramName = paramNameField.getText, tp = typeMap.get(typeCombobox.getSelectedItem), replaceAll = replaceOccurrencesChb.isSelected, defaultArg = defaultForIntroducedTextField.getText)	ScalaIntroduceParameterData	newData
forBinding.pattern.findFirstChildByType(ScalaTokenTypes.tCOLON)	PsiElement	colon
paramNameField.getText	String	newText
PsiDocumentManager.getInstance(data.getProject).getDocument(file)	Document	doc
myExprMarker.getStartOffset	Int	startOffset
if (data.replaceAll) data.occurrences else Seq(data.mainOcc)	Seq[TextRange]	occurrences
method.getMethod	TypePresentationContext	context
myFile.findElementAt(startOffset)	PsiElement	elementAt
new LocalSearchScope(myElementToRename.getContainingFile)	LocalSearchScope	scope
scope.getScope	Array[PsiElement]	elements
ScalaAddImportAction.getImportHolder(commonParent, project)	ScImportsHolder	importsHolder
namedElement(getDeclaration).orNull	ScNamedElement	named
TemplateManagerImpl.getTemplateState(myEditor)	TemplateState	templateState
new OffsetsArray(offsets, startIndex)	AssociationsData.OffsetsArray	array
Key.create[Associations]("ASSOCIATIONS")	Key[Associations]	key
mutable.ArrayBuffer.empty[Association]	ArrayBuffer[Association]	buffer
null	Associations	result
new ThreadLocal[ScalaLexer] { override def initialValue(): ScalaLexer = new ScalaLexer }	{ def initialValue(): ScalaLexer }	lexerCache
KEYWORDS.getTypes .map(_.toString) .toSet	Set[String]	keywordNames
usages.collect {case t: TextRangeUsageInfo => t}	IndexedSeq[TextRangeUsageInfo]	textRangeUsages
data.paramName	String	pName
data.functionalArgParams.getOrElse("")	String	args
s"$pName$args"	String	text
ranges.zipWithIndex.map { case (range, index) => new Attachment(s"Selection-${index + 1}.scala", subText(range)) }	IndexedSeq[Attachment]	attachments
textRangeUsages.head.file	PsiFile	file
Array( new ScalaExpressionSurroundDescriptor(), new ScalaDocCommentDataSurroundDescriptor(), new ScalaIgnoreErrorHighlightingSurroundDescriptor() )	Array[SurroundDescriptor]	SURROUND_DESCRIPTORS
PsiDocumentManager.getInstance(file.getProject)	PsiDocumentManager	manager
false	Boolean	processed
3000L	Long	Timeout
parameterItems.map(_.parameter.getName.length) match { case Seq() => 0 case seq => seq.max }	Int	maxLength
item.parameter.getName	String	name
file.findElementAt(startOffset)	PsiElement	startElement
(for (i <- 0 until templateState.getSegmentsCount) yield templateState.getSegmentRange(i)).toArray	Array[TextRange]	occurrences
file.findElementAt(endOffset - 1)	PsiElement	endElement
ScalaVariableValidator(myFile, named, occurrences)	ScalaVariableValidator	validator
new ValidationReporter(myProject, new BalloonConflictsReporter(myEditor), validator)	ValidationReporter	reporter
parameterItems.map(_.typeText.length) match { case Seq() => 0 case seq => seq.max }	Int	maxLength
ScalaPsiUtil.getElementsRange(startElement, endElement)	Seq[PsiElement]	range
item.typeText	String	typeText
range.shiftRight(offset)	TextRange	shiftedRange
item.defaultValueCodeFragment.getText	String	defaultValue
v.element	PsiNamedElement	elem
Array[Surrounder](new ScalaDocWithBoldSurrounder, new ScalaDocWithUnderlinedSurrounder, new ScalaDocWithMonospaceSurrounder, new ScalaDocWithItalicSurrounder, new ScalaDocWithSubscriptSurrounder, new ScalaDocWithSuperscriptSurrounder)	Array[Surrounder]	surrounders
editor.getSelectionModel.getSelectionStart	Int	startOffset
editor.getSelectionModel.getSelectionEnd	Int	endOffset
Set(DOC_COMMENT_DATA, DOC_WHITESPACE)	Set[IElementType]	validBoundElements
elements(0)	PsiElement	element
element.getTextOffset	Int	offset
new StringBuilder()	StringBuilder	surroundedText
if (checkBoundElement(startElement)) { //cannot extract function because of return false } else { if (checkSyntaxBoundElement(startElement, true)) true else return PsiElement.EMPTY_ARRAY }	Boolean	isFirstElementMarked
if (checkBoundElement(endElement)) { false } else { if (checkSyntaxBoundElement(endElement, false)) true else return PsiElement.EMPTY_ARRAY }	Boolean	isLastElementMarked
if (isLastElementMarked) { if (endElement.getTextOffset >= startOffset) (endElement.getParent) else return PsiElement.EMPTY_ARRAY } else { endElement }	PsiElement	lastBoundElement
false	Boolean	hasAsterisk
nodeWithIfNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
element.asInstanceOf[ScIfImpl]	ScIfImpl	stmt
elements(0).asInstanceOf[ScExpression]	ScExpression	expression
(stmt.condition: @unchecked) match { case Some(c) => c.getNode }	ASTNode	conditionNode
conditionNode.getStartOffset	Int	offset
withForNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
element.asInstanceOf[ScFor]	ScFor	forStmt
elements match { case Array(_: ScDo | _: ScIf | _: ScTry | _: ScFor | _: ScWhile | _: ScThrow | _: ScReturn) => true case Array(_) => false case _ => true }	Boolean	needParenthesis
findTargetRangeFor(source, predicate).getOrElse { if (canUseLineAsTarget) nextLineRangeFor(source) else null }	LineRange	targetRange
Array[Surrounder]( new ScalaWithIfSurrounder, new ScalaWithIfElseSurrounder, new ScalaWithWhileSurrounder, new ScalaWithDoWhileSurrounder, new ScalaWithForSurrounder, new ScalaWithForYieldSurrounder, ScalaWithTryCatchSurrounder, new ScalaWithTryFinallySurrounder, new ScalaWithTryCatchFinallySurrounder, new ScalaWithBracesSurrounder, ScalaWithMatchSurrounder, new ScalaWithParenthesisSurrounder, ScalaWithIfConditionSurrounder, new ScalaWithIfElseConditionSurrounder, new ScalaWithUnaryNotSurrounder, new ScalaTypeSurrounder, )	Array[Surrounder]	Surrounders
(forStmt.enumerators: @unchecked) match { case Some(x) => x.getNode }	ASTNode	enums
enums.getTextRange.getStartOffset	Int	offset
expression.`type`().getOrAny	ScType	result
withWhileNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
withType.getPsi.asInstanceOf[ScExpression]	ScExpression	expr
expr.getTextRange.getEndOffset	Int	offset
element.asInstanceOf[ScWhileImpl]	ScWhileImpl	whileStmt
{ val expr: ScExpression = withType.getPsi.asInstanceOf[ScExpression] val offset = expr.getTextRange.getEndOffset new TextRange(offset, offset) }	TextRange	defaultRange
file.findElementAt(startOffset)	PsiElement	element
element.getParent.getTextRange	TextRange	textRange
if(down) source.nextSiblings else source.prevSiblings	Iterator[PsiElement]	siblings
(whileStmt.condition: @unchecked) match { case Some(c) => c.getNode }	ASTNode	conditionNode
conditionNode.getTextRange.getStartOffset	Int	startOffset
conditionNode.getTextRange.getEndOffset	Int	endOffset
createDocSimpleData(getNewExprText(surroundedText.toString()))(element.getManager)	PsiElement	newExpr
rangeOf(source, editor)	LineRange	range
editor.offsetToLogicalPosition(editor.getDocument.getTextLength).line	Int	maxLine
surroundPsi(elements).getNode	ASTNode	result
null	ASTNode	childNode
super.getTemplateAsString(elements).parenthesize(needParenthesis)	String	prefix
elements.headOption.map(_.getProject).orNull	Project	project
childNode == null	Boolean	flag
withMatchNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
withDoWhileNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
element.getNode.getLastChildNode.getTreePrev.getTreePrev.getFirstChildNode.getFirstChildNode.getTreeNext.getTreeNext	ASTNode	patternNode
element.asInstanceOf[ScDo]	ScDo	doWhileStmt
patternNode.getTextRange.getStartOffset	Int	offset
doWhileStmt.getNode.getLastChildNode.getTreePrev	ASTNode	conditionNode
withUnaryNot.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x: ScExpression => x }	ScExpression	expression
expression.getTextRange.getEndOffset	Int	offset
elem match { case fun: ScFunction => fun.`type`().getOrAny.canonicalCodeText case _ => v.element.ofNamedElement().getOrElse(Any).canonicalCodeText }	String	typeText
withTryCatchNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
element.asInstanceOf[ScTry]	ScTry	tryCatchStmt
if (elements.length == 0) "=>" else ScalaPsiUtil.functionArrow(elements(0).getProject)	String	arrow
elements.head	PsiElement	element
tryCatchStmt.getNode.getLastChildNode.getLastChildNode.getPsi	PsiElement	caseClause
tryCatchStmt.catchBlock.get	ScCatchBlock	catchBlockPsiElement
caseClause.getTextRange.getStartOffset	Int	offset
withIfNode.getPsi match { case x: ScParenthesisedExpr => x.innerElement match { case Some(y) => y case _ => return x.getTextRange } case x => x }	PsiElement	element
element.asInstanceOf[ScIf]	ScIf	ifStmt
(ifStmt.thenExpression: @unchecked) match { case Some(x) => x }	ScExpression	body
input.map { v => val elem = v.element val typeText = elem match { case fun: ScFunction => fun.`type`().getOrAny.canonicalCodeText case _ => v.element.ofNamedElement().getOrElse(Any).canonicalCodeText } s"${elem.name}: $typeText" }	IndexedSeq[String]	namesAndTypes
body.getTextRange.getStartOffset + 1	Int	offset
getTemplateAsString(elements) .parenthesize(needParenthesis = elements.length == 1 && this.needParenthesis(element))	String	text
element.projectContext	ProjectContext	context
catchBlockPsiElement.expression.get.asInstanceOf[ScBlockExpr].caseClauses.get.caseClauses.head.pattern.get	ScPattern	caseClause
ScalaPsiUtil.functionArrow(project)	String	arrow
namesAndTypes.mkString("(", ", ", ")")	String	paramsText
ExtensionPointName.create("org.intellij.scala.parameterInfoEnhancer")	ExtensionPointName[ScalaParameterInfoEnhancer]	EP_NAME
elements(0).getTextRange.getStartOffset	Int	start
1	Int	NormalStatusId
2	Int	IgnoredStatusId
3	Int	PendingStatusId
elements(elements.length - 1).getTextRange.getEndOffset	Int	end
elems.map(_.getText).mkString	String	bodyText
elems match { case Seq(single: ScExpression) => val bodyText = single.getText s"$paramsText $arrow $bodyText" case _ => val bodyText = elems.map(_.getText).mkString s"$paramsText $arrow {\n$bodyText\n}" }	String	funText
args	ProjectContext	ctx
context.getCurrentParameterIndex	Int	index
ScalaPsiElementFactory.createExpressionWithContextFromText(funText, elems.head.getContext, elems.head).asInstanceOf[ScFunctionExpr]	ScFunctionExpr	expr
owner.typeParameters	Seq[ScTypeParam]	params
method.getTypeParameters	Array[PsiTypeParameter]	params
aim(classOf[ScCaseClause], _.isInstanceOf[ScCaseClause], canUseLineAsTarget = false) .orElse(aim(classOf[ScMember], it => it.isInstanceOf[ScMember] || it.isInstanceOf[ScImportStmt])) .orElse(aim(classOf[ScIf], _ => false)) .orElse(aim(classOf[ScFor], _ => false)) .orElse(aim(classOf[ScMatch], _ => false)) .orElse(aim(classOf[ScTry], _ => false)) .orElse(aim(classOf[ScMethodCall], isControlStructureLikeCall).filter(p => isControlStructureLikeCall(p._1)))	Option[(PsiElement, LineRange)]	pair
td.typeParameters	Seq[ScTypeParam]	params
editor.offsetToLogicalPosition(e.getTextRange.getStartOffset).line	Int	begin
clazz.getTypeParameters	Array[PsiTypeParameter]	params
editor.offsetToLogicalPosition(e.getTextRange.getEndOffset).line + 1	Int	end
new HashSet[Class[_]]()	HashSet[Class[_]]	set
buffer.indexOf("<g>")	Int	isGrey
buffer.indexOf("<b>")	Int	startOffset
ConvertParameterToUnderscoreIntention.createExpressionToIntroduce(expr, withoutParameterTypes = true) match { case Left(e) => e case _ => expr }	ScExpression	toReturn
buffer.indexOf("</b>")	Int	endOffset
if (params.indexOf(param) == index) true else { //todo: check type false }	Boolean	isBold
edgeLeafsOf(line, editor, file)	(Option[PsiElement], Option[PsiElement])	edges
ScalaElementPresentation.getMethodPresentableText(function)	String	presentation
definition.typeParametersClause.map(_.typeParameters.map(_.name).mkString("[", ", ", "]"))	Option[String]	typeParameters
context.getOffset	Int	offset
value.flatMap(_.typeElement.map(_.getText))	Option[Nothing]	typeAnnotation
o.getNode.getFirstChildNode	ASTNode	child
args.projectContext	ProjectContext	project
variable.flatMap(_.typeElement.map(_.getText))	Option[Nothing]	typeAnnotation
false	Boolean	isGrey
if (function.isConstructor) None else function.returnTypeElement match { case Some(_) => None case None => if (showType) function.returnType.toOption.map(ScTypePresentation.withoutAliases) else None }	Option[String]	inferredType
sign.method.name	String	methodName
sign.substitutor	ScSubstitutor	subst
o.asInstanceOf[Element]	Element	that
a.seq	Seq[(String, ScType, PsiAnnotationMemberValue)]	seq
param.getExtendsList.getReferencedTypes	Array[PsiClassType]	refTypes
StringBuilder.newBuilder ++= param.name	mutable.StringBuilder	paramText
definition.asOptionOf[ScClass].flatMap { _.constructor.map(it => StructureViewUtil.getParametersAsString(it.parameterList)) }	Option[String]	valueParameters
Option(definition.nameId).map(_.getText)	Option[Nothing]	name
subst(param.`type`().getOrNothing)	ScType	typez
sign.method match { case function: ScFunction => subst(function.returnType.getOrAny) case method: PsiMethod => subst(method.getReturnType.toScType()) }	ScType	returnType
collectData(exprWithTypes, elems, methodLike, editor)	Option[ScalaIntroduceParameterData]	data
new Array[Sorter](2)	Array[Sorter]	res
if (useActualElement) r.getActualElement else m	PsiNamedElement	element
createDialog(data)	ScalaIntroduceParameterDialog	dialog
PsiTreeUtil.getParentOfType(element, getArgumentListClass)	ScTypeArgs	args
subst(function.returnType.getOrAny)	ScType	typez
writableScalaFile(file, REFACTORING_NAME)	ScalaFile	scalaFile
document.getLineStartOffset(line)	Int	start
Seq( "\\bvoid\\b".r -> "Unit", "(\\w+)\\[\\]".r -> "Array[$1]", "\\.\\.\\.".r -> "*", "\\<".r -> "[", "\\>".r -> "]", "\\?".r -> "_", "\\bextends\\b".r -> "<:", "\\bsuper\\b".r -> ">:")	Seq[Nothing]	Transformations
start.max(document.getLineEndOffset(line) - 1)	Int	end
typeElement match { case projection: ScTypeProjection => Some(projection) case ScSimpleTypeElement(reference) => Some(reference) case _ => None }	Option[ScReference]	maybeReferenceElement
getExpressionWithTypes(scalaFile)	Option[(ScExpression, Array[ScType])]	exprWithTypes
start.to(end)	Range.Inclusive	span
exprWithTypes match { case Some((e, _)) => Seq(e) case None => selectedElements(editor, scalaFile, trimComments = false) }	Seq[PsiElement]	elems
methodLike.getProject	Project	project
ReachingDefinitionsCollector.collectVariableInfo(elems, methodLike)	FragmentVariableInfos	info
args.getParent match { case ScGenericCall(expr, _) => fromResolved(expr) case ScInfixExpr(_, ref, _) => fromResolved(ref) case ScParameterizedTypeElement(typeElement, _) => val maybeReferenceElement = typeElement match { case projection: ScTypeProjection => Some(projection) case ScSimpleTypeElement(reference) => Some(reference) case _ => None } maybeReferenceElement.flatMap(fromResolved(_, useActualElement = true)) case _ => None // todo: ScMacroDefinition }	Option[(PsiElement, ScSubstitutor)]	res
element	PsiElement	el
1	Int	index
definition.extendsBlock.templateBody.toSeq .flatMap(_.getChildren) .filterBy[ScBlockExpr]	IndexedSeq[ScBlockExpr]	blocks
input.map(_.element.name).mkString("(", ", ", ")")	String	argClauseText
ScPattern.unapplySubpatternTypes(returnType, args, sign.method.asInstanceOf[ScFunction]).zipWithIndex	IndexedSeq[(ScType, Int)]	params
StringBuilder.newBuilder	mutable.StringBuilder	sb
if (i == index || (isSeq && i <= index)) true else { //todo: check type false }	Boolean	isBold
paramTextFor(sign, i, paramTypeText)	String	paramText
Option(fun.containingClass) match { case Some(x: ScObject) => ScalaPsiUtil.getCompanionModule(x) match { case Some(x: ScClass) => Some(x) case _ => None } case _ => None }	Option[ScClass]	companionClass
funType match { case FunctionType(retType, _) => Array(funType, retType, Any) case _ => Array(funType, Any) }	Array[ScType]	allTypes
ScalaPsiUtil.getApplyMethods(fun.containingClass) match { case Seq(sig) => sig.method.parameters.lift(o) case _ => None }	Option[PsiParameter]	applyParam
file.projectContext	ProjectContext	project
PsiTreeUtil.getParentOfType(element, getArgumentListClass)	ScPatternArgumentList	args
constr.ref	ScStableCodeReference	ref
methodLike.findDeepestSuperMethod() match { case null => methodLike case _: ScMethodLike => SuperMethodWarningUtil.checkSuperMethod(methodLike, RefactoringBundle.message("to.refactor")) case _ => methodLike }	PsiMethod	superMethod
superMethod match { case m: ScMethodLike => m case _ => return None }	ScMethodLike	methodToSearchFor
new ScalaVariableValidator(elems.head, false, methodLike, methodLike)	ScalaVariableValidator	validator
new ArrayBuffer[Object]	ArrayBuffer[Any]	res
ref.multiResolveScala(false)	Array[ScalaResolveResult]	variants
r.breadthFirst().filter(_.isInstanceOf[ScAssignment]).toVector	Vector[PsiElement]	assignments
b match { case block: ScBlockExpr => code"$a.$o {${block.exprs}}" case _ => code"$a.$o($b)" }	ScalaPsiElement	element
definition.membersWithSynthetic.flatMap { case constructor: ScPrimaryConstructor => definition match { case c: ScClass if c.isCase => constructor.effectiveFirstParameterSection case _ => constructor.valueParameters } case element @ (_: ScFunction | _: ScVariable | _: ScValue | _: ScTypeAlias) if !element.isSynthetic => Seq(element) case _ => Seq.empty }	IndexedSeq[ScMember]	members
definition.typeDefinitions	Seq[ScTypeDefinition]	definitions
e.matchedParameters.filter(_._2.isRepeated).map(_._1).sortBy(_.getStartOffsetInParent)	IndexedSeq[ScExpression]	as2
as.take(as.length - as2.length)	Seq[ScExpression]	as1
elems match { case Seq(expr: ScExpression) => NameSuggester.suggestNames(expr, validator, types) case _ => NameSuggester.suggestNamesByType(types(0)) }	Seq[String]	possibleNames
{ val validator: ScalaVariableValidator = new ScalaVariableValidator(elems.head, false, methodLike, methodLike) val possibleNames = elems match { case Seq(expr: ScExpression) => NameSuggester.suggestNames(expr, validator, types) case _ => NameSuggester.suggestNamesByType(types(0)) } possibleNames.head }	String	suggestedName
methodLike match { case ScFunctionDefinition.withBody(body) => body case pc: ScPrimaryConstructor => pc.containingClass.extendsBlock case _ => methodLike }	ScalaPsiElement	occurrencesScope
getOccurrenceRanges(expr, occurrencesScope)	Seq[TextRange]	occurrences
if (as1.isEmpty) code"f(Array(${@@(as2)}): _*)" else code"f(${@@(as1)}, Array(${@@(as2)}): _*)"	ScalaPsiElement	call
ScSubstitutor.bind(typeParameters)(UndefinedType(_))	ScSubstitutor	undefSubst
l match { case ScParenthesisedTypeElement(element) => Seq(element) case ScTupleTypeElement(elements @ _*) => elements case element => Seq(element) }	Seq[ScTypeElement]	elements
addInitialTextDelimiter(addTextDelimiters(extractSpecifiersIn(parts)))	Seq[StringPart]	normalizedParts
ScalaIntroduceParameterData(methodLike, methodToSearchFor, elems, suggestedName, types, types(0), occurrences, mainOcc, replaceAll = false, argText, Some(argClauseText))	ScalaIntroduceParameterData	data
new ArrayBuffer[ScMethodLike]	ArrayBuffer[ScMethodLike]	enclosingMethods
normalizedParts.collect { case Text(s) => s }	IndexedSeq[String]	strings
expr	PsiElement	elem
normalizedParts.collect { case Injection(expr, _) => expr }	IndexedSeq[ScExpression]	arguments
clause.parameters .map(p => p.typeElement.filter(const(typed)).map(t => p.name + ": " + t.getText).getOrElse(p.name))	IndexedSeq[String]	list
seq.zipWithIndex.map { case ((name, tp, value), paramIndex) => val valueText = Option(value).map(_.getText) .map(" = " + _) .getOrElse("") (new Parameter(name, None, tp, tp, value != null, false, false, paramIndex), s"$name: ${tp.presentableText}$valueText") }	Seq[(Parameter, String)]	paramsSeq
clauses.map(formatParameters)	IndexedSeq[String]	parameters
for { Typeable(parameterType) <- fun.parameters.headOption substituted = undefSubst(parameterType) expectedType <- constr.expectedType substitutor <- substituted.conformanceSubstitutor(expectedType) } yield substitutor	Option[ScSubstitutor]	maybeSubstitutor
e.parents.toStream.takeWhile(e => e.isInstanceOf[ScExpression] || e.isInstanceOf[ScArgumentExprList]).last	PsiElement	enclosure
clauses.map(formatArguments)	IndexedSeq[String]	arguments
method.effectiveParameterClauses	Seq[ScParameterClause]	clauses
if (typeParameters.isEmpty) substitutor else { val undefSubst = ScSubstitutor.bind(typeParameters)(UndefinedType(_)) val maybeSubstitutor = for { Typeable(parameterType) <- fun.parameters.headOption substituted = undefSubst(parameterType) expectedType <- constr.expectedType substitutor <- substituted.conformanceSubstitutor(expectedType) } yield substitutor maybeSubstitutor.fold(substitutor) { _.followed(substitutor) } }	ScSubstitutor	subst
if (arguments.nonEmpty) parameters.mkString(" => ") else "()"	String	declarations
enclosingMethods.filter { case f: ScFunctionDefinition if f.superMethods.exists(isLibraryInterfaceMethod) => false case _ => true }	ArrayBuffer[ScMethodLike]	methodsNotImplementingLibraryInterfaces
if (i >= 0) clauses(i) else clauses.head	ScParameterClause	clause
new ScalaParameterInfo(data.paramName, -1, data.tp, project, false, false, data.defaultArg, isIntroducedParameter = true)	ScalaParameterInfo	paramInfo
if (arguments.nonEmpty) Some(arguments.mkString) else None	Option[String]	applications
clause.effectiveParameters.length	Int	length
if (i == -1) Seq.empty else clauses.take(i)	Seq[ScParameterClause]	preceedingClauses
if (i == -1) Seq.empty else clauses.drop(i + 1)	Seq[ScParameterClause]	remainingClauses
preceedingClauses.nonEmpty || remainingClauses.nonEmpty	Boolean	multipleLists
createMethodDescriptor(data.methodToSearchFor, paramInfo)	ScalaMethodDescriptor	descriptor
ps.filter(isApplicable).map(targetFor)	IndexedSeq[String]	targets
if (i != -1) clause.effectiveParameters else clause.effectiveParameters.take(length - 1)	Seq[ScParameter]	parameters
super.parametersInner	Seq[Seq[ScalaParameterInfo]]	params
e.isInstanceOf[ScInfixExpr] || e.isInstanceOf[ScPostfixExpr]	Boolean	enclose
parametersOf(clause)	Seq[(Parameter, String)]	parameters
createReferenceExpressionFromText(paths.takeRight(2).mkString("."))(e.getManager)	ScReferenceExpression	reference
e.getParent	PsiElement	context
seq.dropRight(1) :+ paramInfo :+ seq.last	IndexedSeq[ScalaParameterInfo]	newFirstClause
seq :+ paramInfo	IndexedSeq[ScalaParameterInfo]	newFirstClause
targets.map(simpleNameOf).mkString(", ")	String	arguments
getEnclosingMethods(element)	Seq[ScMethodLike]	validEnclosingMethods
createPatternFromText(e.getText + ": " + annotation.getText)	ScPattern	typedPattern
method.params	Array[Parameter]	params
placeholders.length	Int	count
if (params.indexOf(param) == index || (param.isRepeated && params.indexOf(param) <= index)) true else { //todo: check type false }	Boolean	isBold
count == 1	Boolean	singleParameter
method.getParameterList	PsiParameterList	p
v.name match { case "Char" => "Character" case "Int" => "Integer" case name => name }	String	postfix
name(placeholders)	Seq[String]	names
{ val enclose = e.isInstanceOf[ScInfixExpr] || e.isInstanceOf[ScPostfixExpr] val arguments = targets.map(simpleNameOf).mkString(", ") e.replace(enclose.fold(code"($e)($arguments)", code"$e($arguments)")) }	PsiElement	result
result.getLastChild.asInstanceOf[ScArgumentExprList].exprs	Seq[ScExpression]	references
code"(${p.getText}: ${annotation.getText}) => ()" .getFirstChild.getFirstChild	PsiElement	replacement
s"$Class.${boxMethodName(t).get}"	String	target
code"(_: $annotation)"	ScalaPsiElement	replacement
e.replace(replacement).asInstanceOf[ScParameterClause]	ScParameterClause	result
e.replace(replacement)	PsiElement	result
code"def f(): Unit = ()".asInstanceOf[ScFunctionDefinition]	ScFunctionDefinition	prototype
prototype.getParameterList.getNextSibling	PsiElement	colon
new Regex("(?:.+\\.)?(.+)")	Regex	SimpleName
new Regex(".+\\.(.+\\..+)")	Regex	PartiallyQualifiedName
10	Int	RecursionDepthThreshold
new Regex("_root_\\.(.+)")	Regex	RelativeName
prototype.assignment.get	PsiElement	equals
new Regex("(_root_\\..+)")	Regex	AbsoluteName
new Regex("(.+)")	Regex	FullName
names.zip(typeElements).map(p => p._2.map(p._1 + ": " + _.getText).getOrElse(p._1))	IndexedSeq[String]	typedIds
reference.getParent	PsiElement	context
it.annotationExpr.getAnnotationParameters	Seq[ScExpression]	arguments
if (singleParameter && typeElements.head.isEmpty) names.head else { val typedIds = names.zip(typeElements).map(p => p._2.map(p._1 + ": " + _.getText).getOrElse(p._1)) typedIds.mkString("(", ", ", ")") }	String	parameters
reference.isInstanceOf[ScReferenceExpression]	Boolean	isExpression
r1.projectContext	ProjectContext	projectContext
expressions.map(name)	IndexedSeq[String]	names
event.getProject	Project	project
repeated(names)	Set[String]	repeatedNames
CommonDataKeys.PSI_FILE.getData(event.getDataContext).asInstanceOf[ScalaFile]	ScalaFile	file
CommonDataKeys.EDITOR.getData(event.getDataContext)	Editor	editor
editor.getSelectionModel	SelectionModel	selection
List.empty[RangeMarker]	List[RangeMarker]	markers
usages.getOrElse(s, 0) + 1	Int	i
if (p.getParameters.indexOf(param) == index || (param.isVarArgs && p.getParameters.indexOf(param) <= index)) true else { //todo: check type false }	Boolean	isBold
file.getViewProvider.getDocument	Document	document
r1.replace(createReferenceElement(path)).asInstanceOf[ScReference]	ScReference	r2
TokenSet.create( ClassDefinition, TraitDefinition, EnumDefinition, ObjectDefinition )	TokenSet	TYPE_DEFINITIONS
TokenSet.create( REFERENCE_PATTERN, NAMING_PATTERN, TYPED_PATTERN )	TokenSet	BINDING_PATTERNS
s"Desugar Scala code (${selection.hasSelection.fold("selection", "file")})"	String	title
TokenSet.create(tIDENTIFIER, tUNDER)	TokenSet	ID_SET
TokenSet.create(kTHIS, tIDENTIFIER, tUNDER)	TokenSet	SELF_TYPE_ID
variantsOf(target)	Seq[String]	variants
TokenSet.create(TYPE_DECLARATION, TYPE_DEFINITION)	TokenSet	ALIASES_SET
document.createRangeMarker(selection.getSelectionStart, selection.getSelectionEnd)	RangeMarker	marker
r.nameId	PsiElement	id
TokenSet.create(FUNCTION_DECLARATION, FUNCTION_DEFINITION, MACRO_DEFINITION)	TokenSet	FUNCTIONS
TokenSet.create( VALUE_DECLARATION, PATTERN_DEFINITION, VARIABLE_DECLARATION, VARIABLE_DEFINITION )	TokenSet	PROPERTIES
FUNCTIONS ++ ALIASES_SET ++ TYPE_DEFINITIONS ++ PROPERTIES + PRIMARY_CONSTRUCTOR ++ MemberElementTypesExtension.getAllElementTypes	TokenSet	MEMBERS
TokenSet.orSet(FUNCTIONS, PROPERTIES)	TokenSet	DECLARED_ELEMENTS_HOLDER
TokenSet.create(PARAM, CLASS_PARAM)	TokenSet	PARAMETERS
TokenSet.create( SIMPLE_TYPE, TYPE, TYPE_IN_PARENTHESIS, TYPE_GENERIC_CALL, INFIX_TYPE, TUPLE_TYPE, EXISTENTIAL_TYPE, COMPOUND_TYPE, ANNOT_TYPE, WILDCARD_TYPE, TYPE_PROJECTION, TYPE_VARIABLE, LITERAL_TYPE )	TokenSet	TYPE_ELEMENTS_TOKEN_SET
TokenSet.create( INTERPOLATED_PREFIX_LITERAL_REFERENCE, INTERPOLATED_PREFIX_PATTERN_REFERENCE, tINTERPOLATED_STRING_ID )	TokenSet	INTERPOLATED_PREFIX_TOKEN_SET
constructor.effectiveParameterClauses	Seq[ScParameterClause]	clauses
selection.hasSelection.option { val document = editor.getDocument val marker = document.createRangeMarker(selection.getSelectionStart, selection.getSelectionEnd) marker.setGreedyToLeft(true) marker.setGreedyToRight(true) marker }	Option[RangeMarker]	range
clauses(i)	ScParameterClause	clause
clauses.take(i)	Seq[ScParameterClause]	preceedingClauses
new EnumSetProvider { type EnumSet[E <: Enum[E]] = Int def empty[E <: Enum[E]]: EnumSet[E] = 0 def single[E <: Enum[E]](e: E): EnumSet[E] = 1 << e.ordinal() def union[E <: Enum[E]](set1: EnumSet[E], set2: EnumSet[E]): EnumSet[E] = set1 | set2 def intersect[E <: Enum[E]](set1: EnumSet[E], set2: EnumSet[E]): EnumSet[E] = set1 & set2 def add[E <: Enum[E]](set: EnumSet[E], e: E): EnumSet[E] = union(set, single(e)) def contains[E <: Enum[E]](set: EnumSet[E], e: E): Boolean = intersect(set, single(e)) == single(e) def readFromInt[E <: Enum[E]](i: Int): EnumSet[E] = i }	EnumSetProvider	instance
clauses.drop(i + 1)	Seq[ScParameterClause]	remainingClauses
classTag.runtimeClass.asInstanceOf[Class[E]]	Class[E]	aClass
offset	Int	idx
constructor.getModifierList.hasModifierProperty(PsiModifier.PUBLIC) && constructor.getParameterList.getParametersCount == 0	Boolean	isPublicAndParameterless
element.elementScope	ElementScope	scope
text.indexOf('\n')	Int	newLineIdx
range.map(elementsIn(file, _)).getOrElse(file.depthFirst())	Iterator[PsiElement]	elementIterator
text.lastIndexOf('\n')	Int	idx
usage.getTextRange	TextRange	simpleRange
elementIterator.foldLeft(false) { (hadApply, element) => val (result, marker) = applyTransformer(element, transformer, document) marker.foreach(markers ::= _) hadApply || result }	Boolean	hasApply
Iterator.continually { transformers.foldLeft(false) { (hadApply, transformer) => val elementIterator = range.map(elementsIn(file, _)).getOrElse(file.depthFirst()) val hasApply = elementIterator.foldLeft(false) { (hadApply, element) => val (result, marker) = applyTransformer(element, transformer, document) marker.foreach(markers ::= _) hadApply || result } hadApply || hasApply } }	Iterator[Boolean]	resultIterator
inReadAction(targetImplicit.getProject)	Project	project
element.scalaLanguageLevelOrDefault	ScalaLanguageLevel	languageLevel
document.createRangeMarker(e.getTextRange)	RangeMarker	marker
file.findElementAt(range.getStartOffset)	PsiElement	first
file.findElementAt(range.getEndOffset)	PsiElement	last
PsiTreeUtil.findCommonParent(first, last)	PsiElement	parent
Logger.getInstance("ScalaMethodCallTracing")	Logger	Log
Option(System.getProperty("scala.method.trace.log.level")).map(_.toLowerCase) match { case Some("info") => LogLevel.Info case Some("debug") => LogLevel.Debug case Some("trace") => LogLevel.Trace case Some("none") => LogLevel.None case _ => LogLevel.Debug }	TracingLogger.LogLevel	DefaultTraceLogLevel
str.lastIndexOf('.')	Int	i
mutable.Map.empty[String, Int]	mutable.Map[String, Int]	cachedDistance
(fqn: String) => cachedDistance.getOrElseUpdate(fqn, distanceFrom(place)(fqn))	String => Int	distanceFromContext
10	Int	periodMs
place.containingScalaFile.flatMap(_.firstPackaging)	Option[ScPackaging]	packaging
progress.timestamp	Long	timestamp
packaging.map(_.fullPackageName)	Option[String]	packageQualifier
false	Boolean	isGuarded
ProgressManager.getInstance()	ProgressManager	progressManager
ProgressManager.getInstance().getProgressIndicator	ProgressIndicator	indicator
1000	Int	threshold
getRelevantImports(place)	Seq[ScImportStmt]	ctxImports
IdeEventQueue.getInstance()	IdeEventQueue	queue
parametersOf(clause)	IndexedSeq[(Parameter, String)]	parameters
Seq(Event.KEY_ACTION, Event.KEY_PRESS, MouseEvent.MOUSE_PRESSED, MouseEvent.MOUSE_WHEEL)	Seq[Nothing]	userEventIds
new EmptyProgressIndicator()	EmptyProgressIndicator	delegate
getActualParameters(args)	Seq[ScExpression]	exprs
methodSubst.followed(subst)(funType)	ScType	substituted
Array( "scala.Option", "scala.None", "scala.util.Try", "scala.util.Either.RightProjection", "scala.util.Either.LeftProjection" ).map(_ + ".get")	Array[String]	knownUnsafeGetters
parameters(getIt)	(Parameter, String)	param
Array("head", "tail", "last", "reduce", "reduceLeft", "reduceRight")	Array[String]	knownUnsafeMethodNames
expr.`type`().getOrNothing	ScType	exprType
Option(method.getReturnType.toScType())	Option[ScType]	returnType
packageQualifier.toSeq ++ ctxImports .flatMap(_.importExprs) .flatMap(e => Option(e.qualifier)) .map(_.qualName)	IndexedSeq[String]	ctxImportRawQualifiers
"scala"	String	group
"Warning"	String	title
NotificationType.WARNING	NotificationType	notificationType
NotificationDisplayType.BALLOON	NotificationDisplayType	displayType
subst(param._1.paramType)	ScType	paramType
ctxImportRawQualifiers.distinct.map(_.split('.')).toArray	Array[Array[String]]	ctxImportQualifiers
IdHandler	NotificationUtil.Handler	handler
mutable.Buffer()	mutable.Buffer[NotificationAction]	actions
fullQualifedName.split('.').init	Array[String]	candidateQualifier
0	Int	distanceMod
new Notification(group, null, title, null, message, notificationType, new HyperlinkListener(handler))	Notification	notification
{ (_: String) => {} }	NotificationUtil.Handler	IdHandler
Map( "scala" -> 10000, "java" -> 100000 )	Map[String, Int]	specialPackageDistance
method.parameters.map(_.getTypeElement.getType.toScType())	IndexedSeq[ScType]	paramTypes
project	Project	projectContext
TypeDefinitionMembers.getSignatures(cls).allSignatures.filter(_.isAbstract).toSeq	Seq[TermSignature]	abstractMembers
clazz1.containingClass	PsiClass	containingClazz1
clazz2.containingClass	PsiClass	containingClass2
Group("root", Group("Method invocations", Entry("Expand \"apply\" call", new ExpandApplyCall()), Entry("Expand \"update\" call", new ExpandUpdateCall()), Entry("Expand unary call", new ExpandUpdateCall()), Entry("Expand property setter call", new ExpandSetterCall()), Entry("Expand assignment call", new ExpandAssignmentCall()), Entry("Expand dynamic call", new ExpandDynamicCall()), Entry("Canonize infix call", new CanonizeInfixCall()), Entry("Canonize postfix call", new CanonizePostifxCall()), Entry("Canonize arity-0 call", new CanonizeZeroArityCall()), Entry("Canonize block argument", new CanonizeBlockArgument()), Entry("Expand auto-tupling", new ExpandAutoTupling()), Entry("Expand vararg argument", new ExpandVarargArgument(), enabled = false), Entry("Inscribe default arguments", enabled = false), Entry("Expand \"==\" to \"equals\" call") ), Group("Type annotations", Entry("Value definition", new AddTypeToValueDefinition()), Entry("Variable definition", new AddTypeToVariableDefinition()), Entry("Method definition", new AddTypeToMethodDefinition()), Entry("Function parameter", new AddTypeToFunctionParameter()), Entry("Underscore parameter", new AddTypeToUnderscoreParameter()), Entry("Reference pattern", new AddTypeToReferencePattern()), Entry("Type parameters") ), Group("Types", Entry("Expand function type", new ExpandFunctionType()), Entry("Expand tuple type", new ExpandTupleType()), Entry("Expand type alias"), Entry("Expand context bound"), Entry("Expand view bound"), Entry("Substitute AnyRef") ), Group("Implicits", Entry("Expand implicit conversion", new ExpandImplicitConversion()), Entry("Inscribe implicit parameters", new InscribeImplicitParameters()) ), Group("Functions", Entry("Expand placeholder syntax", new ExpandPlaceholderSyntax()), Entry("Expand eta expansion", new ExpandEtaExpansion()), Entry("Make eta-expansion explicit", new MakeEtaExpansionExplicit()), Entry("Expand single abstract methods", enabled = false), Entry("Expand function instantiation", enabled = false) ), Group("Expressions", Entry("Expand for comprehensions", new ExpandForComprehension()), Entry("Expand string interpolation", new ExpandStringInterpolation()), Entry("Expand tuple instantiation", new ExpandTupleInstantiation()) ), Group("Declarations", Entry("Expand procedure syntax", new ExpandProcedureSyntax()), Entry("Make method return expressions explicit", new MakeResultExpressionExplicit()), Entry("Add explicit \"override\" modifier"), Entry("Replace underscore section with default value"), Entry("Expand property declaration", enabled = false), Entry("Expand property definition", enabled = false), Entry("Convert implicit class to class and function") ), Group("References", Entry("Expand wildcard import"), Entry("Fully qualify import expression"), Entry("Partially qualify simple reference", new PartiallyQualifySimpleReference()), Entry("Fully qualify reference", enabled = false) ), Group("General", Entry("Append semicolon", new AppendSemicolon(), enabled = false), Entry("Inscribe explicit braces", enabled = false), Entry("Enforce parentheses in constructor invocation"), Entry("Convert parentheses to braces in for comprehensions"), Entry("Expand macro", enabled = false) ) )	Group	RootGroup
new MyDialog(RootGroup)	SelectionDialog.this.MyDialog	dialog
parameters.indexWhere(param => ScalaNamesUtil.equivalent(param._1.name, name))	Int	ind
0	Int	requestCountsToShow
parameters(ind)	(Parameter, String)	param
{ val objectMethods = Array("wait", "finalize", "notifyAll", "notify").map("java.lang.Object." + _) val stringMethods = "java.lang.String.getChars" //copies to destination array objectMethods :+ stringMethods }	Array[String]	knownMethodsWithSideEffects
node.value.forall(!_)	Boolean	toggle
bp.`type`()	result.TypeResult	tp
ShowSettingsUtilImpl.getConfigurableGroups(project, true)	Array[ConfigurableGroup]	groups
params.map(convertParameter(_, wildcards, Variance.Contravariant))	IndexedSeq[ScType]	newParams
convertParameter(retTp, wildcards, Variance.Covariant)	ScType	newRetTp
seqCommonPrefixSize(qualifier, t)	Int	prefixLen
subst(parameters.last._1.paramType)	ScType	paramType
args.element.projectContext	ProjectContext	project
new ConfigurableVisitor.ByID("preferences.sourceCode.Scala")	ConfigurableVisitor.ByID	visitor
MultilineQuotes.length	Int	MultilineQuotesLength
'|'	Char	DefaultMarginChar
visitor.find(groups: _*)	Configurable	configurable
if (prefixLen >= 2) qualifier.length + t.length - 2 * prefixLen else Int.MaxValue	Int	dist
call.getParent match { case assignStmt: ScAssignment if call == assignStmt.leftExpression => true case notExpr if !notExpr.isInstanceOf[ScExpression] || notExpr.isInstanceOf[ScBlockExpr] => true case _ => false }	Boolean	canBeUpdate
args.invocationCount	Int	count
stringElement.getParent	PsiElement	parent
configurable.createComponent.asInstanceOf[CodeStyleMainPanel]	CodeStyleMainPanel	codeStyleMainPanel
literal.contentText	String	text
operation match { case ref if hasImplicitConversion(ref) => false case ref if ref.refName.endsWith("_=") => false case ResolvesTo(_: ScSyntheticFunction) => true case ResolvesTo(m: PsiMethod) => methodHasNoSideEffects(m, baseExpr.`type`().toOption) case _ => false }	Boolean	checkOperation
args.callGeneric.getOrElse(null: ScGenericCall)	ScGenericCall	gen
e match { case null => return foundImports case holder: ScImportsHolder => foundImports ++ holder.getImportStatements case _ => foundImports }	Seq[ScImportStmt]	found
ScalaPsiElementFactory.createExpressionWithContextFromText(withApplyText, expr.getContext, expr)	ScExpression	withApply
element match { case tpo: ScTypeParametersOwner => tpo.typeParameters.toArray case ptpo: PsiTypeParameterListOwner => ptpo.getTypeParameters case _ => return ScSubstitutor.empty }	Array[_ >: ScTypeParam <: PsiTypeParameter]	typeParams
if (functionName == "update") -1 else 0	Int	i
new ColumnInfo[Node, java.lang.Boolean]("Enabled") { override def getColumnClass = classOf[Boolean] override def isCellEditable(item: Node) = true override def valueOf(node: Node) = node.value.map(Boolean.box).orNull override def setValue(node: Node, value: java.lang.Boolean) { val toggle = node.value.forall(!_) node.value = Some(toggle) } }	ColumnInfo[Node, Any] { def isCellEditable(item: Node): Boolean def valueOf(node: Node): Any def setValue(node: Node, value: Any): Unit def getColumnClass: Class[Boolean] }	rightColumn
Some(functionName)	Some[String]	forName
new CompletionProcessor(StdKinds.refExprQualRef, call, isImplicit = true) { override protected val forName = Some(functionName) }	CompletionProcessor { val forName : Some[String] }	processor
baseExpr match { case _ if hasImplicitConversion(baseExpr) => false case u: ScUnderscoreSection => false case ResolvesTo(m: PsiMethod) => methodHasNoSideEffects(m, typeOfQual) case ResolvesTo(_: ScSyntheticFunction) => true case ResolvesTo(_: ScTypedDefinition) => val withApplyText = baseExpr.getText + ".apply" + args.map(_.getText).mkString("(", ", ", ")") val withApply = ScalaPsiElementFactory.createExpressionWithContextFromText(withApplyText, expr.getContext, expr) withApply match { case ScMethodCall(ResolvesTo(m: PsiMethod), _) => methodHasNoSideEffects(m, typeOfQual) case _ => false } case _ => hasNoSideEffectsInner(baseExpr) }	Boolean	checkBaseExpr
processor.candidates	Array[ScalaResolveResult]	variants
{ val text = """ |object implicit0 { | def unapply[A](a: A): Option[A] = ??? |} """.stripMargin ScalaPsiElementFactory.createElement(text)(TmplDef()(_))(project) }	PsiElement	implicit0
new PhysicalMethodSignature(method, subst.followed(collectSubstitutor(method)))	PhysicalMethodSignature	signature
Seq( implicit0 )	Seq[PsiElement]	syntheticDeclarations
Seq("StringBuffer._", "StringBuilder._").map("exclude:java.lang." + _)	IndexedSeq[Any]	excludeNonString
panel.getSelectedPanel	CodeStyleAbstractPanel	selectedPanel
new HyperlinkLabel(msg)	HyperlinkLabel	typeAnnotationsSettings
(Seq(Lambda, LambdaSymbolic) ++ inlineSyntaxIds) .map(new ScSyntheticClass(_, Any))	IndexedSeq[ScSyntheticClass]	syntheticClasses
new ListTreeTableModel(root, Array(new TreeColumnInfo("Transformation"), rightColumn)) { override def setValueAt(aValue: Any, node: Any, column: Int) { super.setValueAt(aValue, node, column) nodeChanged(node.asInstanceOf[TreeNode]) } }	ListTreeTableModel { def setValueAt(aValue: Any, node: Any, column: Int): Unit }	model
Seq("Integer", "Byte", "Character", "Short", "Boolean", "Long", "Double", "Float") .map(name => s"java.lang.$name._")	IndexedSeq[String]	javaWrappers
new TreeTable(model)	TreeTable	table
ref.getSameNameVariants	Array[ScalaResolveResult]	sameName
Seq("java.lang.String._", "java.lang.Math._", "java.math.BigInteger._", "java.math.BigDecimal._")	Seq[Nothing]	otherJavaClasses
{ val sameName = ref.getSameNameVariants if (sameName.isEmpty) ref.multiResolveScala(false) else sameName }	Array[ScalaResolveResult]	variants
new ThreeStateCheckBoxRenderer()	ThreeStateCheckBoxRenderer	cellRenderer
Seq("Boolean", "Byte", "Char", "Double", "Float", "Int", "Long", "Unit") .map(name => s"scala.$name._")	IndexedSeq[String]	scalaValueClasses
Seq("Option._", "Some._", "Tuple._", "Symbol._").map("scala." + _)	IndexedSeq[Any]	otherFromScalaPackage
Seq("Either", "Failure", "Left", "Right", "Success", "Try") .map(name => s"scala.util.$name._")	IndexedSeq[String]	fromScalaUtil
Seq("scala.math.BigInt._", "scala.math.BigDecimal._")	Seq[Nothing]	fromScalaMath
Seq("scala.collection.immutable._")	Seq[Nothing]	immutableCollections
Some(enabled)	Option[Boolean]	value
m.name	String	methodName
new JdomExternalizerMigrationHelper(element)	JdomExternalizerMigrationHelper	helper
Option(m.containingClass).map(_.qualifiedName)	Option[String]	methodClazzName
subst(typed.`type`().getOrNothing)	ScType	typez
ServiceManager.getService(project, classOf[BuildViewManager])	BuildViewManager	viewManager
new DefaultBuildDescriptor(buildId, title, project.getBasePath, System.currentTimeMillis())	DefaultBuildDescriptor	buildDescriptor
fqn + "." + methodName	String	methodQName
new RunContentDescriptor(null, null, new JComponent {}, title)	RunContentDescriptor	descriptor
constrInvocation.typeElement	ScTypeElement	typeElement
constrInvocation.arguments.indexOf(args.element)	Int	i
new MyConcurrentMap[Tracer, AtomicInteger]	MyConcurrentMap[Tracer, Any]	parentCallCounters
typeOfQual.map(_.tryExtractDesignatorSingleton) match { case Some(tp) => tp.extractClass.map(_.qualifiedName) case None => methodClazzName }	Option[String]	clazzName
currentTime - lastUpdate.get	Long	delta
Seq(Lambda, LambdaSymbolic) .map(createPolyLambdaSyntheticObject)	IndexedSeq[PsiElement]	syntheticObjects
{ implicit val projectContext: Project = project // used in type-level lambdas val syntheticClasses = (Seq(Lambda, LambdaSymbolic) ++ inlineSyntaxIds) .map(new ScSyntheticClass(_, Any)) // used in value-level lambdas val syntheticObjects = Seq(Lambda, LambdaSymbolic) .map(createPolyLambdaSyntheticObject) syntheticClasses ++ syntheticObjects }	Seq[PsiElement]	syntheticDeclarations
"Lambda"	String	Lambda
""	String	LambdaSymbolic
Seq("?", "+?", "-?", "*", "+*", "-*")	Seq[String]	inlineSyntaxIds
new ComparableVersion("0.10.0")	ComparableVersion	newSyntaxVersion
s""" |object $objectName { | def apply[T[_[_], _[_]]]: Any = ??? |} """.stripMargin	String	text
0	Int	BEFORE_CACHE_READ
{ tracingProperty || ApplicationManager.getApplication.isInternal }	Boolean	isAvailable
fn.isAbstractMember	Boolean	isAbstract
tracingProperty	Boolean	_enabled
fn.parameters.size == 1	Boolean	singleArgument
new MyConcurrentMap[String, Tracer]()	MyConcurrentMap[String, Tracer]	tracersMap
new Tracer("root-tracer-id$$", "<root>")	Tracer	root
fn.typeParameters.size == 1	Boolean	hasTypeParam
tparams.length == 2 && tparams.forall(_.typeParameters.size == 1)	Boolean	typeParametersValid
totalTime.toDouble / actualCount	Double	exact
fn.returnTypeElement.exists(isAppliedTypeConstructor(_, tparams.last, fn.typeParameters.head))	Boolean	correctReturnType
fn.parameters.head.typeElement.exists(isAppliedTypeConstructor(_, tparams.head, fn.typeParameters.head))	Boolean	correctParameterType
v(k)	V	newValue
new StartBuildEventImpl(buildDescriptor, "running ...") .withContentDescriptorSupplier { () => // dummy runContentDescriptor to set autofocus of build toolwindow off val descriptor = new RunContentDescriptor(null, null, new JComponent {}, title) descriptor.setActivateToolWindowWhenAdded(false) descriptor.setAutoFocusContent(false) descriptor }	StartBuildEventImpl	startEvent
new FinishBuildEventImpl(buildId, null, System.currentTimeMillis(), resultMessage, result)	FinishBuildEventImpl	finishEvent
ProjectRootManager.getInstance(tdef.getProject)	ProjectRootManager	rootManager
new FailureResultImpl(err)	FailureResultImpl	failureResult
ScSubstitutor.bind(clazz.typeParameters, gen.typeArgList.typeArgs)(_.calcType)	ScSubstitutor	substitutor
new FinishBuildEventImpl(buildId, null, System.currentTimeMillis(), "failed", failureResult)	FinishBuildEventImpl	finishEvent
tdef.typeParameters	Seq[ScTypeParam]	tparams
new SkippedResultImpl	SkippedResultImpl	canceledResult
new FinishBuildEventImpl(buildId, null, System.currentTimeMillis(), "canceled", canceledResult)	FinishBuildEventImpl	finishEvent
new StartEventImpl(taskId, parent.orNull, time, message)	StartEventImpl	startEvent
tdef.functions.filter(canBeRewritten(_, tparams))	Seq[ScFunction]	methods
Function.const(true)	String => Boolean	currentFilter
(AnnotationParameters(clazz.getMethods.toSeq.filter(_.isInstanceOf[PsiAnnotationMethod]).map(meth => (meth.name, meth.getReturnType.toScType(), meth.asInstanceOf[PsiAnnotationMethod].getDefaultValue))), i)	(ScalaFunctionParameterInfoHandler.AnnotationParameters, Int)	resulting
preferredWidths.iterator	Iterator[Int]	widths
new DataById[TracerData](_.id)	DataById[TracerData]	dataById
{ val dataById = new DataById[TracerData](_.id) new DataByIdTableModel(dataById, dataById.stringColumn("Computation", _.name), dataById.numColumn("Invoked", _.totalCount), dataById.numColumn("Read from cache", _.fromCacheCount), dataById.numColumn("Actually computed", _.actualCount), dataById.numColumn("Max Time, ms", _.maxTime), dataById.numColumn("Total Time, ms", _.totalTime), dataById.numColumn("Own Time, ms", _.ownTime), dataById.numColumn("Avg Time, ms", _.avgTime) )(preferredWidths = Seq(5, 1, 1, 1, 1, 1, 1, 1)) }	DataByIdTableModel[TracerData]	timingsModel
{ val dataById = new DataById[TracerData](_.id) new DataByIdTableModel(dataById, dataById.stringColumn("Computation", _.name), dataById.numColumn("Actually computed", _.actualCount), dataById.numColumn("Total Time, ms", _.totalTime), dataById.stringColumn("Parent calls", parentCallsText) )(preferredWidths = Seq(6, 1, 1, 12)) }	DataByIdTableModel[TracerData]	parentCallsModel
if (unit == null) "items" else unit	String	unitOrDefault
methods.map { m => s"def ${m.name}(f: F[A] => G[A]): ${tdef.name}[F, G] = ???" }.mkString("\n ")	String	methodsText
new ProgressBuildEventImpl(taskId, null, time, message, total, progress, unitOrDefault)	ProgressBuildEventImpl	event
new FinishEventImpl(taskId, null, time, message, result)	FinishEventImpl	event
new TableView[String](this)	TableView[String]	table
getRowCount - 1	Int	idx
getRowValue(idx)	String	id
s""" |trait `${tdef.getName}PolyLambdaBuilder`[F[_], G[_]] { | type A | $methodsText |} """.stripMargin	String	text
text.linesIterator .map(_.trim) .filterNot(_.isEmpty)	Iterator[Any]	lines
lines.drop(1)	Iterator[Any]	withoutFirst
ScalaPsiElementFactory.createTypeDefinitionWithContext(text, tdef, null)	ScTypeDefinition	buiderTrait
Seq(Lambda, LambdaSymbolic)	Seq[String]	polyLambdaIds
if (marginChar == DefaultMarginChar) ".stripMargin" else s".stripMargin('$marginChar')"	String	stripText
ContentFactory.SERVICE.getInstance()	ContentFactory	factory
new ArrayBuffer[Array[ScExpression]]()	ArrayBuffer[Array[ScExpression]]	calls
findParentMLString(stringElement).getOrElse(return Array.empty)	PsiElement	prevParent
prevParent.getParent	PsiElement	parent
argsToFind.sorted	Seq[String]	myArgs
new DefaultActionGroup(new RunPauseAction(dataSource), new ClearAction(dataSource, tableModel))	DefaultActionGroup	actionGroup
Logger.getInstance("#org.jetbrains.plugins.scala.caches.RecursionManager")	Logger	LOG
elem.getParent	PsiElement	element
ActionManager.getInstance().createActionToolbar(ID, actionGroup, false)	ActionToolbar	actionToolBar
tableModel.createTable()	TableView[String]	table
new ProjectUserDataHolder[PsiElement] { override def dataHolder(e: PsiElement): UserDataHolder = e override def project(e: PsiElement): Project = e.getProject }	ProjectUserDataHolder[PsiElement]	psiElement
ScalaShortNamesCacheManager.getInstance(project)	ScalaShortNamesCacheManager	cacheManager
PlatformRM.markStack()	RecursionGuard.StackStamp	platformStamp
500L	Long	refreshRateMs
new ProjectUserDataHolder[Module] { override def dataHolder(e: Module): UserDataHolder = e override def project(e: Module): Project = e.getProject }	ProjectUserDataHolder[Module]	module
cacheManager.getClassesByName(name, scope)	Iterable[PsiClass]	classes
createKey(data)	RecursionManager.MyKey[Data]	realKey
createKey(data)	RecursionManager.MyKey[Data]	key
new ArrayBuffer[PsiClass]()	ArrayBuffer[PsiClass]	res
new ProjectUserDataHolder[Project] { override def dataHolder(e: Project): UserDataHolder = e override def project(e: Project): Project = e }	ProjectUserDataHolder[Project]	project
Key.create("local.modification.counter")	Key[BlockModificationTracker.ExpressionModificationTracker]	key
createKey(data, myCallEquals = true)	RecursionManager.MyKey[Data]	key
ExpressionModificationTracker(originalElement)	BlockModificationTracker.ExpressionModificationTracker	originalCounter
BlockModificationTracker(expression.getContext)	ModificationTracker	contextTracker
createKey(data, myCallEquals = true)	RecursionManager.MyKey[Data]	realKey
stack.progressMap.size	Int	sizeBefore
stack.progressMap.size	Int	sizeAfter
Objects.hash(guardId, userObject)	Int	hashCode
Int.MaxValue	Int	minStackDepthInRecursion
0	Int	depth
0	Int	enters
0	Int	exits
false	Boolean	_isDirty
Logger.getInstance("#org.jetbrains.plugins.scala.caches.ScalaShortNamesCacheManager")	Logger	LOG
myDelegate.getTokenType	IElementType	tokenType
Map.empty	RecursionManager.LocalCacheMap	localCache
progressMap.size	Int	sizeBefore
progressMap.size	Int	sizeAfter
minStackDepthInRecursion	Int	minDepthBefore
{ val recordedStackSizeInteger = progressMap.remove(realKey) assert(recordedStackSizeInteger != null) recordedStackSizeInteger }	Int	recordedStackSize
Key.create[T](id)	Key[T]	newKey
depth	Int	oldDepth
ScalaParserDefinitionBase.createLexer	ScalaLexer	scalaLexer
ProjectRootManager.getInstance(element.getProject)	ProjectRootManager	rootManager
cleanFqn(name)	String	cleanName
cacheManager.getClassesByName(nameWithoutDollar, scope)	Iterable[PsiClass]	classes
arg.map(_.getText).sorted	IndexedSeq[Nothing]	argsString
psiPackage.getQualifiedName match { case "" => "" case qualifiedName => s"$qualifiedName." }	String	packageName
new MultilineStringSettings(element.getProject)	MultilineStringSettings	settings
_	ScalaAutoImportOptionsProviderForm	form
file.findElementAt(start)	PsiElement	elementAtStart
file.findElementAt(end)	PsiElement	elementAtEnd
psiNamesCache	PsiShortNamesCache	namesCache
"ScalaShortNamesCacheManager"	String	getComponentName
CachedValuesManager.getManager(elem.getProject)	CachedValuesManager	manager
interpolatorPrefix(literal) + MultilineQuotes	String	firstMLQuote
child.getNextSibling	PsiElement	s
endLineNumber != startLineNumber	Boolean	multipleLines
psiElement match { case call: ScMethodCall => call.args case _ => return NoOperation }	ScArgumentExprList	args
new CachedValueProvider[ConcurrentMap[Data, Result]] { def compute(): CachedValueProvider.Result[ConcurrentMap[Data, Result]] = new CachedValueProvider.Result(ContainerUtil.newConcurrentMap(), dependencyItem()) }	CachedValueProvider[Any] { def compute(): CachedValueProvider.Result[Any] }	provider
psiElement.asInstanceOf[ScMethodCall]	ScMethodCall	methodCall
settings.quotesOnNewLine && multipleLines && !startsOnNewLine	Boolean	needNewLineBefore
manager.createCachedValue(provider, false)	CachedValue[Any]	newValue
brace.getPsi	PsiElement	r
settings.calcIndentSize(text.subSequence(startLineOffset, literalStart))	Int	oldIndent
if (needNewLineBefore) { val oldIndent = settings.calcIndentSize(text.subSequence(startLineOffset, literalStart)) oldIndent + settings.regularIndent } else { settings.getSmartLength(text.subSequence(startLineOffset, literalStart)) }	Int	quotesIndent
document.lineStartOffset(end)	Int	nextLineStart
ScSubstitutor.bind(clazz.getTypeParameters, gen.typeArgList.typeArgs)(_.calcType)	ScSubstitutor	substitutor
Option(methodCall.deepestInvokedExpr).flatMap(_.getReference.toOption)	Option[PsiReference]	ref
quotesIndent + interpolatorPrefixLength(literal) + settings.marginIndent	Int	marginIndent
document.getLineStartOffset(lineNumber)	Int	lineStart
elem.getUserData(key) match { case null => val manager = CachedValuesManager.getManager(elem.getProject) val provider = new CachedValueProvider[ConcurrentMap[Data, Result]] { def compute(): CachedValueProvider.Result[ConcurrentMap[Data, Result]] = new CachedValueProvider.Result(ContainerUtil.newConcurrentMap(), dependencyItem()) } val newValue = manager.createCachedValue(provider, false) elem.putUserDataIfAbsent(key, newValue) case d => d }	CachesUtil.CachedMap[Data, Result]	cachedValue
clauses.clauses	Seq[ScParameterClause]	cl
(document.lineEndOffset(end) + 1).min(document.getTextLength)	Int	nextLineEnd
psiElement.getContainingFile.findElementAt(editor.getCaretModel.getOffset)	PsiElement	currentPsi
self.arguments.indexOf(args.element)	Int	i
{ var currentPsi = psiElement.getContainingFile.findElementAt(editor.getCaretModel.getOffset) while (currentPsi != null && methodCall.getTextRange.contains(currentPsi.getTextRange) && !currentPsi.isInstanceOf[ScArgumentExprList]) { currentPsi = currentPsi.getParent } currentPsi match { case a: ScArgumentExprList => a case _ => args } }	ScArgumentExprList	rightArgs
-1	Int	endOffset
args.getFirstChild	PsiElement	child
args.exprs	Seq[ScExpression]	params
context.getEditor.getCaretModel.getOffset	Int	offset
p1.reference.map(_.getTextRange.getEndOffset).getOrElse(p1.getTextRange.getStartOffset)	Int	insertIdx
editor.getDocument	Document	doc
doc.getLineEndOffset(doc.getLineNumber(forStartOffset))	Int	stopOffset
new CachedValueProvider[AtomicReference[Result]] { def compute(): CachedValueProvider.Result[AtomicReference[Result]] = new CachedValueProvider.Result(new AtomicReference[Result](), dependencyItem()) }	CachedValueProvider[Any] { def compute(): CachedValueProvider.Result[Any] }	provider
doc.getLineEndOffset(doc getLineNumber ifStartOffset)	Int	stopOffset
calcOffset()	Int	actualOffset
Invocation.getInvocation(elem)	Option[ScalaFunctionParameterInfoHandler.this.Invocation]	res
elem.getUserData(key) match { case null => val manager = CachedValuesManager.getManager(elem.getProject) val provider = new CachedValueProvider[AtomicReference[Result]] { def compute(): CachedValueProvider.Result[AtomicReference[Result]] = new CachedValueProvider.Result(new AtomicReference[Result](), dependencyItem()) } val newValue = manager.createCachedValue(provider, false) elem.putUserDataIfAbsent(key, newValue) case d => d }	CachesUtil.CachedRef[Result]	cachedValue
findArgs(element).orElse(refWithImplicitArgs)	Option[ScalaFunctionParameterInfoHandler.this.Invocation]	argsOption
argsOption.get	ScalaFunctionParameterInfoHandler.this.Invocation	args
doc.getLineEndOffset(doc getLineNumber whileStartOffset)	Int	stopOffset
scalaTopLevelModTracker(file.getProject).getModificationCount	Long	topLevel
false	Boolean	transformingOneLiner
settings.getSmartSpaces(indent) + marginChar.getOrElse("")	String	indentStr
if (caretIsAfterNewLine) { 1 + marginIndent // if caret is at new line then indent and margin char will be inserted AFTER caret } else if (caretOffset == literalStart && needNewLineBefore) { 1 + quotesIndent // if caret is at literal start then indent and new line will be inserted AFTER caret } else { 0 // otherwise caret will be automatically shifted by document.insertString, no need to fix it }	Int	caretShift
CodeStyle.getSettings(project)	CodeStyleSettings	settings
settings.getCustomSettings(classOf[ScalaCodeStyleSettings]).getMarginChar	Char	defaultMarginChar
settings.useTabCharacter(ScalaFileType.INSTANCE)	Boolean	useTabs
settings.getTabSize(ScalaFileType.INSTANCE)	Int	tabSize
settings.getIndentOptions(ScalaFileType.INSTANCE).INDENT_SIZE	Int	regularIndent
scalaSettings.MULTILINE_STRING_CLOSING_QUOTES_ON_NEW_LINE	Boolean	closingQuotesOnNewLine
scalaSettings.MULTILINE_STRING_INSERT_MARGIN_ON_ENTER	Boolean	insertMargin
scalaSettings.supportMultilineString()	Boolean	supportMultilineString
scalaSettings.MULTILINE_STRING_MARGIN_INDENT	Int	marginIndent
scalaSettings.MULTILINE_STRING_OPENING_QUOTES_ON_NEW_LINE	Boolean	quotesOnNewLine
l.getNode.getChildren(null)	Array[ASTNode]	children
Seq( new ScalaMethodCallFixer, new ScalaIfConditionFixer, new ScalaForStatementFixer, new ScalaWhileConditionFixer, new ScalaMissingWhileBodyFixer, new ScalaMissingIfBranchesFixer, new ScalaMissingForBodyFixer )	Seq[ScalaFixer]	myFixers
e.getNode.getFirstChildNode	ASTNode	firstChild
Seq()	Seq[EnterProcessor]	myEnterProcessors
e.getNode.getLastChildNode	ASTNode	lastChild
firstChild.getTextRange.getEndOffset	Int	start
lastChild.getTextRange.getStartOffset	Int	end
e.getTextRange	TextRange	range
e.getNode.getTreeNext	ASTNode	treeNext
range.getStartOffset + 1	Int	start
if (Set(ScalaTokenTypes.tRPARENTHESIS, ScalaTokenTypes.tRSQBRACKET).contains( e.getNode.getLastChildNode.getElementType )) range.getEndOffset - 1 else range.getEndOffset	Int	end
e.getTextRange.getStartOffset	Int	start
e.getTextRange	TextRange	r
ext.templateBody match { case Some(x) => x.getTextRange.getStartOffset case None => e.getTextRange.getEndOffset }	Int	end
Key.create("smartEnterOriginalTimestamp")	Key[Long]	SMART_ENTER_TIMESTAMP
getStatementAtCaret(editor, file)	PsiElement	atCaret
new TextRange(e.getTextRange.getStartOffset, treeNext.getTextRange.getEndOffset)	TextRange	r
if (!x.getParent.isInstanceOf[ScMethodCall]) x.getTextRange.getEndOffset else x.getParent.getTextRange.getEndOffset	Int	offset
Seq(e) ++ e.prevSiblings	IndexedSeq[PsiElement]	previous
fixer.apply(editor, this, psiElement)	fixer.OperationPerformed	operation
previous.takeWhile(isPartOfAttributeValue).last	PsiElement	start
caret	PsiElement	atCaret
atCaret.getParent match { case block: ScBlockExpr if block.exprs.headOption.contains(atCaret) => block case forStmt: ScFor => forStmt case _ => atCaret }	PsiElement	atCaretAdjusted
Seq(e) ++ e.nextSiblings	IndexedSeq[PsiElement]	next
'.'	Char	Dot
atCaret.getContainingFile	PsiFile	psiFile
s"(\\s*)$PackageLiteral .+".r	Regex	PackageRegex
next.takeWhile(isPartOfAttributeValue).last	PsiElement	end
createRangeMarker(atCaret)	RangeMarker	rangeMarker
Set( XML_ATTRIBUTE_VALUE_START_DELIMITER, XML_ATTRIBUTE_VALUE_TOKEN, XML_ATTRIBUTE_VALUE_END_DELIMITER)	Set[IElementType]	ValueTokenTypes
document.getLineNumber(caretOffset)	Int	lineNumber
document.getLineStartOffset(lineNumber)	Int	start
document.getLineEndOffset(lineNumber)	Int	end
scala.collection.mutable.ArrayBuffer((caret, doNotVisit(caret)))	ArrayBuffer[(PsiElement, Boolean)]	buffer
doNotVisit(e)	Boolean	eNonOK
caretOffset - start	Int	caretIndex
skipWhitespace(findGroupBoundary(e, back, ScalaTokenTypes.tLBRACE), forward)	PsiElement	startElement
file.findElementAt(editor.offset)	PsiElement	element
start + dotIndex	Int	dotOffset
if (line.contains(Semicolon) && dotOffset > 0) { document.insertString(dotOffset, Semicolon) dotOffset + 1 } else { dotOffset }	Int	caretOffsetNew
Logger.getInstance("#org.jetbrains.plugins.scala.editor.enterHandler.EnterBetweenClosureBracesHandler")	Logger	LOG
block.getChildren	Array[PsiElement]	children
new TextRange(if (fRange.getStartOffset != fRange.getEndOffset) fRange.getStartOffset else { //if we have dummy range we must find td letter to concatenate ranges var end = fRange.getEndOffset var flag = true while (flag) { editorText.charAt(end) match { case ' ' | '.' | '\n' => end += 1 case _ => flag = false } } end }, offset)	TextRange	tRange
skipWhitespace(findGroupBoundary(e, forward, ScalaTokenTypes.tRBRACE), back)	PsiElement	endElement
new TextRange(startElement.getTextRange.getStartOffset, endElement.getTextRange.getEndOffset)	TextRange	range
startElement	PsiElement	current
step(current)	PsiElement	sibling
LineTokenizer.tokenize(leaf.getText.toCharArray, false)	Array[String]	strings
start	PsiElement	current
editor.offset	Int	offset
' '	Char	found
caretOffset.get.intValue	Int	offset
CharArrayUtil.shiftForward(text, offset, " \t")	Int	nextCharOffset
false	Boolean	wasInMultilineString
""	String	whiteSpaceAfterCaret
Option(file.findElementAt(offset))	Option[PsiElement]	element
file.asInstanceOf[ScalaFile]	ScalaFile	scalaFile
scalaFile.findElementAt(caretOffset)	PsiElement	nextParent
nextParent.asInstanceOf[ScDocTag]	ScDocTag	tagParent
tagParent.getValueElement	PsiDocTagValue	tagValueElement
tagParent.getNameElement	PsiElement	tagNameElement
if (tagValueElement != null) tagValueElement.getNextSibling else tagNameElement.getNextSibling	PsiElement	probData
if (probData.getNextSibling != null) probData.getNextSibling.getNode else null	ASTNode	nextProbData
tagParent.getNameElement.getTextRange.getStartOffset	Int	startOffset
CharArrayUtil.shiftForward(text, caretOffset, " \t")	Int	offset
probData.getTextRange.getStartOffset + (Option(nextProbData).map(_.getElementType) match { case Some(ScalaDocTokenType.DOC_COMMENT_DATA) => probData.getTextLength case Some(ScalaDocTokenType.DOC_COMMENT_LEADING_ASTERISKS) => 1 case _ => 0 })	Int	endOffset
PsiUtilCore.getElementAtOffset(file, offset)	PsiElement	element
e == null || (eNonOK && nonOk) || e.getChildren.isEmpty	Boolean	isInvalid
super.getStatementAtCaret(editor, psiFile)	PsiElement	atCaret
PsiTreeUtil.getParentOfType(atCaret, classOf[ScPatternDefinition], classOf[ScIf], classOf[ScWhile], classOf[ScFor], classOf[ScCatchBlock], classOf[ScMethodCall])	PsiElement	statementAtCaret
editor.getUserData(SMART_ENTER_TIMESTAMP)	Long	timestamp
new ArrayBuffer[ImportInfo]()	ArrayBuffer[ImportInfo]	result
this.relative.orElse(second.relative)	Option[String]	relative
isTokenType(offset - 1, t => t == tRBRACE || t == tIDENTIFIER) && isTokenType(offset, t => t == tINTERPOLATED_STRING || t == tINTERPOLATED_MULTILINE_STRING || t == tINTERPOLATED_STRING_END)	Boolean	afterInterpolatedInjection
relative.isEmpty && (this.rootUsed || second.rootUsed)	Boolean	rootUsed
isTokenType(offset - 1, t => STRING_LITERAL_TOKEN_SET.contains(t) || t == tINTERPOLATED_STRING_ESCAPE)	Boolean	previousIsStringToken
new StringLiteralLexer(StringLiteralLexer.NO_QUOTE_CHAR, a.getNode.getElementType)	StringLiteralLexer	lexer
math.min(imp1Components.size, imp2Components.size)	Int	max
(implicitNames -- singleNames).nonEmpty	Boolean	hasWildcardImplicits
imp.qualifier	ScStableCodeReference	qualifier
editor.asInstanceOf[EditorEx].getHighlighter	EditorHighlighter	highlighter
compareNames(comp1, comp2, isImport = true)	Int	result
highlighter.createIterator(offset)	HighlighterIterator	iterator
ArrayBuffer[ImportUsed]()	ArrayBuffer[ImportUsed]	importsUsed
mutable.HashSet[String]()	mutable.HashSet[String]	allNames
Ordering.fromLessThan(compareNames(_, _, isImport = false) < 0)	Ordering[String]	nameOrdering
file.findElementAt(caretOffset)	PsiElement	element
mutable.HashSet[String]()	mutable.HashSet[String]	singleNames
mutable.HashMap[String, String]()	mutable.HashMap[String, String]	renames
mutable.HashSet[String]()	mutable.HashSet[String]	hiddenNames
false	Boolean	hasWildcard
Set.empty[String]	Set[String]	allNamesForWildcard
file match { case scFile: ScalaFile => scFile case multiRootFile: PsiFile if multiRootFile.getViewProvider.getLanguages.contains(ScalaLanguage.INSTANCE) => multiRootFile.getViewProvider.getPsi(ScalaLanguage.INSTANCE).asInstanceOf[ScalaFile] case _ => return EmptyRunnable.getInstance() }	ScalaFile	scalaFile
false	Boolean	hasNonUsedImplicits
caretModel.getOffset	Int	offset
document.createRangeMarker(offset, offset)	RangeMarker	caretMarker
deepestQualifier(qualifier)	ScStableCodeReference	deepRef
MultilineStringUtil.findParentMLString(element) match { case Some(v) => v case _ => return Result.Continue }	ScLiteral	literal
scalaFile.getProject	Project	project
deepRef.getText == _root_prefix	Boolean	rootUsed
MultilineStringUtil.interpolatorPrefix(literal)	String	interpolRef
e.getDataContext	DataContext	context
interpolRef + MultilineQuotes	String	firstMLQuote
try qualifiedRef(deepRef) catch { case _: IllegalStateException => return None }	String	qualifiedDeepRef
firstMLQuote.length	Int	firstMLQuoteLength
CommonDataKeys.EDITOR.getData(context)	Editor	editor
new MultilineStringSettings(project)	MultilineStringSettings	settings
documentManager.getDocument(scalaFile)	Document	document
file.findElementAt(offset - 1)	PsiElement	element
element.getParent.getLastChild	PsiElement	tagToDelete
if (tagToDelete.getNode.getElementType != ScalaDocTokenType.DOC_BOLD_TAG) tagToDelete.getTextLength else 1	Int	textLength
document.getLineStartOffset(number)	Int	start
document.getLineEndOffset(number)	Int	end
PsiUtilBase.getPsiFileInEditor(editor, CommonDataKeys.PROJECT.getData(context))	PsiFile	file
element.getParent.asInstanceOf[ScXmlStartTag]	ScXmlStartTag	openingTag
ScalastyleCodeInspection.configurationFor(file)	Option[ScalastyleConfiguration]	scalastyleConfig
openingTag.getClosingTag	ScXmlEndTag	closingTag
editor.getCaretModel.getOffset - element.getTextOffset + 1	Int	offsetInName
editor.asInstanceOf[EditorEx].getHighlighter.createIterator(offset)	HighlighterIterator	hiterator
if (progressIndicator != null) progressIndicator else if (progressManager.hasProgressIndicator) progressManager.getProgressIndicator else null	ProgressIndicator	indicator
getLineByNumber(document.getLineNumber(nlOffset))	String	line
scalastyleConfig.flatMap(_.checks.find(_.className == ScalastyleSettings.importOrderChecker))	Option[ConfigurationChecker]	scalastyleChecker
qualifiedDeepRef + withDot(explicitQualifierString(qualifier, withDeepest = false))	String	prefixQual
qualifiedDeepRef != deepRef.getText	Boolean	relative
document.getLineNumber(offset)	Int	lineNumber
ImportSelectorUsed(selector)	ImportSelectorUsed	importUsed
scalastyleChecker.filter(_.enabled).flatMap(ScalastyleSettings.groups)	Option[Seq[Any]]	groups
ImportExprUsed(imp)	ImportExprUsed	importUsed
getLineByNumber(lineNumber)	String	line
hiterator.getStart + (hiterator.getTokenType match { case `tMULTILINE_STRING` => QuotesLength case `tINTERPOLATED_STRING_END` => 0 case _ => 0 })	Int	closingQuotesOffset
if (codeStyleSettings.isSortAsScalastyle) { val scalastyleConfig = ScalastyleCodeInspection.configurationFor(file) val scalastyleChecker = scalastyleConfig.flatMap(_.checks.find(_.className == ScalastyleSettings.importOrderChecker)) val groups = scalastyleChecker.filter(_.enabled).flatMap(ScalastyleSettings.groups) ScalastyleSettings(scalastyleOrder = true, groups) } else ScalastyleSettings(scalastyleOrder = false, None)	ScalastyleSettings	scalastyleSettings
if (imp.selectorSet.isEmpty) ImportExprUsed(imp) else ImportWildcardSelectorUsed(imp)	ImportUsed	importUsed
line.takeWhile(c => c == ' ' || c == '\t')	String	wsPrefix
document.getLineNumber(offset)	Int	currentLineNumber
if (isRelative) Some(explicitQualifierString(qualifier, withDeepest = true)) else None	Option[String]	relativeQualifier
currentLineNumber - 1	Int	prevLineNumber
currentLineNumber + 1	Int	nextLineNumber
getLineByNumber(prevLineNumber)	String	prevLine
editor match { case e: EditorEx => e case _ => return null }	EditorEx	editorEx
getLineByNumber(prevLineNumber + 1)	String	currentLine
editorEx.getHighlighter.createIterator(offset)	HighlighterIterator	highlighterIterator
if (document.getLineCount > nextLineNumber) getLineByNumber(prevLineNumber + 2) else ""	String	nextLine
{ deepRef.resolve() match { case named: PsiNamedElement => ScalaPsiUtil.hasStablePath(named) case _ => false } }	Boolean	isStableImport
MultilineStringUtil.getMarginChar(element)	Char	marginChar
{ if (settings.insertMargin && ( lines.length > 3 || MultilineStringUtil.hasMarginChars(element, marginChar.toString) || MultilineStringUtil.needAddByType(literal))) { Some(marginChar) } else { None } }	Option[Char]	marginCharOpt
(suffix: String) => { if (qualifiedName.endsWith(suffix)) { cacheManager.getClassesByFQName(qualifiedName.stripSuffix(suffix), scope) } else { Nil } }	String => Seq[PsiClass]	classesWoSuffix
c.qualifiedName.split('.')	Array[String]	parts
classesWoSuffix("").collect { case o: ScObject if o.isPackageObject => None case o: ScObject => o.fakeCompanionClass case td: ScTypeDefinition => Some(td) }.distinct	Seq[Option[PsiClass]]	x
quotesOnNewLine && !literal.startsFromNewLine(false)	Boolean	needNewLineBeforeLiteral
classesWoSuffix("$").collect { case o: ScObject => Some(o) case c: ScTypeDefinition => ScalaPsiUtil.getCompanionModule(c) }.distinct	Seq[Option[PsiClass]]	x$
CodeStyleManager.getInstance(project)	CodeStyleManager	manager
classesWoSuffix("$class").collect { case c: ScTrait => Option(c.fakeCompanionClass) }	Seq[Option[PsiClass]]	x$class
prevLineNumber + needNewLineBeforeLiteral.toInt	Int	lineIdx
document.getLineStartOffset(lineIdx)	Int	lineOffset
{ val lineIdx = prevLineNumber + needNewLineBeforeLiteral.toInt val lineOffset = document.getLineStartOffset(lineIdx) val indentStr = manager.getLineIndent(document, lineOffset) calcIndentSize(indentStr) }	Int	firstLineIndent
firstLineIndent + interpolRef.length	Int	quotesIndent
settings.closingQuotesOnNewLine && literalText.substring(offset - literalOffset) == MultilineQuotes	Boolean	closingQuotesOnNewLine
aType.projectContext.stdTypes	StdTypes	stdTypes
document.getLineStartOffset(prevLineNumber)	Int	prevLineOffset
document.getLineStartOffset(currentLineNumber)	Int	currentLineOffset
createDocCommentFromText(ScalaDocumentationProvider.createScalaDocStub(docOwner).trim())(docOwner.getManager)	ScDocComment	newComment
docOwner.getProject	Project	project
docOwner.getTextRange.getStartOffset - 1	Int	docCommentEnd
originalElement match { case ref: ScReference => ref.bind() match { case Some(ScalaResolveResult(_, subst)) => subst case _ => ScSubstitutor.empty } case _ => ScSubstitutor.empty }	ScSubstitutor	substitutor
element.getContainingFile	PsiFile	containingFile
f.containingClass match { case null => throw new IllegalStateException() //somehting is wrong case clazz => clazz.qualifiedName.split('.').map(fixName).mkString(".") }	String	clazzFqn
docOwner.getDocComment.getTextRange	TextRange	docRange
getElementWithDoc(element)	PsiElement	elementWithDoc
mutable.HashSet[String]()	mutable.HashSet[String]	namesForWildcard
elementWithDoc.getNavigationElement	PsiElement	e
docOwner.getDocComment.asInstanceOf[ScDocComment]	ScDocComment	oldComment
mutable.HashSet[String]()	mutable.HashSet[String]	implicitNames
new HtmlBuilderWrapper	ScalaDocumentationProvider.HtmlBuilderWrapper	builder
createExpressionFromText("\"%\"")	ScExpression	literal
qualifier + ".someIdentifier"	String	refText
length	Int	start
s.split('%')	Array[String]	splitted
file.findElementAt(offset - 2)	PsiElement	prevPositionElement
ScalaPsiElementFactory.createReferenceFromText(refText, place.getContext, place) .asInstanceOf[ScStableCodeReferenceImpl]	ScStableCodeReferenceImpl	reference
ScalaTypedHandler.getPrevSiblingCondition(prevPositionElement)	Option[PsiElement]	prevSibling
counter.getAndIncrement	Int	count
new CompletionProcessor(StdKinds.stableImportSelector, reference, isImplicit = true) { override val includePrefixImports = false }	CompletionProcessor { val includePrefixImports : Boolean }	processor
settings(scalaFile)	OptimizeImportSettings	importsSettings
prevLine.prefixLength(c => c == ' ' || c == '\t')	Int	wsPrefixLength
oldComment findTagsByName (_ => true)	Array[PsiDocTag]	oldTags
if (isPrevLineFirst) firstMLQuoteLength else 0	Int	quotesOptLength
wsPrefixLength + quotesOptLength	Int	idx
if (isInDocComment(element)) { //we don't have to check offset >= 3 because "/**" is already has 3 characters getScaladocTask(text, offset) } else if (c == ' ' && hasPrefix(" case ")) { indentCase(file) } else if (c == ' ' && hasPrefix(" else ")) { indentElse(file) } else if (c == '{' && hasPrefix(" {")) { indentValBraceStyle(file) } else if (isInPlace(element, classOf[ScXmlExpr], classOf[ScXmlPattern])) { chooseXmlTask(withAttr = true) } else if (file.findElementAt(offset - 2) match { case el: PsiElement if !ScalaNamesUtil.isOperatorName(el.getText) && el.getText != "=" => c == '>' || c == '/' case _ => false }) { chooseXmlTask(withAttr = false) } else if (element.getPrevSibling != null && element.getPrevSibling.getNode.getElementType == ScalaElementType.CASE_CLAUSES) { val ltIndex = element.getPrevSibling.getText.indexOf("<") if (ltIndex > "case ".length - 1 && element.getPrevSibling.getText.substring(0, ltIndex).trim == "case") { chooseXmlTask(withAttr = false) } else { null } } else if (c == '{' && (element.getParent match { case l: ScInterpolatedStringLiteral => !l.isMultiLineString case _ => false })) { completeInterpolatedStringBraces } else if (c == '>' || c == '-') { replaceArrowTask(file, editor) } else if (c == '$') { startAutoPopupCompletion(file, editor) } else if (c == '{') { convertToInterpolated(file, editor) } else if (c == '.' && isSingleCharOnLine(editor)) { addContinuationIndent } else if (c == '.') { startAutoPopupCompletionInInterpolatedString(file, editor) } else if (offset > 1) { val prevPositionElement = file.findElementAt(offset - 2) if (ScalaPsiUtil.isLineTerminator(prevPositionElement)) { val prevSibling = ScalaTypedHandler.getPrevSiblingCondition(prevPositionElement) prevSibling.map(_.getNode.getElementType).orNull match { case ScalaTokenTypes.tDOT => indentRefExprDot(file) case ScalaTokenTypes.tCOMMA => indentParametersComma(file) case ScalaTokenTypes.tASSIGN => indentDefinitionAssign(file) case ScalaTokenTypes.tSEMICOLON => indentForGenerators(file) case _ => null } } else null } else null	Task	myTask
{ val idx = wsPrefixLength + quotesOptLength prevLine.substring(idx) }	String	prevLineStriped
editor	Editor	e
project	Project	p
file.findElementAt(offset - 1)	PsiElement	prevElement
collectRanges(createInfo(_, isImportUsed))	Seq[RangeInfo]	rangeInfos
element.getNode.getElementType	IElementType	elementType
file	PsiFile	f
splitted.flatMap(text => List(Injection(literal, None), Text(text))).toList	List[StringPart with Product with Serializable]	list
rangeInfos.map(range => (range, optimizedImportInfos(range, importsSettings)))	IndexedSeq[(RangeInfo, Seq[ImportInfo])]	optimized
PsiTreeUtil.prevLeaf(rBrace) match { case ws@Whitespace(wsText) => ws.startOffset + wsText.lastIndexOf('\n').max(0) case _ => rBrace.startOffset }	Int	start
if (document.getText != analyzingDocumentText) //something was changed... sameInfosWithUpdatedRanges() else optimized	Seq[(RangeInfo, Seq[ImportInfo])]	ranges
editor.asInstanceOf[EditorEx].getHighlighter.createIterator(offset)	HighlighterIterator	iterator
iterator.getTokenType	IElementType	tpe
BraceMatchingUtil.getBraceMatcher(fileType, tpe)	BraceMatcher	matcher
range.firstPsi.retrieve()	PsiElement	firstPsi
range.lastPsi.retrieve()	PsiElement	lastPsi
scala.collection.mutable.Stack[IElementType]()	mutable.Stack[IElementType]	stack
getImportTextCreator	ScalaImportOptimizer.ImportTextCreator	textCreator
"\n" + indentForOffset(range.startOffset)	String	newLineWithIndent
-1	Int	prevGroupIndex
convertToParamMap(param)	mutable.HashMap[String, T]	paramMap
element match { case DocWhitespace(ws) => ws.contains("\n") case _ => false }	Boolean	isAtNewLine
groupNames zip params map { case (name, param) => val paramMap = convertToParamMap(param) filterTags(name, paramMap) paramMap }	IndexedSeq[mutable.HashMap[String, T]]	paramMaps
specifier.map(_.format) .getOrElse("%" + injection.expressionType.map(letterFor).getOrElse('s'))	String	format
oldComment.getTags	Array[PsiDocTag]	tags
rr.element	PsiNamedElement	named
if (injection.isComplexBlock) injection.text else injection.value	String	argument
if (tags.nonEmpty) tags(tags.length - 1) else oldComment.getLastChild.getPrevSibling	PsiElement	firstAnchor
element.getParent	PsiElement	nextParent
fixName(named.name)	String	nameToAdd
definition.aliasedTypeElement.flatMap { _.`type`().toOption }.getOrElse(Any)	ScType	tp
file.findElementAt(offset - 2)	PsiElement	anotherElement
arg match { case tuple: ScTuple => tuple.exprs case it => Seq(it) }	Seq[ScExpression]	args
element.getTextOffset	Int	elementOffset
arguments.toIterator	Iterator[ScExpression]	remainingArguments
if (literal.isMultiLineString) 3 else 1	Int	shift
Nil	List[ScExpression]	referredArguments
document.lineStartOffset(offset)	Int	lineStart
if (psiDocument.getText(new TextRange(currentAnchor - 1, currentAnchor)) == "*") s"$name ${param._2.getName} \n" else s"* $name ${param._2.getName} \n"	String	newTagText
parts.collect { case Text(s) => (StringUtil.escapeStringCharacters(s), None) case injection @ Injection(_, specifier) => if (injection.isLiteral && specifier.isEmpty) if (injection.value == "%") ("%%", None) else (injection.value, None) else { val format = specifier.map(_.format) .getOrElse("%" + injection.expressionType.map(letterFor).getOrElse('s')) val argument = if (injection.isComplexBlock) injection.text else injection.value (format, Some(argument)) } }	IndexedSeq[(Any, Option[String])]	bindings
literal.firstChild.exists(_.getText == "f")	Boolean	formatted
comment.getOwner	PsiDocCommentOwner	commentOwner
Span(literal, it.start(0) + shift, it.end(0) + shift)	Span	span
docOwner.getDocComment.getTextRange	TextRange	range
CodeStyle.getLanguageSettings(file, ScalaLanguage.INSTANCE).getIndentOptions.CONTINUATION_INDENT_SIZE	Int	additionalIndentSize
literal.children.toList.drop(1)	List[PsiElement]	elements
strings.mkString	String	formatString
{ val elements = literal.children.toList.drop(1) elements.zipAll(elements.drop(1).map(Some(_)), null, None) }	Seq[(PsiElement, Option[PsiElement])]	pairs
block.exprs	Seq[ScExpression]	blockExpressions
arguments.collect { case Some(it) => it }	IndexedSeq[String]	argumentString
expression match { case block: ScBlockExpr => val blockExpressions = block.exprs if (blockExpressions.length == 1) blockExpressions.head else block case it => it }	ScExpression	actualExpression
{ val span = Span(literal, it.start(0) + shift, it.end(0) + shift) val cleanFormat = { val format = it.group(0) "%" + format.substring(1 + it.end(1) - it.start(1)) } Specifier(span, cleanFormat) }	Specifier	specifier
textIn(next)	String	nextText
literal.projectContext	ProjectContext	projectContext
textIn(e)	String	s
{ val s = textIn(e) if (!formatted) s else FormatSpecifierPattern.findFirstIn(s).map(format => s.substring(format.length)).getOrElse(s) }	String	text
intersperse(texts.toList, bindings.toList).filter { case Text("") => false case _ => true }	List[Nothing]	prefix
parse(left).getOrElse(parseOperand(left))	Seq[StringPart]	prefix
new ScalaXmlLexer	ScalaXmlLexer	xmlLexer
remainingArguments.filterNot(referredArguments.contains).map(UnboundExpression).toList	List[UnboundExpression]	unusedArguments
element match { case clazz: ScTypeDefinition => generateClassInfo(clazz, substitutor) case function: ScFunction => generateFunctionInfo(function, substitutor) case value@inNameContext(_: ScValue | _: ScVariable) => generateValueInfo(value, substitutor) case alias: ScTypeAlias => generateTypeAliasInfo(alias, substitutor) case parameter: ScParameter => generateParameterInfo(parameter, substitutor) case b: ScBindingPattern => generateBindingPatternInfo(b, substitutor) case _ => null }	String	text
pairs.collect { case (expression: ScExpression, nextOpt: Option[PsiElement]) => val actualExpression = expression match { case block: ScBlockExpr => val blockExpressions = block.exprs if (blockExpressions.length == 1) blockExpressions.head else block case it => it } val specifier = if (!formatted) None else nextOpt match { case Some(next) if isTextElement(next) => val nextText = textIn(next) FormatSpecifierPattern.findFirstIn(nextText).map { format => Specifier(Span(next, 0, format.length), format) } case _ => None } Injection(actualExpression, specifier) case (e, _) if isTextElement(e) => val text: String = { val s = textIn(e) if (!formatted) s else FormatSpecifierPattern.findFirstIn(s).map(format => s.substring(format.length)).getOrElse(s) } Text(text) case (e, _) if e.getNode.getElementType == ScalaTokenTypes.tINTERPOLATED_STRING_ESCAPE => Text(e.getText.drop(1)) }	IndexedSeq[StringPart with Product with Serializable]	parts
element.startOffset	Int	elementStartOffset
Option(literal.getValue).toSeq	Seq[literal.V]	value
document.getLineNumber(elementStartOffset)	Int	elementLine
document.getLineNumber(prev.startOffset)	Int	prevElementLine
document.getLineNumber(caretOffset)	Int	caretLine
caretOffset <= elementStartOffset	Boolean	caretIsBeforeElement
caretLine == prevElementLine	Boolean	caretAndPrevElementOnSameLine
prevElementLine == elementLine	Boolean	singleLineDefinition
parts match { case Text(s) :: tail => Text(s.drop(literal.quoteLength)) :: tail case it => it }	Seq[Any]	withFixedLeadingQuote
caretIsBeforeElement && caretAndPrevElementOnSameLine && isElementIndented(parent, element)	Boolean	needToHandle
advanceElementToLineComment(element)	PsiElement	endElement
parts.exists { case Text(s) => s.contains("\n") case i: Injection => i.value == "\n" case _ => false }	Boolean	toMultiline
elementStartOffset + 1	Int	elementActualStartOffset
withFixedLeadingQuote flatMap { case t: Text => t.withEscapedPercent(element.getManager) case part => List(part) }	IndexedSeq[Any]	withEscapedPercents
e.getNode.getElementType	IElementType	elementType
prevLine.endsWith('{') && nextLine.trim.startsWith('}') || prevLine.endsWith('(') && nextLine.trim.startsWith(')')	Boolean	inBraces
{ if (inBraces) getPrefix(prevLine) + getSmartSpaces(quotesOptLength) else if (prevLineStriped.trim.startsWith(marginChar)) getPrefix(prevLine) + getSmartSpaces(quotesOptLength) else if (nextLine.trim.startsWith(marginChar)) getPrefix(nextLine) else getPrefix(currentLine) }	String	prefix
endElement.endOffset + 1	Int	elementActualEndOffset
parts.filterBy[Injection]	Seq[Injection]	injections
if (injection.isLiteral || injection.isComplexBlock) injection.text else injection.value	String	s
formatContent(parts, toMultiline, needPrefix = prefix.nonEmpty)	String	content
it.value	String	text
wsText.lastIndexOf("\n").max(0)	Int	lastNewLineIdx
Set("^", "`")	Set[Nothing]	wiki1LTagMatch
parts.collect { case Text(s) => escapePlainText(s, toMultiline, escapeDollar = needPrefix) case it: Injection => val text = it.value if (injectByValue(it)) text else { val presentation = if ((it.isComplexBlock || (!it.isLiteral && it.isAlphanumericIdentifier)) && noBraces(parts, it)) "$" + text else "${" + text + "}" if (it.isFormattingRequired) presentation + it.format else presentation } }	IndexedSeq[Any]	strings
Map( "__" -> "__", "''" -> "''", ",," -> ",,", "[[" -> "]]" )	Map[Nothing, Nothing]	wiki2LTagMatch
PsiTreeUtil.prevLeaf(element)	PsiElement	prev
PsiTreeUtil.prevLeaf(element) match { case ws: PsiWhiteSpace => PsiTreeUtil.prevLeaf(ws) case prev => prev }	PsiElement	prevElement
prevElement.getParent	PsiElement	parent
parent match { case funDef: ScFunctionDefinition => (funDef.assignment.contains, funDef.body, wrap(_)) case varDef: ScVariableDefinition => (varDef.assignment.contains, varDef.expr, wrap(_)) case patDef: ScPatternDefinition => (patDef.assignment.contains, patDef.expr, wrap(_)) case d: ScDo => (d.getFirstChild.eq, d.body, wrap(_, true)) case w: ScWhile => (w.rightParen.contains, w.expression, wrap(_)) case t: ScTry => (t.getFirstChild.eq, t.expression, wrap(_, true)) case ifExpr: ScIf if ifExpr.rightParen.contains(prevElement) => (_ => true, ifExpr.thenExpression, wrap(_, ifExpr.elseKeyword.isDefined)) case ifExpr: ScIf => (ifExpr.elseKeyword.contains, ifExpr.elseExpression, wrap(_)) case f: ScFinallyBlock => ( f.getFirstChild.eq, f.getFirstChild.getNextSiblingNotWhitespace.toOption, BraceWrapInfo(_, prevElement, firstElementOnTheLine(f.getParent)) ) case f: ScFor => ((if (f.isYield) f.getYield else f.getRightBracket).contains, f.body, wrap(_)) case _ => (_ => false, None, _ => null) }	(PsiElement => Boolean, () => Option[PsiElement], PsiElement => ScalaTypedHandler.BraceWrapInfo)	tuple
parts.indexOf(it)	Int	ind
if (isPrevLineFirst) firstMLQuoteLength + prevLineStriped.startsWith(marginChar).toInt else 1	Int	offsetToContent
{ val offsetToContent = if (isPrevLineFirst) firstMLQuoteLength + prevLineStriped.startsWith(marginChar).toInt else 1 prevLinePrefixAfterDelimiter(wsPrefixLength + offsetToContent) }	Int	indentSizeAfterMargin
document.getLineStartOffset(prevLineNumber + 2)	Int	nextLineOffset
StringUtils.isBlank(currentLine)	Boolean	isCurrentLineEmpty
element.getNode.getElementType == ScalaTokenTypes.tIDENTIFIER	Boolean	isIdentifier
parts.collect { case Text(s) => quoted(StringUtil.escapeStringCharacters(s)) case injection: Injection => val s = if (injection.isLiteral || injection.isComplexBlock) injection.text else injection.value if (injection.isFormattingRequired) "%s.formatted(%s)".format(s, quoted(injection.format)) else s }	IndexedSeq[Any]	strings
prevLinePrefixAfterDelimiter(0)	Int	beforeQuotes
element.getParent match { case fun: ScFunctionDefinition => ScalaMainMethodUtil.isMainMethod(fun) case obj: ScObject if ScalaMainMethodUtil.hasMainMethod(obj) => true case c: PsiClass => ScalaMainMethodUtil.hasMainMethodFromProviders(c) case _ => false }	Boolean	hasMain
prevLine.indexOf(firstMLQuote) + firstMLQuoteLength	Int	elementStart
prevLinePrefixAfterDelimiter(elementStart)	Int	prevLineWsPrefixAfterQuotes
if (isCurrentLineEmpty) 0 else wsPrefixLength	Int	shiftLeft
collectSummary	String	summary
ApplicationInfoEx.getInstanceEx	ApplicationInfoEx	appInfo
if (isPrevLineFirst) { beforeQuotes + firstMLQuoteLength + prevLineWsPrefixAfterQuotes } else { val shiftLeft = if (isCurrentLineEmpty) 0 else wsPrefixLength elementStart - shiftLeft + prevLineWsPrefixAfterQuotes }	Int	spacesToInsert
prevLinePrefixAfterDelimiter(wsPrefixLength + firstMLQuoteLength) + firstMLQuoteLength	Int	wsAfterQuotes
{ // first line can contain quotes, so check stripped content def prevLineHasMargin = prevLineStriped.startsWith(marginChar) def otherLinesHaveMargin = lines.exists(_.trim.startsWith(marginChar)) prevLineHasMargin || otherLinesHaveMargin }	Boolean	literalAlreadyHasLineMargin
wrap(td)	PsiClassWrapper	wrapper
context.getLocation	Location[_ <: PsiElement]	location
Range(currentGroupIndex - 1, prevGroupIndex, -1).dropWhile(!isBlankLine(_)).takeWhile(isBlankLine).size	Int	blankLineNumber
findGroupIndex(info.prefixQualifier, settings)	Int	index
ScalaMainMethodUtil.findObjectWithMain(context.getPsiLocation)	Option[ScObject]	containingObj
RunManagerEx.getInstanceEx(location.getProject).asInstanceOf[RunManagerImpl]. getConfigurationTemplate(getConfigurationFactory).getConfiguration.asInstanceOf[T].getConfigurationModule.getModule	Module	predefinedModule
if (!elem.isValid) { s"[Invalid Element: ${elem.getNode} ${elem.getClass.getName}]" } else if (elem.getContainingFile == null) { s"[Element: ${elem.getNode} ${elem.getClass.getName}] [File: NULL]" } else s"[Element: ${elem.getNode} ${elem.getClass.getName}] [File: ${elem.getContainingFile.getName}] [Language: ${elem.getContainingFile.getLanguage}]"	String	footer
groupSeparatorsBefore(info, index)	String	blankLines
Iterator.range(offset, chars.length() - 1).map(chars.charAt)	Iterator[Nothing]	iterator
Map("__" -> "u>", "'''" -> "b>", "''" -> "i>", "`" -> "tt>", ",," -> "sub>", "^" -> "sup>")	Map[Nothing, Nothing]	replaceWikiScheme
mutable.HashMap[String, String]()	mutable.HashMap[String, String]	myCache
configuration.getConfigurationModule.getModule	Module	module
None	Option[PsiDocComment]	lastProcessedComment
containingObj.map(nameForConfiguration).contains(configuration.getMainClassName)	Boolean	sameName
mutable.Queue.apply[ScDocCommentOwner]()	mutable.Queue[ScDocCommentOwner]	processingQueue
false	Boolean	init
selectComment2()	Option[ScDocComment]	commentToProcess
JavaExecutionUtil.stepIntoSingleClass(context.getLocation)	Location[_ <: PsiElement]	location
location.getPsiElement	PsiElement	element
ImplicitCollector.probableArgumentsFor(value)	Seq[(ScalaResolveResult, ImplicitCollector.FullInfoResult)]	arguments
CommonDataKeys.PROJECT.getData(context)	Project	project
arguments.map { case (resolveResult, fullInfo) => new ImplicitArgumentWithReason(resolveResult, fullInfo) }	Seq[AbstractTreeNode[_]]	nodes
if (PsiTreeUtil.isAncestor(obj, element, false)) obj.fakeCompanionClassOrCompanionClass else element.getContainingFile	PsiNamedElement with NavigatablePsiElement	sourceElem
value.element.getProject	Project	project
PsiUtilBase.getPsiFileInEditor(editor, project)	PsiFile	file
tag.getValueElement	PsiDocTagValue	vEl
s"${SystemInfo.OS_NAME} (${SystemInfo.OS_VERSION}, ${SystemInfo.OS_ARCH})"	String	osInfo
{ val version = properties.getProperty("java.runtime.version", properties.getProperty("java.version", Unknown)) val osArch = properties.getProperty("os.arch", "") s"$version$osArch" }	String	javaRuntime
s"${properties.getProperty("java.vm.name", Unknown)} ${properties.getProperty("java.vendor", Unknown)}"	String	javaVmName
e.getProject	Project	project
element.withParentsInFile.collect { case td: ScTypeDefinition => td }	Iterator[ScTypeDefinition]	classes
s"Short troubleshooting summary coped to your clipboard\n$summary"	String	message
PsiFileFactory.getInstance(file.getProject)	PsiFileFactory	fileFactory
fileFactory.createFileFromText("dummy." + file.getFileType.getDefaultExtension, file.getLanguage, text)	PsiFile	dummyFile
m.contexts.take(2).collectFirst { case named: ScNamedElement => named.name case d: ScDeclaredElementsHolder => d.declaredNames.headOption.getOrElse("") }	Option[String]	owner
event.getDataContext	DataContext	context
CommonDataKeys.PROJECT.getData(context) match { case null => return case value => value }	Project	project
_	JBPopup	popup
new ActionPopupStep(expression, function, elements.contains(function))	MakeExplicitAction.ActionPopupStep	step
dummyFile.getChildren.filter(_.isInstanceOf[PsiErrorElement]).map(_.getNode)	IndexedSeq[ASTNode]	errorElements
firstPsi.getParent.getNode	ASTNode	parentNode
firstPsi.getNode	ASTNode	firstPsiNode
firstPsiNode.getTreePrev	ASTNode	prevNode
new LightweightHint(label)	LightweightHint	hint
HintManagerImpl.getInstanceImpl	HintManagerImpl	hintManager
if (text.isEmpty) { val prevNode = firstPsiNode.getTreePrev if (prevNode != null && ScalaTokenTypes.WHITES_SPACES_TOKEN_SET.contains(prevNode.getElementType)) prevNode else firstPsiNode } else firstPsiNode	ASTNode	firstNodeToRemove
editor.getCaretModel.getLogicalPosition	LogicalPosition	position
aClass.qualifiedName	String	className
Option(lastPsi.getNextSibling).map(_.getNode).orNull	ASTNode	anchor
(if (vEl != null) vEl.getText else "", tag.getAllText(handler).trim)	(Nothing, Any)	a
aClass.name	String	classSimpleName
method.name	String	methodName
mutable.ArrayBuffer.apply[ScDocCommentOwner]()	ArrayBuffer[ScDocCommentOwner]	tc
processingQueue.dequeue()	ScDocCommentOwner	next
FileTemplateManager.getDefaultInstance	FileTemplateManager	templateManager
new StringBuilder(": ")	StringBuilder	buffer
dummyFile.getNode.getFirstChildNode.toOption	Option[ASTNode]	firstChild
mutable.HashSet[RangeInfo]()	mutable.HashSet[RangeInfo]	result
null	PsiElement	firstPsi
null	PsiElement	lastPsi
holder match { case _: ScalaFile | _: ScPackaging => false case _ => true }	Boolean	isLocalRange
ArrayBuffer[ImportInfo]()	ArrayBuffer[ImportInfo]	infos
findAllTargets(file)	Array[ImplicitArgumentsTarget]	targets
target.expression.getTextRange	TextRange	range
editor.getSelectionModel.hasSelection	Boolean	hadSelection
allUsedImportedNames.toSeq.sortBy(_.offset)	Seq[ScalaImportOptimizer.UsedName]	sortedUsedNames
navigable match { case function: ScFunction => function.syntheticNavigationElement match { case synthetic: NavigatablePsiElement => Some(synthetic) case _ => None } case _ => None }	Option[NavigatablePsiElement]	maybeSynthetic
firstPsi.getTextRange.getStartOffset	Int	rangeStart
expr	TypePresentationContext	context
elem match { case fun: ScFunction => fun.returnType.getOrAny case _ => elem.`type`().getOrAny }	ScType	typez
FileTemplateManager.getDefaultInstance.getInternalTemplate(templateName)	FileTemplate	template
showPopup(editor, target.arguments, target.implicitConversion.nonEmpty)	JBPopup	popup
file.findElementAt(offset) match { case w: PsiWhiteSpace if w.getTextRange.getStartOffset == offset && w.getText.contains("\n") => file.findElementAt(offset - 1) case p => p }	PsiElement	element
ScalaPsiUtil.nameContext(named) match { case member: ScMember => member.containingClass case _ => null }	ScTemplateDefinition	clazz
sortedUsedNames.dropWhile(_.offset < rangeStart).map(_.name).toSet	Set[String]	usedImportedNames
tpe.presentableText	String	tpeText
elem match { case param: ScParameter => decoratedParameterType(param, typeToString(typez)) case _ => typeToString(typez) }	String	typeText
StringBuilder.newBuilder	mutable.StringBuilder	buffer
Some(ScTypePresentation.withoutAliases(tpe))	Some[String]	withoutAliases
methodCallText(expression, function)	String	replacementText
getSelectedNode(jTree)	AbstractTreeNode[_]	selectedNode
new Ref[Boolean]	Ref[Boolean]	succeeded
CommandProcessor.getInstance	CommandProcessor	commandProcessor
if (importStatically) Option(function.containingClass) else None	Option[ScTemplateDefinition]	maybeClass
new Tree()	Tree	tree
ScalaPsiUtil.functionArrow(param.getProject)	String	arrow
parents.next()	PsiElement	current
expr.getText.replace(" /* compiled code */ ", "")	String	text
20	Int	cutTo
expr.getTypeWithoutImplicits().toOption	Option[ScType]	tpeWithoutImplicits
elem.containingClass	ScTemplateDefinition	clazz
tpeWithoutImplicits.map(_.presentableText)	Option[String]	tpeWithoutImplicitsText
new StringBuilder(" ")	StringBuilder	buffer
RangeInfo(PsiAnchor.create(firstPsi), PsiAnchor.create(lastPsi), infos.toVector, usedImportedNames, isLocalRange)	RangeInfo	rangeInfo
new ImplicitArgumentsTreeStructure(project, results)	ImplicitArgumentsTreeStructure	structure
new AbstractTreeBuilder(tree, new DefaultTreeModel(new DefaultMutableTreeNode), structure, null) { override def isSmartExpand: Boolean = false }	AbstractTreeBuilder { def isSmartExpand: Boolean }	builder
mutable.HashMap.apply[String, PsiDocTag]()	mutable.HashMap[String, PsiDocTag]	inheritedParams
mutable.HashMap.apply[String, PsiDocTag]()	mutable.HashMap[String, PsiDocTag]	inheritedTParams
expr.expectedType().map(_.presentableText)	Option[String]	expectedTypeText
templateManager getInternalTemplate templateName	FileTemplate	template
directory.getProject	Project	project
ActionManager.getInstance.getAction(IdeActions.ACTION_EDIT_SOURCE).getShortcutSet.getShortcuts	Array[Shortcut]	F4
CustomShortcutSet.fromString("ENTER").getShortcuts	Array[Shortcut]	ENTER
new CustomShortcutSet(ArrayUtil.mergeArrays(F4, ENTER): _*)	CustomShortcutSet	shortcutSet
null	String	text
dataContext.getData(LangDataKeys.MODULE.getName).asInstanceOf[Module]	Module	module
tpe.extractDesignatorSingleton.map(_.presentableText)	Option[String]	nonSingletonTypeText
Seq("Type: " + tpeText)	Seq[Nothing]	mainText
createFile(fileName, text, project)	PsiFile	file
comment.getNextSibling	PsiElement	next
comment.getPrevSibling	PsiElement	prev
JBPopupFactory.getInstance().createComponentPopupBuilder(panel, jTree). setRequestFocus(true). setResizable(true). setTitle(title). setMinSize(new Dimension(minSize.width + 700, minSize.height)). createPopup	JBPopup	popup
Set.empty	Set[ImportUsed]	NO_IMPORT_USED
navigateSelectedElement(popup, jTree, project)	Boolean	succeeded
inheritedTParams("<" + tparam.name + ">")	PsiDocTag	paramTag
file.getViewProvider.getPsi(file.getViewProvider.getBaseLanguage)	PsiFile	topLevelFile
ProjectRootManager.getInstance(project).getFileIndex	ProjectFileIndex	projectFileIndex
"NAME"	String	NAME_TEMPLATE_PROPERTY
"lowCaseName"	String	LOW_CASE_NAME_TEMPLATE_PROPERTY
e.getDataContext.getData(LangDataKeys.MODULE.getName).asInstanceOf[Module]	Module	module
Option(module).exists(_.hasScala)	Boolean	isEnabled
new ArrayBuffer[String]	ArrayBuffer[String]	groupStrings
createExpressionFromText(replacementText)	ScExpression	replacement
expression.replace(replacement).asInstanceOf[ScMethodCall]	ScMethodCall	methodCall
expr.expectedType().map("Expected" -> _)	Option[Any]	expected
function.findSuperMethods()	Array[PsiMethod]	parents
if (rootUsed) s"${_root_prefix}." else ""	String	root
null	String	returnTag
function.getReturnType != null && !function.hasUnitResultType	Boolean	needReturnTag
null	PsiDocTag	inherRetTag
if (groupStrings.length > 1 || renames.nonEmpty || hiddenNames.nonEmpty) groupStrings.mkString(s"{$space", ", ", s"$space}") else groupStrings.head	String	postfix
_	ShowImplicitConversionsAction.this.LightBulbHint	hint
expr.getTypeWithoutImplicits().toOption.map("Without implicits" -> _)	Option[Any]	withoutImplicits
props.get(FileTemplate.ATTRIBUTE_PACKAGE_NAME) match { case name: String => name case _ => return }	String	attributePackageName
new Alarm	Alarm	hintAlarm
if (module == null) false else ModuleType.get(module) match { case _: SbtModuleType => true case _ => module.hasScala }	Boolean	validModule
s"$root${relative.getOrElse(prefixQualifier)}"	String	prefix
dataContext.getData(LangDataKeys.IDE_VIEW.getName).asInstanceOf[IdeView]	IdeView	view
if (settings.scalastyleOrder) Some(ScalastyleSettings.nameOrdering) else if (settings.sortImports) Some(Ordering.String) else None	Option[Ordering[String]]	ordering
ScalaPsiUtil.superTypeMembers(scType)	Seq[PsiNamedElement]	parents
dataContext.getData(CommonDataKeys.PROJECT.getName).asInstanceOf[Project]	Project	project
view.getDirectories	Array[PsiDirectory]	dirs
new ArrayBuffer[ImportInfo]()	ArrayBuffer[ImportInfo]	buffer
setting.getConfiguration	RunConfiguration	configuration
DefaultRunExecutor.getRunExecutorInstance	Executor	runExecutor
JavaDirectoryService.getInstance.getPackage(dir)	PsiPackage	aPackage
traitt.getSupers	Array[PsiClass]	parents
FileTemplateManager.getInstance(project).getInternalTemplate(templateName)	FileTemplate	template
addFullQualifiedImports && !(isLocalRange && isLocalImportsCanBeRelative)	Boolean	needReplaceWithFqnImports
ProgramRunner.getRunner(runExecutor.getId, configuration)	ProgramRunner[RunnerSettings]	runner
new ExecutionEnvironmentBuilder(project, runExecutor)	ExecutionEnvironmentBuilder	builder
e.getData(CommonDataKeys.EDITOR)	Editor	editor
param match { case c: ScClassParameter => c.isClassMember case _ => false }	Boolean	member
configurationType.getConfigurationFactories.apply(0)	ConfigurationFactory	factory
PsiFileFactory.getInstance(project)	PsiFileFactory	factory
elems.typeParameters	Seq[ScTypeParam]	typeParameters
ScalaFileType.INSTANCE	ScalaFileType	scalaFileType
new StringBuilder()	StringBuilder	buffer
factory.createFileFromText(s"$name.${scalaFileType.getDefaultExtension}", scalaFileType, text)	PsiFile	file
x.allTypeElements	Seq[ScTypeElement]	seq
ScalaConsoleInfo.getConsole(editor)	ScalaLanguageConsole	console
if (collectImports) mergeImportInfos(buffer) else buffer.flatMap(_.split)	IndexedSeq[ImportInfo] with IndexedSeqLike[ImportInfo, IndexedSeq[ImportInfo]]	result
new mutable.HashSet[String]()	mutable.HashSet[String]	importedNames
ScalaConsoleInfo.getProcessHandler(editor).isProcessTerminated	Boolean	terminated
importInfos(i)	ImportInfo	info
false	Boolean	changed
!editor.asInstanceOf[EditorEx].isRendererMode && !terminated	Boolean	isEnabled
startPsi.retrieve()	PsiElement	rangeStartPsi
ScalaConsoleInfo.getProcessHandler(editor)	ProcessHandler	processHandler
ScalaPsiElementFactory.createReferenceFromText(name, rangeStartPsi.getContext, rangeStartPsi)	ScStableCodeReference	ref
Option(context.getData(CommonDataKeys.EDITOR)).exists(ScalaConsoleInfo.isConsole)	Boolean	isScalaConsoleEditor
ScalaConsoleInfo.getController(editor)	ConsoleHistoryController	historyController
console.getEditorDocument	Document	document
info.withAllNamesForWildcard(rangeStartPsi)	ImportInfo	withWildcardNames
info.singleNames.size >= settings.classCountToUseImportOnDemand	Boolean	needUpdate
new TextRange(0, document.getTextLength)	TextRange	range
CommonDataKeys.PSI_FILE.getData(context)	PsiFile	file
info.hiddenNames.isEmpty && info.renames.isEmpty && !info.hasWildcard	Boolean	onlySingleNames
editor.getSelectionModel.hasSelection	Boolean	hasSelection
lineWithFeed.getBytes	Array[Byte]	bytes
1000	Int	MaxLogStringLength
info.toWildcardInfo.withAllNamesForWildcard(rangeStartPsi)	ImportInfo	withWildcard
""	String	myConsoleArgs
Option(getProject.baseDir).map(_.getPath).getOrElse("")	String	workingDirectory
DefaultJavaOptions	String	javaOptions
ScalaConsoleInfo.getConsole(file.getProject)	ScalaLanguageConsole	console
console.getConsoleEditor	EditorEx	consoleEditor
infos.flatMap { case `info` => Seq.empty case other => other.singleNames }.toSet	Set[String]	explicitNames
e.getDataContext	DataContext	dataContext
ScalaConsoleInfo.getProcessHandler(file.getProject)	ProcessHandler	processHandler
createParams	JavaParameters	params
getJavaParameters	JavaParameters	params
CommonDataKeys.PROJECT.getData(dataContext)	Project	project
params.getClassPath	PathsList	classPath
RunManagerEx.getInstanceEx(project)	RunManagerEx	runManagerEx
getMyConfigurationType	T	configurationType
ScalaConsoleInfo.getConsole(project)	ScalaLanguageConsole	console
infos.flatMap { case `info` => Seq.empty case other => other.allNames }.toSet -- explicitNames	Set[String]	namesFromOtherWildcards
requireModule	Module	module
ScalaConsoleInfo.getController(console.getProject)	ConsoleHistoryController	controller
ScalaConsoleInfo.getProcessHandler(console.getProject)	ProcessHandler	processHandler
ModuleRootManager.getInstance(module)	ModuleRootManager	rootManager
withWildcard.allNamesForWildcard & usedImportedNames	Set[String]	problematicNames
rootManager.getSdk	Sdk	sdk
(line + "\n").getBytes	Array[Byte]	bytes
problematicNames & namesFromOtherWildcards	Set[String]	clashesWithOtherWildcards
possiblyWithWildcard(info)	ImportInfo	newInfo
new ScalaConsoleRunConfigurationFactory(this)	ScalaConsoleRunConfigurationFactory	confFactory
buffer.size	Int	i
expr.implicitConversions(fromUnderscore = fromUnderscore)	Seq[PsiNamedElement]	conversions
(Seq(original, dealiased, widened) ++ expected ++ withoutImplicits) .map { case (title, tpe) => title -> tpe.presentableText(element) } .distinctBy(_._2)	Seq[(Any, Nothing)]	infos
implicitElement.orNull	PsiNamedElement	conversionFun
-1	Int	actualIndex
s"<td>${StringUtil.escapeXmlEntities(tpeText)}</td>"	String	contentCell
new ScalaConsoleRunConfigurationForm(project, configuration)	ScalaConsoleRunConfigurationForm	form
Parameters(element, expr, project, editor, conversions)	Parameters	elem
oldInfos.map(buffer.indexOf).filter(_ >= 0).sorted(Ordering[Int].reverse)	IndexedSeq[Int]	oldIndices
new ScImplicitFunctionListCellRenderer(conversionFun)	ScImplicitFunctionListCellRenderer	renderer
oldIndices.last	Int	minIndex
new StringBuilder	StringBuilder	textBuffer
new com.intellij.openapi.util.Key[String]("ScalaLanguageConsoleKey")	Key[String]	SCALA_LANGUAGE_CONSOLE_KEY
(null, null, null)	(Null, Null, Null)	NULL
createContextFile("")	ScalaFile	scalaFile
super.createConfiguration(name, template).asInstanceOf[ScalaConsoleRunConfiguration]	ScalaConsoleRunConfiguration	configuration
new ConsoleHistoryController(ScalaLanguageConsoleView.ScalaConsoleRootType, null, this)	ConsoleHistoryController	controller
ConsoleState.Init	ScalaLanguageConsole.ConsoleState.ConsoleState	state
mutable.ArrayBuffer.empty[ScExpression]	ArrayBuffer[ScExpression]	res
element	PsiElement	parent
getExpressions(guard = false)	Array[ScExpression]	falseGuard
{ val falseGuard = getExpressions(guard = false) if (falseGuard.length != 0) falseGuard else getExpressions(guard = true) }	Array[ScExpression]	expressions
hintForPattern orElse hintForExpression	Option[String]	hint
s"$renamerPrefix.$name"	String	oldPrefix
console.getProject	Project	project
ExtensionPointName.create("org.intellij.scala.sdkResolver")	ExtensionPointName[SdkResolver]	EP_NAME
TargetElementUtil.adjustOffset(file, editor.getDocument, editor.logicalPositionToOffset(editor.getCaretModel.getLogicalPosition))	Int	offset
20	Int	INDENT
KeymapUtil.getFirstKeyboardShortcutText( ActionManager.getInstance.getAction(IdeActions.ACTION_SHOW_INTENTION_ACTIONS))	String	toolTipText
(sdk: Sdk) => sdk.getSdkType == JavaSdk.getInstance	Sdk => Boolean	jdkCondition
s"$newName$stripped"	String	newRelative
_	CompileOrder	compileOrder
_	Boolean	nameHashing
adjustContentType(state, contentType)	ConsoleViewContentType	contentTypeAdjusted
_	Boolean	recompileOnMacroDef
_	Int	transitiveStep
_	Double	recompileAllFraction
_	Boolean	dynamics
_	Boolean	postfixOps
_	Boolean	reflectiveCalls
s"$renamerPrefix.$newRelative"	String	newPrefix
_	Boolean	implicitConversions
_	Boolean	higherKinds
getEditor.getDocument.getTextLength == 0	Boolean	afterConsoleCleanAction
_	Boolean	existentials
new StringBuilder("@")	StringBuilder	res
_	Boolean	macros
(sdk: Sdk) => sdk != null && condition(sdk) && jdkCondition(sdk)	Sdk => Boolean	combinedCondition
elem.constructorInvocation	ScConstructorInvocation	constrInvocation
elem.annotationExpr.getAnnotationParameters	Seq[ScExpression]	attrs
_	Boolean	experimental
infosToAdd.map(withAliasedQualifier)	IndexedSeq[ImportInfo]	actuallyInserted
_	Boolean	warnings
_	Boolean	deprecationWarnings
_	Boolean	uncheckedWarnings
_	Boolean	featureWarnings
new ScalaCompilerConfigurationPanel(project)	ScalaCompilerConfigurationPanel	form
_	Boolean	optimiseBytecode
form.getProfilesPanel	ScalaCompilerProfilesPanel	profiles
form.getIncrementalityType	IncrementalityType	newIncType
new mutable.HashMap[String, TextRange]	mutable.HashMap[String, TextRange]	types
actuallyInserted.map(_.prefixQualifier)	IndexedSeq[String]	addedPrefixes
replaceWikiWithTags(scDocComment)	PsiDocComment	replacedText
_	Boolean	explainTypeErrors
_	Boolean	specialization
_	Boolean	continuations
_	DebuggingInfoLevel	debuggingInfoLevel
_	Seq[String]	additionalCompilerOptions
_	Seq[String]	plugins
Seq( ("-language:dynamics", () => dynamics, dynamics = _), ("-language:postfixOps", () => postfixOps, postfixOps = _), ("-language:reflectiveCalls", () => reflectiveCalls, reflectiveCalls = _), ("-language:implicitConversions", () => implicitConversions, implicitConversions = _), ("-language:higherKinds", () => higherKinds, higherKinds = _), ("-language:existentials", () => existentials, existentials = _), ("-language:experimental.macros", () => macros, macros = _), ("-Xexperimental", () => experimental, experimental = _), ("-nowarn", () => !warnings, (b: Boolean) => warnings = !b), ("-deprecation", () => deprecationWarnings, deprecationWarnings = _), ("-unchecked", () => uncheckedWarnings, uncheckedWarnings = _), ("-feature", () => featureWarnings, featureWarnings = _), ("-optimise", () => optimiseBytecode, optimiseBytecode = _), ("-explaintypes", () => explainTypeErrors, explainTypeErrors = _), ("-no-specialization", () => !specialization, (b: Boolean) => specialization = !b), ("-P:continuations:enable", () => continuations, continuations = _))	Seq[(String, () => Boolean, Boolean => Unit)]	ToggleOptions
new mutable.HashMap[String, (TextRange, Boolean)]	mutable.HashMap[String, (TextRange, Boolean)]	values
Map( "-g:none" -> DebuggingInfoLevel.None, "-g:source" -> DebuggingInfoLevel.Source, "-g:line" -> DebuggingInfoLevel.Line, "-g:vars" -> DebuggingInfoLevel.Vars, "-g:notailcalls" -> DebuggingInfoLevel.Notailcalls)	Map[String, DebuggingInfoLevel]	DebuggingOptions
if (text.nonEmpty) s"$text;\n" else ""	String	content
DebuggingOptions.map(_.swap)	IndexedSeq[(DebuggingInfoLevel, String)]	debuggingLevelToOption
IncrementalityType.IDEA	IncrementalityType	incrementalityType
new ScalaCompilerSettingsProfile("Default")	ScalaCompilerSettingsProfile	defaultProfile
ToggleOptions.collect { case (option, getter, _) if getter() => option }	IndexedSeq[String]	toggledOptions
file.findReferenceAt(offset) match { case ref @ ResolvedWithSubst(e, subst) => typeTextOf(e, subst)(ref.getElement) case _ => val element = file.findElementAt(offset) if (element == null) return None if (element.getNode.getElementType != ScalaTokenTypes.tIDENTIFIER) return None element match { case Parent(p) => typeTextOf(p, ScSubstitutor.empty)(element) case _ => None } }	Option[String]	typeInfoFromRef
Seq.empty	Seq[ScalaCompilerSettingsProfile]	customProfiles
"No type was inferred"	String	NO_TYPE
(prefix + "-(.*?)(?:-src|-sources|-javadoc)?\\.jar").r	Regex	fileNameRegex
Set( ScalaLibrary, ScalaCompiler, ScalaReflect, ScalaXml, ScalaSwing, ScalaCombinators, ScalaActors )	Set[Artifact]	ScalaArtifacts
{ val content = if (text.nonEmpty) s"$text;\n" else "" val dummyContent = "1" content + dummyContent }	String	textFinal
elem match { case fun: ScFunction => fun.superMethod match { case Some(sfun) => sfun case _ => return "" } case method: PsiMethod => Try(SuperMethodsSearch.search(method, null, true, false).findFirst) match { case Success(ss) => ss.getMethod case _ => return "" } case _ => return "" }	PsiMethod	baseMethod
ScalaPsiElementFactory.createScalaFileFromText(textFinal)(getProject)	ScalaFile	file
new StringBuilder("")	StringBuilder	commentBody
new TextAttributes()	TextAttributes	attributes
new StringBuilder("")	StringBuilder	tagsPart
true	Boolean	isFirst
{ val attributes = new TextAttributes() attributes.setFontType(Font.BOLD) new ConsoleViewContentType("SCALA_CONSOLE_WELCOME_TEXT", attributes) }	ConsoleViewContentType	WelcomeTextContentType
new ScalaLanguageConsole(module)	ScalaLanguageConsole	consoleView
SideBorder.ALL	Int	mask
2	Int	thickness
consoleView.getEditor	Editor	viewEditor
consoleView.getConsoleEditor	EditorEx	consoleEditor
ProjectStructureConfigurable.getInstance(project)	ProjectStructureConfigurable	configurable
debuggingLevelToOption(debuggingInfoLevel)	(DebuggingInfoLevel, String)	debuggingLevelOption
element.getParent.getParent.getParent match { case fun: ScFunction => (fun.superMethod map (_.getDocComment)).orNull case clazz: ScTemplateDefinition => (clazz.supers.headOption map (_.getDocComment)).orNull case _ => null }	PsiDocComment	inherited
plugins.map(path => "-Xplugin:" + path)	IndexedSeq[Any]	pluginOptions
ToggleOptions.map(it => (it._1, it._3)).toMap	Map[String, Boolean => Unit]	optionToSetter
new SingleConfigurableEditor(project, configurable, SettingsDialog.DIMENSION_KEY) { override protected def getStyle = DialogStyle.COMPACT }	SingleConfigurableEditor { def getStyle: DialogWrapper.DialogStyle }	editor
for { artifact <- artifacts kind <- Kind.values } yield ( artifact, kind, kind.getPattern(artifact) )	IndexedSeq[(Artifact, Kind, Nothing)]	patterns
new ScalaCompilerSettingsState()	ScalaCompilerSettingsState	state
getWikiTextRepresentation(new MacroFinderDummy)(element)	(mutable.StringBuilder, mutable.StringBuilder)	a
new MacroFinderImpl(comment.asInstanceOf[ScDocComment], { element => val a = getWikiTextRepresentation(new MacroFinderDummy)(element) a._1.result() })	ScalaDocumentationProvider.MacroFinderImpl	macroFinder
new NotificationAction("&Configure Scala SDK classpath") { override def startInTransaction: Boolean = true override def actionPerformed(e: AnActionEvent, notification: Notification): Unit = { notification.expire() val configurable = ProjectStructureConfigurable.getInstance(project) val editor = new SingleConfigurableEditor(project, configurable, SettingsDialog.DIMENSION_KEY) { override protected def getStyle = DialogStyle.COMPACT } module.scalaSdk match { case Some(sdk) => configurable.selectProjectOrGlobalLibrary(sdk, true) case None => configurable.selectGlobalLibraries(true) } editor.show() } }	NotificationAction { def actionPerformed(e: AnActionEvent, notification: Notification): Unit def startInTransaction: Boolean }	goToSdkSettingsAction
s"jline-$JLineVersionInScala213.jar"	String	JLineJarName
customProfiles.find(_.getModuleNames.contains(module.getName)).getOrElse(defaultProfile)	ScalaCompilerSettingsProfile	profile
systemAppRoots.filter(exists).flatMap(findScalaDirectoriesIn)	IndexedSeq[String]	fromApps
env("SCALA_HOME")	Option[String]	fromHome
new ScalaCompilerSettings()	ScalaCompilerSettings	settings
env("PATH").flatMap(findScalaInCommandPath)	Option[String]	fromCommandPath
StringBuilder.newBuilder	StringBuilder	builder
Component.discoverIn(allFiles)	Seq[Component]	components
action(_)	template.SBTProcessListener	listener
new OSProcessHandler(process, "sbt-based downloader", null)	OSProcessHandler	handler
listener.text	String	text
version.map(Version(_))	Option[Version]	comparableVersion
_	LibrariesContainer	librariesContainer
addedPrefixes.map { prefix => val singleNamesCount = (actuallyInserted ++ infos) .filter(_.prefixQualifier == prefix) .flatMap(_.singleNames) .distinct.size prefix -> (singleNamesCount >= classCountToUseImportOnDemand) }.toMap	Map[String, Boolean]	tooManySingleNames
components.groupBy(_.kind) .withDefault(Function.const(Seq.empty))	Map[Kind, Seq[Component]]	componentsByKind
_	LibraryCompositionSettings	libraryCompositionSettings
componentsByKind(Binaries)	Seq[Component]	binaryComponents
binaryComponents.collectFirst { case Component(ScalaLibrary, _, Some(version), _) => version }	Option[String]	libraryVersion
source + " " + i	String	name
JavaModuleType.getModuleType.modifyProjectTypeStep(settingsStep, ScalaModuleBuilder.this)	ModuleWizardStep	javaStep
new ScalaCompilerSettingsProfile(firstFreeName(1))	ScalaCompilerSettingsProfile	profile
new LibraryOptionsPanel( ScalaLibraryType.Description, "", FrameworkLibraryVersionFilter.ALL, librariesContainer, false )	LibraryOptionsPanel	libraryPanel
if (context.isCreatingNewProject) WizardEntity.Project else WizardEntity.Module	WizardEntity	entity
virtualFiles.map(VfsUtilCore.virtualToIoFile)	IndexedSeq[Nothing]	files
Seq(ApplicationLevel, ProjectLevel, ModuleLevel)	Seq[Level]	Values
new Element("option")	Element	incrementalityTypeElement
new ScalaCompilerSettingsProfile(profileElement.getAttributeValue("name"))	ScalaCompilerSettingsProfile	profile
new ScalaCompilerSettings(XmlSerializer.deserialize(profileElement, classOf[ScalaCompilerSettingsState]))	ScalaCompilerSettings	settings
Values.map(level => (level.title, level)).toMap	Map[String, Level]	TitleToLevel
Values.map(level => (level.facetTitle, level)).toMap	Map[String, Level]	FacetTitleToLevel
LibraryReference(ProjectLevel, name)	LibraryReference	id
createLibraryElement()	Elem	libraryElement
new XMLOutputter(Format.getPrettyFormat)	XMLOutputter	outputter
new PrettyPrinter(180, 2)	PrettyPrinter	printer
new SAXBuilder()	SAXBuilder	builder
ScalaSdkDescriptor( libraryVersion, files(binaryComponents)(requiredBinaryArtifacts), files(binaryComponents)(), filesByKind(Sources), filesByKind(Docs) )	ScalaSdkDescriptor	descriptor
builder.build(new StringReader(xml))	Document	document
createScalaFileFromText(text)(comment.getManager).typeDefinitions.head.getDocComment	PsiDocComment	scalaComment
new Element("orderEntry")	Element	entry
ScalaFacetData.scalaFacetElementIn(module).getOrElse( throw new IllegalStateException("Cannot remove Scala facet from module: " + module.getModuleName))	Element	facetElement
createOptionsElement(basePackages)	Elem	optionsElement
ScalaCompilerSettings.from(properties)	ScalaCompilerSettings	compilerSettings
findOrderEntryIn(module).getOrElse(throw new IllegalArgumentException( s"Cannot remove library (${level.title}/$name}) dependency in module ${module.getModuleName}"))	Element	element
Map( "None" -> "None", "Source file attribute" -> "Source", "Source and line number information" -> "Line", "Source, line number and local variable information" -> "Vars", "Complete, no tail call optimization" -> "Notailcalls")	Map[Nothing, Nothing]	DebugginInfoLevels
from(new FacetProperties(new Element("empty")))	ScalaCompilerSettings	Default
new ScalaModuleConversionProcessor(context)	ScalaModuleConversionProcessor	scalaModuleConverter
scalaCompilerSettingsIn(context)	Map[String, ScalaCompilerSettings]	scalaCompilerSettings
new ScalaProjectSettings(basePackagesIn(context))	ScalaProjectSettings	scalaProjectSettings
obsoleteLibrariesIn(context).filter(_.level == ProjectLevel)	Set[LibraryReference]	obsoleteProjectLibraries
Seq.empty	Seq[Any]	createdSettingsFiles
properties.option("compilerLibraryLevel").flatMap { level => properties.option("compilerLibraryName").map(LibraryReference(Level.fromFacetTitle(level), _)) }	Option[LibraryReference]	compilerLibraryId
createOptionsElement()	Elem	optionsElement
obsoleteProjectLibraries.flatMap(_.libraryStorageFileIn(context))	IndexedSeq[Any]	filesToDelete
<component name="libraryTable"> {library} </component>	Elem	componentElement
new StringBuilder	StringBuilder	buffer
scalaProjectSettings.getFilesToUpdate(context)	Set[Any]	filesToUpdate
context.getProjectSettings.getRootElement	Element	rootElement
parseXml(FileUtil.loadFile(file))	Element	rootElement
new Element("component")	Element	element
ModuleUtilCore.findModuleForPsiElement(clazz)	Module	module
merge(scalaCompilerSettings)	ScalaCompilerConfiguration	compilerConfiguration
<project version="4"> {options} </project>	Elem	componentElement
{ val rootElement = context.getProjectSettings.getRootElement XPath.selectSingleNode(rootElement, "component[@name='libraryTable']").asInstanceOf[Element] }	Element	libraryTableElement
compilerConfiguration.createIn(context)	Option[Any]	createdFile
Option(rootElement.getChild("component")).getOrElse { val element = new Element("component") element.setAttribute("name", "ScalaProjectSettings") rootElement.addContent(element) element }	Element	componentElement
scalaProjectSettings.createOrUpdateIn(context)	Option[Any]	createdFile
createSettingsElement(options)	Elem	componentElement
parseXml(formatXml(library))	Element	libraryElement
modulesIn(context)	Seq[ModuleSettings]	modules
Seq.empty	Seq[ScalaSdkData]	createdSdks
Seq( ("2.7", "Scala_2_7"), ("2.8", "Scala_2_8"), ("2.9", "Scala_2_9"), ("2.10", "Scala_2_10"), ("2.11", "Scala_2_11"), ("2.12", "Scala_2_12"))	Seq[(Nothing, Nothing)]	VersionToLanguageLevel
clazz.superTypes	List[ScType]	types
Seq.empty	Seq[Any]	newSdkFiles
function.getModifierList	ScModifierList	list
modules.flatMap(LibraryReference.findAllIn).toSet	Set[LibraryReference]	referencedLibraries
scala.collection.mutable.ListBuffer[MyMessage]()	ListBuffer[MigrationReport.MyMessage]	messages
ScalaFacetData.findIn(module).getOrElse( throw new IllegalStateException("Cannot find Scala facet in module: " + module.getModuleName))	ScalaFacetData	scalaFacet
ScalaProjectConverter.findStandardScalaLibraryIn(module)	Option[LibraryReference]	scalaStandardLibraryReference
LibraryData(element)	LibraryData	standardLibrary
ScalaPsiUtil.nameContext(field) match { case x: ScMember => x case _ => return null }	ScMember	member
SettingsDescriptor(Iterable.empty, Iterable.empty, Iterable.empty)	SettingsDescriptor	EMPTY_SETTINGS
scalaStandardLibraryReference.flatMap(_.resolveIn(context))	Option[LibraryData]	scalaStandardLibrary
scalaFacet.compilerLibrary.flatMap(_.resolveIn(context))	Option[LibraryData]	scalaCompilerLibrary
modules.flatMap(findStandardScalaLibraryIn).toSet	Set[LibraryReference]	standardLibraries
subst(typed.`type`().getOrAny)	ScType	typez
createdSdks.find(_.isEquivalentTo(compilerLibrary))	Option[ScalaSdkData]	existingScalaSdk
Seq(MigratorFqnAttribute, InspectionPackageAttribute)	Seq[ManifestAttributes.ManifestAttribute]	allAttributes
modules.flatMap(findScalaCompilerLibraryIn).toSet	Set[LibraryReference]	compilerLibraries
scalaStandardLibrary.map(library => transform(library.name)).getOrElse("scala-sdk")	String	name
scalaStandardLibrary.getOrElse(LibraryData.empty)	LibraryData	standardLibrary
compilerLibrary.classesAsFileUrls	Seq[String]	compilerClasspath
ScalaSdkData.languageLevelFrom(compilerClasspath)	String	languageLevel
moduleSettings.groupBy(_._2).mapValues(_.keys.toSet).toSeq	Seq[(ScalaCompilerSettings, Set[String])]	settingsToModules
subst(subst(binding.`type`().getOrAny))	ScType	typez
ScalaSdkData(name, standardLibrary, languageLevel, compilerClasspath)	ScalaSdkData	sdk
existingScalaSdk.getOrElse { val name = scalaStandardLibrary.map(library => transform(library.name)).getOrElse("scala-sdk") val standardLibrary = scalaStandardLibrary.getOrElse(LibraryData.empty) val compilerClasspath = compilerLibrary.classesAsFileUrls val languageLevel = ScalaSdkData.languageLevelFrom(compilerClasspath) val sdk = ScalaSdkData(name, standardLibrary, languageLevel, compilerClasspath) createdSdks :+= sdk newSdkFiles ++= sdk.createIn(context) sdk }	ScalaSdkData	scalaSdk
Set("sbt", "maven", "gradle")	Set[Nothing]	BuildTools
subst(d.aliasedType.getOrAny)	ScType	ttype
settingsToModules.sortBy(p => (p._2.size, p._1.isDefault)).reverse	Seq[(ScalaCompilerSettings, Set[String])]	sortedSettingsToModules
1 + settingsDescriptor.checkBoxes.size + settingsDescriptor.comboBoxes.size + settingsDescriptor.textFields.size	Int	elementsCount
compilerClasspath.flatMap(path => versionOf(new File(path)).toSeq)	IndexedSeq[String]	compilerJarVersions
Seq[ScalaLibraryMigrationHandler](new ScalaStdLibHandler)	Seq[ScalaLibraryMigrationHandler]	PREDEFINED_HANDLERS
ManifestHandler(ioFile)	ManifestHandler	manifest
0	Int	currentIndex
sortedSettingsToModules.zipWithIndex.map { case ((settings, modules), i) => new ScalaCompilerSettingsProfile("Profile " + i, modules.toSeq, settings) }	IndexedSeq[ScalaCompilerSettingsProfile]	profiles
Iterator.single("") ++ Iterator.from(2).map("_" + _.toString)	Iterator[Any]	suffixes
versionFrom.size == 1 && versionTo.size == 1 && continuousVersion	Boolean	isRangeVersion
parameter.name	String	name
{ val suffixes = Iterator.single("") ++ Iterator.from(2).map("_" + _.toString) suffixes.map(suffix => new File(new File(base, "libraries"), s"$name$suffix.xml")) }	Iterator[Any]	candidates
profiles.headOption.fold(ScalaCompilerSettings.Default)(_.settings)	ScalaCompilerSettings	defaultSettings
profiles.drop(1)	IndexedSeq[ScalaCompilerSettingsProfile]	customProfiles
typeAnnotation(parameter)(subst.andThen(_.presentableText))	String	typeAnnot
s"$name$typeAnnot"	String	defaultText
new ConvertExpressionToSAMInspection	ConvertExpressionToSAMInspection	samInspection
projectStructure.project	Project	project
{ val rootElement = context.getProjectSettings.getRootElement XPath.selectSingleNode(rootElement, s"component[@name='libraryTable']/library[@name='$name']").asInstanceOf[Element] }	Element	libraryElement
new ProjectSdksModel	ProjectSdksModel	sdksModel
sdksModel.getSdks	Array[Sdk]	sdks
Version("2.11")	Version	Version_2_11
lib.getFiles(OrderRootType.CLASSES).map { file => new File(file.getPath.replace('/', File.separatorChar).replace(".jar!", ".jar")) //todo better way? }	IndexedSeq[Any]	ioFiles
Version("2.12")	Version	Version_2_12
ImportInfo.merge(samePrefixInfos :+ info)	Option[ImportInfo]	merged
InspectionManager.getInstance(project)	InspectionManager	inspectionManager
inReadAction(new FilteringFileIterator /*new FileTreeIterator(project)*/)	ScalaMigrationRunner.this.FilteringFileIterator	myIterator
None	Option[Seq[Library]]	oldLibrariesCopy
settingsDescriptor.checkBoxes.map { case (txt, defaultValue) => val box = new JCheckBox() box.setSelected(defaultValue) addSettingControl(box, txt) }	IndexedSeq[Nothing]	checkBoxes
new ProblemsHolder(inspectionManager, scalaFile, false)	ProblemsHolder	holder
None	Option[Seq[LibraryData]]	newLibrariesCopy
false	Boolean	isImportFinished
false	Boolean	areInjectorsLoaded
settingsDescriptor.comboBoxes.map { case (txt, variants) => val box = new JComboBox[String](variants.toArray[String]) addSettingControl(box, txt) }	IndexedSeq[Nothing]	comboBoxes
getFQN(file)	String	fqn
null	PsiClass	clazz
clazz.asInstanceOf[ScTypeDefinition].getSourceMirrorClass	PsiClass	sourceClass
settingsDescriptor.textFields.map { case (txt, defaultValue) => val field = new JTextField(defaultValue) addSettingControl(field, txt) }	IndexedSeq[Nothing]	textFields
new DialogBuilder(project)	DialogBuilder	builder
new ScalaLexer	ScalaLexer	lexer
clazz.name + " " + clazz.getPresentation.getLocationString + "\n"	String	classWithLocation
mutable.HashSet[LibraryData]()	mutable.HashSet[LibraryData]	libAcc
sourceClass.getContainingFile.getVirtualFile	VirtualFile	result
parameter match { case clParameter: ScClassParameter => clParameter.containingClass.toOption.map { clazz => val classWithLocation = clazz.name + " " + clazz.getPresentation.getLocationString + "\n" val keyword = if (clParameter.isVal) "val " else if (clParameter.isVar) "var " else "" classWithLocation + keyword }.getOrElse("") case _ => "" }	String	prefix
LibraryExtensionsManager.getInstance(project)	LibraryExtensionsManager	extensionManager
Key.create(kitTitle)	Key[EditorNotificationPanel]	getKey
new ExtensionPointName[AttachSourcesProvider]("com.intellij.attachSourcesProvider")	ExtensionPointName[AttachSourcesProvider]	EXTENSION_POINT_NAME
migrators.flatMap { migrator => checkForUserCancel() migrator.migrateLocal(scalaFile, holder) }	IndexedSeq[PartialFunction[PsiElement, Any]]	myCompoundAction
new MyRecursiveVisitorWrapper(myCompoundAction)	MyRecursiveVisitorWrapper	visitor
presentation.split('-').toSeq	Seq[String]	strings
samePrefixInfos.flatMap(_.split) ++ info.split	IndexedSeq[ImportInfo]	samePrefixWithNewSplitted
new EditorNotificationPanel() .text(panelText(kitTitle))	EditorNotificationPanel	panel
toHandlers.filter(_.acceptsFrom(fromLib))	Iterable[ScalaLibraryMigrationHandler]	foundHandlers
otherInfos.flatMap(_.namesFromWildcard).toSet	Set[String]	namesFromOtherWildcards
foundHandlers.foldLeft(mutable.HashSet[ScalaLibraryMigrationHandler]()) { case (set, handler) => if (set.exists(_.precede(handler))) set else {set.add(handler); set} }	mutable.HashSet[ScalaLibraryMigrationHandler]	filteredHandlers
new Key[Module]("ScalaAttachedModule")	Key[Module]	SCALA_ATTACHED_MODULE
PsiManager.getInstance(myProject).findFile(file) match { case scalaFile: ScalaFile => scalaFile case _ => return super.createNotificationPanel(file, fileEditor, myProject) //as Java has now different message }	ScalaFile	scalaFile
ScalaEditorFileSwapper.getFQN(scalaFile)	String	fqn
new EditorNotificationPanel	EditorNotificationPanel	panel
strings.map(Group(_))	IndexedSeq[Version.Group]	groups
findSourceFile(file)	VirtualFile	sourceFile
null	AttachSourcesProvider.AttachSourcesAction	defaultAction
groups.reverse.dropWhile(_.isNotEssential).reverse	Seq[Version.Group]	essentialGroups
simpleInfos.flatMap(_.singleNames).toSet & namesFromOtherWildcards & usedNames	Set[String]	simpleNamesToRemain
false	Boolean	hasNonLightAction
simpleInfos.filter(si => simpleNamesToRemain.contains(si.singleNames.head))	IndexedSeq[ImportInfo]	simpleInfosToRemain
_.isScalaSdk	CommonProcessors.FindProcessor[Library]	processor
new CollectProcessor[Library]()	CommonProcessors.CollectProcessor[Library]	collector
update	T	newValue
Group(Seq.empty, VersionStatus.DEFAULT)	Version.Group	emptyGroup
each.perform(findOrderEntriesContainingFile(file))	ActionCallback	callback
classFile.getParent	VirtualFile	parent
classFile.getName	String	name
withArrows.flatMap(_.renames)	IndexedSeq[(String, String)]	renames
Version(presentation).strings	Seq[String]	groups
withArrows.flatMap(_.hiddenNames)	IndexedSeq[String]	hiddenNames
name.indexOf('$')	Int	i
holder.getResultsArray .flatMap(_.getFixes).collect { case fix: AbstractFixOnPsiElement[_] => fix }	IndexedSeq[AbstractFixOnPsiElement[_ <: PsiElement]]	fixes
numbers.reverse.dropWhile(_ == 0L).reverse	Seq[Long]	essentialNumbers
mutable.Queue[PsiFile]()	mutable.Queue[PsiFile]	myCurrentFiles
mutable.Queue[PsiDirectory]()	mutable.Queue[PsiDirectory]	startDirs
if (presentation.startsWith("M")) VersionStatus.MILESTONE else if (presentation.startsWith("RC")) VersionStatus.RC else VersionStatus.DEFAULT	VersionStatus	prefix
mutable.HashSet[PsiDirectory]()	mutable.HashSet[PsiDirectory]	excludedDirs
extensions .withProgressSynchronously(s"Fetching available $this versions")(loadVersions()) .sorted .reverse .map(_.presentation) .toArray	Array[String]	versions
Seq.newBuilder[(A, A)]	mutable.Builder[(A, A), Seq[(A, A)]]	zipped
new ScalaLibraryEditorForm()	ScalaLibraryEditorForm	form
left.iterator	Iterator[A]	lefts
extensionManager.getExtensions(classOf[ScalaLibraryMigrationHandler])	Seq[Nothing]	bundledHandlers
right.iterator	Iterator[A]	rights
ArtifactHandlerComponent.getInstance(project)	ArtifactHandlerComponent	handlerComponent
propertiesState	ScalaLibraryPropertiesState	state
info.allNamesForWildcard -- simpleNamesToRemain -- renames.map(_._1) -- hiddenNames	Set[String]	fromInsertedWildcard
ModuleRootManager getInstance module	ModuleRootManager	moduleRootManager
{ val fromInsertedWildcard = info.allNamesForWildcard -- simpleNamesToRemain -- renames.map(_._1) -- hiddenNames fromInsertedWildcard & namesFromOtherWildcards & usedNames }	Set[String]	newHiddenNames
handlerComponent.getAllForTo(target)	Iterable[ScalaLibraryMigrationHandler]	predefinedHandlersForTarget
getMigrationApi	MigrationApiService	service
Version(minVersion)	Version	version
psiManager findDirectory root	PsiDirectory	dir
ImportInfo.merge(withArrows ++ wildcard)	Option[ImportInfo]	notSimpleMerged
psiManager findDirectory root	PsiDirectory	excluded
myCurrentDirs.dequeue()	PsiDirectory	dir
myCurrentFiles.dequeue()	PsiFile	current
ImportInfo.merge(simpleInfosToRemain ++ notSimpleMerged)	Option[ImportInfo]	simpleMerged
new OSProcessHandler(process, commandLine) { override def readerOptions(): BaseOutputReader.Options = BaseOutputReader.Options.BLOCKING }	OSProcessHandler { def readerOptions(): BaseOutputReader.Options }	processHandler
infosToAdd.exists(_.hasWildcard) || addedPrefixes.exists(tooManySingleNames)	Boolean	needAdditionalInfo
Vector[String]()	Vector[String]	errorLines
false	Boolean	errorInStdOut
ScalaCompileServerSettings.getInstance	ScalaCompileServerSettings	settings
errorLines	Vector[String]	result
Entity( "https://repo1.maven.org/maven2/org/scala-lang/scala-compiler/", Scala_2_10.major + ".0", scalaVersion :: Scala_2_11.minor :: Scala_2_10.minor :: Nil )	Versions.Entity	ScalaEntity
CompilerModuleExtension.getInstance(module)	CompilerModuleExtension	extension
Entity( "https://dl.bintray.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/", "0.13.5", sbtLatest_0_13 :: Nil )	Versions.Entity	Sbt013Entity
CompileServerLauncher.jvmParameters	Seq[String]	jvmParameters
descriptor.checkBoxes.zip(foundMigrators).collect { case ((_, isSelected), migrator) if isSelected => migrator }	IndexedSeq[(ScalaLibraryMigrator, Library, LibraryData)]	chosen
8	Int	STACKTRACE_FROM_REPORT_CUT_SIZE
Entity( "https://dl.bintray.com/sbt/maven-releases/org/scala-sbt/sbt-launch/", "1.0.0", (sbtLatestVersion :: sbtLatest_1_0 :: Nil).distinct )	Versions.Entity	Sbt1Entity
""" |<html> |<body> |<p>Some migrators has been found.</p> |<br> |<a href="ftp://show">Show</a> <a href="ftp://close">Close</a> |</body> |</html> """.stripMargin	String	MIGRATORS_FOUND_MESSAGE
ScalaCompileServerSettings.getInstance().COMPILE_SERVER_PORT	Int	port
10	Int	COUNT
Seq.empty	Seq[() => Unit]	callbacks
readToken(port)	String	token
infos.to[ArrayBuffer]	ArrayBuffer[ImportInfo]	buffer
rangeStart.retrieve()	PsiElement	rangeStartPsi
Entity( s"https://repo1.maven.org/maven2/ch/epfl/lamp/dotty_${Scala_3_0.major}/", Scala_3_0.major + ".0", Scala_3_0.minor :: Nil, ".+>(\\d+\\.\\d+\\.\\d+(?:-\\w+)?)/<.*".r )	Versions.Entity	DottyEntity
ScalaEntity.copy( hardcodedVersions = Scala_2_13.minor :: ScalaEntity.hardcodedVersions, versionPattern = DottyEntity.versionPattern )	Versions.Entity	ScalaCandidatesEntity
collectUsedImportedNames(holder)	Set[String]	usedNames
buffer(i)	ImportInfo	first
buffer(i + 1)	ImportInfo	second
first.relative.getOrElse(first.prefixQualifier)	String	firstPrefix
getFirstId(firstPrefix)	String	firstPart
second.relative.getOrElse(second.prefixQualifier)	String	secondPrefix
None	Option[ServerInstance]	serverInstance
getFirstId(secondPrefix)	String	secondPart
first	ImportInfo	t
i + 1	Int	j
false	Boolean	installed
samePrefixAfter(i)	Int	prefixIndex
buffer(i).merge(buffer(i + 1))	ImportInfo	merged
JBPopupFactory.ActionSelectionAid.MNEMONICS	JBPopupFactory.ActionSelectionAid	mnemonics
new DefaultActionGroup(Start, Stop, Separator.getInstance, Configure)	DefaultActionGroup	group
buffer(j).merge(buffer(j + 1))	ImportInfo	merged
s.indexOf('`', 1)	Int	index
s.indexOf('.')	Int	index
start(project)	Boolean	started
settings.importLayout	Array[String]	groups
DataManager.getInstance.getDataContext(e.getComponent)	DataContext	context
JBPopupFactory.getInstance.createActionGroupPopup(title, group, context, mnemonics, true)	ListPopup	popup
compileServerJdk(project).map(start(project, _)) match { case None => Left("JDK for compiler process not found") case Some(Left(msg)) => Left(msg) case Some(Right(process)) => invokeLater { CompileServerManager.configureWidget(project) } Right(process) }	Either[String, Any]	result
dottyClasspath(project)	Seq[Any]	bootCp
null	PluginDescriptor	myPluginDescriptor
null	String	myClasspath
ExtensionPointName.create("org.intellij.scala.nailgunServerAdditionalCp")	ExtensionPointName[NailgunServerAdditionalCp]	EP_NAME
((FileUtil toCanonicalPath jdk.executable.getPath) +: "-cp" +: classPath(jdk) +: jvmParameters :+ SERVER_CLASS_NAME).++(args)	IndexedSeq[String]	commands
None	Option[Boolean]	wasRunning
SettingsDescriptor( checkBoxes.map { b => (b.getName, b.isSelected) }, comboBoxes.map { //will make it multiple choice later b => (b.getName, Seq(b.getSelectedItem.toString)) }, textFields.map { f => (f.getName, f.getText) } )	SettingsDescriptor	result
project	Project	myProject
new CompilerErrorTreeView(project, null)	CompilerErrorTreeView	messagesTree
running	Boolean	nowRunning
None	Option[Any]	myProcess
launcher.errors()	Seq[String]	errors
Seq.empty	Seq[() => Unit]	myCallbacks
message.file.map(_.getVirtualFile).orNull	VirtualFile	file
ModuleManager.getInstance(project).getModules.toSeq.filter(hasClashes)	Seq[Module]	modulesWithClashes
true	Boolean	mayProceedWithCompilation
new ProcessWaitFor(p, (task: Runnable) => AppExecutorUtil.getAppExecutorService.submit(task), processName)	ProcessWaitFor	processWaitFor
ContentFactory.SERVICE.getInstance.createContent(messagesTree.getComponent, MigrationApiImpl.MY_MESSAGE_CONTENT_NAME, true)	Content	messagesContent
new Array[Char](8192)	Array[Char]	charBuffer
ApplicationManager.getApplication.isUnitTestMode || modulesWithClashes.forall(maySplitSilently)	Boolean	splitSilently
false	Boolean	read
MessageView.SERVICE.getInstance(myProject).getContentManager	ContentManager	contentManager
CommandProcessor.getInstance()	CommandProcessor	commandProcessor
splitSilently || showSplitDialog(modulesWithClashes) == Messages.YES	Boolean	splitAutomatically
Option(System.getProperty(key))	Option[Nothing]	custom
ToolWindowManager getInstance project getToolWindow ToolWindowId.MESSAGES_WINDOW	ToolWindow	toolWindow
fd.getField	Field	field
SbtData.from( new URLClassLoader(Array(new URL("jar:file:" + (if (libCanonicalPath startsWith "/") "" else "/" ) + libCanonicalPath + "/jps/sbt-interface.jar!/")), getClass.getClassLoader), new File(libRoot, "jps"), System.getProperty("java.class.version") ) match { case Left(msg) => throw new IllegalArgumentException(msg) case Right(data) => data }	SbtData	sbtData
ScalaSyntheticProvider.unspecializedName(name)	Option[String]	unspecializedName
new mutable.HashMap()	mutable.HashMap[DebugProcess, ScalaCollectionRenderer.CachedEvaluators]	evaluators
context.getDebugProcess	DebugProcess	debugProcess
new CachedEvaluators	ScalaCollectionRenderer.CachedEvaluators	value
unwrappedDescriptor(value, context.getProject)	ValueDescriptorImpl { def calcValue(evaluationContext: EvaluationContextImpl): Value def getDescriptorEvaluation(context: DebuggerContext): PsiExpression def calcValueName(): String }	descr
createSizeLabelRenderer()	LabelRenderer	sizeLabelRenderer
bootCp.map(_.getAbsolutePath)	IndexedSeq[Any]	bootClassPathLibs
if (bootClassPathLibs.isEmpty) Nil else Seq("-Xbootclasspath/a:" + bootClassPathLibs.mkString(File.pathSeparator))	Seq[Nothing]	bootclasspathArg
unwrappedDescriptor(value, evaluationContext.getProject)	ValueDescriptorImpl { def calcValue(evaluationContext: EvaluationContextImpl): Value def getDescriptorEvaluation(context: DebuggerContext): PsiExpression def calcValueName(): String }	descr
compilerSettings.toOptions.toArray	Array[String]	scalaParameters
Array.empty[String]	Array[String]	javaParameters
module.scalaCompilerClasspath	Seq[Any]	compilerClasspath
autoRenderer(evaluationContext.getDebugProcess, descr)	NodeRendererImpl	renderer
compilerClasspath :+ runnersJar :+ compilerSharedJar :+ outputDir	Seq[Any]	additionalCp
unwrappedDescriptor(node.getParent.asInstanceOf[ValueDescriptor].getValue, context.getProject)	ValueDescriptorImpl { def calcValue(evaluationContext: EvaluationContextImpl): Value def getDescriptorEvaluation(context: DebuggerContext): PsiExpression def calcValueName(): String }	descr
autoRenderer(context.getDebugProcess, descr)	NodeRendererImpl	renderer
unwrappedDescriptor(descriptor.getValue, evaluationContext.getProject)	ValueDescriptorImpl { def calcValue(evaluationContext: EvaluationContextImpl): Value def getDescriptorEvaluation(context: DebuggerContext): PsiExpression def calcValueName(): String }	unwrapped
assemblyClasspath().toSeq map (f => new File(f.getCanonicalPath stripSuffix "!" stripSuffix "!/"))	IndexedSeq[Any]	classesRoots
unwrappedDescriptor(value, process.getProject)	ValueDescriptorImpl { def calcValue(evaluationContext: EvaluationContextImpl): Value def getDescriptorEvaluation(context: DebuggerContext): PsiExpression def calcValueName(): String }	descr
valueDescriptor.getType	Type	unwrappedType
if (value != null) message + " " + DebuggerBundle.message("evaluation.error.cannot.evaluate.tostring", value.`type`.name) else message	String	msg
groups .filterNot(_ == BLANK_LINE) .filter(matches) .sortBy(_.length) .lastOption	Option[String]	mostSpecific
new ImportTextCreator	ScalaImportOptimizer.ImportTextCreator	textCreator
lInfo.prefixQualifier	String	lPrefix
rInfo.prefixQualifier	String	rPrefix
findGroupIndex(lPrefix, settings)	Int	lIndex
findGroupIndex(rPrefix, settings)	Int	rIndex
textCreator.getScalastyleSortableText(lInfo)	String	lText
textCreator.getScalastyleSortableText(rInfo)	String	rText
textCreator.getImportText(lInfo, settings)	String	lText
textCreator.getImportText(rInfo, settings)	String	rText
c.name	String	name
if (objRef.referenceType() != null) ScalaCollectionRenderer.transformName(objRef.referenceType().name) else ""	String	typeName
srr.importsUsed	Set[ImportUsed]	importsUsed
if (!hasDefiniteSize(objRef, evaluationContext)) "?" else size(objRef, evaluationContext)	Int	sizeValue
""	String	name
new LabelRenderer() { override def calcLabel(descriptor: ValueDescriptor, evaluationContext: EvaluationContext, labelListener: DescriptorLabelListener): String = { descriptor.getValue match { case null => "null" case objRef: ObjectReference => val typeName = if (objRef.referenceType() != null) ScalaCollectionRenderer.transformName(objRef.referenceType().name) else "" val sizeValue = if (!hasDefiniteSize(objRef, evaluationContext)) "?" else size(objRef, evaluationContext) typeName + sizePrefix + sizeValue } } }	LabelRenderer	labelRenderer
""	String	displayName
context.createEvaluationContext(value)	EvaluationContext	newContext
null	String	myName
null	String	myDisplayName
objectRef	ObjectReference	currentTail
context.createEvaluationContext(value)	EvaluationContext	evaluationContext
getStartIndex	Int	indexCount
evaluateChildren(evaluationContext, parentDescriptor)	Value	children
_	Modifier	modifier
DebugProcessImpl.getDefaultRenderer(value.`type`)	ChildrenRenderer	defaultChildrenRenderer
new ArrayBuffer[JVMName]	ArrayBuffer[JVMName]	buffer
builder.getNodeManager	NodeManager	nodeManager
builder.getParentDescriptor	ValueDescriptor	parentDescriptor
evaluateChildren(evaluationContext.createEvaluationContext(value), parentDescriptor)	Value	childrenValue
getChildrenRenderer(childrenValue, parentDescriptor)	NodeRenderer	renderer
builder.getNodeManager.createNode( new CollectionElementNodeDescriptor(indexCount.toString, evaluationContext.getProject, newHead), evaluationContext)	DebuggerTreeNode	newNode
ExpressionChildrenRenderer.getLastChildrenRenderer(parentDescriptor)	NodeRenderer	renderer
tp.projectContext.stdTypes	StdTypes	stdTypes
toArrayEvaluator(context).exprEval	ExpressionEvaluator	evaluator
new StringBuilder()	StringBuilder	stringBuilder
new JVMNameBuffer()	DebuggerUtil.JVMNameBuffer	buff
evaluator.evaluate(context)	Value	value
obj.referenceType()	ReferenceType	tpe
field.name	String	name
objRef.getValue(field).asInstanceOf[ObjectReference]	ObjectReference	rv
left.evaluate(context).asInstanceOf[Value]	Value	leftResult
right.evaluate(context).asInstanceOf[Value]	Value	rightResult
context.getDebugProcess.getVirtualMachineProxy	VirtualMachineProxyImpl	vm
context.getFrameProxy	StackFrameProxyImpl	frameProxy
frameProxy.visibleVariableByName("$this")	LocalVariableProxyImpl	variable
context.getThisObject match { case null => //so we possibly in trait $class try { val variable: LocalVariableProxyImpl = frameProxy.visibleVariableByName("$this") if (variable == null) null else { frameProxy.getValue(variable) } } catch { case _: AbsentInformationException => val args = frameProxy.getArgumentValues if (args.size() > 0) args.get(0) else null } case x => x }	Value	objRef
objRef.asInstanceOf[ObjectReference]	ObjectReference	thisRef
function match { case fun: ScFunction if !fun.isConstructor => fun.typeParameters case _: ScFunction | _: ScPrimaryConstructor => function.containingClass match { case td: ScTypeDefinition => td.typeParameters case _ => Seq.empty } case _ => Seq.empty }	Seq[ScTypeParam]	typeParams
context.getFrameProxy	StackFrameProxyImpl	proxy
proxy.location()	Location	location
context.getFrameProxy.threadProxy()	ThreadReferenceProxyImpl	threadProxy
e.getExceptionFromTargetVM	ObjectReference	targetExc
context.getDebugProcess	DebugProcessImpl	debugProcess
ScalaMethodEvaluator(new ScalaThisEvaluator(), "hasDefiniteSize", JVMNameUtil.getJVMRawText("()Z"), Nil)	ScalaMethodEvaluator	hasDefiniteSizeEval
ScalaMethodEvaluator(new ScalaThisEvaluator(), "nonEmpty", JVMNameUtil.getJVMRawText("()Z"), Nil)	ScalaMethodEvaluator	nonEmptyEval
ScalaMethodEvaluator(new ScalaThisEvaluator(), "size", JVMNameUtil.getJVMRawText("()I"), Nil)	ScalaMethodEvaluator	sizeEval
impQual.multiResolveScala(false).exists(_.importsUsed.nonEmpty)	Boolean	hasImportUsed
typeParams.map(_.upperBound.getOrAny)	IndexedSeq[ScType]	upperBounds
stableObjectEval("scala.reflect.ClassTag$")	ScalaFieldEvaluator	classTagEval
{ val classTagEval = stableObjectEval("scala.reflect.ClassTag$") ScalaMethodEvaluator(classTagEval, "Object", null, Nil) }	ScalaMethodEvaluator	classTagObjectEval
stableObjectEval("scala.Predef$")	ScalaFieldEvaluator	predefEval
cond.evaluate(context) match { case b: BooleanValue => b.value() case _ => throw EvaluationException("condition has wrong type") }	Boolean	condition
_	Field	myEvaluatedField
ScalaMethodEvaluator(predefEval, "Manifest", null, Nil)	ScalaMethodEvaluator	manifestEval
ScSubstitutor.bind(typeParams, upperBounds)	ScSubstitutor	subst
_	Modifier	myModifier
DebuggerUtil.withoutBackticks(_fieldName)	String	fieldName
{ val predefEval = stableObjectEval("scala.Predef$") val manifestEval = ScalaMethodEvaluator(predefEval, "Manifest", null, Nil) ScalaMethodEvaluator(manifestEval, "Object", null, Nil) }	ScalaMethodEvaluator	manifestObjectEval
(jdk.tools +: (presentFiles ++ compilerServerAddtionalCP())) .map(_.canonicalPath) .mkString(File.pathSeparator)	String	classpath
CompileServerLauncher.findFreePort	Int	freePort
settings.COMPILE_SERVER_SHUTDOWN_DELAY	Int	shutdownDelay
ScalaDuplexEvaluator(classTagObjectEval, manifestObjectEval)	ScalaDuplexEvaluator	argEval
{ val classTagObjectEval = { val classTagEval = stableObjectEval("scala.reflect.ClassTag$") ScalaMethodEvaluator(classTagEval, "Object", null, Nil) } val manifestObjectEval = { val predefEval = stableObjectEval("scala.Predef$") val manifestEval = ScalaMethodEvaluator(predefEval, "Manifest", null, Nil) ScalaMethodEvaluator(manifestEval, "Object", null, Nil) } val argEval = ScalaDuplexEvaluator(classTagObjectEval, manifestObjectEval) ScalaMethodEvaluator(new ScalaThisEvaluator(), "toArray", null, Seq(argEval)) }	ScalaMethodEvaluator	toArrayEvaluator
if (settings.COMPILE_SERVER_SHUTDOWN_IDLE && shutdownDelay >= 0) { Seq(s"-Dshutdown.delay=$shutdownDelay") } else Nil	Seq[String]	shutdownDelayArg
DebuggerUtil.withoutBackticks(_methodName)	String	methodName
None	Option[AnyRef]	result
localMethodIndex > 0	Boolean	localMethod
CompileServerVmOptionsProvider.implementations.flatMap(_.vmOptionsFor(project))	IndexedSeq[String]	extraJvmParameters
t.fieldByName(fieldName)	Field	field
function match { case fun: ScFunctionDefinition if fun.isLocal => localParamsForFunDef(fun) case ScalaConstructor.in(c: ScClass) => localParamsForConstructor(c) case _ => Seq.empty }	Seq[ScTypedDefinition]	localParameters
`type`.projectContext.stdTypes	StdTypes	types
fieldByName(cls, fieldName)	Field	foundInClass
findField(interfaceType, context)	Field	field
fieldByName(iface, fieldName)	Field	foundInInterface
function.containingClass match { case cl: ScClass if ValueClassType.isValueClass(cl) => cl.constructors match { case Seq(pc: ScPrimaryConstructor) => pc.parameters.headOption case _ => None } case _ => None }	Option[ScClassParameter]	valueClassParameter
findField(refType, context)	Field	field
objRef.referenceType	ReferenceType	refType
null	Modifier	modifier
function.effectiveParameterClauses.flatMap(_.effectiveParameters)	IndexedSeq[ScParameter]	simpleParameters
literal.`type`().getOrAny match { case literalType: ScLiteralType => literalType.wideType case scType => scType }	ScType	`type`
inReadAction(fragment.getProject)	Project	project
myEvaluatedQualifier.asInstanceOf[ClassType]	ClassType	classType
myEvaluatedQualifier.asInstanceOf[ObjectReference]	ObjectReference	objRef
operandEvaluator.evaluate(context).asInstanceOf[Value]	Value	value
typeEvaluator.evaluate(context).asInstanceOf[ReferenceType]	ReferenceType	refType
refType.classObject	ClassObjectReference	classObject
methodName + "$" + localMethodIndex	String	localMethodName
_	DebugProcess	prevProcess
classObject.referenceType.asInstanceOf[ClassType]	ClassType	classRefType
classRefType.concreteMethodByName("isAssignableFrom", "(Ljava/lang/Class;)Z")	Method	method
GeneratedClass(fragment, psiContext)	GeneratedClass	generatedClass
new ProcessWatcher(process, "scalaCompileServer")	ProcessWatcher	watcher
indexEvaluator.evaluate(context).asInstanceOf[Value]	Value	indexValue
mutable.HashMap[ReferenceType, Option[Method]]()	mutable.HashMap[ReferenceType, Option[Method]]	jdiMethodsCache
arrayReferenceEvaluator.evaluate(context).asInstanceOf[Value]	Value	arrayValue
null	ClassLoaderReference	classLoader
function match { case fun: ScFunction if !fun.isConstructor => getJVMStringForType(subst(fun.returnType.getOrAny), isParam = false) case _: ScFunction | _: ScPrimaryConstructor => "V" }	String	resultType
objectEvaluator.isInstanceOf[ScSuperEvaluator] || (objectEvaluator.isInstanceOf[DisableGC] && objectEvaluator.asInstanceOf[DisableGC].getDelegate.isInstanceOf[ScSuperEvaluator])	Boolean	requiresSuperObject
context.getDebugProcess	DebugProcess	process
myEvaluatedArrayReference.referenceType.asInstanceOf[ArrayType]	ArrayType	tp
null	ArrayReference	myEvaluatedArrayReference
0	Int	myEvaluatedIndex
callEvaluator(context)	ExpressionEvaluator	evaluator
new TextWithImportsImpl(CodeFragmentKind.CODE_BLOCK, generatedClass.callText)	TextWithImportsImpl	callCode
argumentEvaluators.flatMap { ev => ev.evaluate(context) match { case Some(res) => Some(res.asInstanceOf[Value]) case None => None case res => Some(res.asInstanceOf[Value]) } }	Seq[Value]	args
returnType match { case ValueClassType(inner) => inner case _ => returnType }	ScType	trueReturnType
{ val allMethods = referenceType.allMethods() allMethods.asScala.collect { case method if !localMethod && method.name() == methodName => (method, 1) case method if !localMethod && method.name().endsWith("$$" + methodName) => (method, 1) //private method, maybe from parent class case method if localMethod && method.name() == localMethodName => (method, 1) case method if localMethod && method.name.startsWith(methodName + "$") => (method, 2) case method if localMethod && method.name.contains(methodName + "$") => (method, 3) } .sortBy(_._2) .map(_._1) .toList }	List[Method]	sortedMethodCandidates
argumentTypes.map(getJVMStringForType(_, isParam = true)).mkString("(", "", ")")	String	paramText
getJVMStringForType(trueReturnType, isParam = false)	String	returnTypeText
20	Int	depthOfSearch
DebuggerUtil.withoutBackticks(name)	String	myName
DebuggerUtil.withoutBackticks(sourceName)	String	mySourceName
SourcePosition.createFromElement(clazz)	SourcePosition	position
_	EvaluationContextImpl	myContext
methodPosition.map(_.getLine)	IndexedSeq[Int]	lines
mutable.HashMap[String, Value]()	mutable.HashMap[String, Value]	mySyntheticLocals
_	LocalVariableProxyImpl	myEvaluatedVariable
-1	Int	myParameterIndex
_	String	myMethodName
new ScalaCodeFragmentFactory().createCodeFragment(callCode, generatedClass.newContext, project)	JavaCodeFragment	codeFragment
context.getFrameProxy	StackFrameProxyImpl	startFrame
startFrame.threadProxy()	ThreadReferenceProxyImpl	threadProxy
startFrame.getFrameIndex	Int	startIndex
threadProxy.frameCount() - 1	Int	lastIndex
sortedMethodCandidates.filter(sameParamNumber)	List[Method]	withSameParamNumber
withSameParamNumber.filter(linesIntersects)	List[Method]	withSameLines
mutable.HashMap[(PsiFile, Int), mutable.HashMap[PsiElement, Evaluator]]()	mutable.HashMap[(PsiFile, Int), mutable.HashMap[PsiElement, Evaluator]]	cachedEvaluators
process.getVirtualMachineProxy.asInstanceOf[VirtualMachineProxyImpl]	VirtualMachineProxyImpl	proxy
mutable.HashMap[PsiFile, Long]()	mutable.HashMap[PsiFile, Long]	cachedStamp
absentFiles.map(_.getPath).mkString(", ")	String	paths
classLoader.referenceType.asInstanceOf[ClassType]	ClassType	classLoaderType
ScalaCompileServerSettings.getInstance()	ScalaCompileServerSettings	settings
classLoaderType.concreteMethodByName("defineClass", "(Ljava/lang/String;[BII)Ljava/lang/Class;")	Method	defineMethod
new DebuggerManagerListener { override def sessionDetached(session: DebuggerSession): Unit = clear() }	DebuggerManagerListener { def sessionDetached(session: DebuggerSession): Unit }	listener
t.getQualifiedNameForDebugger + classnamePostfix(t, withPostfix)	String	qual
ExtensionPointName.create[EvaluatorCompileHelper]("org.intellij.scala.evaluatorCompileHelper")	ExtensionPointName[EvaluatorCompileHelper]	EP_NAME
elem.getNode	ASTNode	node
cls.toByteArray	Array[Byte]	bytes
args.isEmpty || !correctArgType(args.head, paramTypeNames.get(0))	Boolean	needObj
if (node != null) node.getChildren(null) else Array.empty[ASTNode]	Array[ASTNode]	children
position.getFile	PsiFile	file
position.getOffset	Int	offset
proxy.mirrorOf(cls.origName)	StringReference	name
if (settings.USE_DEFAULT_SDK) defaultSdk else ProjectJdkTable.getInstance().findJdk(settings.COMPILE_SERVER_SDK)	Sdk	sdk
SourcePosition.createFromElement(elem)	SourcePosition	position
compileServerSdk(project)	Option[Sdk]	sdk
process.findClass(context, "java.net.URLClassLoader", context.getClassLoader).asInstanceOf[ClassType]	ClassType	loaderClass
objRef.referenceType()	ReferenceType	refType
loaderClass.concreteMethodByName("<init>", "([Ljava/net/URL;Ljava/lang/ClassLoader;)V")	Method	ctorMethod
context.getSuspendContext.getThread.getThreadReference	ThreadReference	threadReference
findExpressionInner(elementAtCaret, allowMethodCalls = true).map(_.getText).getOrElse("")	String	result
loaderClass.newInstance(threadReference, ctorMethod, args, ClassType.INVOKE_SINGLE_THREADED) .asInstanceOf[ClassLoaderReference]	ClassLoaderReference	reference
codeFragment match { case sf: ScalaCodeFragment => sf case _ => throw EvaluationException(ScalaBundle.message("non-scala.code.fragment")) }	ScalaCodeFragment	scalaFragment
codeFragment.getProject	Project	project
Key.create[String]("generated.class.name")	Key[String]	classNameKey
Key.create[PsiFile]("compiling.evaluator.original.file")	Key[PsiFile]	originalFileKey
process.findClass(context, "java.net.URL[]", context.getClassLoader).asInstanceOf[ArrayType]	ArrayType	arrayType
ScalaEvaluatorCache.getInstance(project)	ScalaEvaluatorCache	cache
arrayType.newInstance(1)	ArrayReference	arrayRef
{ try cache.get(position, codeFragment) catch { case _: Exception => cache.clear() None } }	Option[Evaluator]	cached
process.findClass(context, "java.net.URL", context.getClassLoader).asInstanceOf[ClassType]	ClassType	classType
2	Int	privateModifierMask
ScalaPsiElementFactory.createExpressionWithContextFromText(elem.getText, elem.getContext, elem)	ScExpression	expressionCopy
new ScalaEvaluatorBuilder(scalaFragment, position).getEvaluator	Evaluator	newEvaluator
new ScalaCompilingEvaluator(position.getElementAt, scalaFragment)	ScalaCompilingEvaluator	compilingEvaluator
buildSimpleEvaluator	Evaluator	ev
proxy.mirrorOf("file:a")	StringReference	url
threadProxy.frame(frameIndex)	StackFrameProxyImpl	frameProxy
classType.concreteMethodByName("<init>", "(Ljava/lang/String;)V")	Method	ctorMethod
frameProxy.visibleVariableByName(myName)	LocalVariableProxyImpl	local
ScalaEvaluatorBuilderUtil.getContextClass(fun)	PsiElement	container
ScalaEvaluatorBuilderUtil.getContextClass(cl)	PsiElement	container
cl.extendsBlock	ScExtendsBlock	extendsBlock
classType.newInstance(threadReference, ctorMethod, util.Arrays.asList(url), ClassType.INVOKE_SINGLE_THREADED)	ObjectReference	reference
process.findClass(context, "byte[]", context.getClassLoader).asInstanceOf[ArrayType]	ArrayType	arrayClass
param.owner	PsiElement	owner
process.newInstance(arrayClass, bytes.length)	ArrayReference	reference
ScalaEvaluatorBuilderUtil.getContextClass { owner match { case pc: ScPrimaryConstructor => pc.containingClass case fun => fun } }	PsiElement	container
syntheticFile.getUserData(ScalaCompilingEvaluator.originalFileKey)	PsiFile	originalFile
inReadAction { val originalFile = syntheticFile.getUserData(ScalaCompilingEvaluator.originalFileKey) Option(originalFile).map(findModuleForPsiElement).orNull }	Module	module
for { pos <- Option(position) elem <- Option(pos.getElementAt) } yield { getContextClass(elem, strict = false) }	Option[PsiElement]	maybeContextClass
enumerators.generators	Seq[ScGenerator]	generators
{ val maybeContextClass = for { pos <- Option(position) elem <- Option(pos.getElementAt) } yield { getContextClass(elem, strict = false) } maybeContextClass.orNull }	PsiElement	contextClass
s"new $generatedClassName().$generatedMethodName()"	String	callText
generators.last	ScGenerator	lastGenerator
debugProcess.invokeInstanceMethod(context, objRef, jdiMethod, unwrappedArgs(args, jdiMethod).asJava, ObjectReference.INVOKE_NONVIRTUAL)	Value	result
mutable.Set.empty[ScTypedDefinition]	mutable.Set[ScTypedDefinition]	buf
classType.superclass()	ClassType	superClass
ref.resolve()	PsiElement	elem
newTd.extendsBlock	ScExtendsBlock	extBl
pos.getElementAt	PsiElement	elem
serverInstance	Option[ServerInstance]	currentInstance
settings.USE_PROJECT_HOME_AS_WORKING_DIR	Boolean	useProjectHome
elem.children.find { case ElementType(t) if ScalaTokenTypes.WHITES_SPACES_AND_COMMENTS_TOKEN_SET.contains(t) => false case _: ScAnnotations => false case e if e.getTextLength == 0 => false case _ => true }	Option[PsiElement]	firstSignificant
createCodeFragmentInner(item, wrapContext(context))	ScalaCodeFragment	fragment
findClass(objRef.referenceType().name())	ReferenceType	objType
ScalaShortNamesCacheManager.getInstance(elementScope.project)	ScalaShortNamesCacheManager	cacheManager
DebuggerManagerEx.getInstanceEx(project).getContext	DebuggerContextImpl	debuggerContext
objType.asInstanceOf[ClassType]	ClassType	classType
debuggerContext.getDebuggerSession	DebuggerSession	debuggerSession
new Semaphore	Semaphore	semaphore
obj match { case objRef: ObjectReference => val objType = findClass(objRef.referenceType().name()) if (objType.isInstanceOf[ArrayType]) throw EvaluationException(s"Method $methodName cannot be invoked on array") val classType = objType.asInstanceOf[ClassType] if (requiresSuperObject) findInSuperClass(classType) else classWithMethod(classType) case rt: ReferenceType => classWithMethod(rt) case _ => throw EvaluationException(DebuggerBundle.message("evaluation.error.evaluating.method", methodName)) }	Option[(ReferenceType, Method)]	typeAndMethod
useProjectHome && projectHome(project) != currentInstance.map(_.workingDir)	Boolean	workingDirChanged
classesInScope(elementScope.scope) match { case Seq() if fallbackToProjectScope => classesInScope(GlobalSearchScope.allScope(elementScope.project)) case classes => classes }	Seq[PsiClass]	classes
compileServerJdk(project) match { case Some(projectJdk) => projectJdk != instance.jdk case _ => false }	Boolean	jdkChanged
NameTransformer.decode(refType.name)	String	originalQName
EvaluatorCompileHelper.EP_NAME.getExtensions.headOption.getOrElse { ScalaEvaluatorCompileHelper.instance(module.getProject) }	EvaluatorCompileHelper	helper
psiType match { case tp: PsiClassType => //noinspection ScalaRedundantCast tp.resolve().asInstanceOf[PsiClass] case _ => null }	PsiClass	psiClass
new ScalaRuntimeTypeEvaluator(null, expr, debuggerContext, ProgressManager.getInstance.getProgressIndicator) { override def typeCalculationFinished(psiType: PsiType): Unit = { val psiClass = psiType match { case tp: PsiClassType => //noinspection ScalaRedundantCast tp.resolve().asInstanceOf[PsiClass] case _ => null } nameRef.set(psiClass) semaphore.up() } }	ScalaRuntimeTypeEvaluator { def typeCalculationFinished(psiType: PsiType): Unit }	worker
nameRef.get	PsiClass	psiClass
helper.compile(fileText, module)	Array[(Any, String)]	compiled
0	Int	counter
"invoke"	String	generatedMethodName
ScalaCodeFragment(item.getText, context)	ScalaCodeFragment	fragment
originalContext	PsiElement	context
XDebuggerManager.getInstance(project).getCurrentSession	XDebugSession	session
session.asInstanceOf[XDebugSessionImpl].getValueMarkers	XValueMarkers[_, _]	markers
variablesText.length - 1	Int	offset
copy(file, physical = false)	PsiFile	nonPhysicalCopy
project.modulesWithScala.flatMap { module => val rootManager = ModuleRootManager.getInstance(module) Option(OrderEntryUtil.findJdkOrderEntry(rootManager, rootManager.getSdk)) }	IndexedSeq[JdkOrderEntry]	jdkEntries
context.getTextRange	TextRange	range
new TextWithImportsImpl(CodeFragmentKind.CODE_BLOCK, variablesText, "", getFileType)	TextWithImportsImpl	textWithImports
createCodeFragmentInner(textWithImports, context)	JavaCodeFragment	codeFragment
frameProxy.visibleVariableByName(myName + "$" + i)	LocalVariableProxyImpl	local
ProjectSettingsService.getInstance(project)	ProjectSettingsService	service
false	Boolean	stopped
pat.bindings.head	ScBindingPattern	bindingPattern
bindingPattern.name	String	name
codeFragment.findElementAt(offset)	PsiElement	newContext
mutable.Map[String, Value]()	mutable.Map[String, Value]	reverseMap
markupMap.collect { case (obj: ObjectReference, markup: ValueMarkup) if StringUtil.isJavaIdentifier(markup.getText) => val labelName = markup.getText + CodeFragmentFactoryContextWrapper.DEBUG_LABEL_SUFFIX reverseMap.put(labelName, obj) labelName }	IndexedSeq[Any]	names
evaluateWithFrames(withSimpleName) .orElse(evaluateWithFrames(parameterByIndex)) .orElse(evaluateWithFrames(withDollar))	Option[AnyRef]	result
myContext.getFrameProxy	StackFrameProxyImpl	frameProxy
evaluationContext.getProject	Project	project
context.getDebugProcess	DebugProcessImpl	process
DebuggerUtil.runtimeRefField(objRef.referenceType())	Option[Field]	field
names.map(n => s"val $n: AnyRef = _").mkString("\n")	String	text
Logger.getInstance("#org.jetbrains.plugins.scala.debugger.evaluation.evaluator.ScalaLocalVariableEvaluator")	Logger	LOG
new TextWithImportsImpl(CodeFragmentKind.CODE_BLOCK, expression.getText)	TextWithImportsImpl	textWithImports
mutable.Set[File]()	mutable.Set[Any]	tempFiles
new ScalaCodeFragmentFactory().createCodeFragment(textWithImports, expression, project)	JavaCodeFragment	codeFragment
inReadAction { val textWithImports = new TextWithImportsImpl(CodeFragmentKind.CODE_BLOCK, expression.getText) val codeFragment = new ScalaCodeFragmentFactory().createCodeFragment(textWithImports, expression, project) ScalaEvaluatorBuilder.build(codeFragment, ContextUtil.getSourcePosition(evaluationContext)) }	ExpressionEvaluator	evaluator
evaluator.evaluate(evaluationContext)	Value	value
new DebuggerManagerListener { override def sessionAttached(session: DebuggerSession): Unit = { if (EvaluatorCompileHelper.needCompileServer && project.hasScala) { CompileServerLauncher.ensureServerRunning(project) } } override def sessionDetached(session: DebuggerSession): Unit = { clearTempFiles() if (!ScalaCompileServerSettings.getInstance().COMPILE_SERVER_ENABLED && EvaluatorCompileHelper.needCompileServer) { CompileServerLauncher.ensureNotRunning(project) } } }	DebuggerManagerListener { def sessionDetached(session: DebuggerSession): Unit def sessionAttached(session: DebuggerSession): Unit }	listener
"!unknownName!"	String	unknownName
DebuggerUtil.getFunctionJVMSignature(function)	JVMName	myTargetMethodSignature
Key.create("SCALA_RUNTIME_TYPE_EVALUATOR")	Key[ScExpression => ScType]	KEY
Set("java.lang.Object", "scala.Any", "scala.AnyRef", "scala.AnyVal")	Set[Nothing]	stdTypeNames
constructor.getTextRange	TextRange	newContextRange
PsiManager.getInstance(project).findFile(file)	PsiFile	psiFile
copy(nonPhysicalCopy, physical = true)	PsiFile	physicalCopy
createExpressionWithContextFromText(element.name, ref.getContext, ref)	ScExpression	expr
unwrapped.asInstanceOf[Value].`type`	Type	jdiType
FileDocumentManager.getInstance.getDocument(file)	Document	document
classType.superclass	ClassType	superclass
createExpressionWithContextFromText(exprToEvaluate(p), ref.getContext, ref)	ScExpression	expr
new Processor[PsiElement] { override def process(e: PsiElement): Boolean = e match { case ElementType(ScalaTokenTypes.kPACKAGE | ScalaTokenTypes.kIMPORT) => false case _: PsiWhiteSpace => true case _ if PsiTreeUtil.getParentOfType(e, classOf[PsiComment]) != null => true case _ if PsiTreeUtil.getParentOfType(e, classOf[ScExpression], classOf[ScConstructorPattern], classOf[ScInfixPattern], classOf[ScClass]) != null => result = true false case _ => true } }	Processor[PsiElement]	processor
resolveResult.element	PsiNamedElement	elem
elem.getProject	Project	project
new ServerConnector(module, files, outputDir)	ServerConnector	connector
ListBuffer[String]()	ListBuffer[String]	errors
new Client { override def message(kind: Kind, text: String, source: Option[File], line: Option[Long], column: Option[Long]): Unit = { if (kind == Kind.ERROR) errors += text } override def deleted(module: File): Unit = {} override def progress(text: String, done: Option[Float]): Unit = {} override def isCanceled: Boolean = false override def debug(text: String): Unit = {} override def processed(source: File): Unit = {} override def trace(exception: Throwable): Unit = {} override def generated(source: File, module: File, name: String): Unit = {} }	Client	client
{ val clazz = PsiTreeUtil.getParentOfType(function, classOf[ScTemplateDefinition]) if (clazz == null) JVMNameUtil.getJVMRawText(unknownName) else DebuggerUtil.getClassJVMName(clazz, clazz.isInstanceOf[ScObject] || ValueClassType.isValueClass(clazz)) }	JVMName	myDeclaringClassName
new AsyncPromise[JList[_ <: BreakpointVariant]]()	AsyncPromise[Any]	promise
function match { case ScalaConstructor(_) => "<init>" case fun: ScFunction => ScalaNamesUtil.toJavaName(fun.name) case _ => unknownName }	String	funName
location.method()	Method	method
new RemoteServerRunner(project).buildProcess(arguments, client)	CompilationProcess	compilationProcess
parent match { case _: ScBlock | _: ScTemplateBody => false case _ => true }	Boolean	needBraces
Right(Seq("Compilation failed"))	Either[Array[(Any, String)], Seq[String]]	result
resolveResult.fromType match { case Some(ScThisType(clazz)) => clazz case Some(tp) => val project = elem.getProject tp.extractClass match { case Some(x) => x case None => getContextClass(elem) } case _ => getContextClass(elem) }	PsiElement	containingClass
expr match { case lit: ScLiteral => literalEvaluator(lit) case mc: ScMethodCall => scMethodCallEvaluator(mc) case ref: ScReferenceExpression => refExpressionEvaluator(ref) case t: ScThisReference => thisOrSuperEvaluator(t.reference, isSuper = false) case t: ScSuperReference => thisOrSuperEvaluator(t.reference, isSuper = true) case tuple: ScTuple => tupleEvaluator(tuple) case newTd: ScNewTemplateDefinition => newTemplateDefinitionEvaluator(newTd) case inf: ScInfixExpr => infixExpressionEvaluator(inf) case ScParenthesisedExpr(inner) => evaluatorFor(inner) case p: ScPrefixExpr => prefixExprEvaluator(p) case p: ScPostfixExpr => postfixExprEvaluator(p) case stmt: ScIf => ifStmtEvaluator(stmt) case ws: ScWhile => whileStmtEvaluator(ws) case doSt: ScDo => doStmtEvaluator(doSt) case block: ScBlock => blockExprEvaluator(block) case call: ScGenericCall => methodCallEvaluator(call, Nil, Map.empty) case stmt: ScAssignment => assignmentEvaluator(stmt) case stmt: ScTypedExpression => evaluatorFor(stmt.expr) case e => throw EvaluationException(s"This type of expression is not supported: ${e.getText}") }	Evaluator	innerEval
c => isScalaObject && c.isInstanceOf[ScObject]	PsiClass => Boolean	predicate
position.getLine	Int	line
doc.getLineStartOffset(line)	Int	startOffset
contextClass	PsiElement	current
0	Int	iterations
CharArrayUtil.shiftForward(doc.getCharsSequence, startOffset, " \t{")	Int	offset
sf.findElementAt(offset)	PsiElement	element
createExpressionWithContextFromText(s"{\n${prevParent.getText}\n}", prevParent.getContext, prevParent)	ScExpression	newBlock
if (needBraces) { val newBlock = createExpressionWithContextFromText(s"{\n${prevParent.getText}\n}", prevParent.getContext, prevParent) parent = prevParent.replace(newBlock) parent match { case bl: ScBlock => bl.statements.head case _ => throw EvaluationException("Could not compile local class in this context") } } else prevParent	ScBlockStatement	anchor
findClassesByQName(transformed, elementScope, fallbackToProjectScope = true)	Seq[PsiClass]	classes
createExpressionWithContextFromText(s"new $generatedClassName()", anchor.getContext, anchor)	ScExpression	constructorInvocation
fragment.getProject	ProjectContext	ctx
DumbService.getInstance(project)	DumbService	dumbService
NameTransformer.encode(fun.name)	String	transformed
fragment.children.filter(!_.isInstanceOf[ScImportStmt]).collect { case e @ (_: ScBlockStatement | _: ScMember) => evaluatorFor(e) }	Iterator[Evaluator]	childrenEvaluators
localClassText(fragment, generatedClassName)	String	classText
new SyntheticVariablesHolderEvaluator(null)	SyntheticVariablesHolderEvaluator	currentHolder
currentHolder	SyntheticVariablesHolderEvaluator	old
PsiManager.getInstance(project).findFile(position.getFile) match { case null => return emptyList case sf: ScalaFile => sf case _ => return emptyList }	ScalaFile	file
new SyntheticVariablesHolderEvaluator(currentHolder)	SyntheticVariablesHolderEvaluator	newEvaluator
null	Evaluator	result
ref.refName	String	refText
psiMethod.map { case f: ScMethodLike => DebuggerUtil.getFunctionJVMSignature(f) case m => JVMNameUtil.getJVMSignature(m) }	Option[JVMName]	expectedSignature
localFunName()	String	name
createTemplateDefinitionFromText(classText, context.getContext, context).asInstanceOf[ScClass]	ScClass	classToInsert
parent.addBefore(classToInsert, anchor)	PsiElement	insertedClass
if (fun.isSynthetic) fun.containingClass else getContextClass(fun)	PsiElement	containingClass
parent.addBefore(constructorInvocation, anchor)	PsiElement	insertedConstructor
location.method	Method	method
containingClass match { case obj: ScObject if isStable(obj) => stableObjectEvaluator(obj) case _: ScTrait => thisOrSuperEvaluator(None, isSuper = true) case _ => val (outerClass, iters) = findContextClass(e => e == null || e == containingClass) if (outerClass != null) new ScalaThisEvaluator(iters) else null }	Evaluator	thisEvaluator
DebuggerUtil.localParamsForFunDef(fun)	Seq[ScTypedDefinition]	locals
ScalaPositionManager.lambdasOnLine(file, line)	Seq[PsiElement]	lambdas
SourcePosition.createFromLine(file, line).getElementAt	PsiElement	elementAtLine
inReadAction(if (m.isConstructor) "<init>" else ScalaNamesUtil.toJavaName(m.name))	String	javaName
Nil	List[ScalaLineBreakpointType.this.JavaBPVariant]	res
DebuggerUtil.getContainingMethod(elementAtLine)	Option[PsiElement]	method
stmtsForTemplate(pc.containingClass)	Seq[ScBlockStatement]	statements
b.caseClauses.get	ScCaseClauses	clauses
getContainingMethod(breakpoint)	PsiElement	method
breakpoint.getSourcePosition	SourcePosition	position
argEvaluators ++ locals.map(fromLocalArgEvaluator)	IndexedSeq[Evaluator]	evaluators
first.map(createSourcePosition)	Option[SourcePosition]	firstPos
last.map(createSourcePosition)	Option[SourcePosition]	lastPos
ScalaPositionManager.lambdasOnLine(position.getFile, position.getLine)	Seq[PsiElement]	lambdas
DebuggerUtil.getFunctionJVMSignature(fun)	JVMName	signature
DebuggerUtil.getSourcePositions(fun.getNavigationElement)	Set[SourcePosition]	positions
localFunctionIndex(fun)	Int	idx
DumbService.getInstance(lineBp.getProject)	DumbService	dumbService
breakpoint.getXBreakpoint	XBreakpoint[_]	xBreakpoint
tp.extendsBlock.templateBody.toSeq .flatMap(tb => tb.members ++ tb.exprs)	IndexedSeq[ScalaPsiElement]	membersAndExprs
new ScalaPositionManagerCaches(debugProcess)	ScalaPositionManager.ScalaPositionManagerCaches	caches
DebuggerUtil.getSignificantElement(elem)	PsiElement	significantElem
doc.getLineStartOffset(line)	Int	lineStart
JVMNameUtil.getJVMRawText(qual)	JVMName	jvm
new TextRange(lineStart, doc.getLineEndOffset(line))	TextRange	lineRange
DebuggerUtil.isScala(typeComponent.declaringType(), default = false)	Boolean	isScala
typeComponent.virtualMachine	VirtualMachine	machine
typeComponent match { case _ if hasSpecialization(typeComponent) && !isMacroDefined(typeComponent) => true case m: Method if m.isConstructor && ScalaPositionManager.isAnonfunType(m.declaringType()) => true case m: Method if isDefaultArg(m) => true case m: Method if isForwarder(m) => true case m: Method if m.name().endsWith("$adapted") => true case m: Method if ScalaPositionManager.isIndyLambda(m) => false case m: Method if isAccessorInDelayedInit(m) => true case f: Field if f.name().startsWith("bitmap$") => true case _ => val machine: VirtualMachine = typeComponent.virtualMachine machine != null && machine.canGetSyntheticAttribute && typeComponent.isSynthetic }	Boolean	result
refType.getOrElse(tc.declaringType())	ReferenceType	referenceType
if (obj.isPackageObject) obj.qualifiedName + ".package" else obj.getQualifiedNameForDebugger	String	qualName
maxElementOnLine(element, lineStart)	PsiElement	maxElement
new Range[Integer](line, line)	Range[Any]	lineToSkip
new TargetCollector(lineToSkip, intersectsWithLineRange)	ScalaSmartStepIntoHandler.this.TargetCollector	collector
ElementScope(debugProcess.getProject, debugProcess.getSearchScope)	ElementScope	debugProcessScope
m.declaringType	ReferenceType	refType
m.location().lineNumber()	Int	line
try m.bytecodes() catch {case _: Throwable => return false}	Array[Byte]	bytecodes
bytecodes(i)	Byte	instr
i + 3	Int	nextIdx
bytecodes(nextIdx)	Byte	nextInstr
ct.virtualMachine()	VirtualMachine	vm
qualName.split('.').map(NameTransformer.encode).mkString(".") + "$"	String	qual
NameTransformer.encode(obj.name)	String	objName
context.getFrameProxy	StackFrameProxy	frameProxy
frameProxy.location()	Location	location
s"($qualText).concat(_root_.java.lang.String.valueOf(${arguments.head.getText}))"	String	exprText
PositionUtil.getContextElement(context)	PsiElement	contextElement
createExpressionWithContextFromText(exprText, ref.getContext, ref)	ScExpression	expr
startElem.getParent	PsiElement	parent
contextElement.getLanguage.isKindOf(ScalaLanguage.INSTANCE)	Boolean	isScala
ScalaPositionManager.instance(debugProcess) match { case Some(m) => m case None => return true }	ScalaPositionManager	positionManager
ArrayBuffer[SmartStepTarget]()	ArrayBuffer[SmartStepTarget]	result
templ.extendsBlock	ScExtendsBlock	extBl
ScalaNamesUtil.toJavaName(funName)	String	encoded
DebuggerUtil.generatesAnonClass(templ)	Boolean	generateAnonClass
DebuggerSettings.getInstance().SKIP_SYNTHETIC_METHODS && syntheticProvider.isSynthetic(location.method())	Boolean	synth
synth.name	String	name
ScalaPsiElementFactory.createExpressionWithContextFromText(name, context, context).asInstanceOf[ScReferenceExpression]	ScReferenceExpression	ref
Try(evaluationContext.getFrameProxy.location().method()).toOption	Option[Method]	method
anchor match { case member: ScMember => member.getContainingClass match { case null => None case containingClass => Some(new MemberAnchorLocation(member, InsideClassLocation(containingClass))) } case _ => None }	Option[Location.MemberAnchorLocation]	maybeMemberLocation
arguments.map(evaluatorFor(_))	IndexedSeq[Evaluator]	argEvaluators
customizedLocations(refType, line)	Seq[Location]	customized
inReadAction(sourcePosition.getElementAt)	PsiElement	element
qualOpt match { case None => new ScalaThisEvaluator() case Some(qual) => evaluatorFor(qual) }	Evaluator	eval
new CollectingProcessor(elem)	CollectingProcessor	completionProcessor
(location.declaringType(), customLine)	(ReferenceType, Int)	key
JVMNameUtil.getJVMRawText("(Ljava/lang/Object;Ljava/lang/Object;)Z")	JVMName	rawText
new Regex("(.*)\\*(.*)")	Regex	AsteriskPattern
ref.resolve() match { case m: PsiMethod if !generateAnonClass => m case _ => new FakeAnonymousClassConstructor(templ, ref.refName) }	PsiMethod	method
tpe.projectContext	ProjectContext	ctx
lineToCustomizedLocationCache.getOrElse(key, Seq.empty)	Seq[Location]	old
s"${ref.refName}."	String	prefix
ref.qualifier.flatMap(_.implicitElement()).isDefined	Boolean	isActuallyImplicit
if (isActuallyImplicit) "implicit " else null	Null	prefix
findElementByReferenceType(refType).orNull	PsiElement	generatingElem
generatingElem.getContainingFile	PsiFile	containingFile
PsiDocumentManager.getInstance(debugProcess.getProject).getDocument(containingFile)	Document	document
ref.getParent match { case gen: ScGenericCall => gen.typeArgs match { case Some(args) => args.typeArgs match { case Seq(arg) => arg.calcType case _ => Nothing } case None => Nothing } case _ => Nothing }	ScType	tp
location.method().bytecodes()	Array[Byte]	bytecodes
location.codeIndex()	Long	index
pat match { case cp: ScConstructorPattern => Some(cp.ref) case ip: ScInfixPattern => Some(ip.operation) case _ => None }	Option[ScStableCodeReference]	ref
DebuggerUtil.getJVMQualifiedName(tp)	JVMName	jvmName
ScalaPositionManager.checkedLineNumber(location)	Int	lineNumber
Set("Seq", "Array", "List", "Vector", "Set", "HashSet", "Map", "HashMap", "Iterator", "Option")	Set[Nothing]	TraversableClassNames
s"${r.refName}."	String	prefix
SourcePosition.createFromLine(containingFile, lineNumber)	SourcePosition	linePosition
qual match { case Some(q) => evaluatorFor(q) case None => throw EvaluationException(ScalaBundle.message("array.instance.is.not.found", name)) }	Evaluator	qualEval
nonWhitespaceElement(linePosition)	PsiElement	elem
declaration.entity	Entity	entity
location.isInLocalScope	Boolean	isLocal
new ScalaArrayAccessEvaluator(qualEval, argEvaluators.head)	ScalaArrayAccessEvaluator	leftEval
ScCompoundType(comps, defs, Map.empty)	ScCompoundType	noAliases
DebuggerUtil.getSignificantElement(generatingElem)	PsiElement	significantElem
elementStartLine(significantElem)	Int	lineNumber
try method.bytecodes() catch {case _: Throwable => return }	Array[Byte]	bytecodes
iconst_0Loc.codeIndex().toInt	Int	codeIndex
ref.getContext match { case gen: ScGenericCall => gen.arguments.head.`type`().toOption .flatMap(_.extractClass) .map(DebuggerUtil.getClassJVMName(_)) case _ => None }	Option[JVMName]	maybeClazzJVMName
new ScalaTypeEvaluator(DebuggerUtil.getJVMQualifiedName(classType))	ScalaTypeEvaluator	valueClassType
DebuggerUtil.getJVMStringForType(innerType, isParam = true)	String	innerJvmName
readIstore(codeIndex + 1, bytecodes) match { case Seq() => Nil case istoreCode => iloadCode(istoreCode) }	Seq[Byte]	bytes
JVMNameUtil.getJVMRawText(s"($innerJvmName)V")	JVMName	signature
caseLineLocations.filter(l => isIconst_0(l.codeIndex().toInt, bytecodes))	Seq[Location]	iconst_0Locations
location.codeIndex().toInt	Int	codeIndex
exprsForP.map(_.`type`().getOrAny)	IndexedSeq[ScType]	argTypes
readStoreCode(codeIndex, bytecodes)	Seq[Byte]	code
for { loc <- location.toOption psiFile <- getPsiFileByReferenceType(debugProcess.getProject, loc.declaringType).toOption lineNumber = exactLineNumber(location) if lineNumber >= 0 } yield { calcPosition(psiFile, location, lineNumber).getOrElse { SourcePosition.createFromLine(psiFile, lineNumber) } }	Option[SourcePosition]	position
caseLinesLocations.map(_.filter(!customizedLocationsCache.contains(_)))	IndexedSeq[Seq[Location]]	notCustomizedYet
notCustomizedYet.filter(_.size > 1)	IndexedSeq[Seq[Location]]	repeating
file.getUserData(ScalaCompilingEvaluator.classNameKey)	String	generatedClassName
repeating.map(_.last)	IndexedSeq[Location]	lastLocations
if (argTypes.isEmpty) expectedType.canonicalText else argTypes.lub().canonicalText	String	argTypeText
if (exprsForP.nonEmpty) exprsForP.sortBy(_.getTextRange.getStartOffset).map(_.getText).mkString(".+=(", ").+=(", ").result()") else ""	String	argsText
s"_root_.scala.collection.Seq.newBuilder[$argTypeText]$argsText"	String	exprText
createExpressionWithContextFromText(exprText, context, context)	ScExpression	newExpr
fun.effectiveParameterClauses.lastOption match { case Some(clause) if clause.isImplicit => clause.effectiveParameters case _ => Seq.empty }	Seq[ScParameter]	implicitParameters
implicitParameters.indexOf(param)	Int	i
getPsiFileByReferenceType(file.getProject, refType) == file	Boolean	sameFile
mutable.ArrayBuffer.empty[ReferenceType]	ArrayBuffer[ReferenceType]	exactClasses
mutable.Set[NamePattern]()	mutable.Set[ScalaPositionManager.NamePattern]	namePatterns
None	Option[String]	packageName
getInstance()	ScalaApplicationSettings	settings
for (loc <- lastLocations; code <- storeCode(loc)) yield (loc, code)	IndexedSeq[(Location, Seq[Byte])]	withStoreCode
positionsOnLine(file, position.getLine)	Seq[PsiElement]	possiblePositions
- util.Arrays.binarySearch(listModel.toArray, pattern) - 1	Int	index
ScalaProjectSettingsUtil.getPatternValidator	InputValidator	validator
substitutor(clazz.`type`().get)	ScType	argType
inReadAction { val completionProcessor = new CollectingProcessor(elem) PsiTreeUtil.treeWalkUp(completionProcessor, elem, null, ScalaResolveState.empty) completionProcessor.candidates .filter(srr => !alreadyCollected.asScala.map(ScalaParameterNameAdjuster.fixName).contains(srr.name)) .filter(canEvaluate(_, elem)) }	Array[ScalaResolveResult]	initialCandidates
Messages.showInputDialog(parent, inputMessage, inputTitle, Messages.getWarningIcon, "", validator)	String	pattern
ScalaProjectSettingsUtil.getPackageValidator	InputValidator	validator
loadCode(codes.head)	Seq[Byte]	bytes
possiblePositions.map(findGeneratingClassOrMethodParent)	IndexedSeq[PsiElement]	onTheLine
locations.filter(!customizedLocationsCache.contains(_))	Seq[Location]	filtered
try method.bytecodes() catch { case _: Throwable => return }	Array[Byte]	bytecodes
onTheLine.head.withParentsInFile	Iterator[PsiElement]	nonStrictParents
filtered.tail	Seq[Location]	tail
ScalaPsiUtil.nameContext(elem)	PsiElement	context
if (isCompiledWithIndyLambdas(file)) { val nonStrictParents = onTheLine.head.withParentsInFile nonStrictParents.find(p => ScalaEvaluatorBuilderUtil.isGenerateNonAnonfunClass(p)) } else None	Option[PsiElement]	nonLambdaParent
tail.filter { l => readLoadCode(l.codeIndex().toInt, bytecodes).nonEmpty }	Seq[Location]	loadExpressionValueLocations
initialCandidates.filter(canEvaluateLong(_, elem, evaluationContext))	Array[ScalaResolveResult]	candidates
v.clone()	TextAttributes	result
getSpecificNameForDebugger(td)	String	qName
"..."	String	foldedString
false	Boolean	hyperlink
false	Boolean	highlighted
mutable.SortedSet()(Ordering.by[ScalaResolveResult, Int](_.getElement.getTextRange.getStartOffset))	mutable.SortedSet[ScalaResolveResult]	sorted
new XExpressionImpl(s, ScalaLanguage.INSTANCE, "")	XExpressionImpl	xExpr
PsiTreeUtil.getParentOfType(place, classOf[ScPatternDefinition]) match { case null => null case LazyVal(lzy) => lzy case _ => null }	ScPatternDefinition	lazyVal
tail.filter { l => returnCodes.contains(bytecodes(l.codeIndex().toInt)) }	Seq[Location]	returnLocations
Option(scheme.getAttributes(EditorColors.FOLDED_TEXT_ATTRIBUTES)) .map(adjusted)	Option[TextAttributes]	plainFolded
toTextWithImports(name)	TextWithImports	twi
attributes.clone()	TextAttributes	result
new ScalaCodeFragmentFactory().createCodeFragment(twi, place, evaluationContext.getProject)	JavaCodeFragment	codeFragment
evaluationContext.getFrameProxy.location()	Location	location
ScalaPositionManager.instance(evaluationContext.getDebugProcess).map(_.getSourcePosition(location))	Option[SourcePosition]	sourcePosition
0	Int	DefaultGroup
10	Int	MultilineLevel
td match { case _: ScTrait => qName.stripSuffix("$class") :: Nil case c: ScClass if ValueClassType.isValueClass(c) => s"$qName$$" :: Nil case c if isDelayedInit(c) => s"$qName$delayedInitBody" :: Nil case _ => Nil }	List[Any]	additional
Key.create[AnnotatorHints]("AnnotatorHints")	Key[AnnotatorHints]	AnnotatorHintsKey
possibleLocations.filter(loc => isGoto(loc.codeIndex().toInt, bytecodes))	Seq[Location]	gotos
inReadAction { val twi = toTextWithImports(name) val codeFragment = new ScalaCodeFragmentFactory().createCodeFragment(twi, place, evaluationContext.getProject) val location = evaluationContext.getFrameProxy.location() val sourcePosition = ScalaPositionManager.instance(evaluationContext.getDebugProcess).map(_.getSourcePosition(location)) if (sourcePosition.isEmpty) throw EvaluationException("Debug process is detached.") ScalaEvaluatorBuilder.build(codeFragment, sourcePosition.get) match { case _: ScalaCompilingExpressionEvaluator => throw EvaluationException("Don't use compiling evaluator here") case e => e } }	ExpressionEvaluator	evaluator
srr.getElement	PsiNamedElement	named
inReadAction(named.name)	String	name
ScalaEvaluatorBuilderUtil.getContextClass(place, strict = false)	PsiElement	contextClass
getGroup(element)	Option[Int]	g
ScalaEvaluatorBuilderUtil.getContextClass(named)	PsiElement	containingClass
element	PsiElement	e
0	Int	lines
element.getPrevSibling	PsiElement	e
ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	placesToSearch
getGroup(e)	Option[Int]	g
caseClauses.getParent match { case ms: ScMatch => ms.expression.map(elementStartLine) case (_: ScBlock) childOf (_: ScTry) => return //todo: handle try statements case b: ScBlock => Some(elementStartLine(b)) case _ => None }	Option[Int]	baseLine
placesToSearch.map(new LocalSearchScope(_))	IndexedSeq[LocalSearchScope]	scopes
new PsiSearchHelperImpl(place.getManager.asInstanceOf[PsiManagerEx])	PsiSearchHelperImpl	helper
false	Boolean	used
onTheLine ++ nonLambdaParent	IndexedSeq[PsiElement]	sourceImages
context.getContext match { case _: ScTemplateBody | _: ScEarlyDefinitions => ScalaPsiUtil.getContextOfType(context, true, classOf[PsiClass]) case _ if context.isInstanceOf[ScClassParameter] => ScalaPsiUtil.getContextOfType(context, true, classOf[PsiClass]) case _ => null }	PsiElement	clazz
caseClauses.caseClauses.map(elementStartLine)	IndexedSeq[Int]	caseLines
new TextOccurenceProcessor { override def execute(element: PsiElement, offsetInElement: Int): Boolean = { used = true false } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
NamePattern.forElement(elem)	ScalaPositionManager.NamePattern	namePattern
fn.superSignaturesIncludingSelfType	Seq[TermSignature]	sigs
ScalaPsiUtil.nameContext(named) match { case nc@(_: ScForBinding | _: ScGenerator) => Option(PsiTreeUtil.getParentOfType(nc, classOf[ScFor])) case _ => None }	Option[Nothing]	forStmt
containingFile.findElementAt(offset)	PsiElement	sourceElement
element.getTextRange.getStartOffset	Int	startOffset
if (namePatterns.isEmpty) Nil else filterAllClasses(c => hasLocations(c, position) && namePatterns.exists(_.matches(c)), packageName)	Seq[ReferenceType]	foundWithPattern
exactClasses.distinct	ArrayBuffer[ReferenceType]	distinctExactClasses
caseLinesLocations.flatten	IndexedSeq[Nothing]	flattenCaseLines
generatingElem.breadthFirst().collect { case cc: ScCaseClauses => cc }	Iterator[ScCaseClauses]	allCaseClauses
0x03.toByte	Byte	iconst_0
0x3b.toByte	Byte	istore_0
0x3c.toByte	Byte	istore_1
0x3d.toByte	Byte	istore_2
0x3e.toByte	Byte	istore_3
0x36.toByte	Byte	istore
0x1a.toByte	Byte	iload_0
0x1b.toByte	Byte	iload_1
0x1c.toByte	Byte	iload_2
0x1d.toByte	Byte	iload_3
0x15.toByte	Byte	iload
0x19.toByte	Byte	aload
0x2a.toByte	Byte	aload_0
0x2b.toByte	Byte	aload_1
0x2c.toByte	Byte	aload_2
0x2d.toByte	Byte	aload_3
0x3a.toByte	Byte	astore
sourceElement.parent	Option[PsiElement]	maybeParent
0x4b.toByte	Byte	astore_0
0x4c.toByte	Byte	astore_1
0x4d.toByte	Byte	astore_2
0x4e.toByte	Byte	astore_3
0x18.toByte	Byte	dload
0x26.toByte	Byte	dload_0
0x27.toByte	Byte	dload_1
0x28.toByte	Byte	dload_2
0x29.toByte	Byte	dload_3
0x39.toByte	Byte	dstore
resolveResults(i) match { case ScalaResolveResult(clazz: ScTrait, substitutor) if clazz.qualifiedName == "scala.reflect.ClassManifest" => val argType = substitutor(clazz.`type`().get) argType match { case ParameterizedType(_, Seq(paramType)) => classManifestText(paramType) case _ => throw EvaluationException(cannotFindMessage) } case ScalaResolveResult(clazz: ScTrait, substitutor) if clazz.qualifiedName == "scala.reflect.ClassTag" => val argType = substitutor(clazz.`type`().get) argType match { case ParameterizedType(_, Seq(arg)) => classTagText(arg) case _ => throw EvaluationException(cannotFindMessage) } case ScalaResolveResult(elem, _) => val context = ScalaPsiUtil.nameContext(elem) val clazz = context.getContext match { case _: ScTemplateBody | _: ScEarlyDefinitions => ScalaPsiUtil.getContextOfType(context, true, classOf[PsiClass]) case _ if context.isInstanceOf[ScClassParameter] => ScalaPsiUtil.getContextOfType(context, true, classOf[PsiClass]) case _ => null } clazz match { case o: ScObject if isStable(o) => o.qualifiedName + "." + elem.name case _: ScObject => //todo: It can cover many cases! throw EvaluationException(ScalaBundle.message("implicit.parameters.from.dependent.objects")) case _ => elem.name //from scope } }	String	exprText
0x47.toByte	Byte	dstore_0
0x48.toByte	Byte	dstore_1
0x49.toByte	Byte	dstore_2
0x4a.toByte	Byte	dstore_3
0x17.toByte	Byte	fload
0x22.toByte	Byte	fload_0
0x23.toByte	Byte	fload_1
0x24.toByte	Byte	fload_2
0x25.toByte	Byte	fload_3
0x38.toByte	Byte	fstore
0x43.toByte	Byte	fstore_0
0x44.toByte	Byte	fstore_1
0x45.toByte	Byte	fstore_2
createExpressionWithContextFromText(exprText, owner.getContext, owner)	ScExpression	newExpr
0x46.toByte	Byte	fstore_3
0x16.toByte	Byte	lload
0x1e.toByte	Byte	lload_0
0x1f.toByte	Byte	lload_1
0x20.toByte	Byte	lload_2
0x21.toByte	Byte	lload_3
0x37.toByte	Byte	lstore
0x3f.toByte	Byte	lstore_0
maybeParent.flatMap { case self: ScSelfInvocation => self.bind case _ => None }	Option[PsiElement]	maybeResult
0x40.toByte	Byte	lstore_1
0x41.toByte	Byte	lstore_2
0x42.toByte	Byte	lstore_3
0xB8.toByte	Byte	invokeStatic
0xB0.toByte	Byte	areturn
0xAF.toByte	Byte	dreturn
0xAE.toByte	Byte	freturn
0xAC.toByte	Byte	ireturn
0xAD.toByte	Byte	lreturn
0xB1.toByte	Byte	voidReturn
0xA7.toByte	Byte	goto
if (containingBlock != null) { containingBlock.depthFirst().collect { case ref: ScReferenceExpression if ref.qualifier.isEmpty => ref.refName }.toSet } else Set.empty	Set[String]	usedNames
containingFile.findReferenceAt(sourceElement.getTextRange.getStartOffset)	PsiReference	reference
EditSourceUtil.getDescriptor(element)	Navigatable	descriptor
NameTransformer.encode(resolve.asInstanceOf[PsiNamedElement].name)	String	name
new ScalaLocalVariableEvaluator(name, fileName)	ScalaLocalVariableEvaluator	evaluator
super.execute(namedElement)	Boolean	result
candidate.getElement	PsiNamedElement	candElem
Array[PsiElement]()	Array[PsiElement]	empty
ScalaPsiUtil.nameContext(candElem) match { case cc: ScCaseClause => cc.pattern.getOrElse(cc) case other => other }	PsiElement	candElemContext
DebuggerUtil.localParamsForFunDef(fun).indexOf(elem)	Int	locIndex
fun.effectiveParameterClauses.flatMap(_.effectiveParameters)	IndexedSeq[ScParameter]	funParams
paramIndex(funDef, getContextClass(fun), resolve)	Int	pIndex
getOverridesImplementsMarkers(element) .orElse(getImplementsSAMTypeMarker(element)) .orNull	LineMarkerInfo[_ <: PsiElement]	lineMarkerInfo
new ScalaTypeEvaluator(JVMNameUtil.getContextClassJVMQualifiedName(SourcePosition.createFromElement(field)))	ScalaTypeEvaluator	eval
function.recursiveReferencesGrouped	statements.RecursiveReferences	references
evaluatorFor(qual)	Evaluator	qualEvaluator
thisOrImportedQualifierEvaluator(ref)	Evaluator	evaluator
PsiTreeUtil.firstChild(element).toOption.getOrElse(element)	PsiElement	leaf
member match { case d: ScDeclaredElementsHolder => d.declaredElements.filterBy[ScNamedElement] case param: ScClassParameter => Seq(param) case ta: ScTypeAlias => Seq(ta) case _ => Seq.empty }	Seq[ScNamedElement]	namedElems
Set("scala.Function", "scala.PartialFunction", "java.util.function")	Set[String]	trivialSAMs
typed.`type`()	result.TypeResult	res
res.getOrElse(return null)	ScType	tp
method match { case fun: ScMethodLike => fun.effectiveParameterClauses.flatMap(_.parameters) case m: PsiMethod => m.parameters case _ => return arguments }	Seq[PsiParameter]	params
template.supers.filterNot((x: PsiClass) => ignored.contains(x.qualifiedName))	Seq[PsiClass]	supers
element.parent.exists { case _: ScReference => false case _ => true }	Boolean	notReference
file.findElementAt(offset)	PsiElement	el
el	PsiElement	elOrig
d.declaredElements	Seq[PsiNamedElement]	elements
ScalaBundle.message("type.parameter.value.class.may.not.be.specialized")	String	message
method.superSignaturesIncludingSelfType	Seq[TermSignature]	signatures
reference match { case DynamicResolveProcessor.DynamicReference(results) => results.toSet[ResolveResult] .map(_.getElement) .filterNot(_ == null) case referenceElement: ScReference => referenceElement.multiResolveScala(incomplete = false) .toSet[ScalaResolveResult] .flatMap { case ScalaResolveResult(pkg: ScPackage, _) => packageCase(pkg, maybeParent) case result => regularCase(result) } case ResolvesTo(resolved) => Set(resolved) case _ => return null }	Iterable[PsiElement] with (Int with PsiElement => Any)	targets
extractClassName(signatures)	Option[String]	maybeClass
overridingMember	ScalaMarkerType	markerType
nonWhitespaceElement(position)	PsiElement	element
result.getActualElement	PsiNamedElement	actualElement
boxArguments(arguments.map(evaluatorFor(_)), method)	Seq[Evaluator]	argEvals
debugProcess.getRequestsManager	RequestManager	reqManager
pkg.findPackageObject(pkg.getResolveScope)	Option[ScObject]	maybePackageObject
DebuggerUtil.getSourcePositions(method.getNavigationElement)	Set[SourcePosition]	methodPosition
ScalaPsiUtil.superValsSignatures(param, withSelfType = true)	Seq[TermSignature]	signatures
ScalaPsiUtil.superValsSignatures(cParam, withSelfType = true)	Seq[TermSignature]	signatures
JVMNameUtil.getJVMSignature(method)	JVMName	signature
boxEvaluator(evaluatorFor(qual))	Evaluator	boxEval
new ScalaTypeEvaluator(JVMNameUtil.getContextClassJVMQualifiedName(SourcePosition.createFromElement(method)))	ScalaTypeEvaluator	eval
mutable.HashSet[NavigatablePsiElement]((if (el != null && elements.contains(el.asInstanceOf[ScTypedDefinition])) { ScalaPsiUtil.superValsSignatures(el.asInstanceOf[ScTypedDefinition], withSelfType = true) } else ScalaPsiUtil.superValsSignatures(elements.head, withSelfType = true)).flatMap(_.namedElement match { case n: NavigatablePsiElement => Some(n) case _ => None }): _*)	mutable.HashSet[NavigatablePsiElement]	supers
args.map(evaluatorFor(_))	IndexedSeq[Evaluator]	argEvals
NameTransformer.encode(ref.refName)	String	name
mutable.HashSet[NavigatablePsiElement](func.superSignaturesIncludingSelfType.flatMap(_.namedElement match { case n: NavigatablePsiElement => Some(n) case _ => None }): _*)	mutable.HashSet[NavigatablePsiElement]	supers
classPreparePattern + nestedTypesSuffix	String	nestedTypesPattern
ScalaPsiUtil.superTypeMembers(d, withSelfType = true)	Seq[PsiNamedElement]	superTypeMembers
new Ref[String](null)	Ref[String]	qName
clauses.flatMap(_.effectiveParameters).map(Parameter(_))	IndexedSeq[Parameter]	parameters
new Ref[ClassPrepareRequestor](null)	Ref[ClassPrepareRequestor]	waitRequestor
for { _ <- maybePackageObject parent <- maybeParent dot <- Option(parent.getNextSiblingNotWhitespaceComment) if dot.getNode.getElementType == tDOT segment <- Option(dot.getNextSiblingNotWhitespaceComment) } yield segment	Option[PsiElement]	maybeSegment
findReferenceTypeSourceImage(position)	PsiElement	sourceImage
isInsideMacro(nonWhitespaceElement(position))	Boolean	insideMacro
Map( istore_0 -> iload_0, istore_1 -> iload_1, istore_2 -> iload_2, istore_3 -> iload_3, astore_0 -> aload_0, astore_1 -> aload_1, astore_2 -> aload_2, astore_3 -> aload_3, dstore_0 -> dload_0, dstore_1 -> dload_1, dstore_2 -> dload_2, dstore_3 -> dload_3, fstore_0 -> fload_0, fstore_1 -> fload_1, fstore_2 -> fload_2, fstore_3 -> fload_3, lstore_0 -> lload_0, lstore_1 -> lload_1, lstore_2 -> lload_2, lstore_3 -> lload_3 )	Map[Byte, Byte]	oneByteCodes
getSpecificNameForDebugger(typeDef)	String	specificName
oneByteCodes.values.toSet	Set[Byte]	oneByteLoadCodes
oneByteCodes.keySet	Set[Byte]	oneByteStoreCodes
Parameter(param)	Parameter	p
holder.createErrorAnnotation(element.keyword, error)	Annotation	annotation
inReadAction { positionsOnLine(file, position.getLine).map(SourcePosition.createFromElement) }	IndexedSeq[SourcePosition]	possiblePositions
element.method.getOrElse { val error = ScalaBundle.message("return.outside.method.definition") val annotation: Annotation = holder.createErrorAnnotation(element.keyword, error) annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL) return }	ScFunctionDefinition	function
nonLambdaName(refType)	String	name
name.lastIndexOf('.')	Int	lastDot
ScalaPsiUtil.superTypeMembers(ta, withSelfType = true)	Seq[PsiNamedElement]	superMembers
ScalaPsiUtil.superTypeMembers(ta, withSelfType = true)	Seq[PsiNamedElement]	elements
superMembers.headOption.collect { case ContainingClass(aClass) => aClass }	Option[PsiClass]	maybeClass
overridingMember	ScalaMarkerType	typez
pattern	ProjectContext	ctx
Map( istore -> iload, astore -> aload, dstore -> dload, fstore -> fload, lstore -> lload )	Map[Byte, Byte]	twoBytesCodes
twoBytesCodes.values.toSet	Set[Byte]	twoBytesLoadCodes
twoBytesCodes.keySet	Set[Byte]	twoBytesStoreCodes
Set(areturn, dreturn, freturn, ireturn, lreturn, voidReturn)	Set[Byte]	returnCodes
bytecodes(codeIndex)	Byte	bytecode
signatures.flatMap(sigToNavigatableElement).toArray	Array[NavigatablePsiElement]	superMembers
widen(ScalaType.expandAliases(exprType).getOrElse(exprType))	ScType	exTp
file.findElementAt(element.getTextRange.getEndOffset)	PsiElement	nextElement
ClassInheritorsSearch.search(aClass, false).findFirst.toOption	Option[PsiClass]	inheritor
aClass.nameId.getTextRange	TextRange	range
file.findElementAt(position.getOffset)	PsiElement	firstElement
supers.iterator	Iterator[TermSignature]	iter
iter.next()	TermSignature	s
_patType.removeAliasDefinitions()	ScType	patType
defaultArgIndex.toInt - 1	Int	paramNumber
!matchesPattern(exTp, patType) && isNeverSubType(exTp, patType)	Boolean	neverMatches
element.expr.toSet[ScExpression] .flatMap(_.getTypeAfterImplicitConversion().importsUsed)	IndexedSeq[ImportUsed]	importUsed
holder.createWarningAnnotation(valKeyword, ScalaBundle.message("generator.val.keyword.removed"))	Annotation	annotation
s"$topic parameters may not be call-by-name"	String	message
positionsOnLine(file, lineNumber)	Seq[PsiElement]	possiblePositions
location.method()	Method	currentMethod
lambdasOnLine(file, lineNumber)	Seq[PsiElement]	lambdas
indyLambdaMethodsOnLine(location.declaringType(), lineNumber)	Seq[Method]	methods
ScalaPsiUtil.superTypeMembers(ta, withSelfType = true)	Seq[PsiNamedElement]	superElements
superElements.collect { case ne: NavigatablePsiElement => ne }.toArray	Array[NavigatablePsiElement]	navigatable
methods.zip(lambdas).toMap	Map[Method, PsiElement]	methodsToLambdas
generator.nextSiblings .takeWhile(!_.isInstanceOf[ScGenerator])	Iterator[PsiElement]	followingEnumerators
findElementByReferenceType(location.declaringType())	Option[PsiElement]	generatingPsiElem
ScalaMarkerType( element => namedParent(element) .flatMap { case method: ScFunction => val signatures = method.superSignaturesIncludingSelfType val maybeClass = extractClassName(signatures) val key = if (GutterUtil.isOverrides(element, signatures)) "overrides.method.from.super" else "implements.method.from.super" maybeClass.map(ScalaBundle.message(key, _)) case param: ScClassParameter => val signatures = ScalaPsiUtil.superValsSignatures(param, withSelfType = true) val maybeClass = extractClassName(signatures) val key = if (GutterUtil.isOverrides(element, signatures)) "overrides.val.from.super" else "implements.val.from.super" maybeClass.map(ScalaBundle.message(key, _)) case v: ScValueOrVariable => val bindings = v.declaredElements.filter(_.name == element.getText) val signatures = bindings.flatMap(ScalaPsiUtil.superValsSignatures(_, withSelfType = true)) val maybeClass = extractClassName(signatures) val key = if (GutterUtil.isOverrides(element, signatures)) "overrides.val.from.super" else "implements.val.from.super" maybeClass.map(ScalaBundle.message(key, _)) case ta: ScTypeAlias => val superMembers = ScalaPsiUtil.superTypeMembers(ta, withSelfType = true) val maybeClass = superMembers.headOption.collect { case ContainingClass(aClass) => aClass } maybeClass.map(cls => ScalaBundle.message("overrides.type.from.super", cls.name)) case _ => None } .orNull, (event, element) => namedParent(element).collect { case method: ScFunction => navigateToSuperMethod(event, method, includeSelf = false) case param: ScClassParameter => val signatures = ScalaPsiUtil.superValsSignatures(param, withSelfType = true) val superMembers = signatures.flatMap(sigToNavigatableElement).toArray val title = ScalaBundle.message("navigation.title.super.vals", element.getText) val findUsagesTitle = ScalaBundle.message("navigation.findUsages.title.super.vals", element.getText) navigateToSuperMember(event, superMembers, title, findUsagesTitle) case v: ScValueOrVariable => val bindings = v.declaredElements.filter(_.name == element.getText) val signatures = bindings.flatMap(ScalaPsiUtil.superValsSignatures(_, withSelfType = true)) val superMembers = signatures.flatMap(sigToNavigatableElement).toArray val title = ScalaBundle.message("navigation.title.super.vals", element.getText) val findUsagesTitle = ScalaBundle.message("navigation.findUsages.title.super.vals", element.getText) navigateToSuperMember(event, superMembers, title, findUsagesTitle) case ta: ScTypeAlias => val superElements = ScalaPsiUtil.superTypeMembers(ta, withSelfType = true) val navigatable: Array[NavigatablePsiElement] = superElements.collect { case ne: NavigatablePsiElement => ne }.toArray val title = ScalaBundle.message("navigation.title.super.types", ta.getName) val findUsagesTitle = ScalaBundle.message("navigation.findUsages.title.super.types", ta.getName) navigateToSuperMember(event, navigatable, title, findUsagesTitle) } )	ScalaMarkerType	overridingMember
reference.multiResolveScala(false)	Array[ScalaResolveResult]	results
findOverrides(member, deep = true)	Seq[PsiNamedElement]	overrides
holder.createWarningAnnotation(element, ScalaBundle.message("scala.meta.recompile"))	Annotation	warning
isRequired(set)(_.fromPackage)	Boolean	packageRequired
isRequired(set)(_.fromPackageObject)	Boolean	packageObjectRequired
overrides.headOption.fold("")(_.name)	String	name
originalQName.indexOf(dollarTestSuffix) + dollarTestSuffix.length	Int	index
matchedParameters.find(_._1.name == p.name).map(_._2).getOrElse(Seq.empty).filter(_ != null)	Seq[ScExpression]	exprsForP
parameters.indexOf(p) + 1	Int	paramIndex
findClassesByQName(name, debugProcessScope, fallbackToProjectScope = true)	Seq[PsiClass]	classes
(isFindUsages: Boolean, isAbstract: Boolean) => { val windowType = if (isFindUsages) "findUsages." else "" val targetType = if (isAbstract) "implementing" else "overriding" s"navigation.${windowType}title.$targetType.member" }	(Boolean, Boolean) => String	keyBuilder
findScriptFile(refType)	Option[PsiFile]	scriptFile
infix.rightOption match { case Some(_: ScInfixPattern | _: ScConstructorPattern) => 2 case Some(right) => right.subpatterns match { case Seq() => 2 case s => s.length + 1 } case _ => 1 }	Int	numPatterns
element.leftExpression	ScExpression	left
GutterUtil.isAbstract(member)	Boolean	isAbstract
NameTransformer.decode(nonLambdaName(refType))	String	originalQName
element.rightExpression	Option[ScExpression]	right
delegateHolderFor(enumToken, session)	DelegateAnnotationHolder with ErrorIndication { val element : Some[PsiElement] def transformRange(range: TextRange): TextRange }	errorHolder
defaultParameterMethodName(fun, paramIndex)	String	methodName
followingEnumerators .exists { case ScEnumerator.withDesugaredAndEnumeratorToken(desugaredEnum, enumToken) => val errorHolder = delegateHolderFor(enumToken, session) // TODO decouple desugaredEnum.callExpr.foreach(ScReferenceAnnotator.qualifierPart(_, typeAware)(errorHolder)) errorHolder.hadError case _ => false }	Boolean	foundUnresolvedSymbol
false	Boolean	foundMonadicError
holder.createErrorAnnotation(element, "Reassignment to val")	Annotation	annotation
generator.nextSiblings.collectFirst { case gen: ScGenerator => gen }	Option[ScGenerator]	nextGenOpt
delegateHolderFor(nextGen, session)	DelegateAnnotationHolder with ErrorIndication { val element : Some[PsiElement] def transformRange(range: TextRange): TextRange }	errorHolder
Some(target)	Some[PsiElement]	element
withDollarTestName(originalQName) .flatMap(tryToFindClass) .orElse(tryToFindClass(topLevelClassName(originalQName)))	Option[PsiClass]	clazz
p.paramInCode.toSeq.flatMap(DebuggerUtil.localParamsForDefaultParam(_))	IndexedSeq[ScTypedDefinition]	localParams
scriptFile.getOrElse { val originalQName = NameTransformer.decode(nonLambdaName(refType)) val clazz = withDollarTestName(originalQName) .flatMap(tryToFindClass) .orElse(tryToFindClass(topLevelClassName(originalQName))) clazz.map(_.getNavigationElement.getContainingFile).orNull }	PsiFile	file
new ScCellRenderer	ScalaMarkerType.ScCellRenderer	renderer
inReadAction(findFile())	PsiFile	file
element.parent.flatMap(_.parent) match { case Some(ah: ScAnnotationsHolder) => ah.metaExpand case _ => Right("") }	Either[String, Tree]	result
localParams.map(td => createExpressionWithContextFromText(td.name, call.getContext, call))	IndexedSeq[ScExpression]	localParamRefs
NamePattern.forElement(elem)	ScalaPositionManager.NamePattern	pattern
ScPattern.expectedNumberOfExtractorArguments(substitutor(rt), pattern, fun)	Int	expected
ScalaProjectSettings.getInstance(element.getProject)	ScalaProjectSettings	settings
findElementByReferenceTypeInner(refType)	Option[PsiElement]	found
localParamRefs.map(evaluatorFor(_))	IndexedSeq[Evaluator]	localEvals
SmartPointerManager.getInstance(debugProcess.getProject)	SmartPointerManager	manager
findPsiClassByQName(refType, debugProcessScope) orElse findByShortName(refType)	Option[PsiClass]	byName
debugProcess.getProject	Project	project
expr.`type`().getOrAny	ScType	tp
expected > 0 && numPatterns == 1 && !fun.isSynthetic	Boolean	tupleCrushingIsPresent
Try(refType.allLineLocations().asScala).getOrElse(Seq.empty)	Seq[Nothing]	allLocations
ScalaMarkerType( element => namedParent(element).collect { case _: ScMember => if (GutterUtil.isAbstract(element)) ScalaBundle.message("has.implementations") else ScalaBundle.message("is.overridden.by") }.orNull, (event, element) => namedParent(element).collect { case member: ScMember => val overrides = findOverrides(member, deep = true) if (overrides.nonEmpty) { val name = overrides.headOption.fold("")(_.name) val keyBuilder = (isFindUsages: Boolean, isAbstract: Boolean) => { val windowType = if (isFindUsages) "findUsages." else "" val targetType = if (isAbstract) "implementing" else "overriding" s"navigation.${windowType}title.$targetType.member" } val isAbstract = GutterUtil.isAbstract(member) val title = ScalaBundle.message(keyBuilder(false, isAbstract), name, overrides.length.toString) val findUsagesTitle = ScalaBundle.message(keyBuilder(true, isAbstract), name) val renderer = new ScCellRenderer util.Arrays.sort(overrides.map(e => e: PsiElement).toArray, renderer.getComparator) PsiElementListNavigator.openTargets( event, overrides.map(_.asInstanceOf[NavigatablePsiElement]).toArray, title, findUsagesTitle, renderer ) } } )	ScalaMarkerType	overriddenMember
allLocations.map(checkedLineNumber).filter(_ > 0)	IndexedSeq[Int]	refTypeLineNumbers
holder.createWarningAnnotation(valKeyword, ScalaBundle.message("enumerator.val.keyword.deprecated"))	Annotation	annotation
if (p.isRepeated) repeatedArgEvaluator(exprsForP, p.expectedType, call) else if (exprsForP.size > 1) throw EvaluationException(ScalaBundle.message("wrong.number.of.expressions")) else if (exprsForP.length == 1 && !isDefaultExpr(exprsForP.head)) evaluatorFor(exprsForP.head) else if (param.isImplicitParameter) implicitArgEvaluator(fun, param, call) else if (p.isDefault) { val paramIndex = parameters.indexOf(p) + 1 val methodName = defaultParameterMethodName(fun, paramIndex) val localParams = p.paramInCode.toSeq.flatMap(DebuggerUtil.localParamsForDefaultParam(_)) val localParamRefs = localParams.map(td => createExpressionWithContextFromText(td.name, call.getContext, call)) val localEvals = localParamRefs.map(evaluatorFor(_)) functionEvaluator(ref.qualifier, ref, methodName, previousClausesEvaluators ++ localEvals, isDefaultArg = true) } else throw EvaluationException(ScalaBundle.message("cannot.evaluate.parameter", p.name))	Evaluator	evaluator
refTypeLineNumbers.min	Int	firstRefTypeLine
refTypeLineNumbers.max	Int	lastRefTypeLine
clauses.foldLeft(Seq.empty[Evaluator])(addForNextClause)	Seq[Evaluator]	argEvaluators
NameTransformer.encode(funName)	String	name
holder.createErrorAnnotation(element.getTextRange, ScalaBundle.message("import.expr.should.be.qualified"))	Annotation	annotation
firstRefTypeLine to lastRefTypeLine	Range.Inclusive	refTypeLines
new ScalaTypeEvaluator(DebuggerUtil.getClassJVMName(tr, withPostfix = true))	ScalaTypeEvaluator	traitTypeEval
getPsiFileByReferenceType(project, refType)	PsiFile	file
ClassInheritorsSearch.search(aClass, aClass.getUseScope, true).toArray(PsiClass.EMPTY_ARRAY)	Array[PsiClass]	inheritors
element.getContainingFile.asOptionOf[ScalaFile].exists(_.isCompiled)	Boolean	compiled
document.getLineNumber(elem.getTextRange.getStartOffset)	Int	startLine
document.getLineNumber(elem.getTextRange.getEndOffset)	Int	endLine
(isFindUsages: Boolean, isTrait: Boolean) => { val windowType = if (isFindUsages) "findUsages." else "" val targetType = if (isTrait) "trait" else "class" s"navigation.${windowType}title.inheritors.$targetType" }	(Boolean, Boolean) => String	keyBuilder
aClass.isInstanceOf[ScTrait]	Boolean	isTrait
ScPattern.expectedNumberOfExtractorArguments(substitutor(rt), pattern, fun) - 1	Int	expected
elementLineRange(elem, document)	Range.Inclusive	lineRange
file.findElementAt(offset)	PsiElement	startElem
qualEvaluator(r)	Evaluator	qualEval
for (MissedTypeParameter(p) <- r.problems) yield p.name	IndexedSeq[String]	missing
Seq( document.getLineEndOffset(firstRefTypeLine), document.getLineEndOffset(firstRefTypeLine + 1) )	Seq[Int]	offsetsInTheMiddle
positionsOnLine(file, firstRefTypeLine)	Seq[PsiElement]	firstLinePositions
ScalaBundle.message("type.mismatch.default.args.expected.actual", expected, actual)	String	message
ArrayBuffer[ScType]()	ArrayBuffer[ScType]	buffer
Right(tp)	Right[Nothing, ScType]	expectedType
if (firstRefTypeLine == lastRefTypeLine) firstLinePositions else firstLinePositions ++ positionsOnLine(file, lastRefTypeLine)	Seq[PsiElement]	allPositions
ScalaMethodEvaluator(traitTypeEval, name, null, qualEval +: argEvaluators)	ScalaMethodEvaluator	withTraitImpl
abstraction(parameterized)	ScType	newtp
new PsiClassListCellRenderer	PsiClassListCellRenderer	renderer
findCandidates()	Seq[PsiElement]	candidates
candidates.filter(elementLineRange(_, document) == refTypeLines)	Seq[PsiElement]	withExactlySameLines
tuple.subpatterns	Seq[ScPattern]	subPat
subPat.flatMap(patternType)	IndexedSeq[ScType]	subTypes
ScalaPsiManager.instance(expr.getProject).getCachedClass(expr.resolveScope, "java.lang.Throwable").orNull	PsiClass	throwable
holder.createErrorAnnotation(errSemicolon, msg)	Annotation	annotation
ScDesignatorType(throwable)	ScDesignatorType	throwableType
new MethodResolveProcessor(expr, memberName, List(Seq(new Compatibility.Expression(throwableType))), Seq.empty, Seq.empty)	MethodResolveProcessor	processor
ScalaMethodEvaluator(qualEval, name, null, argEvaluators, traitImplementation(fun))	ScalaMethodEvaluator	withDefault
r.element	PsiNamedElement	resolve
for (MissedValueParameter(p) <- r.problems) yield p.name + ": " + p.paramType.presentableText	IndexedSeq[String]	missed
smartCheckConformance(expectedType, exprType)	Boolean	conformance
ScAnnotationAnnotator :: ScAssignmentAnnotator :: ScCatchBlockAnnotator :: ScClassAnnotator :: ScConstrBlockAnnotator :: ScConstructorInvocationAnnotator :: ScExpressionAnnotator :: ScEnumeratorsAnnotator :: ScForBindingAnnotator :: ScGeneratorAnnotator :: ScImportExprAnnotator :: ScInterpolatedStringLiteralAnnotator :: ScStringLiteralAnnotator :: ScLongLiteralAnnotator :: ScIntegerLiteralAnnotator :: ScLiteralTypeElementAnnotator :: ScMethodCallAnnotator :: ScMethodInvocationAnnotator :: ScNewTemplateDefinitionAnnotator :: ScParameterAnnotator :: ScParameterizedTypeElementAnnotator :: ScParametersAnnotator :: ScPatternAnnotator :: ScPatternDefinitionAnnotator :: ScReferenceAnnotator :: ScReturnAnnotator :: ScSelfInvocationAnnotator :: ScSimpleTypeElementAnnotator :: ScTemplateDefinitionAnnotator :: ScTypeBoundsOwnerAnnotator :: ScTypedExpressionAnnotator :: ScUnderscoreSectionAnnotator :: ScVariableDeclarationAnnotator :: ScopeAnnotator :: ScSymbolLiteralAnnotator :: ScFunctionalTypeElementAnnotator :: ScMacroDefAnnotator :: Nil	List[(ElementAnnotator[_ >: ScAnnotation <: _$1]) forSome {type _$1 >: ScForBinding <: _$1; type _$1 >: ScConstructorInvocation <: _$1; type _$1 >: ScTypedExpression <: _$1; type _$1 >: ScPattern <: _$1; type _$1 >: ScAssignment <: _$1; type _$1 >: ScReturn <: _$1; type _$1 >: ScFunctionalTypeElement with ScMacroDefinition <: ScalaPsiElement with Typeable; type _$1 >: ScVariableDeclaration <: _$1; type _$1 >: ScGenerator <: _$1; type _$1 >: ScPatternDefinition <: _$1; type _$1 >: ScIntegerLiteral <: _$1; type _$1 >: ScalaPsiElement <: _$1; type _$1 >: ScCatchBlock <: _$1; type _$1 >: ScLongLiteral <: _$1; type _$1 >: ScUnderscoreSection <: _$1; type _$1 >: ScEnumerators <: _$1; type _$1 >: ScConstrBlock <: _$1; type _$1 >: ScClass <: _$1; type _$1 >: ScParameter <: _$1; type _$1 >: ScReference <: _$1; type _$1 >: ScParameters <: _$1; type _$1 >: ScExpression <: _$1; type _$1 >: ScParameterizedTypeElement <: _$1; type _$1 >: ScInterpolatedStringLiteral <: _$1; type _$1 >: ScTemplateDefinition <: _$1; type _$1 >: ScImportExpr <: _$1; type _$1 >: ScNewTemplateDefinition <: _$1; type _$1 >: ScLiteralTypeElement <: _$1; type _$1 >: ScTypeBoundsOwner <: _$1; type _$1 >: ScMethodCall <: _$1; type _$1 >: ScSymbolLiteral <: _$1; type _$1 >: ScSimpleTypeElement <: _$1; type _$1 >: MethodInvocation <: _$1; type _$1 >: ScSelfInvocation <: _$1}]	Instances
enumerators.children.filter(!_.isInstanceOf[PsiWhiteSpace]).toSeq	Seq[PsiElement]	allChildren
element match { // TODO fine-grained ranges // When present, highlight type ascription, not expression, SCL-15544 case typedExpression: ScTypedExpression => (typedExpression.typeElement, typedExpression.expr.getTypeAfterImplicitConversion().tr) match { // Don't show additional type mismatch when there's an error in type ascription (handled in ScTypedExpressionAnnotator), SCL-15544 case (Some(typeElement), Right(actualType)) if !actualType.conforms(typeElement.calcType) => return case _ => } typedExpression.typeElement.getOrElse(element) case _ => element }	ScalaPsiElement with Typeable	target
65536	Int	StringLiteralSizeLimit
Option.empty[PsiElement]	Option[PsiElement]	lastInitialSemicolon
StringLiteralSizeLimit / 4	Int	StringCharactersCountLimit
resolve match { case fun: ScFunction => DebuggerUtil.getFunctionJVMSignature(fun) case _ => null }	JVMName	signature
Seq.newBuilder[PsiElement]	mutable.Builder[PsiElement, Seq[PsiElement]]	errSemiBuilder
false	Boolean	canHaveSemicolon
if (inDesugaring) call.argsElement.getTextRange else { call.argumentExpressions.lastOption .map(e => new TextRange(e.getTextRange.getEndOffset - 1, call.argsElement.getTextRange.getEndOffset)) .getOrElse(call.argsElement.getTextRange) }	TextRange	range
literal.containingVirtualFile	Option[VirtualFile]	virtualFile
holder.createErrorAnnotation(expr, error)	Annotation	annotation
call match { case hasDeepestInvokedReference(r) => r case _ => throw EvaluationException(ScalaBundle.message("cannot.evaluate.method", call.getText)) }	ScReferenceExpression	ref
ref.qualifier	Option[ScExpression]	qualOption
argumentEvaluators(fun, matchedParameters, call, ref, arguments)	Seq[Evaluator]	args
!problems.exists(_.is[MissedValueParameter, ExcessArgument])	Boolean	countMatches
false	Boolean	typeMismatchShown
candidates(0) match { case ScalaResolveResult(fun: ScFunction, subst) => fun.returnType.map(subst).toOption case _ => None }	Option[ScType]	maybeType
ScalaMarkerType( element => element.parent.collect { case _: ScTrait => ScalaBundle.message("trait.has.implementations") case _ => ScalaBundle.message("class.has.subclasses") }.orNull, (event, element) => element.parent.collect { case aClass: PsiClass => val inheritors = ClassInheritorsSearch.search(aClass, aClass.getUseScope, true).toArray(PsiClass.EMPTY_ARRAY) if (inheritors.nonEmpty) { val keyBuilder = (isFindUsages: Boolean, isTrait: Boolean) => { val windowType = if (isFindUsages) "findUsages." else "" val targetType = if (isTrait) "trait" else "class" s"navigation.${windowType}title.inheritors.$targetType" } val isTrait = aClass.isInstanceOf[ScTrait] val title = ScalaBundle.message(keyBuilder(false, isTrait), aClass.name, inheritors.length.toString) val findUsagesTitle = ScalaBundle.message(keyBuilder(true, isTrait), aClass.name) val renderer = new PsiClassListCellRenderer util.Arrays.sort(inheritors, renderer.getComparator) PsiElementListNavigator.openTargets( event, inheritors.map(_.asInstanceOf[NavigatablePsiElement]), title, findUsagesTitle, renderer ) } } )	ScalaMarkerType	subclassedClass
c.name	String	clName
holder.createWarningAnnotation(element, ScalaBundle.message("symbolliterals.are.deprecated", element.contentText))	Annotation	annotation
method.containingClass.getPresentation	ItemPresentation	presentation
xlass.getPresentation	ItemPresentation	presentation
ScalaPsiUtil.nameContext(x).asInstanceOf[ScMember].containingClass	ScTemplateDefinition	containing
containing.getPresentation	ItemPresentation	presentation
c.allClauses.flatMap(_.parameters).map(_.name).headOption.getOrElse("$this")	String	paramName
element.multiResolve	Seq[ScalaResolveResult]	resolved
x.getPresentation	ItemPresentation	presentation
s"new $clName($paramName).${call.getText}"	String	text
createExpressionFromText(text, call.getContext)	ScExpression	expr
candidates(0) match { case ScalaResolveResult(fun: ScFunction, subst) => fun.returnType.map(subst) case _ => return }	Either[Failure, ScType]	returnType
holder.createErrorAnnotation(element.thisElement, "Cannot find constructor for this call")	Annotation	annotation
qualifierEvaluator(ref.qualifier, ref)	Evaluator	qualEval
NameTransformer.encode(cp.name)	String	name
literal.scalaLanguageLevel	Option[ScalaLanguageLevel]	languageLevel
{ val target = element match { // TODO fine-grained ranges // When present, highlight type ascription, not expression, SCL-15544 case typedExpression: ScTypedExpression => (typedExpression.typeElement, typedExpression.expr.getTypeAfterImplicitConversion().tr) match { // Don't show additional type mismatch when there's an error in type ascription (handled in ScTypedExpressionAnnotator), SCL-15544 case (Some(typeElement), Right(actualType)) if !actualType.conforms(typeElement.calcType) => return case _ => } typedExpression.typeElement.getOrElse(element) case _ => element } TypeMismatchError.register(target, tp, exprType.getOrNothing, blockLevel = 2, canBeHint = !element.is[ScTypedExpression]) { (expected, actual) => ScalaBundle.message("expr.type.does.not.conform.expected.type", actual, expected) } }	Annotation	annotation
new WrapInOptionQuickFix(element, expectedType, exprType)	WrapInOptionQuickFix	wrapInOptionFix
new ChangeTypeFix(te, exprType.getOrNothing)	ChangeTypeFix	fix
p match { case cp: ScClassParameter if cp.isCallByNameParameter => val qualEval = qualifierEvaluator(ref.qualifier, ref) val name = NameTransformer.encode(cp.name) ScalaFieldEvaluator(qualEval, name, classPrivateThisField = true) case _: ScParameter if p.isCallByNameParameter => calcLocal(p) case _ => throw EvaluationException("By-name parameter expected") }	Evaluator	paramEval
IntegerKind(text)	annotator.IntegerKind	kind
annotationWithoutHighlighting(te)	Annotation	teAnnotation
literal.getParent match { // only "-1234" is negative, "- 1234" should be considered as positive 1234 case parent: ScPrefixExpr => parent.getChildren match { case Array(ElementText("-"), `literal`) => parent case _ => literal } case _ => literal }	ScExpression	target
smartCheckConformance(Right(tp), returnType)	Boolean	conformance
getContextClass(e)	PsiElement	nextClass
new ScalaThisEvaluator(iterationCount)	ScalaThisEvaluator	thisEval
call	ProjectContext	ctx
kind(text, isLong)	String	number
problems.filterBy[ExcessArgument].map(_.argument).filter(inSameFile(_, holder)).firstBy(_.getTextOffset)	Option[ScExpression]	firstExcessiveArgument
NameTransformer.encode(named.name)	String	name
getContextClass(named)	PsiElement	containingClass
new ScalaLocalVariableEvaluator(name, fileName)	ScalaLocalVariableEvaluator	simpleLocal
call.applyOrUpdateElement.map(_.problems).getOrElse(call.applicationProblems)	Seq[ApplicabilityProblem]	problems
TypePresentationContext(element)	TypePresentationContext	context
cachedSourceName(refType).getOrElse("")	String	sourceName
Compatibility.checkConstructorConformance( element, r.substitutor, element.arguments, constr.effectiveParameterClauses )	Compatibility.ConformanceExtResult	res
elem.getContainingFile	PsiFile	containingFile
new ChangeTypeFix(te, returnType.getOrNothing)	ChangeTypeFix	fix
ScalaFieldEvaluator(new ScalaThisEvaluator(), name + "$macro")	ScalaFieldEvaluator	fieldMacro
ScalaPsiUtil.nameContext(named) match { case param: ScParameter => param.owner match { case fun@(_: ScFunction | _: ScFunctionExpr) => parameterEvaluator(fun, param) case _ => throw EvaluationException(ScalaBundle.message("cannot.evaluate.parameter", param.name)) } case caseCl: ScCaseClause => patternEvaluator(caseCl, named) case _: ScGenerator | _: ScForBinding if position != null && isNotUsedEnumerator(named, position.getElementAt) => throw EvaluationException(ScalaBundle.message("not.used.from.for.statement", name)) case LazyVal(_) => localLazyValEvaluator(named) case InsideAsync(_) => val simpleLocal = new ScalaLocalVariableEvaluator(name, fileName) val fieldMacro = ScalaFieldEvaluator(new ScalaThisEvaluator(), name + "$macro") ScalaDuplexEvaluator(simpleLocal, fieldMacro) case _ => new ScalaLocalVariableEvaluator(name, fileName) }	Evaluator	localVariableEvaluator
stringToNumber(number, kind, target != literal)()	Option[(Long, Boolean)]	maybeNumber
if (isNegative) -value else value	Long	newValue
typeElement.calcType	ScType	expected
withOuterFieldEvaluator(containingClass, name, ScalaBundle.message("cannot.evaluate.local.variable", name))	ScalaFieldEvaluator	fieldEval
char.asDigit	Int	digit
getContextClass(obj)	PsiElement	containingClass
element.reference.map(_.resolve()).exists { case ah: ScAnnotationsHolder if isFreestyleAnnotated(ah) => false case c: PsiClass => c.hasTypeParameters case owner: ScTypeParametersOwner => owner.typeParameters.nonEmpty case _ => false }	Boolean	canHaveTypeArgs
argument.prevSiblings.takeWhile(e => e.is[PsiWhiteSpace] || e.is[PsiComment] || e.textMatches(",") || e.textMatches("(")).toSeq.lastOption	Option[PsiElement]	opening
holder.createErrorAnnotation(element.getTextRange, ScalaBundle.message("type.takes.type.parameters", element.getText))	Annotation	annotation
value * radix + digit	Long	newValue
opening.map(e => new TextRange(e.getTextOffset, argument.getTextOffset + 1)).getOrElse(argument.getTextRange)	TextRange	range
NameTransformer.encode(obj.name) + "$module"	String	name
mismatchRangesIn(typeElement, actual)	Seq[TextRange]	ranges
literal.getTextRange	TextRange	range
(expected, actual) match { case (_: ScLiteralType, t2: ScLiteralType) => t2 case (_, t2: ScLiteralType) => t2.wideType case (_, t2) => t2 }	ScType	wideActual
for (MissedValueParameter(p) <- problems) yield p.name + ": " + p.paramType.presentableText	IndexedSeq[String]	missed
withOuterFieldEvaluator(containingClass, name, ScalaBundle.message("cannot.evaluate.local.object", name))	ScalaFieldEvaluator	fieldEval
reference.getContext match { case x: ScMethodCall => x.getEffectiveInvokedExpr match { case x: ScReferenceExpression => x.qualifier case _ => None } case x: ScInfixExpr => Some(x.left) case _ => None }	Option[ScExpression]	qualifier
s"Cannot upcast ${wideActual.presentableText} to ${expected.presentableText}"	String	message
element.isInstanceOf[ScNewTemplateDefinition]	Boolean	newInstance
element.extendsBlock.templateBody.isDefined	Boolean	hasBody
call.argumentExpressions.lastOption .map(e => new TextRange(e.getTextRange.getEndOffset - 1, call.argsElement.getTextRange.getEndOffset)) .getOrElse(call.argsElement.getTextRange)	TextRange	range
element.isInstanceOf[ScNewTemplateDefinition]	Boolean	isNew
Seq(lastDollar, lastDot, 0).max + 1	Int	index
element.isInstanceOf[ScObject]	Boolean	isObject
qualifier.flatMap(_.asOptionOf[ScReference])	Option[ScReference]	refElementOpt
holder.createErrorAnnotation( target, ScalaBundle.message("integer.literal.is.out.of.range") )	Annotation	annotation
labeledOrSyntheticEvaluator(ref, resolve)	Option[Evaluator]	labeledOrSynthetic
refElementOpt.flatMap(_.resolve().toOption)	Option[PsiElement]	ref
DebuggerUtil.isLocalV(resolve)	Boolean	isLocalValue
resolve.asInstanceOf[ScNamedElement]	ScNamedElement	named
ref.exists(ScalaPsiUtil.isReadonly)	Boolean	reassignment
holder.createErrorAnnotation(reference, "Reassignment to val")	Annotation	annotation
qualifierEvaluator(qualifier, ref)	Evaluator	qualEval
ScalaMethodEvaluator(qualEval, name, null /* todo */ , Seq.empty, traitImplementation(resolve), DebuggerUtil.getSourcePositions(resolve.getNavigationElement))	ScalaMethodEvaluator	withSimpleNameEval
element.extendsBlock.earlyDefinitions.exists(_.members.nonEmpty)	Boolean	hasEarlyBody
ScalaImportTypeFix.getTypesToImport(refElement)	Array[ElementToImport]	classes
refElement.multiResolveScala(false)	Array[ScalaResolveResult]	resolve
problems.filterBy[ExcessArgument].map(_.argument).firstBy(_.getTextOffset)	Option[ScExpression]	firstExcessiveArgument
clazz.qualifiedName	String	qualName
superRefs(element)	Seq[(TextRange, PsiClass)]	refs
TypeDiff.forExpected(expected.calcType, actual)	Tree[TypeDiff]	diff
fixes	Seq[IntentionAction]	cachedFixes
cacheManager.getClassesByName(name, GlobalSearchScope.allScope(project)).toSeq	Seq[PsiClass]	classes
refs.exists { case (_, clazz) => isAbstract(clazz) }	Boolean	hasAbstract
asString(x).length	Int	length
holder.createErrorAnnotation(refElement.nameId, error)	Annotation	annotation
{ case Leaf(Mismatch(_, _)) => true; case _ => false }	Tree[TypeDiff] => Boolean	isMismatch
holder.createAnnotation(HighlightSeverity.WARNING, refElement.getTextRange, ScalaBundle.message("cannot.resolve", refElement.refName))	Annotation	annotation
qualName.split('.').map(NameTransformer.encode).mkString("$") + "$$" + name	String	newName
element.typeElement.getTypeNoConstructor.toOption .flatMap(_.extractDesignated(expandAliases = false)) .collect {case t: ScTypeParametersOwner => t}	Option[PsiNamedElement with ScTypeParametersOwner]	typeParamOwner
PsiTreeUtil.findCommonContext(refElement, nameContext)	PsiElement	context
reference.getTextRange.getEndOffset	Int	shift
t.typeParameters.length	Int	typeParametersLength
element.typeArgList.typeArgs.length	Int	argsLength
iterator.next()	ScExpression	injection
ScalaMethodEvaluator(qualEval, newName, null /* todo */ , Seq.empty, traitImplementation(resolve), DebuggerUtil.getSourcePositions(resolve.getNavigationElement))	ScalaMethodEvaluator	reserveEval
element.typeArgList.getNode.findChildByType(ScalaTokenTypes.tLSQBRACKET)	ASTNode	leftBracket
holder.createErrorAnnotation(leftBracket, error)	Annotation	annotation
(PsiTreeUtil.findFirstContext(nameContext, false, elem => elem.getContext.eq(context)) match { case s: ScalaPsiElement => s.getDeepSameElementInContext case elem => elem }).getPrevSibling	PsiElement	neighbour
resolve(0)	ScalaResolveResult	resolveResult
element.typeArgList.getNode.findChildByType(ScalaTokenTypes.tRSQBRACKET)	ASTNode	rightBracket
holder.createErrorAnnotation(rightBracket, error)	Annotation	annotation
{ val (oldTypeDescripton, newTypeDescription) = typeElement.`type`() match { case Right(oldType) => ScTypePresentation.different(oldType, newType) case _ => (typeElement.getText, newType.presentableText) } s"Change type '$oldTypeDescripton' to '$newTypeDescription'" }	String	getText
e.getParent.asInstanceOf[ScPrefixExpr]	ScPrefixExpr	pref
pref.operand	ScExpression	expr
e.getParent.asInstanceOf[ScInfixExpr]	ScInfixExpr	inf
qualifier match { case Some(qual) => ScalaFieldEvaluator(evaluatorFor(qual), name) case None => new ScalaLocalVariableEvaluator(name, fileName) }	Evaluator	fieldOrVarEval
inf.getBaseExpr	ScExpression	expr
refElement.getParent	PsiElement	parent
ScalaPsiElementFactory.createReferenceFromText(refElement.getText, parent.getContext, parent)	ScStableCodeReference	refWithoutArgs
classes.filter(c => c.isValid && sameFileName(c))	Seq[PsiClass]	inSameFile
debugProcess.getVirtualMachineProxy	VirtualMachineProxy	vm
resolve.getUserData(CodeFragmentFactoryContextWrapper.LABEL_VARIABLE_VALUE_KEY)	Value	labeledValue
NameTransformer.decode(fullName)	String	decoded
_member.createSmartPointer	SmartPsiElementPointer[ScMember]	smartPointer
_member match { case _: ScVariableDefinition => ScalaBundle.message("pull.variable.to", name) case _: ScPatternDefinition => ScalaBundle.message("pull.value.to", name) case _ => ScalaBundle.message("pull.method.to", name) }	String	getText
getText	String	getFamilyName
true	Boolean	startInWriteAction
decoded.lastIndexOf("$$")	Int	index
for { reference <- constrInvocation.reference.toList resolveResult <- reference.resolveAllConstructors element = resolveResult.element // resolveAllConstructors might return inaccessible constructors // and as last resort even the class itself (in order to return at least something) // But note: a trait will be returned when a trait is instantiated as anonymous class // (of course traits cannot have constructors) elementShouldHaveBeenConcreteConstructor = element.isInstanceOf[ScConstructorOwner] if resolveResult.isAccessible && !elementShouldHaveBeenConcreteConstructor } yield resolveResult	IndexedSeq[ScalaResolveResult]	resolved
constr	ProjectContext	ctx
typeElement.replace(createTypeElementFromText(newType.canonicalText)(typeElement.getManager))	PsiElement	replaced
resolve.length	Int	resolveCount
refElement.qualifier.get	ScalaPsiElement	qualifier
qualifier.asInstanceOf[ScExpression]	ScExpression	expr
allSupers(project, sourceClass)	Seq[PsiClass]	superClasses
new ScalaExtractMemberInfo(target)	ScalaExtractMemberInfo	info
constr.getClassTypeParameters.map(_.typeParameters).getOrElse(Seq.empty)	Seq[ScTypeParam]	params
for { member <- ScalaOIUtil.getMembersToImplement(element) if member.isInstanceOf[ScalaTypedMember] // See SCL-2887 } yield { try { (member.getText, member.getParentNodeDelegate.getText) } catch { case iae: IllegalArgumentException => throw new RuntimeException("member: " + member.getText, iae) } }	IndexedSeq[(Nothing, Nothing)]	undefined
codeFragment.isAncestorOf(resolve)	Boolean	isSynthetic
constrInvocation.typeArgList.map(_.typeArgs).getOrElse(Seq.empty)	Seq[ScTypeElement]	typeArgs
{ val modifierText = modifier.text nameId match { case null => ScalaBundle.message(key, modifierText) case id => daemon.QuickFixBundle.message(key, id.getText, modifierText) } }	String	getText
namedElement.name	String	name
caseCl.pattern	Option[ScPattern]	pattern
element match { case _: ScNewTemplateDefinition => defaultRange case scalaObject: ScObject => scalaObject.nameId.getTextRange }	TextRange	range
ScalaPsiElementFactory.createEquivMethodCall(inf)	ScMethodCall	equivCall
matchStmt.expression match { case None => throw EvaluationException(ScalaBundle.message("cannot.find.expression.of.match")) case Some(e) => e }	ScExpression	expr
m.parameters	Seq[PsiParameter]	params
try evaluatorFor(expr) catch { case _: NeedCompilationException => new ScalaCompilingEvaluator(expr, ScalaCodeFragment(expr.getText)(caseCl.getProject)) }	Evaluator	exprEval
modifierList.getTextRange	TextRange	textRange
ScSubstitutor.bind(params, typeArgs)(_.calcType) .followed(ScSubstitutor.bind(params)(UndefinedType(_))) .followed(r.substitutor)	ScSubstitutor	substitutor
DebuggerUtilsEx.getLambdaBaseClassName(fullName) match { case baseClassName: String => Some(baseClassName) case null => val decoded = NameTransformer.decode(fullName) val index = decoded.lastIndexOf("$$") if (index < 0) None else Some(NameTransformer.encode(decoded.substring(0, index))) }	Option[String]	containingClassName
"Main$$anon$1"	String	SCRIPT_HOLDER_CLASS_NAME
evaluateSubpatternFromPattern(exprEval, pattern.get, namedElement.asInstanceOf[ScPattern])	Evaluator	fromPatternEvaluator
new ScalaLocalVariableEvaluator("", fileName)	ScalaLocalVariableEvaluator	argEvaluator
mutable.HashMap[PsiFile, Boolean]()	mutable.HashMap[PsiFile, Boolean]	isCompiledWithIndyLambdasCache
Compatibility.checkConstructorConformance( constrInvocation, substitutor, constrInvocation.arguments, constr.effectiveParameterClauses )	Compatibility.ConformanceExtResult	res
r.element	PsiNamedElement	element
mutable.HashMap[DebugProcess, ScalaPositionManager]()	mutable.HashMap[DebugProcess, ScalaPositionManager]	instances
evaluateSubpatternFromPattern(argEvaluator, pattern.get, namedElement.asInstanceOf[ScPattern])	Evaluator	fromPatternEvaluator
scPosManager.debugProcess	DebugProcess	debugProcess
file match { case sf: ScalaFile => sf case _ => return Seq.empty }	ScalaFile	scFile
createWithClauses(s"(${forStmt.getText})")	ScExpression	withClauses
ScalaPsiElementFactory.createDeclarationFromText( keywordType.toString + " x", listOwner.getParent, listOwner ).findFirstChildByType(keywordType)	PsiElement	keyword
cachedMap	ConcurrentIntObjectMap[Seq[PsiElement]]	map
problems.collect { case MissedValueParameter(p) => p}	IndexedSeq[Parameter]	missedParams
parameters.zip(types).map { case (p, t) => t.presentableText + (if(p.isRepeatedParameter) "*" else "") }	IndexedSeq[String]	parts
document.getLineStartOffset(lineNumber)	Int	startLine
fd.paramClauses.clauses.lastOption	Option[ScParameterClause]	lastClause
document.getLineEndOffset(lineNumber)	Int	endLine
(call.args.exprs.map(_.getText) :+ rExprText).mkString("(", ", ", ")")	String	args
s"($invokedText).update$args"	String	exprText
createExpressionWithContextFromText(exprText, stmt.getContext, stmt)	ScExpression	expr
evaluatorFor(stmt.leftExpression)	Evaluator	leftEvaluator
mutable.ArrayBuffer.empty[PsiElement]	ArrayBuffer[PsiElement]	result
transformText(literal.getText)	String	newText
'L'	Char	Marker
stmt.rightExpression match { case Some(expr) => evaluatorFor(expr) case _ => throw EvaluationException(message) }	Evaluator	rightEvaluator
parameters.map(_.paramType())	IndexedSeq[ScType]	types
file.findElementAt(startLine)	PsiElement	elem
ref.bind().get.getActualElement	PsiNamedElement	elem
symbolLiteral.contentText	String	symbolText
element.withParentsInFile.takeWhile(e => e.getTextOffset > startLine).toIndexedSeq	IndexedSeq[PsiElement]	parentsOnTheLine
element match { case templateDefinition: ScNewTemplateDefinition if templateDefinition.extendsBlock.templateBody.isEmpty => Nil case _ => superRefs(element) }	Seq[(TextRange, PsiClass)]	references
s"""Symbol("$symbolText")"""	String	newText
ref.qualifier.map(q => createExpressionWithContextFromText(q.getText, q.getContext, q))	Option[ScExpression]	qual
file.getNavigationElement	PsiElement	fileNavigationElement
element match { case ScalaConstructor(constr) => missedParams.groupBy(parameterToArgClause(_, constr, constrInvocation.arguments)) case _ if missedParams.nonEmpty => Map(None -> missedParams) case _ => Map.empty }	(Map[_ <: _$1, IndexedSeq[Parameter]]) forSome {type _$1 >: None.type <: Option[ScArgumentExprList]}	missedParamsPerArgList
element.nameId	PsiElement	nameId
parentsOnTheLine.collectFirst { case e if isLambda(e) => e case newTd: ScNewTemplateDefinition if generatesAnonClass(newTd) => newTd }	Option[PsiElement]	anon
parentsOnTheLine.reverse.filter { case _: ScExpression => true case _: ScConstructorPattern | _: ScInfixPattern | _: ScBindingPattern => true case callRefId childOf ((ref: ScReferenceExpression) childOf (_: ScMethodCall)) if ref.nameId == callRefId && ref.getTextRange.getStartOffset < startLine => true case _: ScTypeDefinition => true case _ => false }	IndexedSeq[PsiElement]	filteredParents
filteredParents.find(!_.isInstanceOf[ScBlock]).orElse(filteredParents.headOption)	Option[PsiElement]	maxExpressionPatternOrTypeDef
parameters.zip(types).map { case (p, t) => t.presentableText + (if(p.isVarArgs) "*" else "") }	IndexedSeq[String]	parts
element match { case owner: ScModifierListOwner => Some(new ModifierQuickFix.Add(owner, nameId, ScalaModifier.Abstract)) case _ => None }	Option[ModifierQuickFix.Add]	maybeModifierFix
createExpressionWithContextFromText(ref.getText, ref.getContext, ref)	ScExpression	refExpr
param.map { argumentList => argumentList.exprs.lastOption .map(e => new TextRange(e.getTextRange.getEndOffset - 1, argumentList.getTextRange.getEndOffset)) .getOrElse(argumentList.getTextRange) } getOrElse { argsElements }	TextRange	range
ct.superclass()	ClassType	supClass
if (ScalaOIUtil.getMembersToImplement(element).nonEmpty) Some(new ImplementMethodsQuickFix(element)) else None	Option[ImplementMethodsQuickFix]	maybeImplementFix
definition.typeParameters.flatMap(p => p.contextBoundTypeElement)	IndexedSeq[ScTypeElement]	contextBoundElements
api.Long(literal.getProject) :: ScalaPsiElementFactory.createTypeFromText( "_root_.scala.math.BigInt", literal.getContext, literal ).toList	List[ScType]	types
evaluatorForReferenceWithoutParameters(qual, elem, refExpr.asInstanceOf[ScReferenceExpression])	Evaluator	refEvaluator
definition.typeParameters.flatMap(p => p.viewTypeElement)	IndexedSeq[ScTypeElement]	viewBoundElements
parameters.map { p => p.paramType.presentableText + (if (p.isRepeated) "*" else "") }	IndexedSeq[String]	parts
Option(file.getUserData(ScalaCompilingEvaluator.originalFileKey)).getOrElse(file)	PsiFile	originalFile
td.getQualifiedNameForDebugger	String	name
fun.name	String	funName
ScalaPsiManager.instance(obj.getProject)	ScalaPsiManager	manager
manager.getCachedClass(obj.resolveScope, "scala.DelayedInit").orNull	PsiClass	clazz
position.getFile	PsiFile	sourceFile
resolveResult.implicitType match { case Some(tp) => tp case _ => Any(expr.projectContext) }	ScType	typeTo
ScalaProjectSettings.getInstance(element.getProject).isShowNotFoundImplicitArguments	Boolean	notFoundArgHighlightingEnabled
debuggerProcess.asInstanceOf[DebugProcessImpl].getPositionManager	CompoundPositionManager	positionManager
holder.createWarningAnnotation(nameId, message)	Annotation	deprAnnot
createAnnotation(nameId)	Annotation	annotation
ScalaMethodEvaluator(refEvaluator, funName, DebuggerUtil.getFunctionJVMSignature(fun), Seq(exprEval))	ScalaMethodEvaluator	extractEval
Seq(new ConvertToObjectFix(element), new AddEmptyParenthesesToPrimaryConstructorFix(element))	Seq[IntentionAction]	fixes
ScalaMethodEvaluator(extractEval, "get", null, Seq.empty)	ScalaMethodEvaluator	getEval
{ val maybeModifierFix = element match { case owner: ScModifierListOwner => Some(new ModifierQuickFix.Add(owner, nameId, ScalaModifier.Abstract)) case _ => None } val maybeImplementFix = if (ScalaOIUtil.getMembersToImplement(element).nonEmpty) Some(new ImplementMethodsQuickFix(element)) else None maybeModifierFix ++ maybeImplementFix }	IndexedSeq[IntentionAction]	fixes
c.targetToken.getTextRange	TextRange	classKeywordTextRange
toImport.toSeq	Seq[ElementToImport]	toImportSeq
element.containingClass	ScTemplateDefinition	clazz
params .map(_.implicitSearchState.map(_.presentableTypeText).getOrElse("unknown type"))	IndexedSeq[String]	presentableTypes
ScalaPsiElementFactory.createObjectWithContext(objectText, c.getContext, c)	ScObject	objectElement
typesToSearch match { case Seq(tp) => tp.presentableText(place) case _ => "..." }	String	typeOrEllipsis
ref.getProject	Project	project
createExpressionFromText("" + nextPatternIndex)(pattern.getManager)	ScExpression	indexExpr
evaluatorFor(indexExpr)	Evaluator	indexEval
constrInvocation.arguments.lastOption .map(_.getTextRange.getEndOffset) .map(off => TextRange.create(off - 1, off)) .getOrElse(constrInvocation.getTextRange)	TextRange	markRange
editor.xyToLogicalPosition(new Point(visibleRectangle.x, visibleRectangle.y))	LogicalPosition	startPosition
editor.logicalPositionToOffset(startPosition)	Int	myStartOffset
holder.createErrorAnnotation(nameId, message)	Annotation	annotation
editor.xyToLogicalPosition(new Point(visibleRectangle.x + visibleRectangle.width, visibleRectangle.y + visibleRectangle.height))	LogicalPosition	endPosition
constr.parameterList.clauses.indexWhere( clause => clause.parameters.contains(param) )	Int	idx
TypeDefinitionMembers.getSignatures(element).allNodesIterator	Iterator[MixinNodes.Node[TermSignature]]	nodes
isCompiledWithIndyLambdas(containingFile)	Boolean	compiledWithIndyLambdas
new BaseListPopupStep("Choose type to search", typesToSearch: _*) { override def getIconFor(aValue: ScType): Icon = null override def getTextFor(value: ScType): String = ObjectUtils.assertNotNull(value.presentableText(place)) override def isAutoSelectionEnabled: Boolean = false override def onChosen(selectedValue: ScType, finalChoice: Boolean): PopupStep[_] = { searchAndSuggestImport(selectedValue, editor) PopupStep.FINAL_CHOICE } }	BaseListPopupStep[ScType] { def isAutoSelectionEnabled: Boolean def getTextFor(value: ScType): String def getIconFor(aValue: ScType): Any def onChosen(selectedValue: ScType, finalChoice: Boolean): PopupStep[_] }	popup
if (funName == "unapply") { val extractEval = ScalaMethodEvaluator(refEvaluator, funName, DebuggerUtil.getFunctionJVMSignature(fun), Seq(exprEval)) if (pattern.subpatterns.length == 1) ScalaMethodEvaluator(extractEval, "get", null, Seq.empty) else if (pattern.subpatterns.length > 1) { val getEval = ScalaMethodEvaluator(extractEval, "get", null, Seq.empty) ScalaFieldEvaluator(getEval, s"_${nextPatternIndex + 1}") } else throw EvaluationException(ScalaBundle.message("unapply.without.arguments")) } else if (funName == "unapplySeq") { val extractEval = ScalaMethodEvaluator(refEvaluator, funName, DebuggerUtil.getFunctionJVMSignature(fun), Seq(exprEval)) val getEval = ScalaMethodEvaluator(extractEval, "get", null, Seq.empty) val indexExpr = createExpressionFromText("" + nextPatternIndex)(pattern.getManager) val indexEval = evaluatorFor(indexExpr) ScalaMethodEvaluator(getEval, "apply", JVMNameUtil.getJVMRawText("(I)Ljava/lang/Object;"), Seq(indexEval)) } else throw EvaluationException(ScalaBundle.message("pattern.doesnot.resolves.to.unapply", ref.refName))	Evaluator with Product with Serializable	newEval
{ elem match { case td: ScTypeDefinition if !isLocalClass(td) => Some(getSpecificNameForDebugger(td)) case _ => None } }	Option[String]	exactName
Seq( (Final, Sealed), (Private, Protected) )	Seq[(ScalaModifier, ScalaModifier)]	modifiers
pattern.subpatterns(nextPatternIndex)	ScPattern	nextPattern
lenghtOf(this)	Int	nodeLength
pattern.subpatterns.indexWhere(next => subPattern.withParentsInFile.contains(next))	Int	nextPatternIndex
_	Seq[String]	classJVMNameParts
par.innerElement.getOrElse(throw new IllegalStateException("Empty parentheses pattern"))	ScPattern	withoutPars
tuple.subpatterns(nextPatternIndex)	ScPattern	nextPattern
ScalaRefCountHolder.getInstance(scalaFile)	ScalaRefCountHolder	refHolder
elem.withParentsInFile.flatMap(partsFor)	Iterator[String]	parts
node.supers.map(_.info.namedElement).forall { case f: ScFunctionDefinition => isOverrideAndAbstract(f) case _: ScBindingPattern => true case m: PsiMethod => m.hasModifierProperty(PsiModifier.ABSTRACT) case _ => true }	Boolean	flag
ArrayBuffer.empty[ImportUsed]	ArrayBuffer[ImportUsed]	redundant
ScalaFieldEvaluator(exprEval, s"_${nextPatternIndex + 1}")	ScalaFieldEvaluator	newEval
GlobalImplicitInstance.compatibleInstances(typeToSearch, place.elementScope)	Set[GlobalImplicitInstance]	instances
file.getAllImportUsed	mutable.Set[ImportUsed]	imports
infix.operation	ScStableCodeReference	ref
templ.getProject	Project	project
ScalaRefCountHolder.getInstance(file)	ScalaRefCountHolder	refHolder
ScalaEvaluatorBuilderUtil.anonClassCount(elem)	Int	anonfunCount
myStartOffset max editor.logicalPositionToOffset(new LogicalPosition(endPosition.line + 1, 0))	Int	myEndOffset
variants.filter(_.isValid)	Array[ElementToImport]	validVariants
ScalaAddImportAction(editor, classes, ref)	ScalaAddImportAction[_]	action
ref.getTextRange.getStartOffset	Int	refStart
ref.getTextRange.getEndOffset	Int	refEnd
chooserTitle(validVariants)	String	title
Seq.fill(anonfunCount - 1)(Seq("$apply", "$anonfun")).flatten	Seq[Nothing]	lastParts
findGeneratingClassOrMethodParent(elem.getParent)	PsiElement	containingClass
selectedValue.qualifiedName	String	qname
new BaseListPopupStep[ElementToImport](title, validVariants: _*) { override def getIconFor(aValue: ElementToImport): Icon = aValue.element.getIcon(0) override def getTextFor(value: ElementToImport): String = { ObjectUtils.assertNotNull(value.qualifiedName) } override def isAutoSelectionEnabled: Boolean = false override def isSpeedSearchEnabled: Boolean = true import com.intellij.openapi.ui.popup.PopupStep.FINAL_CHOICE override def onChosen(selectedValue: ElementToImport, finalChoice: Boolean): PopupStep[_] = { if (selectedValue == null) { return FINAL_CHOICE } if (finalChoice) { PsiDocumentManager.getInstance(project).commitAllDocuments() addImport(selectedValue) return FINAL_CHOICE } val qname: String = selectedValue.qualifiedName if (qname == null) return FINAL_CHOICE val toExclude: java.util.List[String] = AddImportAction.getAllExcludableStrings(qname) new BaseListPopupStep[String](null, toExclude) { override def onChosen(selectedValue: String, finalChoice: Boolean): PopupStep[_] = { if (finalChoice) { AddImportAction.excludeFromImport(project, selectedValue) } super.onChosen(selectedValue, finalChoice) } override def getTextFor(value: String): String = { "Exclude '" + value + "' from auto-import" } } } override def hasSubstep(selectedValue: ElementToImport): Boolean = { true } }	BaseListPopupStep[ElementToImport]	firstPopupStep
importsUsed.filterNot(imp => refHolder.usageFound(imp) || imp.isAlwaysUsed)	mutable.Set[ImportUsed]	toHighlight
ref.getKinds(incomplete = false)	Set[ResolveTargets.Value]	kinds
s"_root_.scala.Array.ofDim$typeArgs$args"	String	exprText
resolveResult.getActualElement	PsiNamedElement	named
element match { case ref: ScReferenceExpression if checkWrite && ScalaPsiUtil.isPossiblyAssignment(ref) => WriteValueUsed(named) case _ => ReadValueUsed(named) }	ValueUsed	value
ScalaRefCountHolder.getInstance(file)	ScalaRefCountHolder	holder
createExpressionWithContextFromText(exprText, templ.getContext, templ)	ScExpression	expr
notFoundImplicitParams.flatMap(withProbableArguments(_)).flatMap(implicitTypeToSearch)	IndexedSeq[ScType]	notFoundTypes
{ val modifiers = Seq( (Final, Sealed), (Private, Protected) ) modifiers ++ modifiers.map { case (left, right) => (right, left) } }	IndexedSeq[(ScalaModifier, ScalaModifier)]	IllegalCombinations
ScalaPsiManager.instance(project)	ScalaPsiManager	cache
getImportHolder(place, place.getProject)	ScImportsHolder	holder
mutable.HashSet.empty[ScalaModifier]	mutable.HashSet[ScalaModifier]	modifiers
if (condition(e)) severityT else severityF	HighlightSeverity	severity
DebuggerUtil.getClassJVMName(clazz)	JVMName	jvmName
cache.getClassesByName(ref.refName, ref.resolveScope)	Seq[PsiClass]	classes
new ScalaTypeEvaluator(jvmName)	ScalaTypeEvaluator	typeEvaluator
IllegalCombinations.collectFirst { case (`modifier`, illegalModifier) if owner.hasModifierPropertyScala(illegalModifier.text()) => illegalModifier }.orElse { if (modifiers.add(modifier)) None else Some(modifier) }	Option[ScalaModifier]	maybeIllegalModifier
new ArrayBuffer[ElementToImport]	ArrayBuffer[ElementToImport]	buffer
if (fun.name == "this") JVMNameUtil.CONSTRUCTOR_NAME else fun.name	String	name
NameTransformer.encode(name)	String	encoded
ImplicitCollector.probableArgumentsFor(parameter).flatMap { case (arg, ImplicitParameterNotFoundResult) => arg.implicitParameters.flatMap(withProbableArguments(_, visited + parameter.element)) case _ => Seq.empty }	IndexedSeq[ScalaResolveResult]	arguments
currentModCount	Long	currentCount
if (accessModifier.isPrivate) Some(Private) else if (accessModifier.isProtected) Some(Protected) else None	Option[ScalaModifier]	maybeModifier
(e.containingClass, e) match { case (_, valMember: ScPatternDefinition) if valMember.typeElement.isEmpty && valMember.pList.simplePatterns => false // constant value definition, see SCL-11500 case (cls, _) if cls.hasFinalModifier => true case _ => false }	Boolean	redundant
c.getContext match { case file: ScalaFile if !file.isScriptFile && !file.isWorksheetFile => true case _: ScPackaging => true case _ => false }	Boolean	onTopLevel
constructorArgumentsEvaluators(templ, constrInvocation, clazz)	Seq[Evaluator]	argumentEvaluators
if (PsiTreeUtil.isAncestor(owner, containingClass, true)) Seq("$anonfun") else owner match { case fun: ScFunctionDefinition => val name = if (fun.name == "this") JVMNameUtil.CONSTRUCTOR_NAME else fun.name val encoded = NameTransformer.encode(name) Seq(s"$$$encoded", "$anonfun") case _ => Seq("$anonfun") }	Seq[String]	firstParts
name	String	nameTail
cache.getStableAliasesByName(ref.refName, ref.resolveScope)	Iterable[ScTypeAlias]	typeAliases
DebuggerUtil.constructorSignature(named)	JVMName	signature
nameTail.indexOf(part)	Int	index
alias.containingClass	ScTemplateDefinition	containingClass
isCompiledWithIndyLambdas(containingFile)	Boolean	newValue
cachedSourceName(refType).getOrElse("")	String	refTypeSourceName
findDirtyScope(file)	Option[Option[TextRange]]	dirtyScope
constrInvocation.reference match { case Some(ResolvesTo(elem)) => elem case _ => throw EvaluationException(ScalaBundle.message("could.not.resolve.constructor")) }	PsiElement	constrDef
Some(file.getTextRange)	Some[TextRange]	defaultRange
new CachedValueProvider[NamePattern] { override def compute(): Result[NamePattern] = Result.create(new NamePattern(elem), elem) }	CachedValueProvider[ScalaPositionManager.NamePattern] { def compute(): CachedValueProvider.Result[ScalaPositionManager.NamePattern] }	cacheProvider
constrInvocation.arguments.flatMap(_.exprs)	IndexedSeq[ScExpression]	explicitArgs
mutable.HashMap[ReferenceType, PsiFile]()	mutable.HashMap[ReferenceType, PsiFile]	refTypeToFileCache
arg.projectContext	ProjectContext	project
evaluatorFor(arg)	Evaluator	eval
constr.parameterList.clauses	Seq[ScParameterClause]	clauses
ScalaPsiUtil.parameterOf(arg).flatMap(_.psiParam)	Option[PsiParameter]	param
clauses.head.parameters	Seq[ScParameter]	parameters
mutable.HashMap[ReferenceType, Option[SmartPsiElementPointer[PsiElement]]]()	mutable.HashMap[ReferenceType, Option[SmartPsiElementPointer[PsiElement]]]	refTypeToElementCache
mutable.HashMap[Location, Int]()	mutable.HashMap[Location, Int]	customizedLocationsCache
mutable.HashMap[(ReferenceType, Int), Seq[Location]]()	mutable.HashMap[(ReferenceType, Int), Seq[Location]]	lineToCustomizedLocationCache
mutable.Set[ReferenceType]()	mutable.Set[ReferenceType]	seenRefTypes
for { arg <- explicitArgs } yield { val eval = evaluatorFor(arg) val param = ScalaPsiUtil.parameterOf(arg).flatMap(_.psiParam) if (param.exists(!isOfPrimitiveType(_))) boxEvaluator(eval) else eval }	IndexedSeq[Evaluator]	explEvaluators
mutable.HashMap[ReferenceType, Option[String]]()	mutable.HashMap[ReferenceType, Option[String]]	sourceNames
scMethod.containingClass.asInstanceOf[ScClass]	ScClass	scClass
getContextClass(scClass)	PsiElement	containingClass
call.expectedType().map(_.canonicalText)	Option[String]	methodType
scMethod.parameterList.params.filter(_.isImplicitParameter)	Seq[ScParameter]	implicitParams
CreateFromUsageUtil.paramsText(call.argumentExpressions)	String	argsText
typeFor(ref)	Option[String]	entityType
Ref.create[TimestampedValueMap[String, ScalaRefCountHolder]]	Ref[ScalaRefCountHolderComponent.TimestampedValueMap[String, ScalaRefCountHolder]]	autoCleaningMap
implicitArgEvaluator(scMethod, p, constrInvocation)	Evaluator	eval
{ val argsText = CreateFromUsageUtil.paramsText(call.argumentExpressions) val dummyTypeText = methodType.fold("")(_ => ": Int") s"def apply$argsText$dummyTypeText = ???" }	String	methodText
genericParametersFor(ref)	Option[String]	genericParams
parametersFor(ref)	Option[String]	parameters
ref	ProjectContext	projectContext
for { p <- implicitParams } yield { val eval = implicitArgEvaluator(scMethod, p, constrInvocation) if (isOfPrimitiveType(p)) eval else boxEvaluator(eval) }	IndexedSeq[Evaluator]	implicitsEvals
value.flatMap(_.`type`().toOption).asTypeResult.getOrAny	ScType	tp
outerClass match { case obj: ScObject if isStable(obj) => None case null => None case _ => Some(new ScalaThisEvaluator(iters)) }	Option[ScalaThisEvaluator]	outerThis
DebuggerUtil.localParamsForConstructor(scClass)	Seq[ScTypedDefinition]	locals
p.`type`().getOrAny	ScType	tp
(cs2, cs2).zipped.map(diff).intersperse(aMatch(" with "))	Seq[Tree[TypeDiff]]	components
local.asInstanceOf[PsiNamedElement].name	String	name
position.getElementAt	PsiElement	elemAt
ScalaCodeStyleSettings.getInstance(project).getImportsWithPrefix.filter { case exclude if exclude.startsWith(ScalaCodeStyleSettings.EXCLUDE_PREFIX) => false case include => val parts = include.split('.') if (parts.length > 1) parts.takeRight(2).head == ref.refName else false }.map(s => s.reverse.dropWhile(_ != '.').tail.reverse)	IndexedSeq[Any]	packagesList
createExpressionWithContextFromText(name, elemAt, elemAt)	ScExpression	ref
evaluatorFor(ref)	Evaluator	refEval
ScPackageImpl.findPackage(project, packageQualifier)	ScPackageImpl	pack
createExpressionWithContextFromText(string, context.getContext, context)	ScExpression	expr
PsiTreeUtil.getParentOfType(ref, classOf[ScConstructorInvocation]) match { case ScConstructorInvocation(simple: ScSimpleTypeElement, args) if ref.getParent == simple => args case ScConstructorInvocation(pt: ScParameterizedTypeElement, args) if ref.getParent == pt.typeElement => args case _ => Seq.empty }	Seq[ScArgumentExprList]	fromConstrArguments
named.name	String	name
s"$name$$lzy"	String	localRefName
(tms2.keys.map(_.namedElement) ++ tps2.values.map(_.typeAlias)).toSeq	Seq[PsiNamedElement]	members
if (ref.getParent.isInstanceOf[ScMethodCall]) { buffer.filter { case ClassToImport(clazz) => clazz.isInstanceOf[ScObject] && clazz.asInstanceOf[ScObject].allFunctionsByName("apply").nonEmpty case _ => false } } else buffer	ArrayBuffer[ElementToImport]	finalImports
OrderingUtil.orderingByRelevantImports(ref)	Ordering[String]	byRelevance
new ScalaLocalVariableEvaluator(localRefName, fileName)	ScalaLocalVariableEvaluator	localRefEval
lazyValIndex(named)	Int	lzyIndex
parameter.getNameIdentifier	PsiIdentifier	id
s"Create $description '${ref.nameId.getText}'"	String	getText
element.getTextRange.getEndOffset	Int	offset
new ScalaLocalVariableEvaluator(bitmapName, fileName)	ScalaLocalVariableEvaluator	bitmapEval
localFunctionIndex(named)	Int	localFunIndex
new OpenFileDescriptor(project, element.getContainingFile.getVirtualFile, offset)	OpenFileDescriptor	descriptor
s"$name$$$localFunIndex"	String	methodName
s"Create $description"	String	getFamilyName
stmt.condition match { case Some(cond) => evaluatorFor(cond) case None => throw EvaluationException(ScalaBundle.message("if.statement.without.condition")) }	Evaluator	condEvaluator
stmt.thenExpression match { case Some(th) => evaluatorFor(th) case None => throw EvaluationException(ScalaBundle.message("if.statement.without.if.branch")) }	Evaluator	ifBranch
1.minute.toMillis	Long	CleanupDelay
stmt.elseExpression.map(evaluatorFor(_))	Option[Evaluator]	elseBranch
pattern.expectedType.getOrElse(Any)	ScType	pType
td.projectContext	ProjectContext	ctx
nameByType(pType)	String	pName
ref match { case it if it.isQualified => ref.qualifier.flatMap(tryToFindBlock) case Parent(infix: ScInfixExpr) => tryToFindBlock(infix.getBaseExpr) case _ => None }	Option[ScExtendsBlock]	block
materializeSytheticObject(obj).extendsBlock	ScExtendsBlock	bl
createExpressionFromText( s"""Symbol("${symbol.name}")""", literal.getContext )	ScExpression	expr
CreateFromUsageUtil.patternArgs(pattern).map(_.`type`().getOrAny)	IndexedSeq[ScType]	types
ws.condition match { case Some(cond) => evaluatorFor(cond) case None => throw EvaluationException(ScalaBundle.message("while.statement.without.condition")) }	Evaluator	condEvaluator
new hash.LinkedHashMap[K, Timestamped](maximumSize, true) { override def removeEldestEntry(eldest: ju.Map.Entry[K, Timestamped]): Boolean = size() > maximumSize override def doRemoveEldestEntry(): Unit = this.synchronized { super.doRemoveEldestEntry() } }	LinkedHashMap[K, TimestampedValueMap.this.Timestamped] { def doRemoveEldestEntry(): Unit def removeEldestEntry(eldest: Any): Boolean }	innerMap
ws.expression match { case Some(body) => evaluatorFor(body) case None => throw EvaluationException(ScalaBundle.message("while.statement.without.body")) }	Evaluator	iterationEvaluator
{ val members = (tms2.keys.map(_.namedElement) ++ tps2.values.map(_.typeAlias)).toSeq members.map(_.getText.takeWhile(_ != '=').trim).sorted.map(s => Node(aMatch(s))) }	IndexedSeq[Tree.Node[TypeDiff.Match]]	declarations
doSt.condition match { case Some(cond) => evaluatorFor(cond) case None => throw EvaluationException(ScalaBundle.message("do.statement.without.condition")) }	Evaluator	condEvaluator
Timestamped(value)	TimestampedValueMap.this.Timestamped	newValue
block match { case Some(_ childOf (obj: ScObject)) if obj.isSyntheticObject => val bl = materializeSytheticObject(obj).extendsBlock createEntity(bl, ref, text) case Some(it) => createEntity(it, ref, text) case None => createEntity(ref, text) }	Option[PsiElement]	maybeEntity
doSt.body match { case Some(body) => evaluatorFor(body) case None => throw EvaluationException(ScalaBundle.message("do.statement.without.body")) }	Evaluator	iterationEvaluator
new TemplateBuilderImpl(entity)	TemplateBuilderImpl	builder
Logger.getInstance("#org.jetbrains.plugins.scala.annotator.createFromUsage.CreateTemplateDefinitionQuickFix")	Logger	LOG
types.map(_.canonicalText).mkString(", ")	String	typesText
ref.refName	String	name
file.getName == ScalaLanguageConsoleView.ScalaConsole	Boolean	isScalaConsole
clazz.members match { case Seq(fun: ScFunction) => fun case _ => return }	ScFunction	method
s"($invokedText).apply$argsText"	String	newExprText
unapplyMethodText(p)	String	methodText
applyCall(call.getInvokedExpr.getText, call.args.getText + tailString)	ScExpression	expr
false	Boolean	_hadError
{ val classKind = td match { case _: ScObject => "object" case _: ScTrait => "trait" case _: ScClass => "class" case _ => "" } s"$getFamilyName in $classKind ${td.name}" }	String	getText
createMethodFromText(methodText)(clazz.getManager)	ScFunction	method
None	Option[PsiElement]	element
innerMap.get(key) match { case null => val newValue = Timestamped(value) innerMap.put(key, newValue) newValue case cached => cached }	TimestampedValueMap.this.Timestamped	timestamped
block.templateBody.get.getFirstChild	PsiElement	anchor
anchor.getParent	PsiElement	holder
positionCursor(entity.getLastChild)	Editor	newEditor
expression	ProjectContext	ctx
entity.getTextRange	TextRange	range
obj.fakeCompanionClassOrCompanionClass	PsiClass	clazz
gen.typeArgs.map(_.getText).mkString	String	typeArgsText
s"object ${clazz.name} {}"	String	objText
ScalaPsiElementFactory.createTemplateDefinitionFromText(objText, clazz.getParent, clazz)	ScTemplateDefinition	fromText
applyCall(ref.getText, s"$typeArgsText${call.args.getText}$tailString")	ScExpression	expr
methodCall.copy().asInstanceOf[ScMethodCall]	ScMethodCall	copy
holder.children.containsInstanceOf[ScMember]	Boolean	hasMembers
ref.withParentsInFile.collect { case inner childOf (_: ScTemplateBody) => inner case td: ScTypeDefinition if td.isTopLevel => td }	Iterator[PsiElement]	inThisFile
ws2.map { case ScExistentialArgument(_, _, lower, upper) => Node(aMatch("_") +: ((if (lower.isNothing) Seq.empty else Seq(aMatch(" >: "), diff(lower, lower)(reversed(conformance), context))) ++ (if (upper.isAny) Seq.empty else Seq(aMatch(" <: "), diff(upper, upper)))): _*) }	IndexedSeq[Tree.Node[TypeDiff]]	wildcards
s"$baseText = $baseText $operation $argumentText"	String	exprText
holder.addAfter(createElementFromText(text), anchor)	PsiElement	entity
if (file == null || file.getContainingDirectory == null) None else Some(file)	Option[PsiFile]	fileOption
createEntity(td.extendsBlock, methodText).asInstanceOf[ScFunction]	ScFunction	entity
infix match { case ScInfixExpr.withAssoc(ElementText(baseText), isUpdate(operation), ElementText(argumentText)) => val exprText = s"$baseText = $baseText $operation $argumentText" createExpressionWithContextFromText(exprText, infix.getContext, infix) case _ => createEquivMethodCall(infix) }	ScExpression	newExpression
CreateFromUsageUtil.positionCursor(entity.getLastChild)	Editor	newEditor
holder	AnnotationHolder	h
(p1, p2).zipped.map(diff(_, _)(reversed, context)).intersperse(aMatch(", "))	Seq[Tree[TypeDiff]]	parameters
block.templateBody.get.children.toSeq	Seq[PsiElement]	children
block.statements.filter(!_.isInstanceOf[ScImportStmt]).map(evaluatorFor)	IndexedSeq[Evaluator]	evaluators
createEquivQualifiedReference(p)	ScReferenceExpression	equivRef
holder.createErrorAnnotation(e, ScalaBundle.message("abstract.member.not.have.private.modifier"))	Annotation	annotation
isAdvancedHighlightingEnabled(element)	Boolean	typeAware
s"(${p.operand.getText}).unary_${p.operation.refName}"	String	newExprText
createExpressionWithContextFromText(newExprText, p.getContext, p)	ScExpression	newExpr
ScalaPsiUtil.parameterOf(exp)	Option[Parameter]	parameter
ref.copy().asInstanceOf[ScReferenceExpression]	ScReferenceExpression	copy
createExpressionWithContextFromText(exprText, tuple.getContext, tuple)	ScExpression	expr
ArrayBuffer[Evaluator]()	ArrayBuffer[Evaluator]	evaluators
new ScalaCachingEvaluator(evaluatorFor(expr))	ScalaCachingEvaluator	exprEval
if(ScalaProjectSettings.getInstance(exp.getProject).isIncludeLiterals) Seq(exp.getTextRange) else nonLiteralRangesIn(exp)	Seq[TextRange]	ranges
clashesOf(functions) ::: clashesOf(parameterless) ::: clashesOf(types) ::: clashesOf(fieldLikes) ::: Nil	List[ScNamedElement]	clashes
holder.addBefore(createElementFromText(text), anchor)	PsiElement	entity
binding.name	String	name
new TextAttributes()	TextAttributes	emptyAttr
syntheticVariableEvaluator(name)	SyntheticVariableEvaluator	leftEval
holder.createInfoAnnotation(r, "Passed as by-name parameter")	Annotation	annotation
clashes.toSet -- clashesOf(classParameters)	Set[ScNamedElement]	withoutClassParameters
l match { case Right(res) => res case _ => return true }	ScType	leftType
r match { case Right(res) => res case _ => return true }	ScType	rightType
ref.parentsInFile	Iterator[PsiElement]	parents
{ if (p1.length == p2.length) { val parameters = (p1, p2).zipped.map(diff(_, _)(reversed, context)).intersperse(aMatch(", ")) if (p2.isEmpty) Seq(aMatch("()")) else if (p2.length > 1 || p2.exists(FunctionType.isFunctionType)) Seq(aMatch("("), Node(parameters: _*), aMatch(")")) else parameters } else { Seq(aMismatch(if (p2.length == 1) p2.head.presentableText else p2.map(_.presentableText).mkString("(", ", ", ")"))) } }	Seq[Tree[TypeDiff]]	left
elementToHighlight.getTextRange	TextRange	range
holder.createInfoAnnotation(range, null)	Annotation	annotation
diff(r1, r2)	Tree[TypeDiff]	right
evaluateSubpatternFromPattern(exprEval, pattern, binding)	Evaluator	rightEval
new ArrayBuffer[PsiElement]()	ArrayBuffer[PsiElement]	elements
Nil	List[ScNamedElement]	types
Nil	List[ScFunction]	functions
Nil	List[ScNamedElement]	parameterless
Nil	List[ScNamedElement]	fieldLike
Nil	List[ScClassParameter]	classParameters
ref.withParentsInFile	Iterator[PsiElement]	anchors
function.nameId	PsiElement	functionNameId
d1.extractClass match { case Some(scalaClass: ScClass) => scalaClass.typeParameters.map(_.variance).map(conformanceFor) case _ => Seq.fill(args2.length)((t1: ScType, t2: ScType) => t1.equiv(t2)) }	Seq[(ScType, ScType) => Boolean]	conformances
holder.createErrorAnnotation( functionNameId, "Method annotated with @tailrec is neither private nor final (so can be overridden)" )	Annotation	annotation
containingClassParams(element)	List[ScClassParameter]	classParams
parents.zip(anchors).find { case (_ : ScTemplateBody, _) => true case (_ : ScalaFile, _) => true case _ => false }	Option[(PsiElement, PsiElement)]	place
exp.depthFirst(parent => !parent.isInstanceOf[ScLiteral]) .instancesOf[ScLiteral].map(_.getTextRange).toList	List[TextRange]	literalRanges
dirs.find(PsiTreeUtil.isAncestor(_, ref, true)) .orElse(dirs.find(ScalaPsiUtil.getModule(_) == ScalaPsiUtil.getModule(ref)))	Option[PsiDirectory]	currentDir
file.getVirtualFile.nullSafe.exists { ProjectRootManager.getInstance(file.getProject).getFileIndex.isInSourceContent }	Boolean	isInSources
psiPackage.getDirectories.filter(_.isWritable) match { case Array(dir) => dir case Array() => throw new IllegalStateException(s"Cannot find directory for the package `${psiPackage.getName}`") case dirs => val currentDir = dirs.find(PsiTreeUtil.isAncestor(_, ref, true)) .orElse(dirs.find(ScalaPsiUtil.getModule(_) == ScalaPsiUtil.getModule(ref))) currentDir.getOrElse(dirs(0)) }	PsiDirectory	directory
target.extendsBlock	ScExtendsBlock	extBlock
expr.smartExpectedType() match { case Some(Int) => unbox("toInteger") case Some(Byte) => unbox("toByte") case Some(Long) => unbox("toLong") case Some(Boolean) => unboxEvaluator(evaluator) case Some(Float) => unbox("toFloat") case Some(Short) => unbox("toShort") case Some(Double) => unbox("toDouble") case Some(Char) => unbox("toCharacter") case Some(Unit) => new BlockStatementEvaluator(Array(evaluator, unitEvaluator())) case None => evaluator case _ => box() }	Evaluator	unboxed
param.getType	PsiType	tp
extBlock.templateBody.getOrElse( extBlock.add(createTemplateBody(target.getManager)))	PsiElement	targetBody
new TypeEvaluator(JVMNameUtil.getJVMRawText("scala.runtime.BoxesRunTime"))	TypeEvaluator	BOXES_RUN_TIME
new TypeEvaluator(JVMNameUtil.getJVMRawText("scala.runtime.BoxedUnit"))	TypeEvaluator	BOXED_UNIT
JVMNameUtil.getJVMRawText("(Ljava/lang/Object;)Ljava/lang/Object;")	JVMName	rawText
function.recursiveReferencesGrouped match { case references if references.noRecursion => Seq(holder.createErrorAnnotation(functionNameId, "Method annotated with @tailrec contains no recursive calls")) case references => for { reference <- references.ordinaryRecursive target = reference.getParent match { case methodCall: ScMethodCall => methodCall case _ => reference } } yield holder.createErrorAnnotation(target, "Recursive call not in tail position (in @tailrec annotated method)") }	Seq[Annotation]	annotations
s"${kind.keyword} $name"	String	text
literalRanges.flatMap(r => List(r.getStartOffset, r.getEndOffset))	IndexedSeq[Int]	literalIndices
function.hasExplicitType	Boolean	explicitType
JVMNameUtil.getJVMRawText("(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")	JVMName	rawText
createTemplateDefinitionFromText(text, parent, parent.getFirstChild)	ScTemplateDefinition	newTd
anchorAfter.orNull	PsiElement	anchor
parent.addBefore(newTd, anchor)	PsiElement	result
functionType == Unit	Boolean	unitType
function.hasAssign	Boolean	hasAssign
!hasAssign || unitType	Boolean	unitFunction
s"${fun.name}(${expr.getText})"	String	callText
if (args1.length == args2.length) (args1, args2, conformances).zipped.map(diff(_, _)(_, context)).intersperse(aMatch(", ")) else Seq(aMismatch(args2.map(_.presentableText).mkString(", ")))	Seq[Tree[TypeDiff]]	inner
usage.isInstanceOf[ScReturn]	Boolean	explicitReturn
if (t1.eq(t2)) t2.presentableText else ScTypePresentation.different(t1, t2)._2	String	text2
explicitReturn && usage.asInstanceOf[ScReturn].expr.isEmpty	Boolean	emptyReturn
fun.containingClass match { case o: ScObject if isStable(o) => s"${o.qualifiedName}.$callText" case _: ScObject => //todo: It can cover many cases! throw EvaluationException(ScalaBundle.message("implicit.conversions.from.dependent.objects")) case _ => callText //from scope }	String	newExprText
(expectedType, actualType) match { case (_: ScLiteralType, t2: ScLiteralType) => t2 case (_, t2: ScLiteralType) => t2.wideType case (_, t2) => t2 }	ScType	wideActualType
designatorType.extractDesignated(expandAliases = false)	Option[PsiNamedElement]	designator
new PsiElementListCellRenderer[PsiElement] { override def getElementText(element: PsiElement): String = element match { case _: PsiFile => "New file" case td: ScTypeDefinition if td.isTopLevel => "Top level in this file" case _ childOf (tb: ScTemplateBody) => val containingClass = PsiTreeUtil.getParentOfType(tb, classOf[ScTemplateDefinition]) s"Inner in ${containingClass.name}" case _ => "Local scope" } override def getContainerText(element: PsiElement, name: String) = null override def getIconFlags = 0 override def getIcon(element: PsiElement) = null }	PsiElementListCellRenderer[PsiElement] { def getElementText(element: PsiElement): String def getIconFlags: Int def getIcon(element: PsiElement): Null def getContainerText(element: PsiElement, name: String): Null }	renderer
siblings.head	PsiElement	selection
new PsiElementProcessor[PsiElement] { def execute(elem: PsiElement): Boolean = { inWriteCommandAction { createClassAtLevel(elem) }(elem.getProject) false } }	PsiElementProcessor[PsiElement] { def execute(elem: PsiElement): Boolean }	processor
ScalaDirectoryService.createClassFromTemplate(directory, name, kind.templateName, askToDefineVariables = false)	PsiClass	clazz
new TemplateBuilderImpl(clazz)	TemplateBuilderImpl	builder
clazz.getContainingFile	PsiFile	targetFile
targetFile.getName == ScalaLanguageConsoleView.ScalaConsole	Boolean	isScalaConsole
Option(td).map(_.extendsBlock).orNull	ScExtendsBlock	extBlock
positionCursor(clazz.nameId)	Editor	newEditor
clazz.getTextRange	TextRange	range
usageType.isAny	Boolean	anyReturn
{ val wideActualType = (expectedType, actualType) match { case (_: ScLiteralType, t2: ScLiteralType) => t2 case (_, t2: ScLiteralType) => t2.wideType case (_, t2) => t2 } val (actualTypeText, expectedTypeText) = ScTypePresentation.different(wideActualType, expectedType) if (ApplicationManager.getApplication.isUnitTestMode) formatMessage(expectedTypeText, actualTypeText) else ScalaBundle.message("type.mismatch.message", expectedTypeText, actualTypeText) }	String	message
new ScalaElementVisitor { override def visitExpression(expr: ScExpression) { if (!compiled) { ImplicitParametersAnnotator.annotate(expr, typeAware) ByNameParameter.annotate(expr, typeAware) } if (isAdvancedHighlightingEnabled(element)) { expr.getTypeAfterImplicitConversion() match { case ExpressionTypeResult(Right(t), _, Some(implicitFunction)) => highlightImplicitView(expr, implicitFunction.element, t, expr) case _ => } } super.visitExpression(expr) } override def visitMacroDefinition(fun: ScMacroDefinition): Unit = { Stats.trigger(isInSources, FeatureKey.macroDefinition) super.visitMacroDefinition(fun) } override def visitReferenceExpression(ref: ScReferenceExpression) { visitExpression(ref) } override def visitGenericCallExpression(call: ScGenericCall) { //todo: if (typeAware) checkGenericCallExpression(call, holder) super.visitGenericCallExpression(call) } override def visitFor(expr: ScFor) { registerUsedImports(expr, ScalaPsiUtil.getExprImports(expr)) super.visitFor(expr) } override def visitFunctionDefinition(fun: ScFunctionDefinition) { if (!compiled && !fun.isConstructor) annotateFunction(fun, typeAware) super.visitFunctionDefinition(fun) } override def visitFunctionDeclaration(fun: ScFunctionDeclaration) { checkAbstractMemberPrivateModifier(fun, Seq(fun.nameId)) super.visitFunctionDeclaration(fun) } override def visitFunction(function: ScFunction) { if (typeAware && !compiled) checkOverrideMethods(function, isInSources) if (!function.isConstructor) checkFunctionForVariance(function) super.visitFunction(function) } override def visitTypeProjection(proj: ScTypeProjection) { visitTypeElement(proj) } override def visitModifierList(modifierList: ScModifierList) { ModifierChecker.checkModifiers(modifierList) super.visitModifierList(modifierList) } override def visitExistentialTypeElement(exist: ScExistentialTypeElement): Unit = { Stats.trigger(isInSources, FeatureKey.existentialType) super.visitExistentialTypeElement(exist) } override def visitTypeAlias(alias: ScTypeAlias) { if (typeAware && !compiled) checkOverrideTypeAliases(alias) if (!compoundType(alias)) checkBoundsVariance(alias, alias.nameId, alias, checkTypeDeclaredSameBracket = false) super.visitTypeAlias(alias) } override def visitVariable(variable: ScVariable) { if (typeAware && !compiled) checkOverrideVariables(variable, isInSources) variable.typeElement match { case Some(typ) => checkBoundsVariance(variable, typ, variable, checkTypeDeclaredSameBracket = false) case _ => } if (!childHasAnnotation(variable.typeElement, "uncheckedVariance")) { checkValueAndVariableVariance(variable, Covariant, variable.declaredElements) checkValueAndVariableVariance(variable, Contravariant, variable.declaredElements) } super.visitVariable(variable) } override def visitValueDeclaration(v: ScValueDeclaration) { checkAbstractMemberPrivateModifier(v, v.declaredElements.map(_.nameId)) super.visitValueDeclaration(v) } override def visitValue(value: ScValue) { if (typeAware && !compiled) checkOverrideValues(value, isInSources) value.typeElement match { case Some(typ) => checkBoundsVariance(value, typ, value, checkTypeDeclaredSameBracket = false) case _ => } if (!childHasAnnotation(value.typeElement, "uncheckedVariance")) { checkValueAndVariableVariance(value, Covariant, value.declaredElements) } super.visitValue(value) } override def visitClassParameter(parameter: ScClassParameter) { if (typeAware && !compiled) checkOverrideClassParameters(parameter) checkClassParameterVariance(parameter) super.visitClassParameter(parameter) } override def visitTemplateParents(tp: ScTemplateParents): Unit = { checkTemplateParentsVariance(tp) super.visitTemplateParents(tp) } }	ScalaElementVisitor { def visitGenericCallExpression(call: ScGenericCall): Unit def visitTypeAlias(alias: ScTypeAlias): Unit def visitExistentialTypeElement(exist: ScExistentialTypeElement): Unit def visitMacroDefinition(fun: ScMacroDefinition): Unit def visitFunctionDeclaration(fun: ScFunctionDeclaration): Unit def visitFor(expr: ScFor): Unit def visitTemplateParents(tp: ScTemplateParents): Unit def visitVariable(variable: ScVariable): Unit def visitModifierList(modifierList: ScModifierList): Unit def visitFunction(function: ScFunction): Unit def visitValueDeclaration(v: ScValueDeclaration): Unit def visitTypeProjection(proj: ScTypeProjection): Unit def visitReferenceExpression(ref: ScReferenceExpression): Unit def visitClassParameter(parameter: ScClassParameter): Unit def visitValue(value: ScValue): Unit def visitExpression(expr: ScExpression): Unit def visitFunctionDefinition(fun: ScFunctionDefinition): Unit }	visitor
if (paramOwner.isInstanceOf[ScTemplateDefinition]) false else true	Boolean	inParameterized
usage.getContext.isInstanceOf[ScCatchBlock]	Boolean	underCatchBlock
pt.typeArgList.typeArgs match { case args if args.size == 1 => "[T]" case args => args.indices.map(i => s"T${i + 1}").mkString("[",", ", "]") }	String	paramsText
clazz.nameId	PsiElement	nameId
if (!fun.isLocal) "" else "$" + localFunctionIndex(fun)	String	suffix
createTypeParameterClauseFromTextWithContext(paramsText, clazz, nameId)	ScTypeParamClause	clause
elementV.name	String	elementVariance
cl.constructor.get	ScPrimaryConstructor	constr
positionV.name	String	posVariance
elementAt(element, blockLevel)	PsiElement	annotatedElement
function.superSignaturesIncludingSelfType	Seq[TermSignature]	signaturesWithSelfType
parametersText(ref)	String	text
!ScalaProjectSettings.in(element.getProject).isTypeMismatchHints || !canBeHint	Boolean	highlightExpression
function.superSignatures	Seq[TermSignature]	signatures
containingClass.depthFirst { case `containingClass` => true case elem if isGenerateClass(elem) => false case _ => true }	Iterator[PsiElement]	depthFirstIterator
createParamClausesWithContext(text, constr, constr.getFirstChild)	ScParameters	parameters
superValsSignatures(td, withSelfType = true)	Seq[TermSignature]	valsSignaturesWithSelfType
superValsSignatures(td)	Seq[TermSignature]	valsSignatures
depthFirstIterator.filter(condition).toList	List[PsiElement]	sameNameElements
getContextClass(elem)	PsiElement	clazz
returnUsages.collect { case retStmt: ScReturn => retStmt.expr.flatMap(_.`type`().toOption).getOrElse(Any) case expr: ScExpression => expr.`type`().getOrAny }	IndexedSeq[ScType]	returnTypes
element.is[ScInfixExpr, ScPostfixExpr]	Boolean	needsParentheses
superValsSignatures(parameter, withSelfType = true)	Seq[TermSignature]	supersWithSelfType
superValsSignatures(parameter)	Seq[TermSignature]	supers
elements.map(nameOf).filterNot(_ == "_")	IndexedSeq[String]	names
superTypeMembers(alias, withSelfType = true).filter(_.isInstanceOf[ScTypeAlias])	Seq[PsiNamedElement]	supersWithSelfType
holder.createErrorAnnotation(toHighlight, ScalaBundle.message(s"$elementVariance.type.$posVariance.position.of.$place", name, typeParam.toString, pos))	Annotation	annotation
f.getContext.isInstanceOf[ScRefinement]	Boolean	isInStructuralType
holder.createErrorAnnotation(usage.asInstanceOf[ScReturn].keyword, message)	Annotation	annotation
superTypeMembers(alias).filter(_.isInstanceOf[ScTypeAlias])	Seq[PsiNamedElement]	supers
namedElement.nameId	PsiElement	memberNameId
if (explicitReturn) usage.asInstanceOf[ScReturn].expr else None	Option[ScExpression]	returnExpression
returnExpression.getOrElse(usage)	ScExpression	expression
file.getVirtualFile	VirtualFile	vFile
f.paramClauses.clauses.map(format(_, isInStructuralType)).mkString	String	params
scTypeParam.owner	ScTypeParametersOwner	compareTo
checkParentOf.parents	Iterator[PsiElement]	parentIt
if (!isInStructuralType) erased(f.returnType.getOrAny.removeAliasDefinitions()).canonicalText else ""	String	returnType
StdTypes.instance(t.projectContext)	StdTypes	stdTypes
TypePresentationContext(annotatedElement)	TypePresentationContext	context
holder.createErrorAnnotation( memberNameId, ScalaBundle.message("member.overrides.nothing", memberType, namedElement.name) )	Annotation	annotation
false	Boolean	isConcretes
holder.createErrorAnnotation( memberNameId, ScalaBundle.message("member.needs.override.modifier", memberType, namedElement.name) )	Annotation	annotation
mutable.ArrayBuffer.empty[Int]	ArrayBuffer[Int]	indexes
0	Int	lastIndex
holder match { // handle possible element mapping (e.g. ScGeneratorAnnotator) case DelegateAnnotationHolder(element) => element case _ => annotatedElement }	PsiElement	delegateElement
EditorColorsManager.getInstance().getGlobalScheme	EditorColorsScheme	scheme
project	Project	projectCopy
if (needsParentheses) Seq(Hint(Seq(Text("(")), element, suffix = false)) else Seq.empty	Seq[Hint]	prefix
if (parameter.isVal || (parameter.isCaseClassVal && !parameter.isVar)) kVAL else kVAR	IElementType	keywordElementType
Set.empty[TextRange]	Set[TextRange]	res
p.`type`().getOrAny.removeAliasDefinitions()	ScType	paramType
if (!isInStructuralType) erased(paramType) else paramType	ScType	erasedType
clause.parameters.map { p => val `=>` = if (p.isCallByNameParameter) " => " else "" val `*` = if (p.isRepeatedParameter) "*" else "" val paramType = p.`type`().getOrAny.removeAliasDefinitions() val erasedType = if (!isInStructuralType) erased(paramType) else paramType `=>` + erasedType.canonicalText + `*` }	IndexedSeq[Any]	parts
namedElement match { case param: ScClassParameter if param.isCaseClassVal && !(param.isVal || param.isVar) => superSignaturesWithSelfType.headOption.collect { case signature: TermSignature => signature.namedElement }.flatMap { element => import ScalaTokenTypes.{kVAL, kVAR} nameContext(element) match { case parameter: ScClassParameter => val keywordElementType = if (parameter.isVal || (parameter.isCaseClassVal && !parameter.isVar)) kVAL else kVAR Some(keywordElementType) case _: ScValue | _: ScFunction => Some(kVAL) case _: ScVariable => Some(kVAR) case _ => None } }.map { new AddWithKeyword(member, memberNameId, _) } case _ => Some(new Add(member, memberNameId, Override)) }	Option[ModifierQuickFix.Add]	maybeQuickFix
false	Boolean	overridesFinal
ignoredRanges()	Set[TextRange]	ignored
if (includeNonProjectItems) GlobalSearchScope.allScope(project) else GlobalSearchScope.projectScope(project)	GlobalSearchScope	scope
element.children.find { case _: PsiComment | _: PsiWhiteSpace => false case _ => true }	Option[PsiElement]	noCommentWhitespace
noCommentWhitespace .map(_.getTextOffset) .getOrElse(element.getTextOffset)	Int	offset
ScalaProjectSettings.getInstance(project).isSearchAllSymbols	Boolean	searchAll
ProjectFileIndex.SERVICE.getInstance(file.getProject)	ProjectFileIndex	index
if (s.name == baseName + "_=") { overType match { case ParameterizedType(des, args) if des.canonicalText == "_root_.scala.Function1" => args.head case _ => return true } } else overType	ScType	actualType
ActionManager.getInstance.getAction(IdeActions.GROUP_CALL_HIERARCHY_POPUP).asInstanceOf[ActionGroup]	ActionGroup	group
Class.forName("com.intellij.ide.hierarchy.CallHierarchyBrowserBase")	Class[_]	forName
effectiveParams(sFun)	IndexedSeq[ScParameter]	sParams
effectiveParams(mFun)	IndexedSeq[ScParameter]	mParams
descriptor.asInstanceOf[CallHierarchyNodeDescriptor].getEnclosingElement	PsiMember	enclosingElement
enclosingElement match { case method: PsiMethod => method case _ => return ArrayUtil.EMPTY_OBJECT_ARRAY }	PsiMethod	method
s.typeParams	Seq[TypeParameter]	sTypeParams
new ArrayBuffer[PsiMethod]	ArrayBuffer[PsiMethod]	methods
method.getBody	PsiCodeBlock	body
mFun.typeParameters	Seq[ScTypeParam]	mTypeParams
getBaseDescriptor.asInstanceOf[CallHierarchyNodeDescriptor].getTargetElement.asInstanceOf[PsiMethod]	PsiMethod	baseMethod
baseMethod.containingClass	PsiClass	baseClass
NOT_VISIBLE_IN_JAVA_SHORT_NAME_KEY.elements(cleanName, scope, classOf[PsiClass])	Iterable[PsiClass]	classes
enclosingElement.asInstanceOf[PsiMethod]	PsiMethod	method
new mutable.HashMap[PsiMethod, CallHierarchyNodeDescriptor]	mutable.HashMap[PsiMethod, CallHierarchyNodeDescriptor]	methodToDescriptorMap
new ArrayBuffer[CallHierarchyNodeDescriptor]	ArrayBuffer[CallHierarchyNodeDescriptor]	result
METHOD_NAME_KEY.elements(cleanName, scope, classOf[ScFunction])	Iterable[ScFunction]	methods
new CallHierarchyNodeDescriptor(myProject, descriptor, calledMethod, false, false)	CallHierarchyNodeDescriptor	d
OverridingMethodsSearch.search(method, method.getUseScope, true).toArray(PsiMethod.EMPTY_ARRAY)	Array[PsiMethod]	overridingMethods
new CallHierarchyNodeDescriptor(myProject, descriptor, overridingMethod, false, false)	CallHierarchyNodeDescriptor	node
ScSubstitutor.bind(sTypeParams, mTypeParams)(TypeParameterType(_))	ScSubstitutor	typeParamSubst
PACKAGE_OBJECT_SHORT_NAME_KEY.elements(cleanName, scope, classOf[PsiClass])	Iterable[PsiClass]	packageObjects
callExpression.getMethodExpression	PsiReferenceExpression	methodExpression
methodExpression.resolve.asInstanceOf[PsiMethod]	PsiMethod	method
newExpression.resolveConstructor	PsiMethod	method
TYPE_ALIAS_NAME_KEY.elements(cleanName, scope, classOf[ScTypeAlias])	Iterable[ScTypeAlias]	typeAliases
ArrayBuffer.empty[NavigationItem]	ArrayBuffer[NavigationItem]	items
null	Class[_]	baseClass
baseMethod match { case mem: ScMember => mem.getContainingClassLoose case x => x.containingClass }	PsiClass	containing
!literal.isInstanceOf[ScInterpolatedStringLiteral] && !literal.isMultiLineString	Boolean	needEscape
getSearchScope(scopeType, containing)	SearchScope	searchScope
method.containingClass	PsiClass	originalClass
new mutable.HashSet[PsiMethod]	mutable.HashSet[PsiMethod]	methodsToFind
new mutable.HashMap[PsiMember, CallHierarchyNodeDescriptor]	mutable.HashMap[PsiMember, CallHierarchyNodeDescriptor]	methodToDescriptorMap
Text(": ") +: partsOf(expectedType, actualType, tooltipFor(expectedType, actualType)) |> { parts => if (needsParentheses) Text(")") +: parts else parts }	IndexedSeq[Text]	parts
ScSubstitutor.paramToParam(sParams, mParams)	ScSubstitutor	paramTypesSubst
PsiTreeUtil.getNonStrictParentOfType(element, classOf[PsiMethod], classOf[PsiClass])	PsiMember	key
new CallHierarchyNodeDescriptor(myProject, descriptor, element, false, true)	CallHierarchyNodeDescriptor	newD
methodToDescriptorMap.get(key) match { case Some(call) => if (!call.hasReference(reference)) { call.incrementUsageCount() } call case _ => val newD = new CallHierarchyNodeDescriptor(myProject, descriptor, element, false, true) methodToDescriptorMap.put(key, newD) newD }	CallHierarchyNodeDescriptor	d
if (sParams.size != mParams.size || sTypeParams.size != mTypeParams.size) s.substitutor else { val typeParamSubst = ScSubstitutor.bind(sTypeParams, mTypeParams)(TypeParameterType(_)) val paramTypesSubst = ScSubstitutor.paramToParam(sParams, mParams) s.substitutor.followed(typeParamSubst).followed(paramTypesSubst) }	ScSubstitutor	subst
(s.namedElement, namedElement) match { case (sFun: ScFunction, mFun: ScFunction) if effectiveParams(sFun).length == effectiveParams(mFun).length && s.typeParamsLength == mFun.typeParameters.length => val sParams = effectiveParams(sFun) val mParams = effectiveParams(mFun) val sTypeParams = s.typeParams val mTypeParams = mFun.typeParameters val subst = if (sParams.size != mParams.size || sTypeParams.size != mTypeParams.size) s.substitutor else { val typeParamSubst = ScSubstitutor.bind(sTypeParams, mTypeParams)(TypeParameterType(_)) val paramTypesSubst = ScSubstitutor.paramToParam(sParams, mParams) s.substitutor.followed(typeParamSubst).followed(paramTypesSubst) } subst(baseType) case _ => s.substitutor(baseType) }	ScType	actualBase
exp.getTextRange.getStartOffset :: literalIndices ::: exp.getTextRange.getEndOffset :: Nil	List[Int]	allIndices
if (needsParentheses) None else Hint.leftInsetLikeChar(' ')	Option[Any]	margin
property.declaredElementsArray	Array[PsiNamedElement]	elems
WorksheetCommonSettings(worksheetFile)	WorksheetCommonSettings	fileSettings
ScalaNamesUtil.scalaName(elem)	String	navigationItemName
WorksheetCommonSettings(worksheetFile.getProject)	WorksheetCommonSettings	projectSettings
ScalaNamesUtil.scalaName(clazz)	String	navigationItemName
new WorksheetAllSettingsForm(worksheetFile, getFileSettingsData, getDefaultSettingsData)	WorksheetAllSettingsForm	myPanel
ScalaCompilerConfiguration.instanceIn(settings.project)	ScalaCompilerConfiguration	config
config.defaultProfile	ScalaCompilerSettingsProfile	defaultProfile
null	InteractiveStatusDisplay	statusDisplayN
Seq(defaultProfile) ++ config.customProfiles	IndexedSeq[ScalaCompilerSettingsProfile]	profiles
originalEditor.getDocument	Document	originalDocument
settings.getCompilerProfileName	String	profileName
viewerEditor.getDocument	Document	viewerDocument
mutable.ArrayBuffer[FoldRegionInfo]()	ArrayBuffer[WorksheetFoldGroup.FoldRegionInfo]	_regions
originalEditor.getProject	Project	project
unfolded floorKey left	Int	key
(_: VisibleAreaEvent) => redrawDiffs()	VisibleAreaListener	visibleAreaListener
worksheetViewer.getDocument	Document	viewerDocument
new TextRange(foldStartOffset, foldStartOffset + offset)	TextRange	range
factory.create("WorksheetConsolePrinter", WORKSHEET_NAME, WORKSHEET_NAME, project)	RunnerLayoutUi	layoutUi
{ val offset = Math.min(foldEndOffset - foldStartOffset, WorksheetFoldGroup.PLACEHOLDER_LIMIT) val range = new TextRange(foldStartOffset, foldStartOffset + offset) viewerDocument.getText(range) }	String	placeholder
worksheetViewer.getFoldingModel.asInstanceOf[FoldingModelEx]	FoldingModelEx	viewerFolding
new WorksheetFoldGroup(worksheetViewer, originalEditor, project, getWorksheetSplitter.orNull)	WorksheetFoldGroup	foldGroup
false	Boolean	inited
ArrayBuffer[EvaluationChunk]()	ArrayBuffer[WorksheetDefaultEditorPrinter.EvaluationChunk]	evaluatedChunks
new ConsoleViewImpl(project, false)	ConsoleViewImpl	cv
PsiDocumentManager.getInstance(editor1.getProject)	PsiDocumentManager	documentManager
StringBuilder.newBuilder	mutable.StringBuilder	currentOutputBuffer
0	Int	currentOutputNewLinesCount
false	Boolean	cutoffPrinted
false	Boolean	terminated
0	Int	buffed
documentManager.getCachedPsiFile(editor1.getDocument)	PsiFile	file
if(errorMessage == null) "" else s": $errorMessage"	String	reason
15	Int	BULK_COUNT
1000	Int	IDLE_TIME_MLS
s"$internalErrorPrefix$reason"	String	fullErrorMessage
0.5f	Float	DEFAULT_WORKSHEET_VIEWERS_RATIO
ToolWindowManager.getInstance(project)	ToolWindowManager	manager
Key.create[SimpleWorksheetSplitter]("SimpleWorksheetViewerSplitter")	Key[WorksheetDiffSplitters.SimpleWorksheetSplitter]	DIFF_SPLITTER_KEY
new FileAttribute("LastWorksheetRunResult", 2, false)	FileAttribute	LAST_WORKSHEET_RUN_RESULT
outputStartLine + inputLinesCount - 1	Int	foldStartLine
new FileAttribute("ScalaWorksheetLastRatio", 1, false)	FileAttribute	LAST_WORKSHEET_RUN_RATIO
toolWindow.getContentManager	ContentManager	contentManager
viewerDocument.getLineNumber(outputEndOffset)	Int	foldEndLine
foldEndLine - foldStartLine	Int	foldedLinesCount
viewerDocument.getLineStartOffset(foldStartLine)	Int	foldStartOffset
outputEndOffset	Int	foldEndOffset
from	Int	start1
toolWindow.getContentManager	ContentManager	manager
to + 1	Int	end1
foldingModel.createFoldRegion(foldStartOffset, foldEndOffset, placeholder, null, false)	FoldRegion	region
offset - (to - from)	Int	start2
originalDocument.getLineEndOffset(inputEndLine.min(originalDocument.getLineCount))	Int	leftEndOffset
viewerEditor.getFoldingModel.asInstanceOf[FoldingModelEx]	FoldingModelEx	folding
offset + spaces + 1	Int	end2
editor1.getLineHeight	Int	lineHeight1
WorksheetCache.getInstance(don.getProject)	WorksheetCache	cache
editor2.getLineHeight	Int	lineHeight2
!scalaSettings.isWorksheetFoldCollapsedByDefault || expandedIndexes.contains(index)	Boolean	isExpanded
calcVisibleInterval(editor1)	WorksheetDiffSplitters.Segment	visibleInterval1
(Seq.empty, null, 0)	(Seq[WorksheetDiffSplitters.DiffMapping], WorksheetFoldGroup.FoldRegionInfo, Int)	emptyResult
calcVisibleInterval(editor2)	WorksheetDiffSplitters.Segment	visibleInterval2
new TwosideSyncScrollSupport( util.Arrays.asList(originalEditor, worksheetViewer), NoopSyncScrollable )	SyncScrollSupport.TwosideSyncScrollSupport	syncSupport
reg.leftEndOffset - 1	Int	leftEndOffset
offset2Line(leftEndOffset)	Int	leftEndLine
0	Int	ind
leftEndLine - reg.leftContentLines + 1	Int	leftStartLine
EvaluationChunk(inputStartLine, inputEndLine, output)	WorksheetDefaultEditorPrinter.EvaluationChunk	chunk
None	Option[Int]	lastProcessedLine
originalEditor.getScrollingModel.getVerticalScrollOffset	Int	scroll
worksheetViewer.getScrollingModel.getVerticalScrollOffset	Int	worksheetScroll
file	ScalaFile	currentFile
new VisibleAreaListener { override def visibleAreaChanged(e: VisibleAreaEvent): Unit = { splitter.redrawDiffs() syncSupport.visibleAreaChanged(e) } }	VisibleAreaListener { def visibleAreaChanged(e: VisibleAreaEvent): Unit }	listener
false	Boolean	hasErrors
false	Boolean	hasMessages
foldGroup.expandedRegionsIndexes.toSet	Set[Int]	expandedIndexes
StringBuilder.newBuilder	mutable.StringBuilder	outputBuffer
StringBuilder.newBuilder	mutable.StringBuilder	messagesBuffer
mutable.Queue.empty[QueuedPsi]	mutable.Queue[WorksheetIncrementalEditorPrinter.QueuedPsi]	psiToProcess
res :+ numbers(nextRegion, offset)	IndexedSeq[WorksheetDiffSplitters.DiffMapping]	resUpdated
WorksheetProjectSettings.getMakeType(module.getProject)	WorksheetMakeType	runType
ArrayBuffer(ArrayBuffer(chunks.head))	ArrayBuffer[ArrayBuffer[WorksheetDefaultEditorPrinter.EvaluationChunk]]	result
prefix :+ Hint(parts, element, margin = margin, suffix = true, relatesToPrecedingElement = true, offsetDelta = offsetDelta)	IndexedSeq[Hint]	hints
mutable.ListBuffer.empty[(Int, Int)]	ListBuffer[(Int, Int)]	inputToOutputMapping
StringBuilder.newBuilder	mutable.StringBuilder	resultText
ArrayBuffer.empty[FoldingOffsets]	ArrayBuffer[WorksheetEditorPrinterBase.FoldingOffsets]	resultFoldings
viewerDocument.getLineStartOffset(lineIdx)	Int	start
WorksheetDefaultEditorPrinter.groupChunks(chunks)	Seq[Seq[WorksheetDefaultEditorPrinter.EvaluationChunk]]	chunksGrouped
0	Int	foldedLines
s"res$ind"	String	name
viewerDocument.getLineEndOffset(viewerDocument.getLineCount - 1)	Int	end
ArrayBuffer[Int]()	ArrayBuffer[Int]	inds
mappings.map(diffToLinesMapping).map(linesToOffsetMapping)	IndexedSeq[(WorksheetDiffSplitters.Segment, WorksheetDiffSplitters.Segment)]	offsetMappings
group.head.inputStartLine	Int	inputStartLine
WorksheetPsiGlue()	WorksheetPsiGlue	glue
FileAttributeUtilCache.readAttribute(LAST_WORKSHEET_RUN_RATIO, file)	Option[String]	ratioAttribute
inds exists { idx => holder.findElementAt(expr.getTextRange.getStartOffset + idx + 1) match { case psi: PsiElement if psi.getNode.getElementType == ScalaTokenTypes.tIDENTIFIER => true case _ => false } }	Boolean	skip
group.last.inputEndLine	Int	inputEndLine
new WorksheetInterpretExprsIterator(getScalaFile, Option(originalEditor), lastProcessedLine)	WorksheetInterpretExprsIterator	iterator
inputEndLine - inputStartLine + 1	Int	inputLinesCount
seg1.start - visibleInterval1.start	Int	start1
glue.result	Seq[WorksheetIncrementalEditorPrinter.QueuedPsi]	elements
if (nextRegion.region == target) { if (nextRegion.expanded) { (res, nextRegion, offset) } else { val resUpdated = res :+ numbers(nextRegion, offset) (resUpdated, nextRegion, offset + nextRegion.spaces) } } else if (nextRegion.expanded) { val resUpdated = res :+ numbers(nextRegion, offset) (resUpdated, currentRegion, offset + nextRegion.spaces) } else { acc }	(Seq[WorksheetDiffSplitters.DiffMapping], WorksheetFoldGroup.FoldRegionInfo, Int)	accNew
seg1.end - visibleInterval1.start	Int	end1
offset2Line(target.leftEndOffset - 1)	Int	line
seg2.start - visibleInterval2.start	Int	start2
target.spaces	Int	spaces
75	Int	PLACEHOLDER_LIMIT
seg2.end - visibleInterval2.start	Int	end2
new FileAttribute("WorksheetPersistentFoldings", 1, false)	FileAttribute	WORKSHEET_PERSISTENT_FOLD_KEY
(idx & 1) == 0	Boolean	isEven
ArrayBuffer[(Int, Int)]()	ArrayBuffer[(Int, Int)]	result
group.map(_.outputText.length).sum	Int	outputTextLength
diff.flatten.map { case Leaf(Match(text, _)) => text case Leaf(Mismatch(text, _)) => f(text) } map { "<td style=\"text-align:center\">" + _ + "</td>" }	IndexedSeq[Any]	parts
group.map(_.outputLinesCount).sum	Int	outputLinesCount
resultText.length	Int	totalOutputLength
offsetMappings.zipWithIndex.collect { case ((seg1, seg2), idx) if visibleInterval1.intersects(seg1) || visibleInterval2.intersects(seg2) => // relative to the beginning of the editor component window top val start1 = seg1.start - visibleInterval1.start val end1 = seg1.end - visibleInterval1.start val start2 = seg2.start - visibleInterval2.start val end2 = seg2.end - visibleInterval2.start val isEven = (idx & 1) == 0 // to switch color between sibling polygons, to make them more noticeable val fillColor = if (isEven) COLOR1 else COLOR2 new DividerPolygon(start1, start2, end1, end2, fillColor, null, true) }	IndexedSeq[DiffDividerDrawUtil.DividerPolygon]	plainPolygons
editor.getScrollingModel.getVerticalScrollOffset	Int	verticalScrollOffset
verticalScrollOffset	Int	first
verticalScrollOffset + editorHeight	Int	last
parsedTail :+ fakeEndFoldRegion(originalDocument, viewerDocument)	IndexedSeq[WorksheetFoldGroup.FoldRegionSerializer.ParsedRegion]	regionsEffective
originalDocument.getLineNumber(prevFolding.leftEndOffset - 1)	Int	prevLeftEndLine
viewerDocument.getLineNumber(prevFolding.foldStartOffset)	Int	prevRightStartLine
originalDocument.getLineNumber(currFolding.leftEndOffset - 1)	Int	currLeftEndLine
None	Option[InteractiveStatusDisplay]	statusDisplay
currLeftEndLine - currFolding.leftSideLength + 1	Int	currLeftStartLine
currLeftStartLine - prevLeftEndLine - 1	Int	linesBetween
FileEditorManager.getInstance(project)	FileEditorManager	myFileEditorManager
viewerDocument.getLineNumber(prevFolding.foldEndOffset)	Int	prevRightEndLine
KeymapManager.getInstance.getActiveKeymap.getShortcuts("Scala.RunWorksheet")	Array[Shortcut]	shortcuts
(1 to linesBetween).map { idx => (prevLeftEndLine + idx, prevRightEndLine + idx) }	IndexedSeq[(Int, Int)]	mappingsBetween
ratioAttribute.flatMap(_.toFloatOpt).getOrElse(DEFAULT_WORKSHEET_VIEWERS_RATIO)	Float	ratio
viewerDocument.getTextLength - 1	Int	viewerLength
originalDocument.getTextLength - 1	Int	originalLength
myFileEditorManager.getAllEditors(file)	Array[FileEditor]	editors
newDefaultUiFor(editor, scalaFile, isPlain = true)	WorksheetDefaultEditorPrinter	printer
WorksheetCache.getInstance(editor.getProject)	WorksheetCache	cache
create(editor, scalaFile)	WorksheetEditorPrinter	printer
new WorksheetFileHook.MyPanel(file)	WorksheetFileHook.MyPanel	panel
psiToProcess.dequeue()	WorksheetIncrementalEditorPrinter.QueuedPsi	queuedPsi
serializeFoldRegions(group._regions)	String	regionsSerialized
PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument)	PsiFile	psiFile
new WorksheetFoldGroup(viewerEditor, originalEditor, project, splitter)	WorksheetFoldGroup	group
new WorksheetUiConstructor(panel, project)	WorksheetUiConstructor	constructor
psiFile match { case file: ScalaFile if file.isWorksheetFile => file case _ => return }	ScalaFile	file
Array(worksheetClassName, runnersJar.getAbsolutePath, output.getAbsolutePath) ++ outputDirs	IndexedSeq[String]	base
setupRightSideViewer(editor, scalaFile.getVirtualFile, getOrCreateViewerEditorFor(editor, isPlain))	Editor	sideViewer
if (runType != OutOfProcessServer) { val base = Array(worksheetClassName, runnersJar.getAbsolutePath, output.getAbsolutePath) ++ outputDirs replArgs.map(ra => base ++ Array(ra.path, ra.codeChunk, "replenabled")).getOrElse(base) } else Array.empty[String]	Array[String]	worksheetArgs
extractRegions(file)	Option[Seq[WorksheetFoldGroup.FoldRegionSerializer.ParsedRegion]]	parsedRegions
setupRightSideViewer(editor, scalaFile.getVirtualFile, getOrCreateViewerEditorFor(editor, isPlain = true))	Editor	sideViewer
rightSideEditor.getSettings	EditorSettings	viewerSettings
WorksheetFileHook.instance(project)	WorksheetFileHook	worksheetHook
new MyTranslatingClient(callback, project, originalFile, consumer)	RemoteServerConnector.MyTranslatingClient	client
rightSideEditor.asInstanceOf[EditorImpl]	EditorImpl	worksheetViewer
countNewLines(outputText) + 1	Int	linesCountOutput
new ClientEventProcessor(client)	ClientEventProcessor	eventClient
extractRegions(file).getOrElse(Seq())	Seq[WorksheetFoldGroup.FoldRegionSerializer.ParsedRegion]	parsedRegions
StringUtil.countNewLines(resultText)	Int	totalOutputLinesCount
WorksheetCache.getInstance(project) getViewer editor	Editor	viewer
totalOutputLinesCount - foldedLines	Int	totalOutputVisibleLinesCount
countNewLines(queuedPsi.getText) + 1	Int	linesCountInput
inputStartLine - totalOutputVisibleLinesCount	Int	diff
queuedPsi.getWholeTextRange	TextRange	originalTextRange
(className: String, addToCp: String) => invokeLater { executeWorksheet(file.getName, project, file.getContainingFile, className, addToCp) }	(String, String) => Unit	callback
extractMappings(parsedRegions, originalEditor.getDocument, viewerEditor.getDocument)	Seq[(Int, Int)]	mappings
new WorksheetCompiler(editor, file, callback, auto)	WorksheetCompiler	compiler
if (editorComponent.getComponentCount > 0) { editorComponent.getComponent(0) match { case splitter: JBSplitter => splitter.getProportion /* case _ if worksheetViewer.getUserData(DIFF_SPLITTER_KEY) != null => worksheetViewer.getUserData(DIFF_SPLITTER_KEY).getProportion */ case _ => DEFAULT_WORKSHEET_VIEWERS_RATIO } } else DEFAULT_WORKSHEET_VIEWERS_RATIO	Float	prop
originalLine(queuedPsi.getFirstProcessedOffset)	Int	processedStartLine
WorksheetCommonSettings(file)	WorksheetCommonSettings	fileSettings
originalLine(queuedPsi.getLastProcessedOffset)	Int	processedStartEndLine
FileAttributeUtilCache.readAttribute(WORKSHEET_PERSISTENT_FOLD_KEY, file).filter(_.nonEmpty)	Option[String]	regionsSerialized
','	Char	FieldSeparator
'|'	Char	RegionsSeparator
originalLine(originalTextRange.getEndOffset)	Int	processedEndLine
(aborted: Boolean, errors: Int, _: Int, _: CompileContext) => { if (!aborted && errors == 0) runnable() }	CompileStatusNotification	compilerNotification
(viewerDocument.getLineCount - 1).max(0)	Int	viewerDocumentLastLine
chunks.map { case c@EvaluationChunk(s, e, t) => (s, e, t.length, c.outputLinesCount) }	IndexedSeq[(Int, Int, Int, Int)]	chunksDump
createDefaultParameters(project, file, mainClassName, addToCp)	JavaParameters	params
foldGroup.foldedLines	Int	numberOfFoldedLines
params.createOSProcessHandler()	OSProcessHandler	processHandler
s"leadingNewLinesCount is expected to be non-negative but got: $diff, chunks: $chunksDump"	String	message
WorksheetDiffSplitters.createSimpleSplitter(editor, worksheetViewer, prop)	WorksheetDiffSplitters.SimpleWorksheetSplitter	diffPane
{ val diff = inputStartLine - totalOutputVisibleLinesCount if (diff < 0){ // expecting visible lines to be folded with the last input end line, thus less then current input start line // NOTE: be careful not to log chunk text itself val chunksDump = chunks.map { case c@EvaluationChunk(s, e, t) => (s, e, t.length, c.outputLinesCount) } val message = s"leadingNewLinesCount is expected to be non-negative but got: $diff, chunks: $chunksDump" Log.warn(message) } diff.max(0) }	Int	leadingNewLinesCount
(viewerDocumentLastLine - numberOfFoldedLines).max(0)	Int	viewerDocumentLastVisibleLine
outputLinesCount - inputLinesCount	Int	diffLocal
totalOutputLinesCount + leadingNewLinesCount	Int	outputStartLine
(processedStartLine - viewerDocumentLastVisibleLine).max(0)	Int	blankLinesBase
Seq(region.getStartOffset, region.getEndOffset, expanded, leftEndOffset, spaces, leftContentLines)	Seq[AnyVal]	fields
totalOutputLength + leadingNewLinesCount + outputTextLength - 1	Int	outputEndOffset
buildNewLines(blankLinesBase)	String	prefix
new JavaParameters()	JavaParameters	params
WorksheetCache.getInstance(project).getViewer(editor)	Editor	viewer
EditorFactory.getInstance	EditorFactory	factory
factory.createViewer(factory.createDocument(""), project)	Editor	editor
(dataId: String) => { if (CommonDataKeys.HOST_EDITOR.is(dataId)) editor else null }	DataProvider	dataProvider
("NO_TOKEN" +: arguments) map { case "" => Base64Converter.encode("#STUB#" getBytes "UTF-8") case s => Base64Converter.encode(s getBytes "UTF-8") }	IndexedSeq[Nothing]	encodedArgs
queuedPsi.getPrintChunks(outputText)	Seq[WorksheetIncrementalEditorPrinter.QueuedPsi.PrintChunk]	outputChunks
FoldingOffsets( outputStartLine, outputEndOffset, inputLinesCount, inputEndLine )	WorksheetEditorPrinterBase.FoldingOffsets	folding
-diffLocal	Int	trailingNewLinesCount
PsiFileFactory.getInstance(project).createFileFromText("dummy_" + Random.nextString(10), lang, "")	PsiFile	file
EditorHelper.openInEditor(file)	Editor	editor
EditorFactory.getInstance.createViewer(PsiDocumentManager.getInstance(project).getDocument(file), project)	Editor	editor
new ErrorHandler { override def error(message: String): Unit = Notifications.Bus notify { new Notification( "Scala Worksheet", "Cannot run worksheet", s"<html><body>${message.replace("\n", "<br>")}</body></html>", NotificationType.ERROR ) } }	ErrorHandler { def error(message: String): Unit }	errorHandler
file match { case sc: ScalaFile => sc case _ => return }	ScalaFile	scalaFile
EditorHighlighterFactory.getInstance.createEditorHighlighter(project, fileType)	EditorHighlighter	editorHighlighter
originalLine(absoluteOffset)	Int	currChunkLine
originalLine(absoluteOffset - relativeOffset)	Int	prevChunkLine
currChunkLine - prevChunkLine	Int	linesBetween
new ActionButton(this, getTemplatePresentation, ActionPlaces.EDITOR_TOOLBAR, ActionToolbar.DEFAULT_MINIMUM_BUTTON_SIZE)	ActionButton	button
getTemplatePresentation	Presentation	presentation
PlainRunType.createPrinter(editor, scalaFile)	WorksheetEditorPrinter	worksheetPrinter
outputChunks.map { case PrintChunk(absoluteOffset, relativeOffset, chunkText) => val currChunkLine = originalLine(absoluteOffset) val prevChunkLine = originalLine(absoluteOffset - relativeOffset) val linesBetween = currChunkLine - prevChunkLine (chunkText, linesBetween) }	IndexedSeq[(String, Int)]	outputTextWithNewLinesOffset
new WorksheetReplRunAction	WorksheetReplRunAction	ACTION_INSTANCE
buildNewLines(newLinesOffset)	String	prefix
new ProcessAdapter { override def onTextAvailable(event: ProcessEvent, outputType: Key[_]) { val text = event.getText if (ConsoleViewContentType.NORMAL_OUTPUT == ConsoleViewContentType.getConsoleViewType(outputType)) worksheetPrinter.processLine(text) } override def processTerminated(event: ProcessEvent): Unit = { worksheetPrinter.flushBuffer() } }	ProcessAdapter	myProcessListener
regions.map { case FoldRegionInfo(region, leftEndOffset, leftContentLines, spaces, expanded) => val fields = Seq(region.getStartOffset, region.getEndOffset, expanded, leftEndOffset, spaces, leftContentLines) fields.mkString(FieldSeparator.toString) }	IndexedSeq[Any]	regionsSerialized
outputTextWithNewLinesOffset.foldLeft(0)(_ + _._2)	Int	blankLinesFromOutput
processedStartEndLine	Int	inputLine
text.split(RegionsSeparator)	Array[String]	regionsDumps
WorksheetFileHook.getDocumentFrom(source.getProject, file)	Option[Document]	document
viewerDocumentLastLine + blankLinesBase + linesCountOutput + blankLinesFromOutput	Int	outputLine
viewerDocument.getLineCount	Int	lineCount
CommonDataKeys.VIRTUAL_FILE.getData(e.getDataContext)	VirtualFile	file
viewerDocumentLastLine + blankLinesBase	Int	outputStartLine
viewerDocument.getLineEndOffset(lineCount - 1)	Int	outputEndOffset
regionsDumps.map(_.split(FieldSeparator))	IndexedSeq[Array[String]]	regionsFields
Event.fromBytes(Base64Converter.decode(text.getBytes("UTF-8")))	Event	event
WorksheetCommonSettings(file).getModuleFor	Module	module
event.getPresentation	Presentation	presentation
WorksheetEditorPrinterFactory.loadWorksheetEvaluation(scalaFile)	Option[(String, Float)]	evaluationResults
FoldingOffsets( outputStartLine, outputEndOffset, linesCountInput, processedEndLine )	WorksheetEditorPrinterBase.FoldingOffsets	foldings
WorksheetEditorPrinterFactory.createViewer(editor, vFile)	Editor	viewer
runType match { case InProcessServer | OutOfProcessServer => new RemoteServerRunner(project).buildProcess(arguments, client) case NonServer => val eventClient = new ClientEventProcessor(client) val encodedArgs = ("NO_TOKEN" +: arguments) map { case "" => Base64Converter.encode("#STUB#" getBytes "UTF-8") case s => Base64Converter.encode(s getBytes "UTF-8") } val errorHandler = new ErrorHandler { override def error(message: String): Unit = Notifications.Bus notify { new Notification( "Scala Worksheet", "Cannot run worksheet", s"<html><body>${message.replace("\n", "<br>")}</body></html>", NotificationType.ERROR ) } } new NonServerRunner(project, Some(errorHandler)).buildProcess(encodedArgs, (text: String) => { val event = Event.fromBytes(Base64Converter.decode(text.getBytes("UTF-8"))) eventClient.process(event) }) }	CompilationProcess	worksheetProcess
viewer.getDocument	Document	document
WorksheetEditorPrinterFactory.DIFF_SPLITTER_KEY.get(viewer)	WorksheetDiffSplitters.SimpleWorksheetSplitter	splitter
shortcutId flatMap { id => KeymapManager.getInstance.getActiveKeymap.getShortcuts(id).headOption map (shortcut => genericText + (" (" + KeymapUtil.getShortcutText(shortcut) + ")")) } getOrElse genericText	String	text
inputLine.indexOf("$Lambda$")	Int	idx
createMerged2(editor, viewer, psiFile).withNormalizedSeparator	String	resultText
rightEditor.getDocument	Document	rightDocument
getActionButton	ActionButton	actionButton
editor.getDocument	Document	leftDocument
viewer.getDocument	Document	rightDocument
new StringBuilder	StringBuilder	result
WorksheetFoldGroup.load(viewer, editor, project, splitter, scalaFile)	WorksheetFoldGroup	group
Array(WorksheetReplRunAction.ACTION_INSTANCE)	Array[AnAction]	WORKSHEET_HK_ACTIONS
WorksheetFoldGroup.computeMappings(viewer, editor, psiFile)	Seq[(Int, Int)]	mappings
FileEditorManager.getInstance(project).getAllEditors(file)	Array[FileEditor]	editors
extensions.inReadAction(PsiManager getInstance project findFile originalFile) match { case scalaFile: ScalaFile if WorksheetFileSettings.isRepl(scalaFile) => Some(scalaFile) case _ => None }	Option[ScalaFile]	fileToReHighlight
80	Int	COPY_BORDER
new Key[PsiElement]("WORKSHEET_GOTO_PSI_KEY")	Key[PsiElement]	WORKSHEET_GOTO_PSI_KEY
createAnimatedIcon(InteractiveStatusDisplay.MY_COMPILE_ACTION, MY_OK_ICON, ICON_STEP_COUNT)	AnimatedIcon	successIcon
e getData CommonDataKeys.EDITOR	Editor	editor
createAnimatedIcon(InteractiveStatusDisplay.MY_COMPILE_ACTION, MY_ERROR_ICON, ICON_STEP_COUNT)	AnimatedIcon	failIcon
null	AnimatedIcon	current
Option(PsiManager.getInstance(project).findFile(file))	Option[PsiFile]	fileOpt
new AnimatedIcon( "Compiling...", (for (i <- 0 to steps) yield new RotatedIcon(icon1, step * i)).toArray[Icon], icon2, ICON_CYCLE_LENGTH )	AnimatedIcon	i
1300	Int	ICON_CYCLE_LENGTH
10	Int	ICON_STEP_COUNT
None	Option[ScalaFile]	file
line.map(i => i - 4).map(_.toInt)	Option[Int]	line1
file findElementAt offset	PsiElement	psi
ammoniteFile.getProject	Project	project
None	Option[String]	execName
RunManagerEx.getInstanceEx(project)	RunManagerEx	manager
None	Option[String]	fileName
None	Option[String]	scriptParameters
getIconWidth / 2 + x	Int	xn
ScratchRootType.getInstance.createScratchFile( project, "scratch", ScalaLanguage.INSTANCE, text, ScratchFileService.Option.create_new_always)	VirtualFile	f
new GeneralCommandLine()	GeneralCommandLine	cmd
getIconHeight / 2 + y	Int	yn
new AmmoniteRunConfigurationFactory(this)	AmmoniteRunConfigurationFactory	factory
new CommandLineState(environment) { override def startProcess(): ProcessHandler = { val cmd = new GeneralCommandLine() execName match { case Some(exec) => val exFile = new File(exec) if (exFile.exists()) cmd.setExePath(exFile.getAbsolutePath) else cmd.setExePath(exec) case None => cmd.setExePath("/usr/local/bin/amm") } if (isRepl) { cmd.addParameter("--predef") cmd.addParameter(s"${createPredefFile(getIOFile.map(_.getName).getOrElse("AmmoniteFile.sc"))}") } fileName.foreach{ f => cmd.addParameter(f) val tf = new File(f) if (tf.exists()) cmd.setWorkDirectory(tf.getParentFile) } scriptParameters.foreach(cmd.getParametersList.addParametersString(_)) patchSdkVersion(cmd) try { JavaCommandLineStateUtil.startProcess(cmd) } catch { case pne: ProcessNotCreatedException => pne.getCause match { case ioe: IOException => ioe.getCause match { case ioe2: IOException if ioe2.getMessage.contains("error=2") => throw new AmmNotFoundException( s"<br>Can't find Ammonite:<br> ${ioe2.getMessage} <br>" + "<br> <a href=\"azaza\">Specify amm executable path?</a>", pne.getCommandLine, project ) case _ => } case _ => } throw pne } } }	CommandLineState { def startProcess(): ProcessHandler }	state
ammoniteFile.getVirtualFile	VirtualFile	vFile
new AmmoniteRunConfigurationForm	AmmoniteRunConfiguration.AmmoniteRunConfigurationForm	form
scalaPsi match { case mem: ScMember => mem.syntheticNavigationElement match { case null => scalaPsi case v => v } case _ => scalaPsi }	PsiElement	originalElement
scalaFile.getContainingDirectory	PsiDirectory	dir
(f: File) => f.exists()	Nothing => Any	existsPredicate
psiToProcess.head	WorksheetIncrementalEditorPrinter.QueuedPsi	currentPsi
currentPsi.getWholeTextRange.getStartOffset	Int	offset
createLabeledElement("Script:", createFileBrowser)	LabeledComponent[TextFieldWithBrowseButton]	comp0
createLabeledElement("Amm executable:", createFileBrowser)	LabeledComponent[TextFieldWithBrowseButton]	comp1
ProgressManager.getInstance	ProgressManager	manager
mutable.WeakHashMap.empty[ScalaFile, (ScObject, Long)]	mutable.WeakHashMap[ScalaFile, (ScObject, Long)]	file2object
createLabeledElement("Script parameters:", new RawCommandLineEditor)	LabeledComponent[RawCommandLineEditor]	comp2
new LabeledComponent[T]	LabeledComponent[T]	c
new TextFieldWithBrowseButton()	TextFieldWithBrowseButton	fileBrowser
mutable.ListBuffer.empty[File]	ListBuffer[Any]	files
new AmmoniteUtil.RegexExtractor	AmmoniteUtil.RegexExtractor	e
AmmoniteUtil.extractLibInfo(stableExpr).map(AmmoniteUtil.convertLibName).getOrElse(stableExpr.refName)	String	refName
refName	String	name
2	Int	count
false	Boolean	ignoreImportStandard
ProjectLibraryTable.getInstance(project).getModifiableModel	LibraryTable.ModifiableModel	tableModel
column.map(_ + 1 - differ).map(_.toInt)	Option[Any]	column1
name	String	n
ScalaPsiElementFactory.createImportFromText(s"import $imp")(ammoniteFile.projectContext)	ScImportStmt	importStmt
Seq("ammonite.main.Router._", "ammonite.runtime.tools.grep", "ammonite.runtime.tools.browse", "ammonite.runtime.tools.time", "ammonite.repl.tools.desugar", "ammonite.repl.tools.source")	Seq[Nothing]	DEFAULT_IMPORTS
s"${name}_$scalaVersion"	String	nv
inReadAction { originalEditor.offsetToLogicalPosition(offset) }	LogicalPosition	p
{ val p = inReadAction { originalEditor.offsetToLogicalPosition(offset) } new LogicalPosition(p.line + vertOffset, p.column + horizontalOffset) }	LogicalPosition	position
kind match { case INFO | JPS_INFO | OTHER => CompilerMessageCategory.INFORMATION case ERROR => hasErrors = true CompilerMessageCategory.ERROR case PROGRESS => CompilerMessageCategory.STATISTICS case WARNING => CompilerMessageCategory.WARNING }	CompilerMessageCategory	category
Seq(("repl", "ammonite.repl.ReplAPI"), ("interp", "ammonite.runtime.Interpreter with ammonite.interp.Interpreter"))	Seq[(Nothing, Nothing)]	DEFAULT_BUILTINS
ProgressManager.getInstance().getProgressIndicator	ProgressIndicator	taskIndicator
GotoOriginalHandlerUtil.createPsi((from: ScalaFile) => ScalaPsiElementFactory.createObjectWithContext( s"object ${AmmoniteScriptWrappersHolder.getWrapperName(from)} {\n${from.getText} }", from, from.getFirstChild ), from)	ScObject	obj
createWrapper(base)	ScObject	wrapper
base.getModificationStamp	Long	timestamp
mutable.ArrayBuffer.empty[CreateImportedLibraryQuickFix]	ArrayBuffer[CreateImportedLibraryQuickFix]	acc
file.getProject	Project	fileProject
severity.isFatal	Boolean	isFatal
ModuleRootManager.getInstance(module).getModifiableModel	ModifiableRootModel	moduleModel
ScalaCompilerConfiguration.instanceIn(project)	ScalaCompilerConfiguration	configuration
getCompilerProfileName	String	name
1	Int	SET_PROBLEM_MASK
2	Int	SET_OPEN_MASK
4	Int	SET_DAEMON_MASK
SET_PROBLEM_MASK | SET_OPEN_MASK | SET_DAEMON_MASK	Int	READY_MASK
s"$n|$nv|$nv.${ScalaUtil.getScalaVersion(refElement.getContainingFile).flatMap(_.split('.').lastOption).getOrElse("0")}"	String	fullVersion
s"$group/$fullVersion/jars|bundles"	String	ivyPath
WorksheetSourceProcessor.processSimple(srcFile, editor)	String	code
WorksheetDefaultSettings.getInstance(project)	WorksheetDefaultSettings	storeComponent
getCompilerProfileName	String	compilerName
Array(PlainRunType, ReplRunType)	Array[WorksheetExternalRunType]	PREDEFINED_TYPES
false	Boolean	afterSemicolon
s"${group.replace('.', '/')}/$nv|$name/$version"	String	mavenPath
store.lastOption match { case Some(value) => value case None => add(element) return }	WorksheetIncrementalEditorPrinter.QueuedPsi	previousElement
Seq(name, version)	Seq[String]	prefixPatterns
elements(previousElement)	Seq[PsiElement]	elementsPrev
PREDEFINED_TYPES.map(rt => (rt.getName, rt)).toMap	Map[String, WorksheetExternalRunType]	PREDEFINED_TYPES_MAP
ExtensionPointName.create[WorksheetExternalRunType]("org.intellij.scala.worksheetExternalRunType")	ExtensionPointName[WorksheetExternalRunType]	EP_NAME
elementsPrev :+ element	IndexedSeq[PsiElement]	elementsNew
WorksheetSourceProcessor.processDefault(srcFile, editor.getDocument)	Either[PsiErrorElement, (String, String)]	result
second.prevSiblings	Iterator[PsiElement]	it
WorksheetSourceProcessor.processIncremental(srcFile, editor)	Either[PsiErrorElement, (String, String)]	result
worksheetFile.getProject	Project	project
WorksheetProjectSettings.getMakeType(project)	WorksheetMakeType	makeType
WorksheetFileSettings.getRunType(worksheetFile)	WorksheetExternalRunType	runType
worksheetFile.getVirtualFile	VirtualFile	worksheetVirtual
configuration.customProfiles match { case profiles if isScratchWorksheet(file.getVirtualFile) => val name = getCompilerProfileName profiles.find(_.getName == name) case profiles => for { ScFile.VirtualFile(virtualFile) <- Some(file) module <- ScalaUtil.getModuleForFile(virtualFile) profile <- profiles.find(_.getModuleNames.contains(module.getName)) } yield profile }	Option[ScalaCompilerSettingsProfile]	maybeCustomProfile
new FileAttribute("ScalaWorksheetMakeBeforeRun", 1, true)	FileAttribute	IS_MAKE_BEFORE_RUN
new FileAttribute("ScalaWorksheetModuleForCp", 1, false)	FileAttribute	CP_MODULE_NAME
new FileAttribute("ScalaWorksheetCompilerProfile", 1, false)	FileAttribute	COMPILER_PROFILE
new FileAttribute("ScalaWorksheetAutoRun", 1, true)	FileAttribute	IS_AUTORUN
JarFileSystem.getInstance	JarFileSystem	jarFileSystem
new FileAttribute("ScalaWorksheetRunType", 1, false)	FileAttribute	WORKSHEET_RUN_TYPE
MessageView.SERVICE.getInstance(project).getContentManager	ContentManager	contentManager
new Task.Backgroundable(project, "Adding dependencies", false) { override def run(indicator: ProgressIndicator): Unit = { indicator.setText("Ammonite: loading list of versions...") val (forScala, predicate) = ScalaUtil.getScalaVersion(file) .fold( ( MajorVersion('2'): MyScalaVersion, Function.const(true)(_: File) ) ) { version => ( ExactVersion(version.charAt(3), Version(version)), (file: File) => file.getName.startsWith("scala-") && Artifact.ScalaArtifacts.exists(_.versionOf(file).isDefined) ) } val (scalaVersion, ammoniteVersion) = detectAmmoniteVersion(forScala) indicator.setText("Ammonite: extracting info from SBT...") val files = mutable.ListBuffer.empty[File] val e = new AmmoniteUtil.RegexExtractor import e._ createTempSbtProject( scalaVersion, Seq("set libraryDependencies += \"com.lihaoyi\" " + "%" + " \"ammonite\" " + "%" + " \"" + ammoniteVersion + "\" " + "%" + " \"test\" cross CrossVersion.full"), Seq("show test:dependencyClasspath") ) { case mre"[info] * Attributed($pathname)" => new File(pathname) match { case f if f.exists() => files += f case _ => } case mre"[success]$_" => indicator.setText("Ammonite: adding dependencies...") ScalaUtil.getModuleForFile(file.getVirtualFile).foreach { module => invokeLater { inWriteAction { val tableModel = ProjectLibraryTable.getInstance(project).getModifiableModel val moduleModel = ModuleRootManager.getInstance(module).getModifiableModel val jarFileSystem = JarFileSystem.getInstance for { file <- files if predicate(file) rootFile = jarFileSystem.findLocalVirtualFileByPath(file.getCanonicalPath) if rootFile != null library = tableModel.createLibrary(file.getName) model = library.getModifiableModel } { model.addRoot(rootFile, OrderRootType.CLASSES) model.commit() moduleModel.addLibraryEntry(library) } tableModel.commit() moduleModel.commit() } } } case mre"[error]$content" => LOG.warn(s"Ammonite, error while importing dependencies: $content") case _ => } } }	Task.Backgroundable { def run(indicator: ProgressIndicator): Unit }	task
WorksheetCommonSettings(worksheetFile).getModuleFor	Module	module
FileAttributeUtilCache.readAttributeLight(WORKSHEET_RUN_TYPE, scalaFile)	Option[String]	attrValue
new SerializableInFileAttribute[String] { override def convertFrom(t: String): String = t override def convertTo(s: String): String = s }	SerializableWorksheetAttributes.SerializableInFileAttribute[String]	StringFileAttribute
new SerializableInFileAttribute[Boolean] with WorksheetPerFileConfig { override def convertFrom(t: Boolean): String = getStringRepresent(t) override def convertTo(s: String): Boolean = s match { case `enabled` => true case _ => false } }	SerializableWorksheetAttributes.SerializableInFileAttribute[Boolean] with WorksheetPerFileConfig	BooleanFileAttribute
new SerializableInFileAttribute[WorksheetExternalRunType] { override def convertFrom(t: WorksheetExternalRunType): String = t.getName override def convertTo(s: String): WorksheetExternalRunType = RunTypes.findRunTypeByName(s).getOrElse(RunTypes.getDefaultRunType) }	SerializableWorksheetAttributes.SerializableInFileAttribute[WorksheetExternalRunType]	ExternalRunTypeAttribute
old.getComponent.asInstanceOf[CompilerErrorTreeView]	CompilerErrorTreeView	oldView
new CompilerErrorTreeView(project, null)	CompilerErrorTreeView	newView
createCompilerTask	CompilerTask	task
new RemoteServerConnector.CompilerInterfaceImpl(task, createWorksheetPrinter, None, auto)	RemoteServerConnector.CompilerInterfaceImpl	consumer
loadScalaVersions(forScala) match { case Success(Some(v)) => v.presentation case _ => DEFAULT_SCALA_VERSION }	String	scalaVersion
new RemoteServerConnector(worksheetFile, tempFile, outputDir, className, None, true)	RemoteServerConnector	connector
new RemoteServerConnector.CompilerInterfaceImpl(task, createWorksheetPrinter, None)	RemoteServerConnector.CompilerInterfaceImpl	consumer
new RemoteServerConnector(worksheetFile, new File(""), new File(""), "", replModeArgs, false)	RemoteServerConnector	connector
loadAmmoniteVersion(forScala, scalaVersion).getOrElse(DEFAULT_AMMONITE_VERSION)	String	ammoniteVersion
ExtensionPointName.create[WorksheetCustomRunner]("org.intellij.scala.worksheetCustomRunner")	ExtensionPointName[WorksheetCustomRunner]	EP_NAME
s"\\Q$AMMONITE_PREFIX\\E$THREE_DIGIT_PATTERN".r	Regex	pattern
mutable.WeakHashMap[VirtualFile, mutable.HashMap[FileAttribute, String]]()	mutable.WeakHashMap[VirtualFile, mutable.HashMap[FileAttribute, String]]	lightKeys
if (isFatal) () => {originalEditor.getCaretModel moveToLogicalPosition position} else () => {}	() => Unit	onError
toMatch.lastIndexOf('\n')	Int	indexOfNl
3000	Int	RUN_DELAY_MS_MAXIMUM
700	Int	RUN_DELAY_MS_MINIMUM
toMatch.lastIndexOf('^')	Int	indexOfC
if (indexOfC < indexOfNl) 0 else indexOfC - indexOfNl	Int	horOffset
new Key[String]("WorksheetPreClassKey")	Key[String]	WORKSHEET_PRE_CLASS_KEY
ContentFactory.SERVICE.getInstance.createContent(newView, ERROR_CONTENT_NAME, true)	Content	errorContent
contentManager findContent ERROR_CONTENT_NAME	Content	oldContent
for { line <- lastProcessedLine editor <- editorOpt (start, end) = lineRange(line, editor) element <- Option(file.findElementAt((start + end) / 2)) } yield element	Option[PsiElement]	element
{ val element = for { line <- lastProcessedLine editor <- editorOpt (start, end) = lineRange(line, editor) element <- Option(file.findElementAt((start + end) / 2)) } yield element element.getOrElse(file.getFirstChild) }	PsiElement	startPsiElement
new Alarm(Alarm.ThreadToUse.SWING_THREAD, project)	Alarm	myAlarm
new MyDocumentAdapter(document)	WorksheetAutoRunner.this.MyDocumentAdapter	listener
PsiTreeUtil.firstChild(psiElement)	PsiElement	leaf
PsiDocumentManager getInstance project	PsiDocumentManager	documentManager
0	Int	lastProcessedOffset
mutable.HashMap.empty[String, (Int, File, File)]	mutable.HashMap[String, (Int, Any, Any)]	compilationInfo
documentManager.getPsiFile(document)	PsiFile	psiFile
s""" |def $PRINT_ARRAY_NAME(an: Any): String = { | an match { | case arr: Array[_] => | val a = scala.collection.mutable.WrappedArray.make(arr) | a.toString.stripPrefix("Wrapped") | case null => "null" | case other => other.toString | }} """.stripMargin	String	PRINT_ARRAY_TEXT
inReadAction { startPsiElement.parentsInFile.lastOption.getOrElse(startPsiElement) }	PsiElement	current
new Key[PsiElement]("GOTO_ORIGINAL_HANDLER_BASE")	Key[PsiElement]	MY_KEY
e.getOffset	Int	offset
creator(original)	O	psi
WorksheetFileSettings.getRunType(psiFile).isReplRunType	Boolean	isRepl
document.getLineNumber(lastProcessedOffset)	Int	line1
document.getLineNumber(offset)	Int	line2
SourceTreeToPsiMap.treeElementToPsi(node)	PsiElement	element
ExtensionPointName.create[FileDeclarationsContributor]("org.intellij.scala.fileDeclarationsContributor")	ExtensionPointName[FileDeclarationsContributor]	EP_NAME
new ArrayBuffer[FoldingDescriptor]	ArrayBuffer[FoldingDescriptor]	descriptors
get(editor)	Editor	viewer
new Notification(GROUP_ID, "Extensions available", s"""<p>Additional support has been found for some of your libraries.</p> |<p>Do you want to enable it? <a href="Yes">Yes</a> / <a href="No">No</a></p> """.stripMargin, NotificationType.INFORMATION, (notification: Notification, event: HyperlinkEvent) => { notification.expire() event.getDescription match { case "Yes" => yesCallback() case "No" => noCallback() } } )	Notification	notification
EditorFactory.getInstance()	EditorFactory	factory
new TextRange(lastProcessedOffset, (offset + 1).min(document.getTextLength))	TextRange	range
ArrayBuffer[String]()	ArrayBuffer[String]	result
None	Option[String]	scalaVersion
LibraryExtensionsManager.getInstance(project)	LibraryExtensionsManager	libraryExtensionsManager
FileEditorManager.getInstance(project)	FileEditorManager	manager
mutable.HashMap[String, Regex]()	mutable.HashMap[String, Regex]	patternCache
s"${TECHNICAL_MESSAGE_START}repl$$$$start$$$$"	String	REPL_START
WorksheetCache.getInstance(srcFile.getProject).getLastProcessedIncremental(editor)	Option[Int]	lastProcessed
libraryExtensionsManager	LibraryExtensionsManager	extensionsManager
ArrayBuffer[String]()	ArrayBuffer[String]	errors
new WorksheetInterpretExprsIterator(srcFile, Some(editor), lastProcessed)	WorksheetInterpretExprsIterator	iterator
s"${TECHNICAL_MESSAGE_START}repl$$$$chunk$$$$end$$$$"	String	REPL_CHUNK_END
s"${TECHNICAL_MESSAGE_START}repl$$$$last$$$$chunk$$$$processed$$$$"	String	REPL_LAST_CHUNK_PROCESSED
32	Int	LAMBDA_LENGTH
isRepl && fragment.length == 0 && e.getOffset + 1 >= e.getDocument.getTextLength && e.getOldFragment.length == 0	Boolean	isTrashEvent
sc.parts.map(Pattern.quote).mkString("(.+)")	String	patternString
elements.map(_.getText)	IndexedSeq[String]	texts
if (lastProcessed.isEmpty) ":reset" +: texts else texts	IndexedSeq[String]	allExprs
Map()	Map[DependencyManagerBase.DependencyDescription, libextensions.ExtensionProps]	INDEX
patternCache.getOrElseUpdate(patternString, patternString.r)	Regex	regex
WorksheetCache.getInstance(srcFile.getProject) .peakCompilationIteration(srcFile.getViewProvider.getVirtualFile.getCanonicalPath) + 1	Int	iterNumber
projectResolvers	Seq[DependencyManagerBase.Resolver]	resolvers
org.apache.ivy.util.Message.MSG_ERR	Int	logLevel
s"A$$A$iterNumber"	String	name
node \@ "interface"	String	interface
node \@ "implementation"	String	impl
node \@ "pluginId"	String	pluginId
s"inst$$A$$A"	String	instanceName
node \ "name" text	String	name
node \ "description" text	String	description
Option(WorksheetCommonSettings(srcFile).getModuleFor)	Option[Module]	moduleOpt
for { dir <- srcFile.getContainingDirectory.toOption psiPackage <- JavaDirectoryService.getInstance().getPackage(dir).toOption packageName = psiPackage.getQualifiedName if !packageName.trim.isEmpty } yield packageName	Option[String]	packOpt
name	String	classPrologue
isRepl && { val length = fragment.length length == 0 || fragment.charAt(length - 1) != '\n' }	Boolean	isReplWrongChar
selectedDescriptor.flatMap(_.descriptor.getCurrentPluginDescriptor.map(_.extensions)).getOrElse(Nil).filter(_.isAvailable)	Seq[ExtensionDescriptor]	myExtensions
if (isRepl) getAutoRunDelay / 2 else getAutoRunDelay	Int	requestDelay
s"""$packStmt import _root_.org.jetbrains.plugins.scala.worksheet.$macroPrinterName | |object $name { |""".stripMargin	String	objectPrologue
new StringBuilder(s"final class $classPrologue { \n")	StringBuilder	classRes
Option(node \@ "since-build").filter(_.nonEmpty).flatMap(Version.parse).orNull	ScalaPluginVersionVerifier.Version	sinceBuild
new LibraryDetailsModel(None)	LibExtensionsSettingsPanelWrapper.this.LibraryDetailsModel	detailsModel
new StringBuilder( s"""def main($runPrinterName: java.io.PrintStream) $returnType { | val $instanceName = new $name | """.stripMargin )	StringBuilder	objectRes
new ScalaSourceBuilder( classRes, objectRes, iterNumber, srcFile, moduleOpt, Some(document), macroPrinterName, packOpt, objectPrologue )	WorksheetSourceProcessor.ScalaSourceBuilder	sourceBuilder
new JBList[ExtensionDescriptor](detailsModel)	JBList[ExtensionDescriptor]	extensionsList
mutable.ListBuffer.empty[PsiElement]	ListBuffer[PsiElement]	preDeclarations
Option(node \@ "until-build").filter(_.nonEmpty).flatMap(Version.parse).orNull	ScalaPluginVersionVerifier.Version	untilBuild
new LibraryListModel(detailsModel)	LibExtensionsSettingsPanelWrapper.this.LibraryListModel	libraryListModel
mutable.ListBuffer.empty[PsiElement]	ListBuffer[PsiElement]	postDeclarations
if (!isForObject(srcFile)) srcFile else { ((null: PsiElement) /: srcFile.getChildren) { case (a, imp: ScImportStmt) => sourceBuilder.processImport(imp) a case (null, obj: ScObject) => obj.putCopyableUserData(WORKSHEET_PRE_CLASS_KEY, "+") obj.extendsBlock.templateBody getOrElse srcFile case (null, cl: ScTemplateDefinition) => cl.putCopyableUserData(WORKSHEET_PRE_CLASS_KEY, "+") preDeclarations += cl null case (a: PsiElement, cl: ScTemplateDefinition) => postDeclarations += cl a case (a, _) => a } }	PsiElement	root
findJarsWithProps()	Seq[(VirtualFile, libextensions.ExtensionProps)]	jarsWithProps
Option(node \@ "pluginId").filter(_.nonEmpty)	Option[String]	pluginId
new JBList[ExtensionJarData](libraryListModel)	JBList[libextensions.ExtensionJarData]	librariesList
node \@ "defaultPackage"	String	defaultPackage
jarsWithProps.map(_._2).toSet	Set[libextensions.ExtensionProps]	libraryProps
getPropsFromLocalIndex	Seq[libextensions.ExtensionProps]	bundledProps
node \ "extension" map parseExtension	IndexedSeq[ExtensionDescriptor]	extensions
getRemoteExtensions((libraryProps ++ bundledProps).toSeq)	Seq[Any]	jars
ProjectLibraryTable.getInstance(project)	LibraryTable	table
data \ "name" text	String	name
data \ "id" text	String	id
data \ "description" text	String	descr
data \ "vendor" text	String	vendor
data \ "version" text	String	version
data \ "ideaVersion" map parseIdeaVersionDescriptor	IndexedSeq[IdeaVersionDescriptor]	descriptors
ScalaProjectSettings.getInstance(file.getProject).isUseEclipseCompatibility	Boolean	isEclipseMode
".replace(\"" + instanceName + ".\", \"\")"	String	eraseClassName
LibraryDescriptor(name, id, descr, vendor, version, descriptors)	LibraryDescriptor	descriptor
".stripPrefix(\"" + name + "$" + name + "$\")"	String	erasePrefixName
0	Int	assignCount
0	Int	resCount
mutable.ArrayBuffer[String]()	ArrayBuffer[String]	importStmts
mutable.HashSet[ScImportStmt]()	mutable.HashSet[ScImportStmt]	importsProcessed
fun.getModifierList.accessModifier	Option[ScAccessModifier]	accessModifier
accessModifier.map(accessModifierText).getOrElse("")	String	hadMods
FileChooser.chooseFile( new FileChooserDescriptor(false, false, true, true, false, false), project, null)	VirtualFile	jar
true	Boolean	TYPE_AWARE_HIGHLIGHTING_ENABLED
false	Boolean	SUGGEST_TYPE_AWARE_HIGHLIGHTING
libraryExtensionsManager.getAvailableLibraries	Seq[libextensions.ExtensionJarData]	libraries
PropertiesComponent.getInstance(project)	PropertiesComponent	properties
new PopupHelper	PopupHelper	popup
project.getMessageBus.syncPublisher(EXTENSIONS_TOPIC)	LibraryExtensionsListener	publisher
new HighlightingSettings()	HighlightingSettings	settings
binding.name	String	pName
mutable.HashMap[Class[_], mutable.ArrayBuffer[Any]]()	mutable.HashMap[Class[_], ArrayBuffer[Any]]	myExtensionInstances
if (major == Int.MaxValue) "SNAPSHOT" else s"$major.$minor.$build"	String	presentation
if (index != -1 && index < libraries.size) { Some(libraries(index)) } else None	Option[libextensions.ExtensionJarData]	newData
variableInstanceName(pName)	String	defName
mutable.ArrayBuffer[ExtensionJarData]()	ArrayBuffer[libextensions.ExtensionJarData]	myLoadedLibraries
DataManager.getInstance.getDataContextFromFocusAsync	Promise[DataContext]	context
new JBLabel(builder.mkString)	JBLabel	label
None	Option[MessageBusConnection]	messageBusConnection
line.lastIndexOf("//")	Int	i
new NotificationGroup("Implicit Hints tip", NotificationDisplayType.STICKY_BALLOON, false)	NotificationGroup	group
ExtensionPointName.create("org.intellij.scala.scalaPluginVersionVerifier")	ExtensionPointName[ScalaPluginVersionVerifier]	EP_NAME
{ getClass.getClassLoader match { case pluginLoader: PluginClassLoader => Version.parse(PluginManagerCore.getPlugin(pluginLoader.getPluginId).getVersion) case _ => Some(Version.Snapshot) } }	Option[ScalaPluginVersionVerifier.Version]	getPluginVersion
new JBSplitter(true, 0.6f)	JBSplitter	listsPane
comment.getNextSibling	PsiElement	c
psi.getFirstChild match { case comment: PsiComment => var c = comment.getNextSibling while (c.is[PsiComment, PsiWhiteSpace]) c = c.getNextSibling if (c != null) c else psi case _ => psi }	PsiElement	actualStart
psiToLineNumbers(varDef)	Option[String]	lineNum
ActionManager.getInstance().getAction("Scala.EnableErrors")	AnAction	action
{ val group = new NotificationGroup("Implicit Hints tip", NotificationDisplayType.STICKY_BALLOON, false) group.createNotification(message, NotificationType.INFORMATION) }	Notification	notification
output.indexOf('\n')	Int	newLineIdx
"https://plugins.jetbrains.com/plugins/%s/" + scalaPluginId	String	baseUrl
false	Boolean	doneUpdating
ScalaPluginVersionVerifier.EP_NAME.getExtensions	Array[ScalaPluginVersionVerifier]	extensions
false	Boolean	failed
Map( CASSIOPEIA_OLD -> Map( Release -> "DUMMY", EAP -> "https://www.jetbrains.com/idea/plugins/scala-eap-cassiopeia.xml", Nightly -> "https://www.jetbrains.com/idea/plugins/scala-nightly-cassiopeia.xml" ), FOURTEEN_ONE_OLD -> Map( Release -> "DUMMY", EAP -> "https://www.jetbrains.com/idea/plugins/scala-eap-14.1.xml", Nightly -> "" ), FOURTEEN_ONE -> Map( Release -> "DUMMY", EAP -> baseUrl.format("eap"), Nightly -> baseUrl.format("nightly") ) )	Map[Nothing, Nothing]	knownVersions
FOURTEEN_ONE	String	currentVersion
new NotificationGroup(updGroupId, NotificationDisplayType.STICKY_BALLOON, true)	NotificationGroup	GROUP
startPsiOffset(first)	Int	offset1
startPsiOffset(second)	Int	offset2
FileDocumentManager.getInstance().getFile(e.getDocument)	VirtualFile	file
new DocumentListener { override def documentChanged(e: DocumentEvent): Unit = { val file = FileDocumentManager.getInstance().getFile(e.getDocument) if (file != null && file.getFileType == ScalaFileType.INSTANCE) scheduleUpdate() } }	DocumentListener { def documentChanged(e: DocumentEvent): Unit }	updateListener
UpdateSettings.getInstance()	UpdateSettings	updateSettings
table.getLibraries.flatMap { lib => lib.getName.split(": ?") match { case Array("sbt", org, module, version, "jar") => Some(DependencyDescription(org, module, version)) case _ => None } }	IndexedSeq[DependencyManagerBase.DependencyDescription]	descriptions
withOptionalBraces { typeElement2Types(tpl).zip(varDef.declaredElements).map { case (tpe, el) => el.name + ": " + tpe.getText } }	String	names
s"${Math.abs(props.hashCode())}.jar"	String	fileName
ModuleManager.getInstance(project) .getModules .toSet .flatMap(SbtModule.Resolvers.apply)	IndexedSeq[SbtResolver]	allProjectResolvers
action.getShortcutSet.getShortcuts.headOption.map(KeymapUtil.getShortcutText)	Option[Nothing]	shortcut
myProject	Project	project
DownloadableFileService.getInstance()	DownloadableFileService	fileService
new ExtensionDownloader(indicator, sbtResolvers).getExtensionJars	Seq[Any]	resolved
shortcut.map(sh => s" or press $sh ").getOrElse(" ")	String	orPressShortcut
ApplicationInfo.getInstance().asInstanceOf[ApplicationInfoImpl]	ApplicationInfoImpl	infoImpl
PrintChunk(offset1, 0, text1)	WorksheetIncrementalEditorPrinter.QueuedPsi.PrintChunk	chunk1
if (strict && element != null) element.getParent else element	PsiElement	current
current	PsiElement	result
infoImpl.getBuild	BuildNumber	localBuildNumber
if (strict && element != null) element.getContext else element	PsiElement	current
myLoadedLibraries.map(_.file).toSet	Set[Any]	alreadyLoadedSet
resolved.toSet	Set[Any]	newExtensionsSet
Option(element).map(_.getFirstChild).orNull	PsiElement	current
withOptionalBraces { varDef.declaredElements.map { case tpePattern: ScTypedPattern => writeTypedPatter(tpePattern) case a => a.name } }	String	names
newExtensionsSet &~ alreadyLoadedSet	Set[Any]	libsAdded
if (element == null) List.empty else List(element)	List[PsiElement]	stack
PluginManagerCore.getPlugin(pluginLoader.getPluginId)	IdeaPluginDescriptor	plugin
alreadyLoadedSet &~ newExtensionsSet	Set[Any]	libsRemoved
branch match { case Release => None case EAP => Some(currentRepo(EAP)) case Nightly => Some(currentRepo(Nightly)) }	Option[String]	url
fileService.createFileDescription(props.urlOverride, s"$fileName.part")	DownloadableFileDescription	description
libsAdded.nonEmpty || libsRemoved.nonEmpty	Boolean	extensionsChanged
stack.head	PsiElement	element
if (element != null) mutable.Queue(element) else mutable.Queue.empty	mutable.Queue[PsiElement]	queue
(varDef.typeElement, varDef.expr) match { case (Some(tpl: ScTypeElement), Some(expr)) => val names = withOptionalBraces { typeElement2Types(tpl).zip(varDef.declaredElements).map { case (tpe, el) => el.name + ": " + tpe.getText } } varDefText(names, expr) case (_, Some(expr)) => val names = withOptionalBraces { varDef.declaredElements.map { case tpePattern: ScTypedPattern => writeTypedPatter(tpePattern) case a => a.name } } varDefText(names, expr) case _ => varDef.getText }	String	txt
JarFileSystem.getInstance().findLocalVirtualFileByPath(resolved.getAbsolutePath)	VirtualFile	vFile
queue.dequeue()	PsiElement	element
psiToLineNumbers(assign)	Option[String]	lineNums
Option(element).map(_.getNextSibling).orNull	PsiElement	current
s"`get$$$$instance_$assignCount$$$$$pName`"	String	defName
if (element == null) null else element.getPrevSibling	PsiElement	current
imp.importExprs.head.qualifier	ScStableCodeReference	currentQual
None	Option[(ScStableCodeReference, PsiElement)]	lastFound
e.getContainingFile	PsiFile	file
lastQualifier.qualName	String	qualifierName
psiToLineNumbers(imp)	Option[String]	lineNums
if (el.isInstanceOf[ScValue] || el.isInstanceOf[ScVariable]) //variable to avoid weird errors variableInstanceName(qualifierName) else qualifierName	String	memberName
s"Plugin ${plugin.getName} of version ${plugin.getVersion} is " + s"incompatible with Scala plugin of version $version. Do you want to disable ${plugin.getName} plugin?\n" + s"""<p/><a href="Yes">Yes, disable it</a>\n""" + s"""<p/><a href="No">No, leave it enabled</a>"""	String	message
XML.withSAXParser(factory.newSAXParser).load(u)	Elem	resp
comment.getTextRange	TextRange	range
new Notification(Scala_Group, "Incompatible plugin detected", message, NotificationType.ERROR, new NotificationListener { def hyperlinkUpdate(notification: Notification, event: HyperlinkEvent) { notification.expire() val description = event.getDescription callback(description) } })	Notification	notification
((resp \\ "idea-plugin").head \ "idea-version" \ "@since-build").text	String	text
PrintChunk(offset2, offset2 - offset1, text2.trim)	WorksheetIncrementalEditorPrinter.QueuedPsi.PrintChunk	chunk2
PluginManagerCore.getPlugin(PluginId.findId(haskforceId))	IdeaPluginDescriptor	plugin
inReadAction(queryParameters.getEffectiveSearchScope)	SearchScope	scope
documentOpt .map(calcContentLines(_, range)) .getOrElse(countNewLines(comment.getText))	Int	count
elements.map(_.getText).mkString(" ; ")	String	concat
startPsiOffset(elements.head)	Int	offset
queryParameters.getProject	Project	project
s"get$$$$instance$$$$res$resCount"	String	resName
sbtResolvers.toSeq.collect { case r: SbtMavenResolver => MavenResolver(r.name, r.root) case r: SbtIvyResolver if r.name != "Local cache" => IvyResolver(r.name, r.root) }	IndexedSeq[DependencyManagerBase.Resolver with Product with Serializable]	ivyResolvers
inReadAction(element.getReferences)	Array[PsiReference]	references
psiToLineNumbers(expr)	Option[String]	lineNums
PrintChunk(offset, 0, output)	WorksheetIncrementalEditorPrinter.QueuedPsi.PrintChunk	chunk
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { val references = inReadAction(element.getReferences) for (ref <- references) { inReadAction { ref match { case refElement: PsiReferenceExpression if ref.getRangeInElement.contains(offsetInElement) => refElement.resolve match { case FakePsiMethod(`vals`) => if (!consumer.process(refElement)) return false case StaticPsiTypedDefinitionWrapper(`vals`) => if (!consumer.process(refElement)) return false case PsiTypedDefinitionWrapper(`vals`) => if (!consumer.process(refElement)) return false case _ => } case _ => } } } true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
PsiSearchHelper.getInstance(queryParameters.getProject)	PsiSearchHelper	helper
Set("apply")	Set[String]	names
s"""Plugin ${plugin.getName} of version ${plugin.getVersion} is |incompatible with Scala Plugin for IDEA 2017.3 |${hyperlink(DisableHaskForcePlugin)} |${hyperlink(DisableScalaPlugin)} |${hyperlink(Ignore)} |""".stripMargin	String	message
props.map(_.artifact.toDepDescription)	IndexedSeq[DependencyManagerBase.DependencyDescription]	deps
new IvyExtensionsResolver(ivyResolvers, progress)	IvyExtensionsResolver	resolver
JarFileSystem.getInstance	JarFileSystem	jarFS
inReadAction { ScalaFilterScope(queryParameters) }	SearchScope	scope
Set("unapply", "unapplySeq")	Set[String]	names
s"""$getObjectPrologue${importStmts.mkString(";")}${classBuilder.toString()} | | |${objectBuilder.toString()}""".stripMargin	String	codeResult
Option(vFile.findFileByRelativePath(MANIFEST_PATH)) .map(vFile => Try(using(vFile.getInputStream)(XMLNoDTD.load)))	Option[Try[Nothing]]	manifest
extensions.inReadAction { FilenameIndex.getFilesByName(project, PROPS_NAME, GlobalSearchScope.allScope(project)) }	Array[PsiFile]	files
mutable.HashMap[Class[_], mutable.ArrayBuffer[Any]]()	mutable.HashMap[Class[_], ArrayBuffer[Any]]	classBuffer
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { val references = inReadAction(element.getReferences) for (ref <- references) { inReadAction { ref match { case refElement: PsiReferenceExpression if ref.getRangeInElement.contains(offsetInElement) => refElement.resolve match { case otherWrapper@PsiTypedDefinitionWrapper(`delegate`) if otherWrapper.getName == name => if (!consumer.process(refElement)) return false case otherWrapper@StaticPsiTypedDefinitionWrapper(`delegate`) if otherWrapper.getName == name => if (!consumer.process(refElement)) return false case _ => } case _ => } } } true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
queryParameters.isIgnoreAccessScope	Boolean	ignoreAccess
s"${packageOpt.fold("")(_ + ".")}$name"	String	mainClassName
files.collect { case f if f.getVirtualFile != null && f.getVirtualFile.getFileSystem == jarFS => jarFS.getJarRootForLocalFile(jarFS.getVirtualFileForJar(f.getVirtualFile)) }	IndexedSeq[VirtualFile]	containingJars
UrlClassLoader.build() .urls(jarFile.toURI.toURL) .parent(getClass.getClassLoader) .useCache() .get()	UrlClassLoader	classLoader
ScalaApplicationSettings.getInstance()	ScalaApplicationSettings	appSettings
createProcessor(consumer, binding, checkApply = true, checkUnapply = true)	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
if (withInstance) instanceName + "." else ""	String	target
psiToLineNumbers(psi)	Option[String]	lineNum
ScalaFilterScope(queryParameters)	SearchScope	scope
containingJars.map(extractPropsFromJar)	IndexedSeq[Option[libextensions.ExtensionProps]]	props
countNewLines(ws.getText)	Int	c
psi	PsiElement	actualPsi
actualPsi.getTextRange.getStartOffset	Int	start
psi.getTextRange.getEndOffset	Int	end
createProcessor(consumer, binding, checkApply, checkUnapply)	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
new Apply(binding)	ApplyUnapplyForBindingSearcher.this.Apply	IsApply
new Unapply(binding)	ApplyUnapplyForBindingSearcher.this.Unapply	IsUnapply
PsiSearchHelper.getInstance(project)	PsiSearchHelper	helper
numberStr getOrElse psiToLineNumbers(psi)	Any	lineNumbers
inReadAction(binding.name)	String	name
cons	Processor[_ >: PsiReference]	consumer
jarFile.findFileByRelativePath(s"META-INF/$PROPS_NAME")	VirtualFile	propsVF
inReadAction { element match { case (fun: ScFunctionDefinition) && ContainingClass(obj: ScObject) if names.contains(fun.name) => val scope = ScalaFilterScope(queryParameters) Some((fun, obj, scope)) case _ => None } }	Option[(ScFunctionDefinition, ScObject, SearchScope)]	data
inReadAction { element match { case _ if !element.isValid => None case f: ScFunction => Some((f, f.name)) case (rp: ScReferencePattern) && inNameContext(_: ScVariable) => Some((rp, rp.name)) case _ => None } }	Option[(ScNamedElement, String)]	data
new Processor[PsiReference] { def process(ref: PsiReference): Boolean = { inReadAction { checkAndTransform(ref).flatMap(_.bind()) match { case Some(ScalaResolveResult(`fun`, _)) => consumer.process(ref) case _ => true } } } }	Processor[PsiReference] { def process(ref: PsiReference): Boolean }	processor
s"Your IDEA is outdated to use with $branch branch.<br/>Would you like to switch IDEA channel to EAP?" + s"""<p/><a href="Yes">Yes</a>""" + s"""<p/><a href="No">Not now</a>""" + s"""<p/><a href="Ignore">Ignore this update</a>"""	String	message
new TextOccurenceProcessor { def execute(elem: PsiElement, offsetInElement: Int): Boolean = { inReadAction { elem match { case Parent(Parent(assign: ScAssignment)) => assign.resolveAssignment match { case Some(res) if res.element.getNavigationElement == element => Option(assign.leftExpression).foreach { case ref: ScReference => if (!consumer.process(ref)) return false } case _ => } case _ => } true } } }	TextOccurenceProcessor { def execute(elem: PsiElement, offsetInElement: Int): Boolean }	processor
HttpRequests.request(url).connect { request => try { Some(new UpdatesInfo(JDOMUtil.load(request.getInputStream))) } catch { case e: JDOMException => LOG.info(e); None } }	Option[UpdatesInfo]	info
new TextOccurenceProcessor { def execute(elem: PsiElement, offsetInElement: Int): Boolean = { inReadAction { elem match { case ref: PsiReference => ref.resolve() match { case FakePsiMethod(`element`) => if (!consumer.process(ref)) return false case PsiTypedDefinitionWrapper(`element`) => if (!consumer.process(ref)) return false case _ => } case _ => } } true } }	TextOccurenceProcessor { def execute(elem: PsiElement, offsetInElement: Int): Boolean }	processor
repr.getReturnType.toScType()	ScType	retTpe
getPlatformUpdateResult match { case Some(result) if isUpToDatePlatform(result) && !infoImpl.isEAP && appSettings.ASK_PLATFORM_UPDATE => // platform is up to date - suggest eap Some(createPlatformChannelSwitchPopup()) case Some(result) if result.getNewBuild != null => Some(createPlatformUpdateSuggestPopup()) case _ => None }	Option[Notification]	notification
PropertiesComponent.getInstance().getOrInitLong(key , 0)	Long	lastUpdateTime
PermanentInstallationID.get()	String	uid
value.find { case elem if clazz.isInstance(elem) && predicate(elem.asInstanceOf[T]) => true case _ => false }	Option[A]	result
new ScalaTypeDefinitionFindUsagesOptions(project)	ScalaTypeDefinitionFindUsagesOptions	typeDefinitionOptions
new ArrayBuffer[A](value.size)	ArrayBuffer[A]	buffer
s"https://plugins.jetbrains.com/plugins/list?pluginId=$scalaPluginId&build=$buildNumber&pluginVersion=$pluginVersion&os=$os&uuid=$uid"	String	url
new ScalaMemberFindUsagesOptions(project)	ScalaMemberFindUsagesOptions	memberOptions
Set[K]()	Set[K]	seen
new ScalaLocalFindUsagesOptions(project)	ScalaLocalFindUsagesOptions	localOptions
new RewriteRule { override def transform(n: Node): NodeSeq = n match { case <version>{_}</version> => <version>{newVersion}</version> case <include/> => NodeSeq.Empty // relative path includes break temp file parsing case other => other } }	RewriteRule	versionPatcher
ScalaPsiUtil.getCompanionModule(cls)	Option[ScTypeDefinition]	companion
properties.getValues(EXT_JARS_KEY)	Array[Nothing]	jarPaths
f(x)	K	v
new ArrayBuffer[B](value.size)	ArrayBuffer[B]	buffer
value.iterator	Iterator[A]	iterator
iterator.next()	A	next
f(next, i)	A	fNext
new RuleTransformer(versionPatcher).transform(XML.withSAXParser(factory.newSAXParser).load(stream))	Seq[Node]	document
companion.toSeq.flatMap(_.allFunctionsByName("apply"))	IndexedSeq[PsiMethod]	applyMethods
f(next)	A	fNext
new ArrayBuffer[(A, B)](value.size)	ArrayBuffer[(A, B)]	b
ScalaApplicationSettings.getInstance()	ScalaApplicationSettings	applicationSettings
value.iterator	Iterator[A]	it
it.next()	A	v
new Notification(updGroupId, title, message, NotificationType.INFORMATION, new NotificationListener { def hyperlinkUpdate(notification: Notification, event: HyperlinkEvent) { notification.expire() applicationSettings.ASK_USE_LATEST_PLUGIN_BUILDS = false event.getDescription match { case "EAP" => doUpdatePluginHostsAndCheck(EAP) case "Nightly" => doUpdatePluginHostsAndCheck(Nightly) case "Release" => doUpdatePluginHostsAndCheck(Release) case _ => applicationSettings.ASK_USE_LATEST_PLUGIN_BUILDS = true } } })	Notification	notification
value.iterator	Iterator[A]	delegate
CompilerIndicesSettings(project)	CompilerIndicesSettings	compilerIndicesOptions
f.returnType.toOption	Option[ScType]	returnType
generator(delegate.next())	Seq[B]	value
c.constructors	Seq[ScMethodLike]	constructors
value.size	Int	size
ProjectManager.getInstance().getOpenProjects.headOption.orNull	Project	project
factory.create(size)	Array[B]	array
_	StateRestoringCheckBox	myCbUsages
t.nameContext match { case v: ScValue if isBeanProperty(v) => Array(GETTER) case v: ScVariable if isBeanProperty(v) => Array(GETTER, SETTER) case v: ScValue if isBooleanBeanProperty(v) => Array(IS_GETTER) case v: ScVariable if isBooleanBeanProperty(v) => Array(IS_GETTER, SETTER) case _ => Array.empty[DefinitionRole] }	Array[PropertyMethods.DefinitionRole]	a
_	StateRestoringCheckBox	myCbOnlyNewInstances
_	StateRestoringCheckBox	myCbMembersUsages
_	StateRestoringCheckBox	myCbImplementingTypeDefinitions
_	StateRestoringCheckBox	myCbCompanionModule
array(idx)	A	element
new Processor[UsageInfo] { override def process(t: UsageInfo): Boolean = { if (t.getFile.getFileType == ScalaFileType.INSTANCE) true else processor.process(t) } }	Processor[UsageInfo] { def process(t: UsageInfo): Boolean }	nonScalaTextProcessor
ProjectFileIndex.getInstance(e.getProject)	ProjectFileIndex	pfindex
element.asInstanceOf[ScTypeDefinition]	ScTypeDefinition	definition
element match { case isWrapper(named) => named case FakePsiMethod(method) => method case _ => element }	PsiElement	unwrapped
new Val("", "")	Model.Val	None
new Val("(", ")")	Model.Val	Parentheses
Seq( myCbToSearchForTextOccurrences, myCbCompanionModule, myCbOnlyNewInstances )	Seq[StateRestoringCheckBox]	dependentCbs
new Val("{", "}")	Model.Val	Braces
new Val("[", "]")	Model.Val	SquareBrackets
isSelected(myCbUsages) || isSelected(myCbMembersUsages) || isSelected(myCbImplementingTypeDefinitions)	Boolean	hasSelected
scalaScope.getOrElse(elementScope)	ElementScope	scope
myLoadedLibraries.find(_ == jarData)	Option[libextensions.ExtensionJarData]	extensionData
new Topic[LibraryExtensionsListener]("EXTENSIONS_TOPIC", classOf[LibraryExtensionsListener])	Topic[LibraryExtensionsListener]	EXTENSIONS_TOPIC
0l	Long	modCount
false	Boolean	isImplementingTypeDefinitions
false	Boolean	isMembersUsages
false	Boolean	isSearchCompanionModule
false	Boolean	isOnlyNewInstances
super.hashCode()	Int	res
new ModificationTracker { private var modCount = 0l def incModCount(): Unit = modCount += 1 override def getModificationCount: Long = modCount }	ModificationTracker { var modCount : Long def incModCount(): Unit def getModificationCount: Long }	MOD_TRACKER
suggestChooseSuper(unwrapped)	Option[PsiNamedElement]	maybeSuper
searchInCompilerIndices(named, processor)	Boolean	res
ArrayBuffer[PsiClass]()	ArrayBuffer[PsiClass]	res
CompilerIndicesSettings(project)	CompilerIndicesSettings	settings
new ShouldBeSearchedInBytecode(settings)	SearchTargetExtractors.ShouldBeSearchedInBytecode	shouldSearchInBytecode
CompilerIndicesInheritorsSearch.search(definition, options.searchScope) .forEach((e: PsiElement) => processor.process(new UsageInfo(e)))	Boolean	success
doBeforeIndicesSearchAction(target, usageType)	Boolean	shouldProceed
usageType == UsageType.SAMInterfaceImplementation	Boolean	isSAMSearch
inReadAction { for { containingClass <- Option(ml.containingClass) } yield { new LocalSearchScope(containingClass) .intersectWith(queryParameters.getEffectiveSearchScope) } }	Option[SearchScope]	localScope
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { inReadAction { element match { case si: ScSelfInvocation if si.bind.contains(ml) => consumer.process(si) case _ => true } } } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
ClassInheritorsSearch.search(definition, true).forEach((cls: PsiClass) => cls match { case _: PsiClassWrapper => true case aClass: PsiClass => processor.process(new UsageInfo(aClass)) case _ => true })	Boolean	success
MixinNodes.linearization(clazz) .flatMap(_.extractClass) .reverse	IndexedSeq[PsiClass]	fromLessConcrete
fromLessConcrete.indexOf(t)	Int	index
inReadAction { element match { case _ if !element.isValid => None case o: ScObject => Some((o, o.name)) case wrapper@PsiClassWrapper(_: ScObject | _: ScTrait) => Some((wrapper, wrapper.getName)) case _ => None } }	Option[(PsiClassAdapter with NavigatablePsiElement, String)]	toProcess
if (!forHighlightUsages) { val maybeSuper = suggestChooseSuper(unwrapped) val settings = CompilerIndicesSettings(project) val shouldSearchInBytecode = new ShouldBeSearchedInBytecode(settings) maybeSuper.flatMap { case shouldSearchInBytecode(target, usageType) => val shouldProceed = doBeforeIndicesSearchAction(target, usageType) val isSAMSearch = usageType == UsageType.SAMInterfaceImplementation shouldProceed.option((target, !isSAMSearch)) case other => (other, false).toOption } } else Option((unwrapped, false))	Option[(PsiElement, Boolean)]	replaced
new mutable.HashSet[PsiReference]	mutable.HashSet[PsiReference]	collectedReferences
inReadAction(element.getUseScope)	SearchScope	scope
new SubPatternWithIndexBindings(index)	ConstructorParamsInConstructorPatternSearcher.this.SubPatternWithIndexBindings	correspondingSubpatternWithBindings
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { val references = inReadAction(element.getReferences) for (ref <- references if ref.getRangeInElement.contains(offsetInElement)) { inReadAction { if (ref.isReferenceTo(elem) || ref.resolve() == elem) { if (!consumer.process(ref)) return false } } } true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { val references = inReadAction(element.getReferences) for (ref <- references if ref.getRangeInElement.contains(offsetInElement) && !collectedReferences.contains(ref)) { inReadAction { ref match { case refElement: PsiReferenceExpression => refElement.resolve match { case ScFunctionWrapper(delegate) if delegate == method && !consumer.process(refElement) => return false case t: StaticPsiMethodWrapper if t.getNavigationElement == method && !consumer.process(refElement) => return false case _ => } case _ => } } } true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
fun.getFunctionWrappers(isStatic, isAbstract = fun.isAbstractMember, concreteClassFor(fun))	Seq[ScFunctionWrapper]	wrappers
RenameSuperMembersUtil.allSuperMembers(e, withSelfType = true).filter(needToAsk)	Seq[PsiNamedElement]	supers
null.asInstanceOf[A]	A	result
true	Boolean	isEmpty
new UsageInfoToUsageConverter.TargetElementsDescriptor(Array(), Array(only))	UsageInfoToUsageConverter.TargetElementsDescriptor	descriptor
if (supers.nonEmpty) Messages.showYesNoCancelDialog(e.getProject, message, "Warning", Messages.getQuestionIcon) else NO	Int	searchForSuperInstead
false	Boolean	intersperseNext
inReadAction(ScalaFilterScope(queryParameters))	SearchScope	scope
UsageInfoToUsageConverter.convert(descriptor, new UsageInfo(t))	Usage	usage
if (intersperseNext) sep else delegate.next()	B	element
FindUsagesHandlerFactory.EP_NAME.getExtensions(project)	Array[FindUsagesHandlerFactory]	extensions
update	V	newValue
new Processor[PsiReference] { def process(t: PsiReference): Boolean = t match { case correspondingSubpatternWithBindings(Seq(only)) => ReferencesSearch.search(only, scope, false).forEach(new Processor[PsiReference] { def process(t: PsiReference): Boolean = { inReadAction { val descriptor = new UsageInfoToUsageConverter.TargetElementsDescriptor(Array(), Array(only)) val usage = UsageInfoToUsageConverter.convert(descriptor, new UsageInfo(t)) processor0.process(usage) } } }) case _ => true } }	Processor[PsiReference] { def process(t: PsiReference): Boolean }	processor
FileDocumentManager.getInstance()	FileDocumentManager	fileDocManager
new CompilerIndicesInheritorsSearch	CompilerIndicesInheritorsSearch	instance
new CompilerIndicesReferencesSearch	CompilerIndicesReferencesSearch	instance
new LinkLabel[AnyRef](ScalaBundle.message("scala.compiler.indices.settings.navigate"), null) { setListener({ case (_, _) => close(DialogWrapper.CLOSE_EXIT_CODE) ShowSettingsUtil.getInstance().showSettingsDialog(project, classOf[CompilerIndicesConfigurable]) }, null) }	LinkLabel[AnyRef]	settingsLink
Ref.create[T]	Ref[T]	ref
Set.newBuilder[String]	mutable.Builder[String, Set[String]]	outdated
inReadAction { queryParameters.getElementToSearch match { case e if !e.isValid => None case parameter: ScParameter => Some((parameter, parameter.name)) case _ => None } }	Option[(ScParameter, String)]	data
new DialogWrapperAction("Enable") { override def doAction(e: ActionEvent): Unit = { enableCompilerIndices() close(DialogWrapper.OK_EXIT_CODE) } }	EnableCompilerIndicesDialog.this.DialogWrapperAction { def doAction(e: Any): Unit }	enable
new DialogWrapperAction("Enable and restart") { override def doAction(e: ActionEvent): Unit = { enableCompilerIndices() ApplicationManagerEx.getApplicationEx.restart(true) close(DialogWrapper.OK_EXIT_CODE) } }	EnableCompilerIndicesDialog.this.DialogWrapperAction { def doAction(e: Any): Unit }	enableAndRestart
params.cls	PsiClass	cls
cls.getProject	Project	project
Promise[T]()	Promise[T]	promise
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { val references = inReadAction(element.getReferences) for (ref <- references if ref.getRangeInElement.contains(offsetInElement) && !collectedReferences.contains(ref)) { ref match { case refElement: ScReference => inReadAction { refElement.getParent match { case assign: ScAssignment if assign.leftExpression == refElement && assign.getParent.isInstanceOf[ScArgumentExprList] => Option(refElement.resolve()) match { case Some(`parameter`) => if (!consumer.process(ref)) return false case Some(x: ScParameter) => ScalaPsiUtil.parameterForSyntheticParameter(x) match { case Some(realParam) => if (realParam == parameter && !consumer.process(ref)) return false case None => } case _ => } case _ => } } case _ => } } true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
PsiDocumentManager.getInstance(project)	PsiDocumentManager	psiDocumentManager
new JBCheckBox( "Pre-compile modules in use scope before searching", !CompilerIndicesSbtSettings().useManualConfiguration)	JBCheckBox	checkBox
{ val checkBox = new JBCheckBox( "Pre-compile modules in use scope before searching", !CompilerIndicesSbtSettings().useManualConfiguration) checkBox.setMnemonic('P') checkBox }	JBCheckBox	shouldCompileCB
127	Byte	ScFunExprMarker
new HyperlinkLabel("bytecode")	HyperlinkLabel	link
cases.iterator	Iterator[PartialFunction[A, B]]	it
it.next()	PartialFunction[A, B]	caze
parameters.element	PsiNamedElement	target
target.getProject	Project	project
param.getType match { case arrayType: PsiArrayType if extractVarargComponent && param.isVarArgs => arrayType.getComponentType case tp => tp }	PsiType	paramType
extractCandidatesFromUsage(psiManager, psiDocumentManager, usage.unwrap)	Option[UsageToPsiElements.ElementsInContext]	maybeCandidates
IndexId.create("sc.back.refs")	IndexId[CompilerRef, Seq[Int]]	backwardUsages
IndexId.create("sc.back.hierarchy")	IndexId[CompilerRef, Seq[CompilerRef]]	backwardHierarchy
0	Int	version
ScalaCompilerReferenceService(project)	ScalaCompilerReferenceService	service
SharedImplUtil.getChildrenOfType(element.getNode, elementType)	Array[ASTNode]	nodes
nodes.length	Int	length
f.create(length)	Array[Psi]	array
element.getNode.getChildren(filter)	Array[ASTNode]	nodes
None	Option[ScalaCompilerReferenceWriter]	indexWriter
fileDocManager.isDocumentUnsaved(doc) || file.getVirtualFile.getTimeStamp > usage.timestamp	Boolean	isOutdated
Option(element.getNode.findChildByType(elementType))	Option[ASTNode]	node
lineNumber(e)	Int	line
stubOrPsiChildren	Array[PsiElement]	children
children.length	Int	size
!processMatchingElements( target, usage.unwrap, isOutdated, candidates, processor )	Boolean	shouldMarkAsOutdated
service.SAMImplementationsOf(cls, checkDeep = false)	Set[Timestamped[compilerReferences.UsagesInFile]]	usages
outdated.result()	Set[String]	filesToNotify
candidates.elements.collect { case (e @ SAMTypeImplementation(sam), line) if ScEquivalenceUtil.areClassesEquivalent(sam, target) => processor.process(e) (e, line) case (cls: PsiClass, line) if cls.isInheritor(target, true) => processor.process(cls) (cls, line) }	Seq[(PsiElement, Int)]	matched
service.usagesOf(target)	Set[Timestamped[compilerReferences.UsagesInFile]]	usages
new KeyDescriptor[CompilerRef] { override def getHashCode(t: CompilerRef): Int = t.hashCode override def isEqual(t: CompilerRef, t1: CompilerRef): Boolean = t == t1 override def save(out: DataOutput, t: CompilerRef): Unit = t.save(out) override def read(in: DataInput): CompilerRef = in.readByte() match { case 0 => new JavaCompilerClassRef(ioutil.readINT(in)) case 1 => new JavaCompilerMethodRef(ioutil.readINT(in), ioutil.readINT(in), ioutil.readINT(in)) case 2 => new JavaCompilerFieldRef(ioutil.readINT(in), ioutil.readINT(in)) case 3 => new JavaCompilerFunExprDef(ioutil.readINT(in)) case 4 => new JavaCompilerAnonymousClassRef(ioutil.readINT(in)) case ScFunExprCompilerRef.ScFunExprMarker => ScFunExprCompilerRef(ioutil.readINT(in)) } }	KeyDescriptor[CompilerRef] { def getHashCode(t: CompilerRef): Int def isEqual(t: CompilerRef, t1: CompilerRef): Boolean def save(out: Any, t: CompilerRef): Unit def read(in: Any): CompilerRef }	refDescriptor
psiFile.depthFirst().flatMap { e => val line = lineNumber(e) canBeUsage(line).option(e -> line) }.toList	List[(PsiElement, Int)]	elems
new CompilerReferenceIndexer(project, expectedIndexVersion)	CompilerReferenceIndexer	indexer
usage.lines.diff(matched.map(_._2))	Seq[Int]	extraLines
ScalaCompilerIndices.version	Int	expectedIndexVersion
enumeratePath(data.file.getPath)	Int	fileId
new BackgroundTaskQueue(project, ScalaBundle.message("scala.compiler.indices.progress.title"))	BackgroundTaskQueue	jobQueue
indexer.toTask(job)	Task.Backgroundable	task
Set.newBuilder[UsagesInFile]	mutable.Builder[compilerReferences.UsagesInFile, Set[compilerReferences.UsagesInFile]]	usages
st.getContext.stubOrPsiChildren.iterator	Iterator[PsiElement]	contextSiblings
Parent	Parent.type	ChildOf
findFileByEnumeratorId(fileId)	Option[VirtualFile]	file
new TIntHashSet()	TIntHashSet	referentFiles
task(project, title)(_ => runnable())	Task.Backgroundable	t
classes.map(_.output)	IndexedSeq[Any]	classfiles
enumeratePath(path)	Int	fileId
new BytecodeReferenceCompilerRefProvider(writer)	BytecodeReferenceCompilerRefProvider	refProvider
writer.enumerateName(parsed.classInfo.fqn)	Int	className
writer.enumerateName(ref.owner)	Int	ownerId
ownerChain.collect { case cs: ClassSymbol => cs case obj: ObjectSymbol => obj }.reverse	IndexedSeq[SymbolInfoSymbol with Product with Serializable]	classes
parsed match { case cl: RegularClass => if (cl.classInfo.isAnonymous) new CompilerRef.JavaCompilerAnonymousClassRef(className) else new CompilerRef.JavaCompilerClassRef(className) case anon: FunExprClass => ScFunExprCompilerRef(anon.line) }	CompilerRef	classRef
parsed.classInfo.superClasses .map(className => new CompilerRef.JavaCompilerClassRef(writer.enumerateName(className)))	Set[CompilerRef]	superClasses
new settings.CompilerIndicesSettings.State	CompilerIndicesSettings.State	state
new ScFunExprCompilerRef(sam.line)	ScFunExprCompilerRef	ref
writer.enumerateName(ref.name)	Int	nameId
writer.enumerateName(sam.interface)	Int	ifaceId
new CompilerRef.JavaCompilerClassRef(ifaceId)	CompilerRef.JavaCompilerClassRef	iface
taskManager.createAllModulesBuildTask(true, project)	ProjectTask	task
classes.map(_.encodedName).mkString("$")	String	nested
false	Boolean	useManualConfiguration
ref.`override`(owner.getName)	CompilerRef	overridden
65337	Int	sbtConnectionPort
new THashSet[CompilerRef.CompilerClassHierarchyElementDef]()	THashSet[CompilerRef.CompilerClassHierarchyElementDef]	res
sym.enclClass	Symbol	owner
new Queue[CompilerRef.CompilerClassHierarchyElementDef](10)	Queue[CompilerRef.CompilerClassHierarchyElementDef]	queue
q.pullFirst()	CompilerRef.CompilerClassHierarchyElementDef	currentClass
refProvider.toCompilerRef(rs.head)	CompilerRef	compilerRef
rs.map(_.line)(collection.breakOut)	Seq[Int]	lines
target.refOrImplicitRefIn(e)	Option[PsiReference]	maybeRef
new CompilerIndicesSettingsForm(project)	CompilerIndicesSettingsForm	panel
None	Option[Any]	shutdownCallback
true	Boolean	indexingEnabled
panel.applyTo(CompilerIndicesSettings(project), CompilerIndicesSbtSettings())	Boolean	requiresRestart
true	Boolean	enabledForImplicitDefs
true	Boolean	enabledForApplyUnapply
true	Boolean	enabledForSAMTypes
true	Boolean	enabledForForCompMethods
elements.flatMap { case (e, line) => val maybeRef = target.refOrImplicitRefIn(e) maybeRef.foreach(ref => processor.process(ref)) maybeRef.map(_ -> line) }.toList	List[(PsiReference, Int)]	refsWithLine
0	Int	buildCompilationDiff
SbtProjectSettings.forProject(project).toOption	Option[SbtProjectSettings]	sbtSettings
sbtSettings.exists(_.useSbtShellForBuild)	Boolean	usesSbtShell
new ClassReader(in)	ClassReader	reader
new ScalaSigVisitor(outer.getPath)	ClassfileParser.ScalaSigVisitor	visitor
Topic.create[SbtCompilationListener]("sbt compilation status", classOf[SbtCompilationListener])	Topic[SbtCompilationListener]	topic
usage.lines.diff(refsWithLine.map(_._2))	Seq[Int]	extraLines
try body finally lock.unlock()	T	result
doc.getLineStartOffset(line - 1)	Int	offset
using(new FileInputStream(outer)) { in => val reader = new ClassReader(in) val visitor = new ScalaSigVisitor(outer.getPath) reader.accept(visitor, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES) visitor.scalaSig }	Option[ScalaSig]	scalaSig
scalaSig.fold(Set.empty[String])( _.syntheticSymbols().map(_.qualifiedName)(collection.breakOut) )	Set[String]	synthetics
None	Option[ScalaSig]	scalaSig
ModuleManager.getInstance(project)	ModuleManager	manager
UnresolvedImplicitReference(target, file, offset)	ImplicitUtil.UnresolvedImplicitReference	ref
_	MessageBusConnection	pendingConnection
Messages.decompressCompilationInfo(messageText)	Try[JpsCompilationInfo]	buildData
project.getMessageBus.connect(project)	MessageBusConnection	connection
CompilerIndicesSbtSettings().sbtPort	Int	port
project.modules	Seq[Module]	modules
None	Option[Int]	actualPort
ProjectTaskManager.getInstance(project)	ProjectTaskManager	manager
Unidentified	SbtCompilationListener.ProjectIdentifier	base
ModuleNode.combinedId(sbtProjectId, Option(projectBaseUri))	String	moduleId
None	Option[Any]	id
Key.findKeyByName("COMPILE_SERVER_BUILD_STATUS")	Key[_]	key
compileContext.getUserData(key) == ExitStatus.UP_TO_DATE	Boolean	wasUpToDate
ProjectBase(Paths.get(in.readUTF()))	SbtCompilationListener.ProjectIdentifier.ProjectBase	projectBase
CompiledScalaFile(sourceFile, parsed, writer)	CompiledScalaFile	data
bus.syncPublisher(SbtCompilationListener.topic)	SbtCompilationListener	publisher
new ParsingVisitor(synthetics)	ClassfileParser.ParsingVisitor	visitor
_	String	internalName
_	String	className
false	Boolean	isAnon
task(project, ScalaBundle.message("scala.compiler.indices.progress.title")) { _ => lock.locked(indexingFinishedCondition.awaitUninterruptibly()) }	Task.Backgroundable	awaitIndexing
(1 to nThreads).map(_ => toCallable(parseClassfiles(writer)))	IndexedSeq[Any]	tasks
Set.newBuilder[String]	mutable.Builder[String, Set[String]]	superNames
None	Option[Int]	earliestSeen
FileTypeRegistry.getInstance()	FileTypeRegistry	fileTypeRegistry
Option(compileContext.getCompileScope) .fold(Set.empty[String])( _.getAffectedModules.filter(_.hasScala).map(_.getName).toSet )	Set[String]	modules
0	Int	indexingPhases
FindManager.getInstance(project).asInstanceOf[FindManagerImpl]	FindManagerImpl	findManager
ScalaFindUsagesHandlerFactory.getInstance(project)	ScalaFindUsagesHandlerFactory	factory
fileTypeRegistry.getFileTypeByFileName(vfile.getNameSequence)	FileType	ftype
JpsCompilationInfo(modules, Set.empty, Set.empty, timestamp)	JpsCompilationInfo	info
inReadAction(target match { case SAMType(_) => new ScalaFindUsagesHandler(target, factory) case _ => new CompilerIndicesFindUsagesHandler(target, factory) })	ScalaFindUsagesHandlerBase	handler
new MethodVisitor(ASM6) with ReferenceInMethodCollector { override def handleMemberRef(ref: MemberReference): Unit = innerRefs.add(ref) override def handleSAMRef(ref: FunExprInheritor): Unit = funExprs.add(ref) override def handleLineNumber(line: Int): Unit = if (isFunExprClassname(className) && earliestSeen.forall(_ > line)) earliestSeen = Option(line) }	MethodVisitor with ClassfileParser.ReferenceInMethodCollector { def handleLineNumber(line: Int): Unit def handleMemberRef(ref: MemberReference): Unit def handleSAMRef(ref: FunExprInheritor): Unit }	methodVisitor
Set.newBuilder[Scope]	mutable.Builder[Scope, Set[Scope]]	dirty
upToDateCompilerIndexExists(project, ScalaCompilerIndices.version)	Boolean	validIndexExists
Topic.create[CompilerReferenceServiceStatusListener]( "compiler reference index build status", classOf[CompilerReferenceServiceStatusListener] )	Topic[CompilerReferenceServiceStatusListener]	topic
None	Option[CompilerIndicesReferencesSearcher.BeforeIndicesSearchAction]	action
() => action = showRebuildSuggestionDialog( project, dirtyModules, upToDateModules, validIndexExists, target, usageType )	() => Unit	dialogAction
ClassInfo(isAnon, className, superNames.result())	ClassInfo	classInfo
-1	Int	currentLineNumber
fqnFromInternalName(owner)	String	ownerFqn
ProjectFileIndex.getInstance(project)	ProjectFileIndex	index
p.getMethod	PsiMethod	method
builder(ownerFqn, name, currentLineNumber)	MemberReference	ref
ta.name	String	nm
p.getOptimizer	SearchRequestCollector	collector
ScPackageImpl(pack)	ScPackageImpl	scPack
new ScalaDirtyScopeHolder( project, LanguageCompilerRefAdapter.INSTANCES.flatMap(_.getFileTypes.asScala), projectFileIndex, fileDocManager, psiDocManager, this )	ScalaDirtyScopeHolder	dirtyScopeHolder
fileIndex.getModuleForFile(vfile).toOption	Option[Module]	module
ScalaCompilerReferenceService(project).getDirtyScopeHolder	ScalaDirtyScopeHolder	dirtyScopeHolder
inReadAction { parameters.getElementToSearch match { case target @ ScalaPsiUtil.inNameContext(ta: ScTypeAliasDefinition) => val nm = ta.name if (nm != null && !StringUtil.isEmptyOrSpaces(nm)) Some((target, nm, parameters.getEffectiveSearchScope)) else None case _ => None } }	Option[(PsiNamedElement, String, SearchScope)]	data
new Processor[PsiReference] { def process(t: PsiReference): Boolean = { if (method.isConstructor) return true consumer.process(t) } }	Processor[PsiReference] { def process(t: PsiReference): Boolean }	newConsumer
parameters.getOptimizer	SearchRequestCollector	collector
mutable.HashSet.newBuilder[ScopedModule]	mutable.Builder[ScalaDirtyScopeHolder.ScopedModule, mutable.HashSet[ScalaDirtyScopeHolder.ScopedModule]]	scopeBuilder
Option.empty[ScalaCompilerReferenceReader]	Option[ScalaCompilerReferenceReader]	reader
collector.getSearchSession	SearchSession	session
new MyProcessor(target, null, session)	TypeAliasUsagesSearcher.this.MyProcessor	processor
new CompilerReferenceIndexerScheduler(project, ScalaCompilerReferenceReaderFactory.expectedIndexVersion)	CompilerReferenceIndexerScheduler	indexerScheduler
dirtyScopeHolder.dirtyScope	GlobalSearchScope	dirtyScopes
usageType.toString	String	title
new ImplicitFindUsagesDialog(false, element, title)	ImplicitUsagesSearchDialogs.ImplicitFindUsagesDialog	dialog
if (fileIndex.isInTestSourceContent(vfile)) ScopedModule.test(m) else ScopedModule.compile(m)	ScalaDirtyScopeHolder.ScopedModule	scoped
project.getMessageBus	MessageBus	messageBus
CompilerMode.JPS	CompilerMode	currentCompilerMode
scPack.name	String	nm
queryParameters.getElementToSearch	PsiElement	elementToSearch
info.affectedModules(project)	Set[Module]	modules
FunExprInheritor(samType.getClassName, currentLineNumber)	FunExprInheritor	ref
inReadAction { parameters.getElementToSearch match { case pack: PsiPackage => val scPack =ScPackageImpl(pack) val nm = scPack.name if (nm != null && !StringUtil.isEmptyOrSpaces(nm)) Some((scPack, nm, parameters.getEffectiveSearchScope)) else None case _ => None } }	Option[(ScPackageImpl, String, SearchScope)]	data
element.getReference	PsiReference	reference
s"`$name`" :: Nil	List[String]	tail
new OpenFileHyperlinkInfo(scope.getProject, vFile, lineNumber)	OpenFileHyperlinkInfo	link
"scala.rename.local"	FeatureKey	renameLocal
"scala.rename.member"	FeatureKey	renameMember
"scala.move.file"	FeatureKey	moveFile
inReadAction { import ScalaNamesUtil.{isBacktickedName, isOpCharacter} elementToSearch match { case named: ScNamedElement if named.isValid => named.name match { case isBacktickedName(name) => val tail = s"`$name`" :: Nil name match { case "" => tail case _ => name :: tail } case name if name.exists(isOpCharacter) => name :: Nil case _ => Nil } case _ => Nil } }	List[String]	namesToProcess
ScalaFilterScope(parameters)	SearchScope	scope
"scala.move.class"	FeatureKey	moveClass
"scala.introduce.variable"	FeatureKey	introduceVariable
"scala.introduce.type.alias"	FeatureKey	introduceTypeAlias
"scala.introduce.field"	FeatureKey	introduceField
"scala.introduce.parameter"	FeatureKey	introduceParameter
PsiManager.getInstance(queryParameters.getProject)	PsiManager	manager
"scala.extract.method"	FeatureKey	extractMethod
"scala.extract.trait"	FeatureKey	extractTrait
"scala.inline"	FeatureKey	inline
"scala.change.signature"	FeatureKey	changeSignature
"scala.show.implicit.parameters"	FeatureKey	showImplicitParameters
"scala.go.to.implicit.conversion"	FeatureKey	goToImplicitConversion
info match { case sbti: SbtCompilationInfo => modules.map(ScopedModule(_, sbti.configuration)) case _: JpsCompilationInfo => modules.flatMap(moduleScopes) }	IndexedSeq[ScalaDirtyScopeHolder.ScopedModule]	scopes
"scala.show.type.info"	FeatureKey	showTypeInfo
"scala.structure.view"	FeatureKey	structureView
"scala.optimize.imports"	FeatureKey	optimizeImports
"scala.createFromUsage"	FeatureKey	createFromUsage
"scala.overrideImplement"	FeatureKey	overrideImplement
inReadAction { parameters.getElementToSearch match { case named: PsiNamedElement => val name = named.name ScalaPsiUtil.nameContext(named) match { case _: PsiNamedElement | _: PsiMember | _: ScTypeAlias if name != null && !StringUtil.isEmptyOrSpaces(name) => val scope = ScalaFilterScope(parameters) Some((named, name, scope)) case _ => None } case _ => None } }	Option[(PsiNamedElement, String, SearchScope)]	data
"scala.desugar.code"	FeatureKey	desugarCode
"scala.structural.type"	FeatureKey	structuralType
"scala.existential.type"	FeatureKey	existentialType
builder.result	String	contents
"scala.worksheet"	FeatureKey	runWorksheet
"scala.sbt.shell.execute.command"	FeatureKey	sbtShellCommand
"scala.sbt.shell.test.command"	FeatureKey	sbtShellTestCommand
"scala.sbt.shell.test.run.config"	FeatureKey	sbtShellTestRunConfig
"scala.convert.javatext"	FeatureKey	convertFromJavaText
"scala.rearrange"	FeatureKey	rearrange
"scala.macro.expand"	FeatureKey	macroExpandAction
"scala.macro.definition"	FeatureKey	macroDefinition
"scala.file.with.type.aware.annotated"	FeatureKey	annotatorTypeAware
"scala.file.without.type.aware.annotated"	FeatureKey	annotatorNotTypeAware
"scala.collection.pack.highlighting"	FeatureKey	collectionPackHighlighting
"scala.file.script.parsed"	FeatureKey	parserScalaScript
"scala.ssp.parsing"	FeatureKey	parserSsp
new SearchRequestCollector(mySession)	SearchRequestCollector	collector
"scalajs.dynamic.resolve"	FeatureKey	scalaJsDynamicResolve
"scalajs.dynamic.completion"	FeatureKey	scalaJsDynamicCompletion
"scala.debugger"	FeatureKey	debuggerTotal
new LocalSearchScope(element.getContainingFile)	SearchScope	fileScope
"scala.debugger.evaluator"	FeatureKey	debuggerEvaluator
"scala.debugger.compiling.evaluator"	FeatureKey	debuggerCompilingEvaluator
"scala.debugger.lambda.breakpoint"	FeatureKey	debuggerLambdaBreakpoint
"scala.debugger.smart.step.into"	FeatureKey	debuggerSmartStepInto
new TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean = { val references = inReadAction(element.getReferences) for { reference <- references if reference.getRangeInElement.contains(offsetInElement) } inReadAction { if (reference.isReferenceTo(elementToSearch) || reference.resolve() == elementToSearch) { if (!consumer.process(reference)) return false } } true } }	TextOccurenceProcessor { def execute(element: PsiElement, offsetInElement: Int): Boolean }	processor
new ExceptionFilter(scope).applyFilter(line, textEndOffset)	Filter.Result	defaultResult
PlatformUtils.isIdeaUltimate	Boolean	isPlayInstalled
Try { val br = Files.newBufferedReader(infoFile.toPath, StandardCharsets.UTF_8) val builder = StringBuilder.newBuilder using(br) { in => var line = in.readLine() while (line != null) { builder ++= line line = in.readLine() } } val contents = builder.result contents.parseJson.convertTo[SbtCompilationInfo] }	Try[SbtCompilationInfo]	result
new CommonProcessors.CollectProcessor[VirtualFile]	CommonProcessors.CollectProcessor[VirtualFile]	collectProcessor
ModuleRootManager.getInstance(m)	ModuleRootManager	manager
Map ( "kind-projector" -> "Kind Projector", "paradise" -> "Macro/Meta paradise", "miniboxing" -> "Miniboxing" )	Map[String, String]	compilerPluginHints
info.affectedModules(project).map(_.getName)	IndexedSeq[Nothing]	modules
SbtSettings.getInstance(project)	SbtSettings	sbtSettings
{ value: Integer => (value.intValue & searchContext) != 0 }	Condition[Any]	condition
maxIfStmt(ifStmt)	ScIf	from
Set.empty[String]	Set[String]	result
expr match { case ScIf(_, Some(thenBr), _) => thenBr case _ => expr }	ScExpression	branch
createNewLine()(lastExtracted.getManager)	PsiElement	newLine
FileIndexFacade.getInstance(manager.getProject)	FileIndexFacade	index
oldExpr.replace(expr.copy())	PsiElement	replaced
new CompilerIndicesEventPublisher { override def onCompilerModeChange(mode: CompilerMode): Unit = { // IDEA JPS compiler <-> sbt shell change happened // current index must be invalidated onIndexCorruption() currentCompilerMode = mode logCompilerIndicesEvent(s"onCompilerModeChange. new mode: $mode") } override def onCompilationStart(): Unit = { closeReader(incrementBuildCount = true) logCompilerIndicesEvent(s"onCompilationStart. active indexing phases: ${activeIndexingPhases.get()}") } override def startIndexing(isCleanBuild: Boolean): Unit = { indexerScheduler.schedule(OpenWriter(isCleanBuild)) logCompilerIndicesEvent(s"startIndexing. clean build: $isCleanBuild") } override def onError(message: String, cause: Option[Throwable]): Unit = { logger.error(message, cause.orNull) onIndexCorruption() } override def onCompilationFinish(success: Boolean): Unit = { indexerScheduler.schedule("Open compiler index reader", () => { openReader(success) logCompilerIndicesEvent( s"onCompilationFinish. success: $success, active indexing phases: ${activeIndexingPhases.get()}" ) }) } override def processCompilationInfo(info: CompilationInfo, isOffline: Boolean): Unit = { val modules = info.affectedModules(project).map(_.getName) logger.debug(s"[compiler indices] processCompilationInfo. offline: $isOffline") indexerScheduler.schedule(ProcessCompilationInfo(info, () => { if (!isOffline) { // do not mark modules as up-to-date when indexing 'offline' sbt compilations modules.foreach(compilationTimestamps.put(_, info.startTimestamp)) logger.debug(s"[compiler indices] Reindexed ${info.generatedClasses.size} classfiles.") dirtyScopeHolder.compilationInfoIndexed(info) messageBus.syncPublisher(CompilerReferenceServiceStatusListener.topic).onCompilationInfoIndexed(modules) } if (!failedToParse.isEmpty) { // if we failed to parse some classes during previous indexing // phase running concurrently with this one, check if current phase handled // these files and therefore restored index consitency failedToParse.removeAll(info.removedSources.asJava) failedToParse.removeAll(info.generatedClasses.map(_.output).asJava) } })) } override def finishIndexing(): Unit = { indexerScheduler.schedule(CloseWriter(_.foreach(processIndexingFailure))) logCompilerIndicesEvent("finishIndexing.") } }	CompilerIndicesEventPublisher { def startIndexing(isCleanBuild: Boolean): Unit def onCompilationFinish(success: Boolean): Unit def finishIndexing(): Unit def onCompilerModeChange(mode: CompilerMode): Unit def processCompilationInfo(info: CompilationInfo, isOffline: Boolean): Unit def onCompilationStart(): Unit def onError(message: String, cause: Option[Throwable] = None): Unit }	publisher
new TransactionGuard[CompilerIndicesState] { override def inTransaction[T](body: CompilerIndicesState => T): T = openCloseLock.locked(body((currentCompilerMode, publisher))) }	TransactionGuard[(CompilerMode, CompilerIndicesEventPublisher)]	transactionManager
reader.map(_.getIndex())	Option[ScalaCompilerReferenceIndex]	index
{ virtualFile: VirtualFile => !index.shouldBeFound(scope, virtualFile) || processor.process(virtualFile) }	ReadActionProcessor[VirtualFile]	readActionProcessor
new TemplateBuilderImpl(elem)	TemplateBuilderImpl	builder
infoFiles.flatMap(parseCompilationInfo(_).toOption)	IndexedSeq[SbtCompilationInfo]	parsedInfos
modules.map(sbtSettings.getLinkedProjectSettings).flatten	IndexedSeq[SbtProjectSettings]	sbtProjectSettings
ScalaCompilerConfiguration.instanceIn(project)	ScalaCompilerConfiguration	compilerSettings
ScalaProjectSettings.getInstance(project)	ScalaProjectSettings	projectSettings
sbtProjectSettings.nonEmpty	Boolean	isSbtProject
sbtProjectSettings.exists(_.useSbtShellForBuild)	Boolean	isSbtShellBuild
parsedInfos.sortBy(_.startTimestamp)	IndexedSeq[SbtCompilationInfo]	infos
element.getPsi	PsiElement	psi
messageBus.connect(project)	MessageBusConnection	connection
new ArrayBuffer[ScalaPsiElement]()	ArrayBuffer[ScalaPsiElement]	buffer
message("intention.type.annotation.toggle.family")	String	FamilyName
element.getContainingFile match { case sc: ScalaFile => sc case _ => return false }	ScalaFile	file
new ScalaRecursiveElementVisitor { override def visitScalaElement(element: ScalaPsiElement): Unit = { if (element.getTextRange.getStartOffset >= startOffset && element.getTextRange.getEndOffset <= endOffset) { buffer += element } else super.visitScalaElement(element) } }	ScalaRecursiveElementVisitor { def visitScalaElement(element: ScalaPsiElement): Unit }	visitor
createPatternFromText(pattern.name)	ScPattern	newPattern
projectFileIndex.getModuleForFile(usage.file)	Module	module
createFunctionParameterFromText(parameter.name)	ScParameter	newParameter
ScalaPsiUtil.getElementsRange( file.findElementAt(selectionModel.getSelectionStart), file.findElementAt(selectionModel.getSelectionEnd))	Seq[PsiElement]	selection
ScalaCompileServerSettings.getInstance().COMPILE_SERVER_ENABLED	Boolean	compileServerEnabled
func.parameters.indexOf(param)	Int	index
element.getContainingFile match { case sf: ScalaFile => sf case _ => return }	ScalaFile	file
calcLookupElements().toArray	Array[LookupElement]	lookupElements
params(index)	ScType	paramExpectedType
ScalaRefactoringUtil.selectedElements(editor, file, trimComments = true)	Seq[PsiElement]	elements
new AddOrRemoveStrategy(maybeEditor)	AddOrRemoveStrategy	strategy
InjectedLanguageUtil.getTopLevelEditor(context.getEditor)	Editor	topLevelEditor
types.flatMap(_.typeWithSuperTypes)	IndexedSeq[ScTypeElement]	tps
message("intention.type.annotation.regen.family")	String	FamilyName
TemplateManagerImpl.getTemplateState(topLevelEditor)	TemplateState	templateState
templateState.getCurrentVariableRange	TextRange	range
parameter.parentOfType(classOf[ScFunctionExpr], strict = false) .filter(_.parameters.size == 1) .flatMap(_.params.clauses.headOption) .filter { clause => val text = clause.getText text.startsWith("(") && text.endsWith(")") }.map { (_, createClauseForFunctionExprFromText(newParameter.getText)) }	Option[(PsiElement, PsiElement)]	pair
PsiTreeUtil.getParentOfType(element, classOf[ScParameterizedTypeElement], false)	ScParameterizedTypeElement	paramTypeElement
paramTypeElement.getParent match { case _: ScTypeArgs | _: ScParenthesisedTypeElement => false case _ => true }	Boolean	needParens
result(item.getObject.asInstanceOf[T])	String	newText
topLevelEditor.getDocument	Document	document
allSupers(psiClass)	Set[String]	superNames
Option(PsiTreeUtil.getParentOfType(element, classOf[ScPackaging])). getOrElse(element.getContainingFile.asInstanceOf[ScImportsHolder])	ScImportsHolder	importsHolder
getTargetExpression(element)	ScExpression	expression
tps.reverse.flatMap(_.`type`().toOption).map(ScTypeText)	IndexedSeq[ScTypeText]	validVariants
TextRange.create(startOffset, startOffset + newText.length)	TextRange	newRange
ScalaRefactoringUtil.commonParent(file, newRange)	PsiElement	elem
lookupItems.count(_.presentableText == elem.presentableText) > 1	Boolean	useCanonicalText
addActualType(tps.head, anchor)	PsiElement	added
new ChooseTypeTextExpression(validVariants)	ChooseTypeTextExpression	expr
Set( "java.lang.Iterable", "java.util.Iterator", "java.util.Collection", "java.util.Dictionary", "java.util.Map" )	Set[String]	targetCollections
le.getObject.asInstanceOf[ScTypeText]	ScTypeText	text
Seq(targ1, paramTypeElement.typeElement, targ2).map(_.getText).mkString(" ").parenthesize(needParens)	String	newTypeText
Set("scala.collection")	Set[String]	alreadyConvertedPrefixes
context match { case variable: ScVariableDefinition => variable.expr case pattern: ScPatternDefinition => pattern.expr case function: ScFunctionDefinition => function.body case _ => None }	Option[ScExpression]	maybeExpression
Set( "scala.collection.Seq", "scala.collection.Set", "scala.collection.Map", "scala.collection.Iterator", "scala.collection.Iterable" )	Set[String]	targetCollections
Set("java.")	Set[String]	alreadyConvertedPrefixes
createTypeElementFromText(newTypeText)(element.getManager)	ScTypeElement	newTypeElement
try { paramTypeElement.replace(newTypeElement) } catch { case npe: NullPointerException => throw new RuntimeException("Unable to replace: %s with %s".format(paramTypeElement, newTypeText), npe) }	PsiElement	replaced
createElementFromText(ref.getText)(ref.projectContext)	PsiElement	replacement
createExpressionFromText(s"${expression.getText}.$methodName")(expression.getManager)	ScExpression	replacement
sign.substitutor	ScSubstitutor	substitutor
m.getProject	Project	ctx
computeBaseTypes(declaredType, dynamicType).sortWith((t1, t2) => t1.conforms(t2))	Seq[ScType]	types
member match { case n: ScNamedElement => n case v: ScValueOrVariable if v.declaredElements.size == 1 => v.declaredElements.head case _ => return Seq.empty }	ScNamedElement with NavigatablePsiElement	named
member match { case ContainingClass(c) => c case _ => return Seq.empty }	PsiClass	aClass
te.replace(ScalaPsiElementFactory.createTypeElementFromText(types.head.canonicalText, te.getContext, te))	PsiElement	replaced
element.getContainingFile.findElementAt(element.getPrevSibling.getTextRange.getEndOffset - 1)	PsiElement	prev
TypeDefinitionMembers.getSignatures(aClass)	TypeDefinitionMembers.TermNodes.Map	signatureMap
types.map(ScTypeText)	IndexedSeq[ScTypeText]	texts
new ChooseTypeTextExpression(texts, ScTypeText(declaredType))	ChooseTypeTextExpression	expr
message("make.type.more.specific")	String	FamilyName
signatureMap .forName(named.name) .findNode(named)	Option[MixinNodes.Node[TermSignature]]	signatureForNamed
doConversion(element)	Seq[ScParameter]	addedParams
createEquivMethodCall(inf)	ScMethodCall	call
inf.replace(call).asInstanceOf[ScMethodCall]	ScMethodCall	replacedCall
replacedCall.getInvokedExpr.asInstanceOf[ScReferenceExpression]	ScReferenceExpression	ref
dynamicType +: BaseTypes.get(dynamicType)	IndexedSeq[ScType]	baseTypes
element match { case function: ScFunctionDefinition => function.returnType.toOption case value: ScPatternDefinition => value.`type`().toOption case variable: ScVariableDefinition => variable.`type`().toOption case _ => None }	Option[ScType]	computedType
element.getParent.asInstanceOf[ScStableCodeReference]	ScStableCodeReference	codeRef
codeRef.getParent.asInstanceOf[ScConstructorPattern]	ScConstructorPattern	constrPattern
{ val computedType = element match { case function: ScFunctionDefinition => function.returnType.toOption case value: ScPatternDefinition => value.`type`().toOption case variable: ScVariableDefinition => variable.`type`().toOption case _ => None } computedType.map(TypeForAnnotation(_)) }	Option[AddOnlyStrategy.TypeForAnnotation]	computedType
s"${imp.qualifier.getText}.{${id.nameId.getText}}"	String	name
for { declared <- declTypeOpt expr <- exprOpt tp <- expr.`type`().toOption } yield computeBaseTypes(declared, tp)	Option[Seq[ScType]]	baseTypes
postfix.replace(createExpressionFromText(s"${qual.getText}.$name")) .asInstanceOf[ScReferenceExpression]	ScReferenceExpression	withDot
oldRef.projectContext	ProjectContext	projectContext
ScalaAddImportAction.getImportHolder(element, project)	ScImportsHolder	importHolder
inf.replaceExpression(call, removeParenthesis = true).asInstanceOf[ScMethodCall]	ScMethodCall	replacedCall
superSignatures(element) .iterator .map(signatureType) .find(_.nonEmpty) .flatten .map(TypeForAnnotation(_, addSuperTypes = false))	Option[AddOnlyStrategy.TypeForAnnotation]	typeFromSuper
imp.replace(createImportExprFromText(name)(element.getManager))	PsiElement	replaced
createPatternFromText(newPatternText)(element.getManager)	ScPattern	newPattern
anchor	ProjectContext	ctx
origPattern.replace(newPattern)	PsiElement	replaced
inWriteAction { val replaced = imp.replace(createImportExprFromText(name)(element.getManager)) PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument) replaced }	PsiElement	replaced
createEquivQualifiedReference(postfix)	ScReferenceExpression	refExpr
ScalaNamesUtil.qualifiedName(named).getOrElse(return) + "._"	String	pathWithWildcard
postfix.replaceExpression(refExpr, removeParenthesis = true).asInstanceOf[ScReferenceExpression]	ScReferenceExpression	withDot
() => { val name = s"${imp.qualifier.getText}.{${id.nameId.getText}}" val replaced = inWriteAction { val replaced = imp.replace(createImportExprFromText(name)(element.getManager)) PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument) replaced } inWriteAction { editor.getDocument.insertString(replaced.getTextRange.getEndOffset - 1, ", ") editor.getCaretModel.moveToOffset(replaced.getTextRange.getEndOffset + 1) } }	() => Unit	doIt
PsiTreeUtil.getParentOfType(element, classOf[ScMethodCall], false)	ScMethodCall	methodCallExpr
toBind match { case m: PsiMember => Option(m.getContainingClass) case _ => None }	Option[PsiClass]	clazz
ref.nameId.getTextRange	TextRange	range
createExpressionFromText(name)	ScExpression	refExpr
expr.replaceExpression(refExpr, removeParenthesis = true)	ScExpression	replaced
oldRef.replace(createReferenceFromText(name))	PsiElement	replaced
p.getParent match { case Parent(Parent(Parent(_: ScBlockExpr))) => p // ensure that the parameter is wrapped in parentheses before we add the type annotation. case clause: ScParameterClause if clause.parameters.length == 1 => clause.replace(createClauseForFunctionExprFromText(p.getText.parenthesize())) .asInstanceOf[ScParameterClause].parameters.head case _ => p }	ScParameter	parameter
underscore.getParent match { case ScParenthesisedExpr(content) if content == underscore => false case _: ScArgumentExprList => false case _ => true }	Boolean	needsParentheses
if (!isQualifier) ref else ref match { case isQualifierFor(r) => r case _ => ref }	PsiReference	trueRef
PsiTreeUtil.getParentOfType(element, classOf[ScMethodCall], false)	ScMethodCall	expr
{ (ref1, ref2) => PsiTreeUtil.isAncestor(actuallyReplaced(ref2), actuallyReplaced(ref1), true) }	(PsiReference, PsiReference) => Boolean	lessThan
expr.getInvokedExpr.asInstanceOf[ScReferenceExpression].nameId.getTextRange.getStartOffset - 1	Int	start
ScalaType.designator(cls)	ScType	tpe
new StringBuilder	StringBuilder	buf
expr.getInvokedExpr.asInstanceOf[ScReferenceExpression].qualifier.get	ScExpression	qualifier
NameSuggester.suggestNamesByType(tpe)	Seq[String]	names
ref.resolve()	PsiElement	resolved
codeRef.bind() match { case Some( result @ ScalaResolveResult(fun: ScFunctionDefinition, _)) if fun.name == "unapply"=> // TODO follow aliases result.parentElement match { case Some(obj: ScObject) => ScalaPsiUtil.getCompanionModule(obj) match { case Some(cls: ScClass) => val tpe = ScalaType.designator(cls) val names = NameSuggester.suggestNamesByType(tpe) names.head case _ => "value" } case _ => "value" } case _ => "value" }	String	name
sorted(usages, isQualifier = true).collect { case isQualifierFor(ref@resolve(resolved: PsiNamedElement)) if !isInImport(ref) => RefWithUsage(ref, resolved) }	IndexedSeq[RefWithUsage]	sortedUsages
methodCallExpr.getInvokedExpr match { case ref: ScReferenceExpression => ref case call: ScGenericCall => Option(call.referencedExpr) match { //if the expression has type args case Some(ref: ScReferenceExpression) => ref case _ => return false } case _ => return false }	ScReferenceExpression	referenceExpr
refPattern.expectedType	Option[ScType]	expectedType
(parameterOwner match { case function: ScFunction => Some(function) case clazz: ScClass => clazz.constructor case _ => None }).getOrElse(return Seq.empty)	ScMethodLike with PsiDocCommentOwner with PsiNameIdentifierOwner	function
PsiTreeUtil.getParentOfType(element, classOf[ScInfixExpr], false)	ScInfixExpr	infixExpr
parameterOwner.typeParameters	Seq[ScTypeParam]	typeParameters
createScalaFileFromText(s"(_: ${annotation.getText})").getFirstChild.asInstanceOf[ScParenthesisedExpr]	ScParenthesisedExpr	e
referenceExpr.nameId.getTextRange	TextRange	range
infixExpr.operation.nameId.getTextRange	TextRange	range
Set( "_root_.scala.collection.mutable.Seq[", "_root_.scala.collection.immutable.Seq[", "_root_.scala.collection.mutable.Set[", "_root_.scala.collection.immutable.Set[", "_root_.scala.collection.mutable.Map[", "_root_.scala.collection.immutable.Map[" )	Set[Nothing]	goodTypes
ScalaPsiElementFactory.createExpressionFromText(s"Some($constant)")(project)	ScExpression	newExpr
InspectionBundle.message("replace.option.with.some")	String	familyName
infixExpr.getTextRange.getStartOffset	Int	start
wildcardPattern.expectedType	Option[ScType]	expectedType
createClauseFromText(implicitParamClause.getText)	ScParameterClause	newClause
newClause.parameters.size	Int	addedParametersCount
methodCallExpr.getInvokedExpr match { case ref: ScReferenceExpression => ref case call: ScGenericCall => Option(call.referencedExpr) match { //if the expression has type args case Some(ref: ScReferenceExpression) => ref case _ => return } case _ => return }	ScReferenceExpression	referenceExpr
methodCallExpr.getTextRange.getStartOffset	Int	start
editor.getCaretModel.getOffset - infixExpr.operation.nameId.getTextRange.getStartOffset	Int	diff
editor.getCaretModel.getOffset - referenceExpr.nameId.getTextRange.getStartOffset	Int	diff
false	Boolean	putArgsFirst
new StringBuilder	StringBuilder	argsBuilder
ScalaPsiElementFactory.createEquivMethodCall(infixExpr)	ScMethodCall	methodCallExpr
new StringBuilder	StringBuilder	invokedExprBuilder
comps.map(t => suggestNamesByType(t).head)	IndexedSeq[String]	names
referenceExpr.qualifier.get	ScExpression	qual
new mutable.HashMap[String, Int]()	mutable.HashMap[String, Int]	map
false	Boolean	clearMap
methodCallExpr.getInvokedExpr match { case ref: ScReferenceExpression => ref case call: ScGenericCall => call.referencedExpr.asInstanceOf[ScReferenceExpression] }	ScReferenceExpression	referenceExpr
methodCallExpr.args	ScArgumentExprList	methodCallArgs
referenceExpr.nameId.getTextRange.getStartOffset - methodCallExpr.getTextRange.getStartOffset	Int	size
expr.getParent match { case _ if expr.isInstanceOf[ScClassParameter] => Option(PsiTreeUtil.getParentOfType(expr, classOf[ScTemplateDefinition])) case _: ScEarlyDefinitions => Option(PsiTreeUtil.getParentOfType(expr, classOf[ScTemplateDefinition])) case _: ScTemplateBody => Option(PsiTreeUtil.getParentOfType(expr, classOf[ScTemplateDefinition])) case _ => None }	Option[ScTemplateDefinition]	clazz
clazz.get.allSignatures	Iterator[TermSignature]	signs
new ScalaRecursiveElementVisitor { override def visitReferenceExpression(expr: ScReferenceExpression) { expr.resolve() match { case p: ScParameter if fun.parameters.contains(p) => if (!map.keySet.contains(expr.getText)) { map.put(expr.getText, expr.getTextRange.getStartOffset) } else { clearMap = true } case _ => } super.visitReferenceExpression(expr) } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(expr: ScReferenceExpression): Unit }	visitor
countMethodCall(call)	Int	cmc
expr.result.getOrElse(return Right(InspectionBundle.message("introduce.implicit.not.allowed.here")))	ScExpression	result
result.getTextRange.getStartOffset	Int	diff
-1	Int	previousOffset
names.mkParenString	String	tuplePattern
new mutable.HashMap[String, Int]	mutable.HashMap[String, Int]	occurrences
primaryConstructor.effectiveFirstParameterSection	Seq[ScClassParameter]	parameters
constrInvocation.arguments.length	Int	argsCount
constr.effectiveParameterClauses	Seq[ScParameterClause]	clauses
p.expectedParamType	Option[ScType]	expectedType
p.typeElement	Option[ScTypeElement]	declaredType
declaredType match { case None => "_" case _ if withoutParameterTypes => "_" case Some(t) if expectedType.exists(_.equiv(t.`type`().getOrAny)) => "_" case Some(_) => s"(_: ${p.typeElement.get.getText})" }	String	newParam
occurrences(p.name) - diff	Int	offset
parameters.map(_.name).mkParenString	String	constructorParams
createParameterFromText(p.getText)	ScParameter	newParam
findExpression(element, editor).get	ScExpression	expr
function.parameterList.addClause(newClause).clauses.last	ScParameterClause	addedClause
function.effectiveParameterClauses.drop(parameterOwner.allClauses.size).headOption	Option[ScParameterClause]	extra
Seq.empty	Seq[ScParameter]	result
ScUnderScoreSectionUtil.underscores(expr)	Seq[ScUnderscoreSection]	underscores
if (ApplicationManager.getApplication.isUnitTestMode) underscores.head.getTextRange.getStartOffset else expr.getTextRange.getStartOffset	Int	parentStartOffset
createClauseFromText(c.getText)	ScParameterClause	newClause
if (ApplicationManager.getApplication.isUnitTestMode) { if (underscores.nonEmpty) underscores.last.getTextRange.getEndOffset else underscores.head.getTextRange.getEndOffset } else expr.getTextRange.getEndOffset	Int	parentEndOffset
c.parameters.size	Int	addedParametersCount
new mutable.HashMap[ScUnderscoreSection, ScParameter]	mutable.HashMap[ScUnderscoreSection, ScParameter]	underscoreToParam
element.getParent.asInstanceOf[ScFor]	ScFor	statement
new mutable.HashMap[String, Int]	mutable.HashMap[String, Int]	offsets
new mutable.HashSet[String]	mutable.HashSet[String]	usedNames
ScalaBundle.message("intention.for.comprehension.convert.to.parentheses")	String	FamilyName
new mutable.HashSet[String]	mutable.HashSet[String]	macros
false	Boolean	needComma
false	Boolean	needBraces
createElementFromText("{}")	PsiElement	block
super.validateName(name)	String	res
statement.getManager	PsiManager	manager
lParen.replace(block.getFirstChild)	PsiElement	lBrace
new InplaceRenameHelper(parent)	InplaceRenameHelper	helper
createExpressionFromText(buf.toString())(expr.getManager)	ScExpression	newExpr
new InplaceRenameHelper(newMatch)	InplaceRenameHelper	renameHelper
PsiTreeUtil.getParentOfType(element, classOf[ScFunctionExpr], false)	ScFunctionExpr	expr
rParen.replace(block.getLastChild)	PsiElement	rBrace
expr.params.getTextRange	TextRange	range
expr.getTextRange.getStartOffset	Int	startOffset
PsiTreeUtil.getParentOfType(element, classOf[ScArgumentExprList])	ScArgumentExprList	argList
commentsAroundElement.before	Seq[PsiElement]	before
commentsAroundElement.after	Seq[PsiElement]	after
Seq(classOf[ScPatternDefinition], classOf[ScIf], classOf[ScFunctionDefinition], classOf[ScTry], classOf[ScFinallyBlock], classOf[ScWhile], classOf[ScDo])	Seq[(Class[_ >: ScFunctionDefinition <: _$1]) forSome {type _$1 >: ScFinallyBlock <: _$1; type _$1 >: ScDo <: _$1; type _$1 >: ScWhile with ScTry <: ScExpression; type _$1 >: ScPatternDefinition <: _$1; type _$1 >: ScIf <: _$1}]	classes
descriptor.getFixes	Array[QuickFix[_ <: CommonProblemDescriptor]]	fixes
argList.exprs.find { e => PsiTreeUtil.isAncestor(e, element, /*strict =*/ false) }	Option[ScExpression]	currentArg
element.parentOfType(classes).flatMap { case ScPatternDefinition.expr(e) if isAncestorOfElement(e) => Some(e) case ifStmt: ScIf => ifStmt.thenExpression.filter(isAncestorOfElement).orElse(ifStmt.elseExpression.filter(isAncestorOfElement)) case funDef: ScFunctionDefinition => funDef.body.filter(isAncestorOfElement) case tryExpr: ScTry => tryExpr.expression.filter(isAncestorOfElement) case finallyBlock: ScFinallyBlock => finallyBlock.expression.filter(isAncestorOfElement) case whileStmt: ScWhile => whileStmt.expression.filter(isAncestorOfElement) case doStmt: ScDo => doStmt.body.filter(isAncestorOfElement) case _ => None }	Option[ScExpression]	expr
fixes.apply(0).asInstanceOf[LocalQuickFix]	LocalQuickFix	fix
new ProblemsHolder(InspectionManager.getInstance(element.getProject), element.getContainingFile, true)	ProblemsHolder	holder
inspection.buildVisitor(holder, true)	PsiElementVisitor	visitor
editor.getDocument.getLineNumber(x.getTextRange.getStartOffset)	Int	startLine
editor.getDocument.getLineNumber(x.getTextRange.getEndOffset)	Int	endLine
x match { case _: ScBlockExpr => true case _ => false }	Boolean	isBlock
Seq(classOf[ScPatternDefinition], classOf[ScIf], classOf[ScFunctionDefinition], classOf[ScTry], classOf[ScFinallyBlock], classOf[ScWhile], classOf[ScDo], classOf[ScCaseClause])	Seq[(Class[_ >: ScFunctionDefinition <: _$1]) forSome {type _$1 >: ScFinallyBlock <: _$1; type _$1 >: ScPatternDefinition <: _$1; type _$1 >: ScCaseClause with ScWhile <: ScalaPsiElement; type _$1 >: ScTry <: _$1; type _$1 >: ScDo <: _$1; type _$1 >: ScIf <: _$1}]	classes
expr.filter { x => val startLine = editor.getDocument.getLineNumber(x.getTextRange.getStartOffset) val endLine = editor.getDocument.getLineNumber(x.getTextRange.getEndOffset) val isBlock = x match { case _: ScBlockExpr => true case _ => false } startLine == endLine && !isBlock }	Option[ScExpression]	oneLinerExpr
Seq("_=", "_$eq")	Seq[String]	setterSuffixes
file.findElementAt(offset)	PsiElement	child
ScalaPsiElementFactory.createObjectWithContext( s"""|object ${clazz.name} { | |}""".stripMargin, psiElement.getContext, psiElement)	ScObject	companion
clazz.getParent	PsiElement	parent
operatorPriority(ref)	Int	priority
argList.matchedParameters .filter(pair => argList.isAncestorOf(pair._1)) .sortBy(_._1.getTextOffset)	Seq[(ScExpression, Parameter)]	sortedMatchedArgs
parent.addAfter(companion, psiElement.getParent)	PsiElement	obj
obj.getTextRange.getStartOffset	Int	startOffset
matchedParamsAfter()	Seq[(ScExpression, Parameter)]	argsAndMatchedParams
document.getLineNumber(startOffset) + 1	Int	nextLine
argsAndMatchedParams.exists { case (_, param) if param.isRepeated => true case _ => false }	Boolean	hasRepeated
oper.parentsInFile.takeWhile { case InfixElement(_, r, _) if priority == operatorPriority(r) => true case _ => false }.toSeq.last	PsiElement	maxInfix
fun.returnUsages ++ Set(keyword)	IndexedSeq[PsiElement]	usages
expr.calculateTailReturns ++ Set(keyword)	IndexedSeq[PsiElement]	returns
templateDef.extendsBlock	ScExtendsBlock	eb
target(_)	ScalaHighlightImplicitUsagesHandler.TargetKind[ScNamedElement]	namedKind
ref => ref.resolve match { case named: ScNamedElement => target(named) case _ => None }	ScalaHighlightImplicitUsagesHandler.TargetKind[ScReference]	refKind
{ case (typeParam, typeElem) => contextBoundImplicitTarget(typeParam, typeElem) }	ScalaHighlightImplicitUsagesHandler.TargetKind[(ScTypeParam, ScTypeElement)]	contextBoundKind
typeElem.getParent.asInstanceOf[ScTypeParam]	ScTypeParam	typeParam
file.findElementAt(offset) match { case ws: PsiWhiteSpace => file.findElementAt(offset - 1) case elem => elem }	PsiElement	element
NameSuggester.suggestNames(u, new ScalaVariableValidator(u, false, expr.getContext, expr.getContext) { override def validateName(name: String): String = { var res = super.validateName(name) var index = 1 if (usedNames.contains(res)) { val indexStr = res.replaceAll(name, "") if (indexStr != "") index = Integer.valueOf(indexStr) while (usedNames.contains(name + index)) { index = index + 1 } } else { return res } res = name + index res } })	Seq[String]	names
eb.members.flatMap { case p: ScPatternDefinition => p.expr.toList // we include lazy vals, perhaps they could be excluded. case v: ScVariableDefinition => v.expr.toList case _ => Seq.empty }	IndexedSeq[ScExpression]	varAndValDefsExprs
names.toList match { case head :: _ if !macros.contains(head) => head case _ :: head :: _ => head case _ => "value" }	String	un
createParameterFromText(un)	ScParameter	newParam
List("java.util.Map", "java.util.Collection")	List[Nothing]	JAVA_COLLECTIONS_BASES
Set("make", "apply")	Set[Nothing]	SCALA_FACTORY_METHODS_NAMES
Set("scala", "scala.Predef")	Set[Nothing]	SCALA_PREDEFINED_OBJECTS
Set("_root_.scala.PredefMap", "_root_.scala.PredefSet", "scalaList", "scalaNil", "scalaStream", "scalaVector", "scalaSeq")	Set[Nothing]	SCALA_PREDEF_IMMUTABLE_BASES
underscoreToParam.get(u)	Option[ScParameter]	param
refElement.projectContext	ProjectContext	project
ScalaProjectSettings.getInstance(project)	ScalaProjectSettings	scalaProjectSettings
u.replace(param.get).asInstanceOf[ScParameter]	ScParameter	replaced
buf.length	Int	diff
argsAndMatchedParams.forall { case (_, param) => !StringUtil.isEmpty(param.name) }	Boolean	allNamesDefined
argsAndMatchedParams.exists { case (_: ScUnderscoreSection, _) => true case _ => false }	Boolean	hasUnderscore
typeParam.getOwner match { case fun: ScFunction => Some(fun) case c: ScClass => c.constructor case _ => None }	Option[ScMethodLike with PsiDocCommentOwner with PsiNameIdentifierOwner]	methodLike
createExpressionFromText(buf.toString())	ScExpression	newExpr
createBlockExpressionWithoutBracesFromText(code)(element.getManager)	ScBlockImpl	replacement
() => { val Regex = """(?ms)\{(.+)\}""".r x.getText match { case Regex(code) => val replacement = createBlockExpressionWithoutBracesFromText(code)(element.getManager) CodeEditUtil.replaceChild(x.getParent.getNode, x.getNode, replacement.getNode) CodeEditUtil.markToReformat(caseClause.getNode, true) case _ => () } }	() => Unit	action
PsiDocumentManager.getInstance(project).getPsiFile(document)	PsiFile	file
element.parentOfType(classes).flatMap { case ScPatternDefinition.expr(e) if isAncestorOfElement(e) => Some(e) case ifStmt: ScIf => ifStmt.thenExpression.filter(isAncestorOfElement).orElse(ifStmt.elseExpression.filter(isAncestorOfElement)) case funDef: ScFunctionDefinition if !funDef.hasUnitResultType => funDef.body.filter(isAncestorOfElement) case tryExpr: ScTry => tryExpr.expression.filter(isAncestorOfElement) case finallyBlock: ScFinallyBlock => finallyBlock.expression.filter(isAncestorOfElement) case whileStmt: ScWhile => whileStmt.expression.filter(isAncestorOfElement) case doStmt: ScDo => doStmt.body.filter(isAncestorOfElement) case caseClause: ScCaseClause => caseClause.expr match { case Some(x: ScBlockExpr) if isAncestorOfElement(x) && isInsideMaxScope(x) => // special handling for case clauses, which never _need_ braces. val action = () => { val Regex = """(?ms)\{(.+)\}""".r x.getText match { case Regex(code) => val replacement = createBlockExpressionWithoutBracesFromText(code)(element.getManager) CodeEditUtil.replaceChild(x.getParent.getNode, x.getNode, replacement.getNode) CodeEditUtil.markToReformat(caseClause.getNode, true) case _ => () } } return Some(action) case _ => None } case _ => None }	Option[ScExpression]	expr
varAndValDefsExprs ++ eb.templateBody.toList.flatMap(_.exprs) :+ keyword	IndexedSeq[PsiElement]	usages
PsiTreeUtil.findCommonParent(file.findElementAt(parentStartOffset), file.findElementAt(parentEndOffset - 1))	PsiElement	parent
new mutable.HashMap[Int, String]()	mutable.HashMap[Int, String]	params
new mutable.HashMap[Int, String]()	mutable.HashMap[Int, String]	depends
collectComments(x, onElementLine = true)	RemoveBracesIntention.CommentsAroundElement	comments
expr.flatMap { case blk: ScBlockExpr => blk.statements match { case Seq(x: ScExpression) => val comments = collectComments(x, onElementLine = true) if (!hasOtherComments(blk, comments) && isInsideMaxScope(blk)) Some((blk, x, comments)) else None case _ => None } case _ => None }	Option[(ScBlockExpr, ScExpression, RemoveBracesIntention.CommentsAroundElement)]	oneLinerBlock
new MyLookupExpression(parameter.name, null, parameter, f, false, null)	MyLookupExpression	lookupExpr
() => { argsAndMatchedParams.foreach { case (_ childOf (a: ScAssignment), param) if a.leftExpression.getText == param.name => case (argExpr, param) => if (!onlyBoolean || (onlyBoolean && param.paramType.isBoolean)) { inWriteAction { argExpr.replace(createExpressionFromText(param.name + " = " + argExpr.getText)(element.getManager)) } } case _ => } }	() => Unit	doIt
operation.nameId.getTextRange	TextRange	range
methodLike.map(implicitParams).getOrElse(Seq.empty)	Seq[ScParameter]	implicits
target.getUseScope	SearchScope	useScope
operand match { case ScParenthesisedExpr(scExpression) => scExpression case _ => operand }	ScExpression	target
file.findElementAt(offsets(parameter.name) + diff)	PsiElement	dependantParam
builder.buildInlineTemplate()	Template	template
new ArrayBuffer[RangeHighlighter]	ArrayBuffer[RangeHighlighter]	myHighlighters
expression match { case _: ScInfixExpr | _: ScPrefixExpr => true case _ => ScalaNamesUtil.isOpCharacter(text(0)) }	Boolean	needParenthesis
Set("in", "ignore", "is", "be", "taggedAs", "when", "that", "which", "must", "can", "should", "behave", "feature", "scenario", "like", "pending", "it", "they", "behavior", "describe", "property", "test")	Set[Nothing]	scalaTestKeywords
new mutable.HashMap[TextRange, TextAttributes]	mutable.HashMap[TextRange, TextAttributes]	rangesToHighlight
resolvedType.canonicalText	String	text
refElement.resolve()	PsiElement	resolvedElement
TokenSet.create(tLINE_COMMENT)	TokenSet	tLINE_COMMENTS
TokenSet.create( tBLOCK_COMMENT, tSH_COMMENT )	TokenSet	tBLOCK_COMMENTS
templateState.getSegmentRange(i)	TextRange	segmentOffset
null	TextAttributes	attributes
_element	PsiElement	element
element.getTextRange.getStartOffset - 1	Int	offset
ScUnderScoreSectionUtil.underscores(expression)	Seq[ScUnderscoreSection]	underscores
u.getTextRange	TextRange	range
TokenSet.create( tOPENXMLTAG, tCLOSEXMLTAG, tXMLTAGPART, tBADCLOSEXMLTAG, XML_PI_START, XML_PI_END, XML_TAG_CHARACTERS, XML_WHITE_SPACE )	TokenSet	tXML_TAG
operation.nameId.getTextRange.getStartOffset - infix.getTextRange.getStartOffset	Int	size
TokenSet.create( XML_TAG_NAME )	TokenSet	tXML_TAG_NAME
project.stdTypes.QualNameToType	Map[String, StdType]	QualNameToType
x.nameContext	PsiElement	parent
if (project != null && file != null) LanguageSubstitutors.getInstance.substituteLanguage(ScalaLanguage.INSTANCE, file, project) else ScalaLanguage.INSTANCE	Language	language
x.asInstanceOf[ScFunction]	ScFunction	fun
TokenSet.create( XML_DATA_CHARACTERS, XML_CDATA_START, XML_CDATA_END )	TokenSet	tXML_TAG_DATA
TokenSet.create( XML_ATTRIBUTE_NAME, XML_EQ )	TokenSet	tXML_ATTRIBUTE_NAME
LanguageParserDefinitions.INSTANCE .forLanguage(language) .createLexer(project) .asInstanceOf[ScalaLexer]	ScalaLexer	scalaLexer
TokenSet.create( XML_ATTRIBUTE_VALUE_START_DELIMITER, XML_ATTRIBUTE_VALUE_TOKEN, XML_ATTRIBUTE_VALUE_END_DELIMITER )	TokenSet	tXML_ATTRIBUTE_VALUE
clean(definition.name)	String	cleanDefinitionName
new ScLiteralExpressionTokenizer	ScLiteralExpressionTokenizer	myLiteralExpressionTokenizer
TokenSet.create( tXML_COMMENT_START, tXML_COMMENT_END, XML_COMMENT_START, XML_COMMENT_END, XML_COMMENT_CHARACTERS )	TokenSet	tXML_COMMENT
TokenSet.create( DOC_HTML_ESCAPE_HIGHLIGHTED_ELEMENT )	TokenSet	tSCALADOC_HTML_ESCAPE
new StringBuilder	StringBuilder	unEscapedText
new Array[Int](text.length + 1)	Array[Int]	offsets
false	Boolean	Enabled
PsiTreeUtil.getParentOfType(element, classOf[PsiModifierListOwner])	PsiModifierListOwner	listOwner
element.getText	String	text
TokenSet.create( XML_TAG_NAME, XML_START_TAG_START, XML_EMPTY_ELEMENT_END, XML_END_TAG_START, XML_TAG_END )	TokenSet	tSCALADOC_HTML_TAGS
ALL_SCALADOC_SYNTAX_ELEMENTS	TokenSet	tSCALADOC_WIKI_SYNTAX
TokenSet.create( DOC_TAG_VALUE_TOKEN )	TokenSet	tDOC_TAG_PARAM
TokenSet.create( tSTRING, tMULTILINE_STRING, tWRONG_STRING, tCHAR, tSYMBOL, tINTERPOLATED_MULTILINE_STRING, tINTERPOLATED_STRING, tINTERPOLATED_STRING_ID, tINTERPOLATED_STRING_END )	TokenSet	tSTRINGS
TokenSet.create( tINTERPOLATED_STRING_INJECTION )	TokenSet	tINTERPOLATED_STRINGS
TokenSet.create( StringEscapesTokenTypes.VALID_STRING_ESCAPE_TOKEN, tINTERPOLATED_STRING_ESCAPE )	TokenSet	tVALID_STRING_ESCAPE
TokenSet.create( StringEscapesTokenTypes.INVALID_CHARACTER_ESCAPE_TOKEN )	TokenSet	tINVALID_CHARACTER_ESCAPE
TokenSet.create( StringEscapesTokenTypes.INVALID_UNICODE_ESCAPE_TOKEN )	TokenSet	tINVALID_UNICODE_ESCAPE
TokenSet.create( DOC_TAG_NAME )	TokenSet	tCOMMENT_TAGS
new StringBuilder	StringBuilder	res
if (clazz.getModifierList.isAbstract) DefaultHighlighter.ABSTRACT_CLASS else DefaultHighlighter.CLASS	TextAttributesKey	attributes
{ import DefaultHighlighter._ attributesMap( tXML_TAG -> XML_TAG, tXML_TAG_NAME -> XML_TAG, tXML_ATTRIBUTE_NAME -> XML_TAG, tXML_ATTRIBUTE_VALUE -> XML_TAG ) }	Map[IElementType, TextAttributesKey]	Attributes0
{ import DefaultHighlighter._ attributesMap( tLINE_COMMENTS -> LINE_COMMENT, tBLOCK_COMMENTS -> BLOCK_COMMENT, TokenSet.create(SCALA_DOC_COMMENT) -> DOC_COMMENT, KEYWORDS -> KEYWORD, NUMBER_TOKEN_SET -> NUMBER, tVALID_STRING_ESCAPE -> VALID_STRING_ESCAPE, tINVALID_CHARACTER_ESCAPE -> INVALID_STRING_ESCAPE, tINVALID_UNICODE_ESCAPE -> INVALID_STRING_ESCAPE, tSTRINGS -> STRING, BRACES_TOKEN_SET -> BRACES, BRACKETS_TOKEN_SET -> BRACKETS, PARENTHESIS_TOKEN_SET -> PARENTHESES, TokenSet.create(tSEMICOLON) -> SEMICOLON, TokenSet.create(tDOT) -> DOT, TokenSet.create(tCOMMA) -> COMMA, TokenSet.create(tASSIGN) -> ASSIGN, TokenSet.create(tFUNTYPE) -> ARROW, tCOMMENT_TAGS -> SCALA_DOC_TAG, TokenSet.orSet( TokenSet.andNot(ALL_SCALADOC_TOKENS, tCOMMENT_TAGS), TokenSet.create(DOC_COMMENT_BAD_CHARACTER, DOC_HTML_ESCAPE_HIGHLIGHTED_ELEMENT) ) -> DOC_COMMENT, tSCALADOC_HTML_TAGS -> SCALA_DOC_HTML_TAG, tSCALADOC_WIKI_SYNTAX -> SCALA_DOC_WIKI_SYNTAX, tSCALADOC_HTML_ESCAPE -> SCALA_DOC_HTML_ESCAPE, tXML_TAG_NAME -> XML_TAG_NAME, tXML_TAG_DATA -> XML_TAG_DATA, tXML_ATTRIBUTE_NAME -> XML_ATTRIBUTE_NAME, tXML_ATTRIBUTE_VALUE -> XML_ATTRIBUTE_VALUE, tXML_COMMENT -> XML_COMMENT, tDOC_TAG_PARAM -> SCALA_DOC_TAG_PARAM_VALUE, tINTERPOLATED_STRINGS -> INTERPOLATED_STRING_INJECTION ) }	Map[IElementType, TextAttributesKey]	Attributes
s.getClosingTag	ScXmlEndTag	endTag
new LayeredLexer(new ScalaDocLexerHighlightingWrapper(scalaDocLexer))	LayeredLexer	scalaDocLayer
s.getOpeningTag	ScXmlStartTag	startTag
false	Boolean	tagMatch
false	Boolean	isInClosingTag
false	Boolean	afterStartTagStart
0	Int	nameIndex
super.getTokenType	IElementType	tokenType
ScalaXmlLexer.ScalaXmlTokenType(super.getTokenType)	IElementType	htmlTokenType
new TextRange(left.getTextLength, call.getTextLength)	TextRange	range
elem.getOpeningTag	ScXmlStartTag	openingTag
element.parentsInFile.toSeq.filterBy[ScMethodLike].reverse	Seq[ScMethodLike]	allMethodsFromRoot
if (isOnTop(tokenType)) DOC_COMMON_CLOSE_WIKI_TAG else tokenType	IElementType	item
v.bindings	Seq[ScBindingPattern]	bindings
{ val range = new TextRange(left.getTextLength, call.getTextLength) val message = "Casting '%s' to '%s' is redundant".format(left.getText, castType.presentableText) new ProblemDescriptorImpl(call, call, message, Array(new RemoveCastQuickFix(call, left)), ProblemHighlightType.LIKE_UNUSED_SYMBOL, false, range, null, false) }	ProblemDescriptorImpl	descriptor
definition.parent.exists(_.isInstanceOf[ScInfixExpr])	Boolean	isInfix
{ val res = new StringBuilder val isInfix = definition.parent.exists(_.isInstanceOf[ScInfixExpr]) if (isInfix) { res.append("(") } fun.effectiveParameterClauses.headOption match { case Some(paramClause) => res.append(cleanedParamsText(paramClause)) res.append(" => ") case _ => } res.append(funBody.getText) if (isInfix) { res.append(")") } res.toString() }	String	replacement
new ReplaceExpressionWithSAMQuickFix(definition, replacement)	ReplaceExpressionWithSAMQuickFix	fix
definition.extendsBlock	ScExtendsBlock	extendsBlock
extendsBlock.templateBody.map(_.startOffsetInParent + extendsBlock.startOffsetInParent)	Option[Int]	lBraceInParent
value.membersWithSynthetic.flatMap { case definition: ScTypeDefinition => Seq(new TypeDefinitionNode(definition)) case element: ScNamedElement => Seq(new NamedElementNode(element)) case value: ScValueOrVariable => value.declaredElements.map(new NamedElementNode(_)) case _ => Seq.empty }.asInstanceOf[Seq[Node]]	Seq[projectView.Node]	result
openingTag.findChildrenByType(ScalaElementType.XML_ATTRIBUTE).map(_.getText)	IndexedSeq[Nothing]	attributes
lBraceInParent.map(new TextRange(0, _)).orNull	TextRange	rangeInElement
paramClause.parameters	Seq[ScParameter]	parameters
p.name	String	name
TokenSet.andNot( tSCALADOC_WIKI_SYNTAX, TokenSet.create( DOC_LINK_TAG, DOC_LINK_CLOSE_TAG, DOC_HTTP_LINK_TAG, DOC_INNER_CODE_TAG, DOC_INNER_CLOSE_CODE_TAG ) )	TokenSet	SyntaxToSwap
new TextRange(offset, element.getTextLength)	TextRange	range
parameters.map { p => val name = p.name val typeText = p.typeElement.map(_.getText).getOrElse("") s"$name: $typeText" }	IndexedSeq[String]	namesWithTypes
{ val range = new TextRange(offset, element.getTextLength) val message = "Casting '%s' to '%s' is redundant".format(left.getText, conversionType) new ProblemDescriptorImpl(element, element, message, Array(new RemoveConversionQuickFix(element, left)), ProblemHighlightType.LIKE_UNUSED_SYMBOL, false, range, null, false) }	ProblemDescriptorImpl	descriptor
element match { case v: ScVariableDefinition => val bindings = v.bindings bindings.flatMap(getterSignature) ++ bindings.flatMap(setterSignature) case v: ScPatternDefinition => v.bindings.flatMap(getterSignature) case _ => Nil }	Seq[String]	methodSignatures
FormattedStringParser.parse(element) .orElse(PrintStringParser.parse(element)) .orElse(InterpolatedStringParser.parse(element))	Option[Seq[StringPart]]	representation
Set("scala.concurrent.Future", "scala.util.Try")	Set[Nothing]	StatefulMonadsTypesNames
createExpressionFromText(InterpolatedStringFormatter.format(parts))	ScExpression	expression
refPat.getParent	PsiElement	parent
new RenameElementAction	AnAction	action
actionEventForElement(element, action)	AnActionEvent	event
refPat.owner	ScTypeParametersOwner	owner
mutable.Map.empty[String, AnyRef]	mutable.Map[String, AnyRef]	map
ref.getContainingFile	PsiFile	containingFile
InjectedLanguageUtil.openEditorFor(containingFile, project)	Editor	editor
Seq("be_===", "be_==", "beEqualTo", "equalTo", "beTypedEqualTo", "typedEqualTo")	Seq[Nothing]	EqualToMatchers
Seq("must_===", "must_==", "mustEqual")	Seq[Nothing]	EqualToOperators
new DynamicExtensionPoint[BundledInspectionBase]	DynamicExtensionPoint[BundledInspectionBase]	EP
Array[LocalQuickFix]( new ConvertToStableIdentifierPatternFix(refPat), new RenameVariablePatternFix(refPat) )	Array[LocalQuickFix]	quickFixes
createExpressionWithContextFromText(fixed, expr.getContext, expr)	ScExpression	retStmt
holder.getProject	Project	ctx
mutable.ArrayBuffer[(java.lang.Boolean, String, String, String)]()	ArrayBuffer[(Any, String, String, String)]	result
Option(BundledCodeStoreComponent.getInstance(project)) match { case Some(sc) => sc.getLoadedInspections.map(i => (i.getId, i.getName)).toMap case _ => Map.empty }	Map[String, String]	idsToNames
{ val result = mutable.ArrayBuffer[(java.lang.Boolean, String, String, String)]() val idsToNames: Map[String, String] = Option(BundledCodeStoreComponent.getInstance(project)) match { case Some(sc) => sc.getLoadedInspections.map(i => (i.getId, i.getName)).toMap case _ => Map.empty } val it = pathToInspections.entrySet().iterator() while (it.hasNext) { val entry = it.next() val jarName = entry.getKey val il = entry.getValue.iterator() while (il.hasNext) { val insName = il.next() result.+=((new java.lang.Boolean(!disabledIds.contains(insName)), idsToNames.getOrElse(insName, "No name"), insName, jarName)) } } result.toArray }	Array[(Any, String, String, String)]	rows
rows.apply(rowIndex)	(Any, String, String, String)	v
if (iExpr.isSingleWildcard) "_" else iExpr.importedNames.headOption.getOrElse("")	String	name
annotation.annotationExpr.constructorInvocation.typeElement	ScTypeElement	element
s"${iExpr.qualifier.getText}.$name"	String	text
pexpr.getNextSiblingNotWhitespace	PsiElement	next
next.getNode	ASTNode	nextNode
ScalaPsiElementFactory.createEquivQualifiedReference(postfix)	ScReferenceExpression	expr
DoubleNegationUtil.removeDoubleNegation(scExpr)	ScExpression	newExpr
hasNegation(left)	Boolean	hasNegLeft
hasNegation(right)	Boolean	hasNegRight
hasNegation(infix)	Boolean	hasNegInfix
SimplifyBooleanUtil.simplify(scExpr)	ScExpression	simplified
stripParentheses(expr) match { case ScPrefixExpr(_, operand) => invertedNegationText(operand) case infix @ ScInfixExpr(left, _, right) => val hasNegLeft = hasNegation(left) val hasNegRight = hasNegation(right) val hasNegInfix = hasNegation(infix) val builder = new mutable.StringBuilder() builder.append(if (hasNegLeft) invertedNegationText(left) else left.getText) builder.append(if (hasNegLeft && hasNegInfix && hasNegRight) " != " else " == ") builder.append(if (hasNegRight) invertedNegationText(right) else right.getText) builder.toString() }	String	text
stripParentheses(expr)	ScExpression	withoutParentheses
Set("==", "!=", "&&", "&", "||", "|", "^")	Set[Nothing]	boolInfixOperations
Option(stmt.findFirstChildByType(ScalaTokenTypes.kMATCH)).getOrElse(stmt)	PsiElement	toHighlight
catchBlock.expression.orNull	ScExpression	expr
if (param.isAnonymousParameter) DefaultHighlighter.ANONYMOUS_PARAMETER else DefaultHighlighter.PARAMETER	TextAttributesKey	attributesKey
block.caseClauses.orNull	ScCaseClauses	caseClauses
caseClauses.caseClause	ScCaseClause	caseClause
caseClause.pattern.orNull	ScPattern	pattern
cc.pattern.orNull	ScPattern	pattern
new AddOnlyStrategy	AddOnlyStrategy	strategy
caseClause.guard.orNull	ScGuard	guard
isInspection._2.getFirstChild	PsiElement	startElement
isInspection._2.pattern.orNull	ScPattern	endElement
stmt.clauses.partition { case BooleanClause(value) => value }	(Seq[ScCaseClause], Seq[ScCaseClause])	parts
createPatternFromText("`%s`".format(ref.getText))	ScPattern	stableIdPattern
getScExprChildren(expr)	List[ScExpression]	children
createExpressionWithContextFromText(expr.getText, expr.getContext, expr)	ScExpression	exprCopy
getScExprChildren(exprCopy)	List[ScExpression]	children
parenthesized.copy.asInstanceOf[ScParenthesisedExpr]	ScParenthesisedExpr	copy
operation.refName	String	operName
expr.projectContext	ProjectContext	projectContext
new ArrayBuffer[Class[_ <: LocalInspectionTool]]()	ArrayBuffer[Class[_ <: LocalInspectionTool]]	buffer
operation match { case "==" => bool == value case "!=" | "^" => bool != value case "&&" | "&" => bool && value case "||" | "|" => bool || value }	Boolean	result
createExpressionFromText("!a").asInstanceOf[ScPrefixExpr]	ScPrefixExpr	negated
expr.copy.asInstanceOf[ScExpression]	ScExpression	copyExpr
booleanConst(expr) match { case Some(bool: Boolean) => val result: Boolean = operation match { case "==" => bool == value case "!=" | "^" => bool != value case "&&" | "&" => bool && value case "||" | "|" => bool || value } result.toString case _ => (value, operation) match { case (true, "==") | (false, "!=") | (false, "^") | (true, "&&") | (true, "&") | (false, "||") | (false, "|") => expr.getText case (false, "==") | (true, "!=") | (true, "^") => val negated: ScPrefixExpr = createExpressionFromText("!a").asInstanceOf[ScPrefixExpr] val copyExpr = expr.copy.asInstanceOf[ScExpression] negated.operand.replaceExpression(copyExpr, removeParenthesis = true) negated.getText case (true, "||") | (true, "|") => ScalaKeyword.TRUE case (false, "&&") | (false, "&") => ScalaKeyword.FALSE case _ => throw new IllegalArgumentException("Wrong operation") } }	String	text
holder	ProblemsHolder	h
new HighlightInfoHolder(javaFile)	HighlightInfoHolder	highlightInfoHolder
s.getFirstChild	PsiElement	tagNameElement
new Annotation( 0, 0, HighlightSeverity.WEAK_WARNING, "message", "tooltip" )	Annotation	FakeAnnotation
if (a.getPrevSibling == null) a else a.getPrevSibling	PsiElement	startElement
new mutable.HashMap[String, Seq[String]]()	mutable.HashMap[String, Seq[String]]	map
if (a.getPrevSibling != null) { a } else if (a.getNextSibling != null) { a.getNextSibling } else { a.getParent }	PsiElement	endElement
s.getFirstChild.getNode.getElementType	IElementType	firstElementType
s.getFirstChild	PsiElement	firstChild
s.getLastChild	PsiElement	lastChild
s.getNextSibling	PsiElement	sibl
sibl	PsiElement	firstSibl
if (s.getNextSibling != null) s.getNextSibling else s	PsiElement	highlightedElement
mutable.HashMap[String, ScDocTag]()	mutable.HashMap[String, ScDocTag]	tagParams
mutable.HashMap[String, ScDocTag]()	mutable.HashMap[String, ScDocTag]	tagTypeParams
mutable.HashSet[ScDocTag]()	mutable.HashSet[ScDocTag]	duplicatingParams
s.findChildrenByType(ScalaDocTokenType.DOC_COMMENT_DATA)	List[PsiElement]	children
Set(PARAM_TAG, THROWS_TAG, TYPE_PARAM_TAG)	Set[Nothing]	OurTags
doConversion(boundOwner)	Seq[ScParameter]	addedParams
if (syntElem.getFirstChild.getText.contains("=")) { StringUtils.repeat(MyScaladocParsing.escapeSequencesForWiki("="), syntElem.getFirstChild.getText.length()) } else { MyScaladocParsing.escapeSequencesForWiki(syntElem.getFirstChild.getText) }	String	replaceText
FileDocumentManager.getInstance().getDocument(syntElem.getContainingFile.getVirtualFile)	Document	doc
syntElem.getFirstChild.getTextRange	TextRange	range
createDocHeaderElement(openTag.getText.length())	PsiElement	newCloseTag
data.getParent	PsiElement	parent
mc.args	ScArgumentExprList	argList
new NameBooleanParametersQuickFix(message, literal)	NameBooleanParametersInspectionBase.NameBooleanParametersQuickFix	quickFix
MessageToProblemDescriptorConverter(file, manager)	ScalastyleCodeInspection.MessageToProblemDescriptorConverter	converter
new mutable.HashMap[VirtualFile, TimestampedScalastyleConfiguration]()	mutable.HashMap[VirtualFile, (Long, ScalastyleConfiguration)]	cache
Set("map", "flatMap", "filter", "withFilter")	Set[Nothing]	monadicMethods
Set("foldLeft", "/:", "foldRight", ":\\", "fold")	Set[Nothing]	foldMethodNames
Set("reduce", "reduceLeft", "reduceRight")	Set[Nothing]	reduceMethodNames
m.containingClass	PsiClass	containingClass
TestSourcesFilter.isTestSources(file.getVirtualFile, project)	Boolean	isTestSource
call.args match { case exprList: ScArgumentExprList => exprList.exprs.map(stripped) case _ => Nil }	Seq[ScExpression]	args
exprToReplace match { case MethodRepr(_, Some(base), _, _) => base case _ => exprToReplace }	ScExpression	exprToHighlightFrom
{ val exprToHighlightFrom: ScExpression = exprToReplace match { case MethodRepr(_, Some(base), _, _) => base case _ => exprToReplace } rightRangeInParent(exprToHighlightFrom, exprToReplace) }	TextRange	rangeInParent
""	String	replacementText
""	String	hint
holder.getManager.createProblemDescriptor( expr, message, quickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, isOnTheFly )	ProblemDescriptor	descriptor
holder.getProject	ProjectContext	projectContext
if (isTestSource) possibleTestConfigFileNames ++ possibleSrcConfigFileNames else possibleSrcConfigFileNames	Seq[String]	possibleFileNames
Seq("scalastyle_config.xml", "scalastyle-config.xml")	Seq[String]	possibleSrcConfigFileNames
Seq("scalastyle_test_config.xml", "scalastyle-test-config.xml")	Seq[String]	possibleTestConfigFileNames
Seq(".idea", "project")	Seq[String]	possibleLocations
project.getBaseDir	VirtualFile	root
argument match { case tuple: ScTuple => tuple.exprs case _ => Seq(argument) }	Seq[ScExpression]	args
exprToReplace.createSmartPointer	SmartPsiElementPointer[ScExpression]	smartPointer
ArrayBuffer[MethodRepr]()	ArrayBuffer[MethodRepr]	result
p.paramInCode.flatMap(_.typeElement)	Option[ScTypeElement]	typeElem
ScalaPsiManager.instance(holder.getProject)	ScalaPsiManager	instance
new Condition[ScReferenceExpression](_ => true)	InvocationTemplate.this.Condition[ScReferenceExpression]	refCondition
qual match { case _: ScReferenceExpression | _: ScMethodCall | _: ScGenericCall => s"${qual.getText}.apply" case _ => s"(${qual.getText}).apply" }	String	text
Try(ScalaPsiElementFactory.createExpressionFromText(text, call).asInstanceOf[ScReferenceExpression]).toOption	Option[ScReferenceExpression]	ref
instance.getCachedClass(m.resolveScope, clazz).orNull	PsiClass	cachedClass
ref.getParent	PsiElement	parent
possibleLocations.flatMap(name => Option(root.findChild(name))) :+ root	IndexedSeq[VirtualFile]	dirs
invocation("exists").from(likeCollectionClasses)	Qualified	`.exists`
ScalastyleConfiguration.readFromString(new String(scalastyleXml.contentsToByteArray()))	ScalastyleConfiguration	configuration
invocation("forall").from(likeCollectionClasses)	Qualified	`.forall`
scalastyleXml.getModificationStamp	Long	currentStamp
invocation("filter").from(likeCollectionClasses)	Qualified	`.filter`
invocation("filterNot").from(likeCollectionClasses)	Qualified	`.filterNot`
invocation("map").from(likeCollectionClasses)	Qualified	`.map`
argListText(Seq(keyArg))	String	firstArgText
invocation("headOption").from(likeCollectionClasses)	Qualified	`.headOption`
invocation("lastOption").from(likeCollectionClasses)	Qualified	`.lastOption`
invocation("head").from(likeCollectionClasses)	Qualified	`.head`
invocation("last").from(likeCollectionClasses)	Qualified	`.last`
PsiDocumentManager.getInstance(file.getProject).getDocument(file).toOption	Option[Document]	maybeDocument
invocationText(qual, "flatMap", f)	String	newText
ScalaPsiElementFactory.createExpressionWithContextFromText(text, expr.getContext, expr)	ScExpression	newExpr
Messages.format(key, args, customMessage)	String	message
if (line > 0) line - 1 else 0	Int	correctLine
baseExpr.getTextRange.getEndOffset - method.itself.getTextRange.getStartOffset	Int	startIndex
(Seq(srr.element) ++ srr.innerResolveResult.map(_.getElement)).filterBy[ScFunction]	IndexedSeq[ScFunction]	targets
invocation(Set("size", "length")).from(likeCollectionClasses)	Qualified	`.sizeOrLength`
qual.projectContext	ProjectContext	ctx
invocation("find").from(likeCollectionClasses)	Qualified	`.find`
invocation("contains").from(likeCollectionClasses)	Qualified	`.contains`
invocation("flatten").from(likeCollectionClasses)	Qualified	`.flatten`
maybeDocument.exists(correctLine == _.getLineNumber(e.getTextOffset))	Boolean	sameLine
invocation("flatMap").from(likeCollectionClasses)	Qualified	`.flatMap`
invocation("collect").from(likeCollectionClasses)	Qualified	`.collect`
s"(${qual.getText}).contains(${arg.getText})"	String	exprText
document.getLineStartOffset(correctLine) + col	Int	offset
invocation(Set("isDefined", "nonEmpty")).from(likeOptionClasses)	Qualified	`.isDefined`
new ScalastyleChecker[SourceSpec](None)	ScalastyleChecker[SourceSpec]	checker
invocation("isEmpty").from(likeOptionClasses)	Qualified	`.isEmptyOnOption`
invocation("isEmpty").from(likeCollectionClasses)	Qualified	`.isEmpty`
invocation("nonEmpty").from(likeCollectionClasses)	Qualified	`.nonEmpty`
invocation(foldMethodNames).from(likeCollectionClasses)	Qualified	`.fold`
invocation(Set("foldLeft", "/:")).from(likeCollectionClasses)	Qualified	`.foldLeft`
invocation(reduceMethodNames).from(likeCollectionClasses)	Qualified	`.reduce`
invocation("getOrElse").from(likeOptionClasses)	Qualified	`.getOrElse`
invocation("get").from(likeOptionClasses)	Qualified	`.get`
invocation("get").from(likeCollectionClasses).ref(checkResolveToMap)	Qualified	`.getOnMap`
invocation("map").from(likeOptionClasses)	Qualified	`.mapOnOption`
invocation(Set("sortWith", "sortBy", "sorted")).from(likeCollectionClasses)	Qualified	`.sort`
invocation("sorted").from(likeCollectionClasses)	Qualified	`.sorted`
invocation("sortBy").from(likeCollectionClasses)	Qualified	`.sortBy`
invocation("reverse").from(likeCollectionClasses)	Qualified	`.reverse`
invocation("iterator").from(likeCollectionClasses)	Qualified	`.iterator`
invocation("apply")	Qualified	`.apply`
invocation("zip").from(likeCollectionClasses)	Qualified	`.zip`
replace(expr).withText(newText).highlightFrom(qual)	SimplificationBuilder	simplification
invocation("unzip").from(likeCollectionClasses)	Qualified	`.unzip`
argListText(Seq(goeArg))	String	firstArgText
invocation("unzip3").from(likeCollectionClasses)	Qualified	`.unzip3`
invocation("indices").from(likeCollectionClasses)	Qualified	`.indices`
argListText(Seq(mapArg))	String	secondArgText
invocation("take").from(likeCollectionClasses)	Qualified	`.take`
invocation("drop").from(likeCollectionClasses)	Qualified	`.drop`
invocation("sameElements").from(likeCollectionClasses)	Qualified	`.sameElements`
invocation("corresponds").from(likeCollectionClasses)	Qualified	`.corresponds`
mapArg match { case Typeable(FunctionType(retType, _)) => retType case _ => return false }	ScType	mapArgRetType
expr match { case (coll`.sizeOrLength`()) `==` literal("0") => Some((coll, coll.end, expr.end)) case coll`.isEmpty`() => Some((coll, coll.end, expr.end)) case `!`(CheckNonEmpty(coll, _, _)) => Some((coll, expr.start, expr.end)) case `!`(CheckIsDefined(coll, _, _))=> Some((coll, expr.start, expr.end)) case coll `==` scalaNone() if isOption(coll) => Some((coll, coll.end, expr.end)) case scalaNone() `==` coll if isOption(coll) => Some((coll, expr.start, coll.start)) case _ => None }	Option[(ScExpression, Int, Int)]	firstLevel
optionalBase match { case Some(e) => e case _ => return false }	ScExpression	baseExpr
tp.tryExtractDesignatorSingleton	ScType	extracted
extracted.canonicalText	String	canonicalText
invocationText(qual, "exists", cond)	String	existsText
expr match { case IfStmt(x `==` literal("null"), scalaNone(), scalaSome(x1)) if PsiEquivalenceUtil.areElementsEquivalent(x, x1) => Some(x) case IfStmt(x `!=` literal("null"), scalaSome(x1), scalaNone()) if PsiEquivalenceUtil.areElementsEquivalent(x, x1) => Some(x) case IfStmt(literal("null") `==` x, scalaNone(), scalaSome(x1)) if PsiEquivalenceUtil.areElementsEquivalent(x, x1) => Some(x) case IfStmt(literal("null") `!=` x, scalaSome(x1), scalaNone()) if PsiEquivalenceUtil.areElementsEquivalent(x, x1) => Some(x) case _ => None }	Option[ScExpression]	inner
invocationText(negation = true, qual, "exists", cond)	String	notExistsText
s"${baseExpr.getText}$lastText$secondText"	String	newText
mapArg.`type`() match { case Right(FunctionType(retType, _)) => retType case _ => return false }	ScType	mapArgRetType
second.optionalBase.getOrElse(second.itself)	ScExpression	qual
InspectionBundle.message("replace.with.lengthCompare")	String	hint
new SimplificationType() { override def hint: String = ComparingLengthInspection.hint override def getSimplification(e: ScExpression): Option[Simplification] = Some(e).collect { case q `.sizeOrLength` () `>` n => (q, ">", n) case q `.sizeOrLength` () `>=` n => (q, ">=", n) case q `.sizeOrLength` () `==` n => (q, "==", n) case q `.sizeOrLength` () `!=` n => (q, "!=", n) case q `.sizeOrLength` () `<` n => (q, "<", n) case q `.sizeOrLength` () `<=` n => (q, "<=", n) } filter { case (q, _, n) => isNonIndexedSeq(q) && !isZero(n) } map { case (q, op, n) => replace(e).withText(s"${invocationText(q, "lengthCompare", n)} $op 0").highlightFrom(q) } }	SimplificationType	ComparingLength
s"${baseExpr.getText}.fold {$firstArgText}{$secondArgText}"	String	newExprText
Seq( Feature("postfix operator notation", "scala.language", "postfixOps", _.postfixOps, _.postfixOps = true) { case e: ScPostfixExpr => e.operation }, Feature("reflective call", "scala.language", "reflectiveCalls", _.reflectiveCalls, _.reflectiveCalls = true) { case e @ ReferenceTarget(decl@Parent(_: ScRefinement)) if !decl.isInstanceOf[ScTypeAlias] => e.getLastChild match { case id @ ElementType(ScalaTokenTypes.tIDENTIFIER) => id case _ => e } }, Feature("dynamic member selection", "scala.language", "dynamics", _.dynamics, _.dynamics = true) { case e@ReferenceTarget(ClassQualifiedName("scala.Dynamic")) && Parent(Parent(Parent(_: ScTemplateParents))) => e }, Feature("implicit conversion", "scala.language", "implicitConversions", _.implicitConversions, _.implicitConversions = true) { case e: ScFunctionDefinition if e.getModifierList.isImplicit && e.parameters.size == 1 && !e.parameterList.clauses.exists(_.isImplicit) => Option(e.getModifierList.findFirstChildByType(ScalaTokenTypes.kIMPLICIT)).getOrElse(e) }, Feature("higher-kinded type", "scala.language", "higherKinds", _.higherKinds, _.higherKinds = true) { case (e: ScTypeParamClause) && Parent(Parent(_: ScTypeParamClause)) => e case (e: ScTypeParamClause) && Parent(_: ScTypeAliasDeclaration) => e }, Feature("existential type", "scala.language", "existentials", _.existentials, _.existentials = true) { case e: ScExistentialClause => e.firstChild.getOrElse(e) // TODO Exclude reducible existential types }, Feature("macro definition", "scala.language.experimental", "macros", _.macros, _.macros = true) { case e: ScMacroDefinition => e.children.find(it => it.getText == "macro").getOrElse(e) } )	Seq[Feature]	Features
ModuleUtilCore.findModuleForPsiElement(e)	Module	module
invocationText(negation = true, qual, "exists", pred)	String	notExistsText
invocationText(qual, "exists", pred)	String	existsText
new SimplificationType { override def hint: String = InspectionBundle.message("ifstmt.to.lift") override def getSimplification(expr: ScExpression): Option[Simplification] = expr match { case IfStmt(IndexLessThanLengthCondition(seq1, index1), Then(seq2, index2), scalaNone()) if areElementsEquivalent(seq1, seq2) && areElementsEquivalent(index1, index2) => createSimplification(expr, seq1, index1) case IfStmt(IndexGreaterEqualsLengthCondition(seq1, index1), scalaNone(), Then(seq2, index2)) if areElementsEquivalent(seq1, seq2) && areElementsEquivalent(index1, index2) => createSimplification(expr, seq1, index1) case _ => None } private def createSimplification(expr: ScExpression, seq: ScExpression, index: ScExpression): Option[Simplification] = { Some(replace(expr).withText(invocationText(seq, "lift", index)).highlightFrom(expr)) } private object IndexLessThanLengthCondition { def unapply(expr: ScExpression): Option[(ScExpression, ScExpression)] = expr match { case index `<` seq `.sizeOrLength` () if isSeq(seq) => Some(seq, index) case seq `.sizeOrLength` () `>` index if isSeq(seq) => Some(seq, index) case _ => None } } private object IndexGreaterEqualsLengthCondition { def unapply(expr: ScExpression): Option[(ScExpression, ScExpression)] = expr match { case index `>=` seq `.sizeOrLength` () if isSeq(seq) => Some(seq, index) case seq `.sizeOrLength` () `<=` index if isSeq(seq) => Some(seq, index) case _ => None } } private object Then { def unapply(expr: ScExpression): Option[(ScExpression, ScExpression)] = expr match { case scalaSome(seq `.apply` (index)) if isSeq(seq) => Some(seq, index) case _ => None } } }	SimplificationType { def hint: String def createSimplification(expr: ScExpression, seq: ScExpression, index: ScExpression): Option[Simplification] def getSimplification(expr: ScExpression): Option[Simplification] }	IndexBoundsCheck
invocationText(qual, "forall", pred)	String	forallText
ScalaAddImportAction.getImportHolder(elem, elem.getProject)	ScImportsHolder	importsHolder
(left, right) match { case (intLiteral(l), intLiteral(r)) => s"${l + r}" case (intLiteral(a) `+` q, intLiteral(b)) => s"${q.getText} + ${a + b}" case (intLiteral(a), intLiteral(b) `+` q) => s"${q.getText} + ${a + b}" case (q `+` intLiteral(a), intLiteral(b)) => s"${q.getText} + ${a + b}" case (intLiteral(a), q `+` intLiteral(b)) => s"${q.getText} + ${a + b}" case (q, intLiteral(b)) => s"${q.getText} + $b" case (intLiteral(a), q) => s"${q.getText} + $a" case _ => s"${left.getText} + ${right.getText}" }	String	sumText
invocationText(negation = true, qual, "forall", pred)	String	notForallText
set.end + 1	Int	highlightStart
expr.end - 1	Int	highlightEnd
expr match { case qual`.nonEmpty`() => Some((qual, qual.end, expr.end)) case (qual`.sizeOrLength`()) `!=` literal("0") => Some((qual, qual.end, expr.end)) case (qual`.sizeOrLength`()) `>` literal("0") => Some((qual, qual.end, expr.end)) case (qual`.sizeOrLength`()) `>=` literal("1") => Some((qual, qual.end, expr.end)) case qual`.exists`(ScFunctionExpr(_, Some(literal("true")))) => Some((qual, qual.end, expr.end)) case qual`.exists`(ScMethodCall(f: ScReferenceExpression, Seq(literal("true")))) if isConstFunction(f) => Some((qual, qual.end, expr.end)) case `!`(CheckIsEmpty(qual, _, _)) => Some(qual, expr.start, expr.end) case qual `!=` scalaNone() if isOption(qual) => Some(qual, qual.end, expr.end) case scalaNone() `!=` qual if isOption(qual) => Some(qual, expr.start, qual.start) case qual`.isDefined`() if isOption(qual) => Some(qual, qual.end, expr.end) case _ => None }	Option[(ScExpression, Int, Int)]	firstLevel
s"${fExpr.params.getText} => ${pred.getText}"	String	newText
createExpressionFromText(s"_._$index")(q.getContext)	ScExpression	args
invocationText(q, "map", args)	String	text
new SimplificationType { override def hint: String = InspectionBundle.message("replace.with.map") override def getSimplification(e: ScExpression): Option[Simplification] = Some(e).collect { case q `.unzip` () `._1` () => (q, 1) case q `.unzip` () `._2` () => (q, 2) case q `.unzip3` () `._1` () => (q, 1) case q `.unzip3` () `._2` () => (q, 2) case q `.unzip3` () `._3` () => (q, 3) } map { case (q, index) => val args = createExpressionFromText(s"_._$index")(q.getContext) val text = invocationText(q, "map", args) replace(e).withText(text).highlightFrom(q) } private val `._1` = invocation("_1").from(Array("scala.Tuple2", "scala.Tuple3")) private val `._2` = invocation("_2").from(Array("scala.Tuple2", "scala.Tuple3")) private val `._3` = invocation("_3").from(Array("scala.Tuple3")) }	SimplificationType	UnzipSingleElement
invocation("to").from(Array("RichInt", "RichChar", "RichLong", "RichDouble", "RichFloat").map("scala.runtime." + _))	Qualified	`.to`
invocation("!=")	Qualified	`!=`
invocation(Set("==", "equals"))	Qualified	`==`
invocation(">")	Qualified	`>`
invocation(">=")	Qualified	`>=`
invocation("<")	Qualified	`<`
invocation("<=")	Qualified	`<=`
invocation(Set("!", "unary_!"))	Qualified	`!`
invocation("-")	Qualified	`-`
invocation("+")	Qualified	`+`
new Qualified(name => name.startsWith("to") && name != "toString").from(likeCollectionClasses)	Qualified	`.toCollection`
invocation("toSet").from(likeCollectionClasses)	Qualified	`.toSet`
new FoldSimplificationType(this, "fold.sum", "0", "+", "sum")	FoldSimplificationType	foldSum
invocation("toIterator").from(likeCollectionClasses)	Qualified	`.toIterator`
invocation("lift").from(Array(PartialFunctionType.TypeName))	Qualified	`.lift`
new FoldSimplificationType(this, "fold.product", "1", "*", "product")	FoldSimplificationType	foldProduct
invocation(monadicMethods).from(likeCollectionClasses)	Qualified	`.monadicMethod`
new ReduceSimplificationType(this, "reduce.sum", "+", "sum")	ReduceSimplificationType	reduceSum
new ReduceSimplificationType(this,"reduce.product", "*", "product")	ReduceSimplificationType	reduceProduct
new ReduceSimplificationType(this, "reduce.min", "min", "min")	ReduceSimplificationType	reduceMin
new ReduceSimplificationType(this, "reduce.max", "max", "max")	ReduceSimplificationType	reduceMax
getReplacement(_: String, expression, methodArgument, methodCall)	String => SimplificationBuilder	replaceWith
replace(expr).withText(invocationText(qual, methodName)).highlightFrom(qual)	SimplificationBuilder	simpl
expr.`type`().getOrAny	ScType	typeAfterConversion
replace(expr).withText(base.getText).highlightFrom(base)	SimplificationBuilder	simplification
(x: PsiElement, y: PsiElement) => x.getTextRange.getStartOffset .compareTo(y.getTextRange.getStartOffset)	Ordering[PsiElement]	Ordering
partConvertedExprText(expr, exprToConvert, "to" + otherKind)	String	convertText
subExpr match { case _: ScMethodCall | _: ScReferenceExpression | _: ScParenthesisedExpr | _: ScTuple => s"${subExpr.getText}.$conversion" case _ => s"(${subExpr.getText}).$conversion" }	String	subExprConvertedText
subExpr.getTextRange.shiftRight( - expr.getTextOffset)	TextRange	rangeInParent
stripped(expr) match { case ScFunctionExpr(Seq(x, y), Some(result)) => def checkResolve(left: ScExpression, right: ScExpression) = (stripped(left), stripped(right)) match { case (leftRef: ScReferenceExpression, rightRef: ScReferenceExpression) => Set(leftRef.resolve(), rightRef.resolve()) equals Set(x, y) case _ => false } stripped(result) match { case ScInfixExpr(left, oper, right) if checkResolve(left, right) => Some(oper) case ScMethodCall(refExpr: ScReferenceExpression, Seq(left, right)) if checkResolve(left, right) => Some(refExpr) case _ => None } case ScInfixExpr(underscore(), oper, underscore()) => Some(oper) case ScMethodCall(refExpr: ScReferenceExpression, Seq(underscore(), underscore())) => Some(refExpr) case _ => None }	Option[ScReferenceExpression]	operRef
new BinaryOperationOnParameterAndExprTemplate("==")	collections.BinaryOperationOnParameterAndExprTemplate	`x == `
new BinaryOperationOnParameterAndExprTemplate("!=")	collections.BinaryOperationOnParameterAndExprTemplate	`x != `
mutable.ListBuffer(cfg: _*)	ListBuffer[Instruction]	queue
y.getName	String	secondArgName
mutable.ListBuffer.empty[collection.Set[Instruction]]	ListBuffer[Set[Instruction]]	buffer
mutable.HashSet.empty[Instruction]	mutable.HashSet[Instruction]	currentSet
mutable.ArrayBuffer.empty[Instruction]	ArrayBuffer[Instruction]	currentSucc
ScalaPsiElementFactory.createExpressionWithContextFromText(s"return ${expression.getText}", expression.getContext, expression)	ScExpression	retStmt
Set("then")	Set[Nothing]	deprecatedNames
Set("?", "+?", "-?")	Set[Nothing]	kindProjectorDeprecatedNames
new ScalaUnwrapContext	ScalaUnwrapContext	unwrapContext
secondArgName + " => " + right.getText	String	funExprText
new ParameterlessCallOnParameterTemplate("_1")	collections.ParameterlessCallOnParameterTemplate	`_._1`
TextRange.create(0, 1)	TextRange	left
new ParameterlessCallOnParameterTemplate("_2")	collections.ParameterlessCallOnParameterTemplate	`_._2`
argListText(args)	String	argsText
invocationText(qual, methName, args: _*)	String	baseText
TextRange.create(element.getTextLength - 1, element.getTextLength)	TextRange	right
UnnecessaryParenthesesSettings( ignoreClarifying = true, ignoreAroundFunctionType = false, ignoreAroundFunctionTypeParam = false, ignoreAroundFunctionExprParam = false )	UnnecessaryParenthesesSettings	default
TextRange.create(2, element.getTextLength - 2)	TextRange	middle
comment.getText	String	text
ScalaPsiElementFactory.createExpressionWithContextFromText(s"${baseExpr.getText}.$methodName", baseExpr.getContext, baseExpr)	ScExpression	expression
parameter.getName	String	name
KindProjectorUtil.isQuestionMarkSyntaxDeprecatedFor(e)	Boolean	questionMarkDeprecated
SuppressionUtilCore.SUPPRESS_INSPECTIONS_TAG_NAME + " " + key.getID	String	text
kindProjectorMessage(questionMarkDeprecated)	String	msg
SuppressionUtil.createComment(project, text, ScalaLanguage.INSTANCE)	PsiComment	comment
new ScalaRecursiveElementVisitor() { override def visitReferenceExpression(ref: ScReferenceExpression) { if (ref.refName == name && ref.resolve() == parameter) result = false super.visitReferenceExpression(ref) } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	visitor
Set("append", "appendAll", "clear", "insert", "insertAll", "prepend", "prependAll", "reduceToSize", "remove", "retain", "transform", "trimEnd", "trimStart", "update", "push", "pushAll", "pop", "dequeue", "dequeueAll", "dequeueFirst", "enqueue", "next")	Set[Nothing]	sideEffectsCollectionMethods
{ case `expr` => true case (ScFunctionExpr(_, _) | (_: ScCaseClauses)) childOf `expr` => true case (e: ScExpression) childOf `expr` if ScUnderScoreSectionUtil.underscores(e).nonEmpty => true case _: ScFunctionDefinition => false case elem: PsiElement => !ScalaEvaluatorBuilderUtil.isGenerateClass(elem) }	PsiElement => Boolean	predicate
questionMarkDeprecated.option(ReplaceWithAsteriskSyntax(e))	Option[DeprecatedKindProjectorSyntaxInspection.ReplaceWithAsteriskSyntax]	fix
createNewLine()(element.getManager)	PsiElement	newLine
stmt.getPrevSiblingNotWhitespace	PsiElement	prev
owner.docComment.get	ScDocComment	docComment
HighlightDisplayKey.find(toolShortName)	HighlightDisplayKey	displayKey
owner.getFirstChild	PsiElement	firstChild
container.getParent	PsiElement	parent
expr.depthFirst(predicate).filter(predicate)	Iterator[PsiElement]	sameLevelIterator
parent.getTextRange.getEndOffset	Int	endOffset
new TypeCheckCanBeMatchQuickFix(call, ifStmt)	TypeCheckCanBeMatchInspection.this.TypeCheckCanBeMatchQuickFix	fix
Map( likeCollectionKey -> InspectionBundle.message("operation.on.collection.like.collection.input.message"), likeOptionKey -> InspectionBundle.message("operation.on.collection.like.option.input.message") )	Map[Nothing, Nothing]	inputMessages
Map( likeCollectionKey -> InspectionBundle.message("operation.on.collection.like.collection.input.title"), likeOptionKey -> InspectionBundle.message("operation.on.collection.like.option.input.title") )	Map[Nothing, Nothing]	inputTitles
expr match { case _ childOf ScInfixExpr(`expr`, op, _) => op.nameId.getTextOffset case _ childOf (ref @ ScReferenceExpression.withQualifier(`expr`)) => ref.nameId.getTextOffset case _ => expr.getTextRange.getEndOffset }	Int	startOffset
Map( likeCollectionKey -> InspectionBundle.message("operation.on.collection.like.collection.panel.title"), likeOptionKey -> InspectionBundle.message("operation.on.collection.like.option.panel.title") )	Map[Nothing, Nothing]	panelTitles
element.isNestingParenthesis	Boolean	keepParentheses
ScalaApplicationSettings.getInstance()	ScalaApplicationSettings	settings
Seq("contains", "indexOf", "lastIndexOf")	Seq[Nothing]	seqFunctions
Set("==", "!=", ">", "<", ">=", "<=")	Set[Nothing]	ComparisonOperators
listOfIfAndIsInstOf(ifStmt, isInstOf, onlyFirst = true).size	Int	chainSize
PatternMayNeverMatchInspection.message(exTp, patType)	String	message
type1.projectContext.stdTypes	StdTypes	stdTypes
target	PsiElement	Target
element.doStripParentheses(keepParentheses) match { // Remove the last level of parentheses if allowed case paren: ScParenthesizedElement if paren.isParenthesisRedundant => paren.doStripParentheses() case other => other }	PsiElement	replaced
Seq(type1, type2)	Seq[ScType]	types
findAsInstanceOfCalls(ifStmt.condition, isInstOf).size + findAsInstanceOfCalls(ifStmt.thenExpression, isInstOf).size	Int	typeCastsNumber
oper.resolve() match { case _: ScSyntheticFunction => true case m: PsiMethod if MethodUtils.isEquals(m) => true case _ => false }	Boolean	needHighlighting
new AbstractFixOnPsiElement[ScParameterClause]("Remove unnecessary parentheses " + getShortText(elt), elt) { override protected def doApplyFix(element: ScParameterClause)(implicit project: Project): Unit = { if (isParenthesised(element)) { elt.getNode.removeChild(elt.getNode.getFirstChildNode) elt.getNode.removeChild(elt.getNode.getLastChildNode) } } }	AbstractFixOnPsiElement[ScParameterClause] { def doApplyFix(element: ScParameterClause) (implicit project: Project): Unit }	quickFix
OperationOnCollectionQuickFix(s)	OperationOnCollectionQuickFix	quickFix
Map( likeCollectionKey -> getLikeCollectionClasses _, likeOptionKey -> getLikeOptionClasses _ )	Map[Nothing, Nothing]	patternLists
ScDesignatorType(clazz)	ScDesignatorType	designatorType
{ Map( likeCollectionKey -> setLikeCollectionClasses _, likeOptionKey -> setLikeOptionClasses _ ) }	Map[Nothing, Nothing]	setPatternLists
invocation(sourceNonClosingMethodNames).from(Array("scala.io.Source", "scala.io.BufferedSource"))	Qualified	sourceNonClosingMethods
getSimplificationTypesEnabled	Array[Any]	enabled
s"Parameter name: $deprecatedName is deprecated."	String	description
patternLists(patternListKey)()	Array[String]	patternList
ScalaPsiUtil.nameContext(named)	PsiElement	context
- util.Arrays.binarySearch (listModel.toArray, pattern) - 1	Int	index
generateComparingUnrelatedTypesMsg(leftType, rightType)	String	message
bl.getChildren.drop(1).dropRight(1)	Array[PsiElement]	children
getActiveEditor(element, project)	Option[Editor]	maybeEditor
block.getChildren.apply(1)	PsiElement	child
child match { case ref: ScReferenceExpression if ref.qualifier.isEmpty => true case t: ScThisReference if t.reference.isEmpty => true case _ => false }	Boolean	probablyRedundant
block.getNextSibling	PsiElement	next
Declaration(element)	Declaration	declaration
block.getParent	PsiElement	parent
isIdentifier(text) && (nextLetter == '$' || !isIdentifier(text + nextLetter))	Boolean	checkId
Location(element)	Location	location
!declaration.entity.isParameter && !location.isInLocalScope && declaration.visibility == Visibility.Default	Boolean	canBePrivate
generateComparingUnrelatedTypesMsg(elemType, argType)	String	message
createDeclaration("x", "Unit", isVariable = false, null)	ScValueOrVariable	declaration
inWriteAction { ifSt.replaceExpression(matchStmt, removeParenthesis = true).asInstanceOf[ScMatch] }	ScMatch	newMatch
call.referencedExpr match { case ScReferenceExpression.withQualifier(q) => q.`type`().map(_.tryExtractDesignatorSingleton).toOption case _ => None }	Option[ScType]	qualType
descriptors.flatMap(_.getFixes).collect { case quickFix: AddTypeAnnotationQuickFix => quickFix }	IndexedSeq[AddTypeAnnotationQuickFix]	quickFixes
new CollectTypesToAddStrategy	AddTypeAnnotationQuickFix.CollectTypesToAddStrategy	strategy
quickFixes.length	Int	quickFixesCount
call.arguments.headOption.flatMap(_.`type`().toOption)	Option[ScType]	argType
Messages.showInputDialog(parent, inputMessage, inputTitle, Messages.getWarningIcon, "", validator)	String	newPattern
canBePrivate.seq(new MakePrivateQuickFix(element.asInstanceOf[ScModifierListOwner])) ++ Seq(new AddTypeAnnotationQuickFix(anchor), new ModifyCodeStyleQuickFix(), new LearnWhyQuickFix())	IndexedSeq[LocalQuickFix]	fixes
generateComparingUnrelatedTypesMsg(t1, t2)	String	message
mutable.ArrayBuffer[(ScTypeElement, PsiElement)]()	ArrayBuffer[(ScTypeElement, PsiElement)]	annotations
Option(refreshViews)	Option[Nothing]	maybeViews
function.paramClauses	ScParameters	paramClauses
firstType.extractDesignatorSingleton.getOrElse(firstType)	ScType	nonSingleton1
paramClauses.clauses	Seq[ScParameterClause]	clauses
secondType.extractDesignatorSingleton.getOrElse(secondType)	ScType	nonSingleton2
s"$matchedExprText match { \n " + caseClausesText + "}"	String	matchStmtText
new AbstractFixOnPsiElement( "Remove redundant type annotation", function ) { override protected def doApplyFix(function: ScFunction)(implicit project: Project): Unit = removeTypeElement(function) }	AbstractFixOnPsiElement[ScFunction] { def doApplyFix(function: ScFunction) (implicit project: Project): Unit }	quickFix
fun.containingClass.qualifiedName.toOption.getOrElse("")	String	className
createExpressionFromText(matchStmtText).asInstanceOf[ScMatch]	ScMatch	matchStmt
None	Option[String]	definedName
None	Option[ScPatternDefinition]	definition
new AbstractFixOnPsiElement( "Remove redundant type annotation and equals sign", function.asInstanceOf[ScFunctionDefinition] ) { override protected def doApplyFix(function: ScFunctionDefinition)(implicit project: Project): Unit = { removeTypeElement(function) removeAssignment(function) } }	AbstractFixOnPsiElement[ScFunctionDefinition] { def doApplyFix(function: ScFunctionDefinition) (implicit project: Project): Unit }	quickFix
reference.getParent match { case parent if !isFixable(parent) => None case call: ScGenericCall if !findCall(call) => Some(call) case _: ScGenericCall => None case _ => Some(reference) }	Option[ScExpression]	maybeTargetExpression
createQuickFix(param)	Option[LocalQuickFix]	quickfix
new AbstractFixOnPsiElement( "Remove redundant equals sign", function.asInstanceOf[ScFunctionDefinition] ) { override protected def doApplyFix(function: ScFunctionDefinition)(implicit project: Project): Unit = removeAssignment(function) }	AbstractFixOnPsiElement[ScFunctionDefinition] { def doApplyFix(function: ScFunctionDefinition) (implicit project: Project): Unit }	quickFix
expression.getParent match { case postfix: ScPostfixExpr => postfix case call: ScGenericCall => call case _ => expression }	ScExpression	target
new AbstractFixOnPsiElement( InspectionBundle.message("convert.to.function.syntax"), function.asInstanceOf[ScFunctionDefinition] ) { override protected def doApplyFix(function: ScFunctionDefinition)(implicit project: Project): Unit = { removeAssignment(function) removeTypeElement(function) addUnitTypeElement(function) } }	AbstractFixOnPsiElement[ScFunctionDefinition] { def doApplyFix(function: ScFunctionDefinition) (implicit project: Project): Unit }	quickFix
ScalaPsiElementFactory.createExpressionFromText(s"${target.getText}()")	ScExpression	replacement
new AbstractFixOnPsiElement( InspectionBundle.message("insert.missing.assignment"), function ) { override protected def doApplyFix(function: ScFunction)(implicit project: Project): Unit = for { (lastType, refinement) <- typeComponents(function) endIndex = lastType.getTextRange.getEndOffset - function.getTextRange.getStartOffset text = s"${function.getText.substring(0, endIndex)} = ${refinement.getText}" method = ScalaPsiElementFactory.createMethodFromText(text) } function.replace(method) }	AbstractFixOnPsiElement[ScFunction] { def doApplyFix(function: ScFunction) (implicit project: Project): Unit }	quickFix
place match { case _ if call.getParent.isInstanceOf[ScMethodCall] => false case Resolved(resolveResult@ScalaResolveResult(method: PsiMethod, _)) if quickfix.isAccessor(method) && isNotOverloadedMethod(place, resolveResult.fromType) => hasSameType(call, place) case _ => false }	Boolean	problemExists
new AbstractFixOnPsiElement( InspectionBundle.message("convert.to.function.syntax"), function ) { override protected def doApplyFix(function: ScFunction)(implicit project: Project): Unit = { def addChildNode(element: PsiElement): Unit = function.getNode.addChild(element.getNode) import ScalaPsiElementFactory.{createColon, createTypeElementFromText, createWhitespace} addChildNode(createColon) addChildNode(createWhitespace) addChildNode(createTypeElementFromText("Unit")) } }	AbstractFixOnPsiElement[ScFunction] { def doApplyFix(function: ScFunction) (implicit project: Project): Unit }	quickFix
patternDef.bindings	Seq[ScBindingPattern]	bindings
qual(expr.qualifier)	ScStableCodeReference	q
context.asOptionOf[PsiDocCommentOwner].flatMap { case Constructor(constr) if constr.isDeprecated => Some(constr) case Constructor.ofClass(clazz) if clazz.isDeprecated => Some(clazz) case func@ScFunction.inSynthetic(clazz) if func.isApplyMethod && clazz.isDeprecated => Some(clazz) case other if other.isDeprecated => Some(other) case func: ScFunction => result.getActualElement.asOptionOf[PsiDocCommentOwner].filter(_.isDeprecated) case _ => None }	Option[PsiDocCommentOwner]	deprecatedElement
new Qualified(_ => true).from(nonClosingBaseClasses)	Qualified	baseClassesNonClosingMethods
ScalaPsiElementFactory.createExpressionFromText(text)	ScExpression	replacement
v.declaredElements.withFilter(elem => isApplicable(superValsSignatures(elem)))	FilterMonadic[ScTypedDefinition, Seq[ScTypedDefinition]]	possibleOverrideElements
new AbstractFixOnPsiElement( InspectionBundle.message("remove.call.parentheses"), call ) { override protected def doApplyFix(call: ScMethodCall)(implicit project: Project): Unit = { val text = call.getInvokedExpr.getText val replacement = ScalaPsiElementFactory.createExpressionFromText(text) call.replace(replacement) } }	AbstractFixOnPsiElement[ScMethodCall] { def doApplyFix(call: ScMethodCall) (implicit project: Project): Unit }	quickFix
args.typeArgs.head	ScTypeElement	typeElem
new CollectMethodsProcessor(place, place.refName)	CollectMethodsProcessor	processor
invocation(Set("fromFile", "fromURL", "fromURI")).from(Array("scala.io.Source"))	Qualified	qualFrom
createQuickFix(v)	Option[LocalQuickFix]	quickfix
findAsInstanceOfCalls(ifStmt.thenExpression, isInstOfCall)	Seq[ScGenericCall]	asInstOfInBody
unqualifed(Set("fromFile", "fromURL", "fromURI")).from(Array("scala.io.Source"))	Unqualified	unqualFrom
q.multiResolveScala(false)	Array[ScalaResolveResult]	resolve
new ArrayBuffer[LocalQuickFix]()	ArrayBuffer[LocalQuickFix]	fixes
findGuardCondition(condition)(equiv(_, isInstOfCall))	Option[ScExpression]	guardCondition
findAsInstanceOfCalls(guardCondition, isInstOfCall)	Seq[ScGenericCall]	asInstOfInGuard
createQuickFix(function)	Option[LocalQuickFix]	quickfix
asInstOfInBody ++ asInstOfInGuard	IndexedSeq[ScGenericCall]	asInstOfEverywhere
ifStmt.getProject	Project	project
new ScalaVariableValidator( ifStmt, false, ifStmt.getParent, ifStmt.getParent )	ScalaVariableValidator	validator
modifierListOwner.getModifierList	ScModifierList	modifierList
createReferenceFromText(fqn, ref.getContext, ref)	ScStableCodeReference	newRef
ScalaPsiElementFactory.createDeclarationFromText( "val x", modifierListOwner.getParent, modifierListOwner ).findFirstChildByType(ScalaTokenTypes.kVAL)	PsiElement	valKeyword
expr.getParent.asInstanceOf[ScImportStmt]	ScImportStmt	impSt
NameSuggester.suggestNames(asInstOfEverywhere.head, validator)	Seq[String]	suggestedNames
suggestedNames.head	String	text
definedName.get	String	text
imp match { case ImportExprUsed(expr) if !PsiTreeUtil.hasErrorElements(expr) => val impSt = expr.getParent.asInstanceOf[ScImportStmt] if (impSt == null) None //todo: investigate this case, this cannot be null else if (impSt.importExprs.size == 1) Some(impSt) else Some(expr) case ImportSelectorUsed(sel) => Some(sel) case ImportWildcardSelectorUsed(e) if e.selectors.nonEmpty => Some(e.wildcardElement.get) case ImportWildcardSelectorUsed(e) if !PsiTreeUtil.hasErrorElements(e) => Some(e.getParent) case _ => None }	Option[PsiElement]	psiOption
ref.nextSiblings.find(_.getNode.getElementType == ScalaTokenTypes.tCOMMA).get.getNextSiblingNotWhitespace.getPrevSibling	PsiElement	end
imp.qualName	Option[String]	qName
for { holder <- deprecatedElement.asOptionOf[ScAnnotationsHolder] annotation <- holder.annotations("scala.deprecated").headOption message <- ScalaPsiUtil.readAttribute(annotation, "value") } yield message	Option[String]	message
createExpressionFromText(text)	ScExpression	newExpr
if (asInstOfInBody.count(checkAndStoreNameAndDef) == 0) { //no usage of asInstanceOf asInstOfEverywhere match { case Seq() => "_" case _ => //no named usage val validator = new ScalaVariableValidator( ifStmt, false, ifStmt.getParent, ifStmt.getParent ) val suggestedNames = NameSuggester.suggestNames(asInstOfEverywhere.head, validator) val text = suggestedNames.head for { expression <- asInstOfEverywhere newExpr = createExpressionFromText(text) } inWriteAction { expression.replaceExpression(newExpr, removeParenthesis = true) } renameData += ((caseClauseIndex, suggestedNames)) text } } else { inWriteAction(definition.get.delete()) val text = definedName.get val newExpr = createExpressionFromText(text) inWriteAction { for { expression <- asInstOfEverywhere } expression.replaceExpression(newExpr, removeParenthesis = true) } text }	String	name
Key.create[java.lang.Long]("SCALA_LAST_POST_PASS_TIMESTAMP")	Key[Any]	SCALA_LAST_POST_PASS_TIMESTAMP
s"Symbol $name is deprecated. ${message.getOrElse("")}"	String	description
ScalaRefCountHolder(element)	ScalaRefCountHolder	refCounter
document.getModificationStamp	Long	stamp
ref.prevSiblings.find(_.getNode.getElementType == ScalaTokenTypes.tCOMMA).get.getPrevSiblingNotWhitespace.getNextSibling	PsiElement	start
"Remove unused element"	String	Hint
mutable.Buffer[HighlightInfo]()	mutable.Buffer[HighlightInfo]	highlightInfos
UndoManager.getInstance(project)	UndoManager	undoManager
new ScalaInspectionSuppressor	ScalaInspectionSuppressor	inspectionSuppressor
file.depthFirst().filter { inspection.shouldProcessElement }.filter { isEnabled }.flatMap { inspection.invoke(_, isOnTheFly = true) }	Iterator[ProblemInfo]	infos
DaemonCodeAnalyzerEx.getInstanceEx(file.getProject)	DaemonCodeAnalyzerEx	codeAnalyzer
info.element.getTextRange	TextRange	range
new Annotation(range.getStartOffset, range.getEndOffset, severity, info.message, info.message)	Annotation	annotation
annotationHolder.createWarningAnnotation(psi, "Unused import statement")	Annotation	annotation
parameterized.typeArgList.typeArgs	Seq[ScTypeElement]	typeArgs
ScalaCodeStyleSettings.getInstance(param.getProject).REPLACE_LAMBDA_WITH_GREEK_LETTER	Boolean	useGreekLambda
new KindProjectorUseCorrectLambdaKeywordQuickFix(simple, "")	KindProjectorUseCorrectLambdaKeywordQuickFix	changeKeywordFix
new SimplifyAppliedTypeLambdaQuickFix(parameterized, simplifyTypeProjection(alias, typeArgs))	AppliedTypeLambdaCanBeSimplifiedInspection.SimplifyAppliedTypeLambdaQuickFix	fix
new ChangeLambdaCodeStyleSetting(!useGreekLambda)	ChangeLambdaCodeStyleSetting	changeSettingsFix
new KindProjectorUseCorrectLambdaKeywordQuickFix(simple, "Lambda")	KindProjectorUseCorrectLambdaKeywordQuickFix	changeKeywordFix
expression.getParent match { case parent childOf (_: ScArgumentExprList | _: ScInfixExpr) => parent case _ => expression }	PsiElement	arg
refCounter.retrieveUnusedReferencesInfo { () => used |= refCounter.isValueReadUsed(element) || refCounter.isValueWriteUsed(element) }	Boolean	success
expr.copy().asInstanceOf[ScBlockExpr]	ScBlockExpr	expressionCopy
element match { case caseClause: ScCaseClause => caseClause.pattern.toSeq.flatMap(_.bindings).filterNot(_.isWildcard) case declaredHolder: ScDeclaredElementsHolder => declaredHolder.declaredElements case fun: ScFunctionExpr => fun.parameters.filterNot(p => p.isWildcard || p.isImplicitParameter) case enumerators: ScEnumerators => enumerators.patterns.flatMap(_.bindings).filterNot(_.isWildcard) //for statement case _ => Seq.empty }	Seq[PsiElement]	elements
"ScalaUnusedSymbol"	String	ShortName
alias.typeParameters	Seq[ScTypeParam]	aliasParam
positionCursor(project, elem.getContainingFile, elem)	Editor	editor
elem.getTextRange	TextRange	range
range.getStartOffset	Int	textOffset
new KindProjectorSimplifyTypeProjectionQuickFix(projection, convertToKindProjIectorSyntax(alias))	KindProjectorSimplifyTypeProjectionInspection.KindProjectorSimplifyTypeProjectionQuickFix	fix
"KindProjectorSimplifyTypeProjection"	String	inspectionId
InspectionBundle.message("kind.projector.simplify.type")	String	inspectionName
new OpenFileDescriptor(project, targetFile.getVirtualFile, textOffset)	OpenFileDescriptor	descriptor
alias.typeParameters	Seq[ScTypeParam]	typeParams
typeParams.nonEmpty && typeParams.forall(hasNoBounds)	Boolean	validTypeParams
simpleTypeArgumentOccurences(paramType)	Map[String, Int]	typeArgOccurences
file.getContainingDirectory	PsiDirectory	dir
JavaDirectoryService.getInstance().getPackage(dir)	PsiPackage	pack
cleanKeywords(file.getPackageName)	String	packName
file	ProjectContext	ctx
MatchToPartialFunctionQuickFix(statement, expression)	LocalQuickFixOnPsiElement	fix
file.packagingRanges match { case Seq() => file.typeDefinitions.map(_.nameId.getTextRange) case seq => seq }	Seq[TextRange]	ranges
statement.copy.asInstanceOf[ScMatch]	ScMatch	matchStmtCopy
findLeftBrace(matchStmtCopy).getOrElse(return)	PsiElement	leftBrace
Seq(new EnablePerformanceProblemsQuickFix(file.getProject))	Seq[EnablePerformanceProblemsQuickFix]	fixes
typeParams.map(p => typeArgOccurences.getOrElse(p.name, 0)).forall(_ == 1)	Boolean	typeParamsAppearOnce
typeParams.iterator	Iterator[ScTypeParam]	typeParamIt
Option(typeParamIt.next())	Option[ScTypeParam]	currentTypeParam
createExpressionFromText(matchStmtCopy.getText)	ScExpression	newBlock
settings.isIgnorePerformance	Boolean	ignoreSettings
if (!ignoreSettings) "Enable" else "Disable"	String	enable
typedPattern.typePattern.map(_.typeElement.calcType)	Option[ScType]	patternType
caseClause.expr.flatMap(_.`type`().toOption)	Option[ScType]	expressionType
paramType.typeArguments.map { ta => currentTypeParam match { case Some(tpt) if ta.presentableText == tpt.name => currentTypeParam = if (typeParamIt.hasNext) Option(typeParamIt.next()) else None tpt.getText.replace(tpt.name, KindProjectorUtil.placeholderSymbolFor(alias)) case _ => ta.presentableText } }	IndexedSeq[Any]	newTypeArgs
ScalaCodeStyleSettings.getInstance(alias.getProject)	ScalaCodeStyleSettings	styleSettings
"ScalaAppliedTypeLambdaCanBeSimplified"	String	inspectionId
packQualName	String	packageName
Seq( new ScalaRenamePackageQuickFix(file, expectedPackageName), new ScalaMoveToPackageQuickFix(file, packName), new EnablePerformanceProblemsQuickFix(file.getProject))	Seq[LocalQuickFix]	fixes
InspectionBundle.message("applied.type.lambda.can.be.simplified")	String	inspectionName
fileIndex.getModuleForFile(file.getVirtualFile)	Module	currentModule
createExpressionFromText(invoked + " " + newBlock.getText)	ScExpression	replacement
alias.typeParameters.map(param => if (param.isCovariant || param.isContravariant || boundsDefined(param)) s"`${param.getText}`" else param.getText )	IndexedSeq[String]	parameters
alias.aliasedType.getOrAny	ScType	aliased
s"(${mc.args.getText})"	String	newArgsText
new MoveClassesOrPackagesProcessor( project, Array[PsiElement](file.typeDefinitions.head), new SingleSourceRootMoveDestination(PackageWrapper.create(JavaDirectoryService.getInstance().getPackage(directory)), directory), false, false, null)	MoveClassesOrPackagesProcessor	processor
if (packageName.nonEmpty) s"Package $packageName" else "Default Package"	String	packageText
statement.expression.getOrElse(return)	ScExpression	expression
createExpressionFromText(s"$invokedExprText$newArgsText")	ScExpression	newCall
statement.clauses	Seq[ScCaseClause]	clauses
definition.declaredType .filter(isApplicable)	Option[ScType]	maybeDeclaredType
getConstructorInvocationFromTemplate(newTemplate)	Option[ScConstructorInvocation]	constructor
definition.expr .filter(_.isValid) .filter(isNull)	Option[ScExpression]	maybeExpression
ScSubstitutor.bind(alias.typeParameters, typeArgs)(_.calcType)	ScSubstitutor	subst
indices.flatMap(i => clauses(i).pattern)	IndexedSeq[ScPattern]	patterns
subst(aliased)	ScType	substituted
ScalaPsiElementFactory.createExpressionWithContextFromText(constructorText, constrInvocation.getContext, constrInvocation)	ScExpression	expression
getDeepestInvokedReference(expression).filter(_.isValid)	Option[ScReferenceExpression]	reference
body.calculateTailReturns	Set[ScExpression]	returns
"VarCouldBeVal"	String	ID
"var could be a val"	String	DESCRIPTION
ref.bind().map(_.getElement)	Option[PsiNamedElement]	referredElement
createVarFromValDeclaration(value)	ScVariable	replacement
FileModificationService.getInstance	FileModificationService	fileModificationService
"Convert 'val' to 'var'"	String	DESCRIPTION
createPatternFromText(text)	ScPattern	replacement
file.findElementAt(endOffset(element))	PsiElement	nextLeaf
endOffset(nextLeaf)	Int	whitespaceOffset
startOffset(element)	Int	offset
raw"${FunctionType.TypeName}(\d)".r	Regex	FunctionN
createValFromVarDefinition(variable)	ScValue	replacement
"Convert 'var' to 'val'"	String	HINT
raw"${TupleType.TypeName}(\d)".r	Regex	TupleN
false	Boolean	hasWriteUsages
typeElement.getContext match { case _: ScFunctionalTypeElement => true // (Tuple2[A, B]) => B ==>> ((A, B)) => C case _ => false }	Boolean	needParens
new ProblemDescriptorImpl(classParam, classParam, ScalaBundle.message("val.on.case.class.param.redundant"), Array(new RemoveValQuickFix(classParam)), ProblemHighlightType.LIKE_UNUSED_SYMBOL, false, TextRange.create(0, 3), holder.isOnTheFly)	ProblemDescriptorImpl	descriptor
ScalaRefCountHolder(element)	ScalaRefCountHolder	holder
ScalaCodeStyleSettings.getInstance(holder.getProject)	ScalaCodeStyleSettings	settings
value.declaredElements.head	ScBindingPattern	e
value.declaredElements.head	ScTypedDefinition	e
removeChar(file.charSequence, offset)	String	textWithoutSemicolon
expr.copy.asInstanceOf[ScInfixExpr]	ScInfixExpr	infixCopy
createScalaFileFromText(textWithoutSemicolon)(element.getManager)	ScalaFile	newFile
clazz.qualifiedName	String	qualifiedName
file.findElementAt(offset - 1)	PsiElement	elem1
createExpressionWithContextFromText(newExprText, oldExpr.getContext, oldExpr)	ScExpression	newExpr
newFile.findElementAt(offset - 1)	PsiElement	elem2
ref.bind() .map(_.getActualElement) .map(nameContext) .collect(asValueOrVariable)	Option[ScValueOrVariable]	maybeResolved
typeElement.typeArgList.typeArgs.dropRight(1)	Seq[ScTypeElement]	paramTypes
methodWithoutArgumentsText(expr)	Seq[String]	withoutArguments
typeElement.typeArgList.typeArgs.last	ScTypeElement	returnType
segments.takeRight(2).mkString(".")	String	replacementText
if (expr.getText endsWith "_") Nil else withoutArguments.map(_ + " _")	Seq[String]	withUnderscore
maybeResolved.exists(resolved => ref.parents.takeWhile(propagatesControlFlowToChildren).contains(resolved.getParent) && ref.getTextOffset < resolved.getTextOffset )	Boolean	isSuspicious
reference match { case _: ScStableCodeReference => Some(createReferenceFromText(replacementText)) case ref: ScReferenceExpression => Some(createExpressionWithContextFromText(replacementText, ref.getContext, ref)) case _ => None }	Option[ScalaPsiElement]	maybeReplacement
if (paramTypes.isEmpty) Seq.empty else ScalaPsiUtil.getElementsRange(paramTypes.head, paramTypes.last)	Seq[PsiElement]	elemsInParamTypes
returnType match { case _: ScFunctionalTypeElement => true case _: ScInfixTypeElement => true case _ => false }	Boolean	returnTypeNeedParens
segments.dropRight(1).mkString(".")	String	fqn
createExpressionFromText(replacement)	ScExpression	newExpr
body.toList.flatMap { case block: ScBlock => for { element <- block.children.toList elementType = element.getNode.getElementType if elementType != ScalaTokenTypes.tLBRACE && elementType != ScalaTokenTypes.tRBRACE } yield element case expression => expression :: Nil }	IndexedSeq[PsiElement]	elements
mutable.StringBuilder.newBuilder	mutable.StringBuilder	builder
typeElement.getContext match { case _: ScFunctionalTypeElement => true case _: ScInfixTypeElement => true case _: ScConstructorInvocation | _: ScTemplateParents => true case _ => false }	Boolean	needParens
new RenameData()	TypeCheckCanBeMatchInspection.RenameData	renameData
mutable.ArrayBuffer.empty[ScGenericCall]	ArrayBuffer[ScGenericCall]	result
FileHeaderChecker.checkFileHeader(file, manager, isOnTheFly)	ProblemDescriptor	descriptor
call.referencedExpr match { case ref: ScReferenceExpression if ref.refName == "asInstanceOf" => Option(ref.resolve()) case _ => None }	Option[PsiElement]	asInstanceOfCall
new ScalaRecursiveElementVisitor { override def visitGenericCallExpression(call: ScGenericCall): Unit = { val asInstanceOfCall = call.referencedExpr match { case ref: ScReferenceExpression if ref.refName == "asInstanceOf" => Option(ref.resolve()) case _ => None } if (asInstanceOfCall.exists(_.isInstanceOf[SyntheticNamedElement])) { for { (base1, type1) <- baseAndType(isInstOfCall) (base2, type2) <- baseAndType(call) if type1.equiv(type2) && equiv(base1, base2) } result += call } super.visitGenericCallExpression(call) } }	ScalaRecursiveElementVisitor { def visitGenericCallExpression(call: ScGenericCall): Unit }	visitor
maybeQuickFix match { case Some(quickFix) => Array(quickFix) case _ => LocalQuickFix.EMPTY_ARRAY }	Array[LocalQuickFix]	fixes
0	Int	currentId
matchStmt.clauses.toList	List[ScCaseClause]	caseClauses
List[Int](0)	List[Int]	idStack
0	Int	testCount
mutable.ListBuffer()	ListBuffer[ProcessListener]	myListeners
idStack.head	Int	suiteId
false	Boolean	isTerminated
mutable.ArrayBuffer.empty[ScNamedElement]	ArrayBuffer[ScNamedElement]	primary
ScalaShortNamesCacheManager.getInstance(project)	ScalaShortNamesCacheManager	namesManager
new UTestConfigurationType	UTestConfigurationType	confType
element match { case value: ScVariableDefinition if value.isSimple => val e = value.declaredElements.head for (t <- e.`type`().toOption if !t.isUnit && !t.isNothing && !t.isAny && !t.isAnyRef && !t.isAnyVal; expr <- value.expr) yield (e.name, t.presentableText, expr) /*.foreach(t => println(e.name + ": " + t.presentableText + " = " + ) )*/ case value: ScPatternDefinition if value.isSimple => val e = value.declaredElements.head for (t <- e.`type`().toOption if !t.isUnit && !t.isNothing && !t.isAny && !t.isAnyRef && !t.isAnyVal; expr <- value.expr) yield (e.name, t.presentableText, expr) case _ => None }	Option[(String, String, ScExpression)]	result
new UTestRunConfigurationFactory(this)	UTestRunConfigurationFactory	confFactory
{ val needParens = typeElement.getContext match { case _: ScFunctionalTypeElement => true case _: ScInfixTypeElement => true case _: ScConstructorInvocation | _: ScTemplateParents => true case _ => false } val arrow = ScalaPsiUtil.functionArrow(project) s"(${elemsInParamTypes.map(_.getText).mkString}) $arrow $returnTypeTextWithParens".parenthesize(needParens) }	String	typeTextWithParens
confType.confFactory	UTestRunConfigurationFactory	confFactory
ElementScope(definition.getProject)	ElementScope	elementScope
removeWS(expr.getText) + "\t" + removeWS(t) + "\t" + name	String	text
null: String	String	oldText
text	String	newText
clazz.getModifierList	PsiModifierList	list
getSuitePaths.iterator.flatMap(elementScope.getCachedClass).headOption	Option[PsiClass]	cachedClass
output.indexOf(sbtInfo)	Int	infoIdx
mutable.HashSet.empty[String]	mutable.HashSet[String]	found
"org.specs2.Specification"	String	acceptanseSpecBase
mutable.SortedSet.empty[ScalaPsiElement](Ordering.by(_.getTextOffset))	mutable.SortedSet[ScalaPsiElement]	dependents
"org.specs2.mutable.Specification"	String	unitSpecBase
List("org.specs2.specification.SpecificationStructure", "org.specs2.specification.core.SpecificationStructure")	List[String]	suitePaths
new ScalaRecursiveElementVisitor() { override def visitPattern(pat: ScPattern) { pat match { case bp: ScBindingPattern if bp.name == name => primary += bp case _ => } super.visitPattern(pat) } }	ScalaRecursiveElementVisitor { def visitPattern(pat: ScPattern): Unit }	patternVisitor
new ScalaRecursiveElementVisitor() { override def visitReferenceExpression(ref: ScReferenceExpression) { for (prim <- primary) { if (ref.refName == name && ref.resolve() == prim) dependents += ref } super.visitReferenceExpression(ref) } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	referenceVisitor
testClass.qualifiedName	String	testClassPath
new Specs2RunConfigurationFactory(this)	Specs2RunConfigurationFactory	confFactory
new Specs2ConfigurationType	Specs2ConfigurationType	confType
confType.confFactory	Specs2RunConfigurationFactory	confFactory
Array[LocalQuickFix]( new RenameClassQuickFix(clazz, virtualFileName), new RenameFileQuickFix(scalaFile, clazz.name + "." + ScalaFileType.INSTANCE.getDefaultExtension) )	Array[LocalQuickFix]	localQuickFixes
patternDef.pList.patterns	Seq[ScPattern]	patterns
s"${testClass.qualifiedName}::$testName"	String	testNamePrefixed
List(testStartRegex, testSuccessfulRegex, testFailedRegex, suiteStartRegex, suiteFinishedRegex, scopeOpenedRegex, scopeClosedRegex, testPendingRegex, testIgnoredRegex)	List[Any]	regexes
ConsoleViewContentType.NORMAL_OUTPUT	ConsoleViewContentType	consoleViewContentType
PsiTreeUtil.getParentOfType(element, classOf[ScTypeDefinition], false)	ScTypeDefinition	parent
ProcessOutputTypes.STDOUT	Key[_]	processOutputType
regexpData.zippedRegexps.head	(String, String)	pattern
getModel.getProperties	TestConsoleProperties	properties
definitions.map { clazz => val localQuickFixes = Array[LocalQuickFix]( new RenameClassQuickFix(clazz, virtualFileName), new RenameFileQuickFix(scalaFile, clazz.name + "." + ScalaFileType.INSTANCE.getDefaultExtension) ) manager.createProblemDescriptor(clazz.nameId, getDisplayName, isOnTheFly, localQuickFixes, ProblemHighlightType.GENERIC_ERROR_OR_WARNING ) }	IndexedSeq[ProblemDescriptor]	descriptors
scalaFile.typeDefinitions match { case Seq(_, _, _, _*) => None case Seq(first, second) if first.name != second.name => None // with companion case definitions if hasProblems(definitions, scalaFile.name, virtualFileName) => val descriptors = definitions.map { clazz => val localQuickFixes = Array[LocalQuickFix]( new RenameClassQuickFix(clazz, virtualFileName), new RenameFileQuickFix(scalaFile, clazz.name + "." + ScalaFileType.INSTANCE.getDefaultExtension) ) manager.createProblemDescriptor(clazz.nameId, getDisplayName, isOnTheFly, localQuickFixes, ProblemHighlightType.GENERIC_ERROR_OR_WARNING ) } Some(descriptors) case _ => None }	Option[IndexedSeq[ProblemDescriptor]]	maybeDescriptors
tuple.exprs.zipWithIndex.find { case (expr, _) => expr == testSuite }.map(_._2).get	Int	index
properties.getConfiguration.asInstanceOf[AbstractTestRunConfiguration]	AbstractTestRunConfiguration	configuration
(null, null)	(Null, Null)	fail
PsiTreeUtil.getParentOfType(element, classOf[ScTypeDefinition], false)	ScTypeDefinition	containingObject
""	String	testClassPath
getClassPathClazz	PsiClass	testClass
properties.asInstanceOf[PropertiesExtension].getRunConfigurationBase	RunConfigurationBase[_]	extensionConfiguration
suitePaths.flatMap { parent.elementScope.getCachedClass(_) }	IndexedSeq[PsiClass]	suiteClasses
suiteClasses.head	PsiClass	suiteClazz
PsiTreeUtil.getParentOfType(element, classOf[ScTypeDefinition], false)	ScTypeDefinition	testClassDef
Array.empty	Array[String]	classRegexps
Array.empty	Array[String]	testRegexps
suitePaths.flatMap { element.elementScope.getCachedClass(_) }	IndexedSeq[PsiClass]	suiteClasses
super.getTestMap	Map[String, Set[String]]	clazzMap
zippedRegexps	Array[(String, String)]	patterns
configuration.getState(executor, env)	RunProfileState	state
state.asInstanceOf[TestCommandLinePatcher]	AbstractTestRunConfiguration.TestCommandLinePatcher	patcher
ScalaPsiUtil.getParentWithProperty(element, strict = false, e => TestNodeProvider.isUTestInfixExpr(e) || TestNodeProvider.isUTestSuiteApplyCall(e) || TestNodeProvider.isUTestApplyCall(e) || TestNodeProvider.isUTestTestsCall(e))	Option[PsiElement]	nameContainer
config.getSuiteClass.toTry.get	PsiClass	suiteClass
""	String	testPackagePath
getClassPathClazz	PsiClass	clazz
new SingleTestData(config)	SingleTestData	res
new ClassTestData(config)	ClassTestData	res
ScalaPsiUtil.getParentWithProperty(element, strict = false, e => TestNodeProvider.isSpecs2TestExpr(e)) match { case Some(infixExpr: ScInfixExpr) => extractStaticTestName(infixExpr).orNull case _ => null }	String	testName
Set( "org.scalatest.FlatSpecLike.ItWord", "org.scalatest.FlatSpecLike.ItVerbStringTaggedAs", "org.scalatest.FlatSpecLike.ItVerbString", "org.scalatest.fixture.FlatSpecLike.ItWord", "org.scalatest.fixture.FlatSpecLike.ItVerbStringTaggedAs", "org.scalatest.fixture.FlatSpecLike.ItVerbString" )	Set[String]	flatSpecItWordFqns
Set( "org.scalatest.AsyncFlatSpecLike.ItWord", "org.scalatest.AsyncFlatSpecLike.ItVerbStringTaggedAs", "org.scalatest.AsyncFlatSpecLike.ItVerbString", "org.scalatest.fixture.AsyncFlatSpecLike.ItWord", "org.scalatest.fixture.AsyncFlatSpecLike.ItVerbStringTaggedAs", "org.scalatest.fixture.AsyncFlatSpecLike.ItVerbString", )	Set[String]	asyncFlatSpecItWordFqns
flatSpecItWordFqns ++ asyncFlatSpecItWordFqns ++ Set( "org.scalatest.FunSpecLike.ItWord", "org.scalatest.fixture.FunSpecLike.ItWord", "org.scalatest.path.FunSpecLike.ItWord", "org.scalatest.WordSpecLike.ItWord", "org.scalatest.fixture.WordSpecLike.ItWord", )	Set[String]	itWordFqns
Set( "org.scalatest.FlatSpecLike.TheyWord", "org.scalatest.FlatSpecLike.TheyVerbStringTaggedAs", "org.scalatest.FlatSpecLike.TheyVerbString", "org.scalatest.fixture.FlatSpecLike.TheyWord", "org.scalatest.fixture.FlatSpecLike.TheyVerbStringTaggedAs", "org.scalatest.fixture.FlatSpecLike.TheyVerbString" )	Set[String]	flatSpecTheyWordFqns
Set( "org.scalatest.AsyncFlatSpecLike.TheyWord", "org.scalatest.AsyncFlatSpecLike.TheyVerbStringTaggedAs", "org.scalatest.AsyncFlatSpecLike.TheyVerbString", "org.scalatest.fixture.AsyncFlatSpecLike.TheyWord", "org.scalatest.fixture.AsyncFlatSpecLike.TheyVerbStringTaggedAs", "org.scalatest.fixture.AsyncFlatSpecLike.TheyVerbString", )	Set[String]	asyncFlatSpecTheyWordFqns
flatSpecTheyWordFqns ++ asyncFlatSpecTheyWordFqns ++ Set( "org.scalatest.FunSpecLike.TheyWord", "org.scalatest.fixture.FunSpecLike.TheyWord", "org.scalatest.path.FunSpecLike.TheyWord", "org.scalatest.WordSpecLike.TheyWord", "org.scalatest.fixture.WordSpecLike.TheyWord", )	Set[String]	theyWordFqns
List( "org.scalatest.FunSuite", "org.scalatest.FunSuiteLike", "org.scalatest.fixture.FunSuite", "org.scalatest.fixture.FunSuiteLike", "org.scalatest.fixture.FixtureFunSuite", "org.scalatest.fixture.MultipleFixtureFunSuite" )	List[String]	funSuiteBases
List( "org.scalatest.FeatureSpec", "org.scalatest.FeatureSpecLike", "org.scalatest.fixture.FeatureSpec", "org.scalatest.fixture.FeatureSpecLike", "org.scalatest.fixture.FixtureFeatureSpec", "org.scalatest.fixture.MultipleFixtureFeatureSpec" )	List[String]	featureSpecBases
if (getModule != null) mScope(getModule, withDependencies) else GlobalSearchScope.EMPTY_SCOPE	GlobalSearchScope	scope
List( "org.scalatest.FreeSpec", "org.scalatest.FreeSpecLike", "org.scalatest.fixture.FreeSpec", "org.scalatest.fixture.FreeSpecLike", "org.scalatest.fixture.FixtureFreeSpec", "org.scalatest.fixture.MultipleFixtureFreeSpec", "org.scalatest.path.FreeSpec", "org.scalatest.path.FreeSpecLike" )	List[String]	freeSpecBases
List( "org.scalatest.junit.JUnit3Suite" )	List[String]	JUnit3SuiteBases
SearchForTest.ACCROSS_MODULE_DEPENDENCIES	TestRunConfigurationForm.SearchForTest	searchTest
List( "org.scalatest.junit.JUnitSuite", "org.scalatest.junit.JUnitSuiteLike" )	List[String]	JUnitSuiteBases
true	Boolean	showProgressMessages
nameContainer.flatMap { case infixExpr: ScInfixExpr => //test location is a scope defined through infix '-' buildPathFromTestExpr(infixExpr) case methodCall: ScMethodCall if TestNodeProvider.isUTestApplyCall(methodCall) => //test location is a scope define without use of '-' method buildPathFromTestExpr(methodCall) case methodCall: ScMethodCall => //test location is a test method definition getTestSuiteName(methodCall) case _ => None }.getOrElse( //it is also possible that element is on left-hand of test suite definition TestNodeProvider.getUTestLeftHandTestDefinition(element).flatMap(getTestSuiteName).orNull )	String	testName
false	Boolean	useSbt
List( "org.scalatest.PropSpec", "org.scalatest.PropSpecLike", "org.scalatest.fixture.PropSpec", "org.scalatest.fixture.PropSpecLike", "org.scalatest.fixture.FixturePropSpec", "org.scalatest.fixture.MultipleFixturePropSpec" )	List[String]	propSpecBases
CommonDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext())	Project	project
false	Boolean	useUiWithSbt
List( "org.scalatest.Spec", "org.scalatest.SpecLike", "org.scalatest.fixture.Spec", "org.scalatest.fixture.SpecLike", "org.scalatest.fixture.FixtureSpec", "org.scalatest.fixture.MultipleFixtureSpec" )	List[String]	funSpecBasesPre2_0
_	String	jrePath
""	String	testArgs
""	String	javaOptions
List( "org.scalatest.FunSpec", "org.scalatest.FunSpecLike", "org.scalatest.fixture.FunSpec", "org.scalatest.fixture.FunSpecLike", "org.scalatest.path.FunSpec", "org.scalatest.path.FunSpecLike" )	List[String]	funSpecBasesPost2_0
""	String	workingDirectory
List( "org.scalatest.testng.TestNGSuite", "org.scalatest.testng.TestNGSuiteLike" )	List[String]	testNGSuiteBases
List( "org.scalatest.FlatSpec", "org.scalatest.FlatSpecLike", "org.scalatest.fixture.FlatSpec", "org.scalatest.fixture.FlatSpecLike", "org.scalatest.fixture.FixtureFlatSpec", "org.scalatest.fixture.MultipleFixtureFlatSpec" )	List[String]	flatSpecBases
List( "org.scalatest.WordSpec", "org.scalatest.WordSpecLike", "org.scalatest.fixture.WordSpec", "org.scalatest.fixture.WordSpecLike", "org.scalatest.fixture.FixtureWordSpec", "org.scalatest.fixture.MultipleFixtureWordSpec" )	List[String]	wordSpecBases
List("org.scalatest.Suite")	List[String]	suitePaths
moduleWorkingDirectory(getModule)	String	workingDir
JavaPsiFacade.getInstance(getProject).findPackage(getTestPackagePath)	PsiPackage	pack
ArrayBuffer[PsiClass]()	ArrayBuffer[PsiClass]	classes
ScPackageImpl(getPackage(getTestPackagePath))	ScPackageImpl	pack
getScope(withDependencies = false)	GlobalSearchScope	scope
new ArrayBuffer[PsiClass]	ArrayBuffer[PsiClass]	buffer
new ArrayBuffer[(String, String)]	ArrayBuffer[(String, String)]	buffer
clazz.projectContext	ProjectContext	project
s.lastIndexOf(".")	Int	i
Logger.getInstance(ScalaTestAstTransformer.getClass)	Logger	LOG
new ScalaTestRunConfigurationFactory(this)	ScalaTestRunConfigurationFactory	confFactory
classes.map(_.qualifiedName)	IndexedSeq[String]	classFqns
new AllInPackageTestData(config)	AllInPackageTestData	res
TestWorkingDirectoryProvider.EP_NAME.getExtensions.find(_.getWorkingDirectory(module) != null)	Option[TestWorkingDirectoryProvider]	provider
new ScalaTestConfigurationType	ScalaTestConfigurationType	confType
confType.confFactory	ScalaTestRunConfigurationFactory	confFactory
create(configuration.testKind, configuration)	TestConfigurationData	testData
getTestNames(List(aSuite))	Set[String]	tests
create(form.getSelectedKind, configuration)	TestConfigurationData	testData
mutable.Map[String, Set[String]]()	mutable.Map[String, Set[String]]	classToTests
clazz match { case PsiClassWrapper(definition) => definition case definition: ScTypeDefinition => definition case _ => return false }	ScTemplateDefinition	definition
classToTests.toMap.filter(_._2.nonEmpty)	Map[String, Set[String]]	res
new RegexpTestData(config)	RegexpTestData	res
patcher.getClasses.map(s => { val i = s.lastIndexOf(".") if (i < 0) s else s.substring(i + 1) } -> s).toMap	Map[Any, String]	classNames
elementScope.getCachedClass(path)	Option[PsiClass]	cachedClass
ScalaTestAstTransformer.getFinder(definition, module)	Option[Finder]	finder
false	Boolean	added
this.asInstanceOf[RunConfigurationBase[_]]	RunConfigurationBase[_]	runConfigHack
if (!configuration.isInstanceOf[ScalaTestRunConfiguration]) false else TestConfigurationUtil.isPackageConfiguration(element, configuration)	Boolean	result
definition.extendsBlock.templateBody match { case Some(value) => value case None => return None }	ScTemplateBody	body
clazz match { case c: ScClass => c.secondaryConstructors.filter(_.isConstructor).toList ::: c.constructor.toList case _ => clazz.getConstructors.toList }	List[PsiMethod]	constructors
element match { case file: ScalaFile => file.typeDefinitions.filter(matchesSomeTestSuite) match { case Seq(testClass) => testClass // run multiple test classes in a file is not supported yet, see SCL-15567 case _ => null } case _ => PsiTreeUtil.getParentOfType(element, classOf[ScTypeDefinition], false) }	ScTypeDefinition	clazz
test.getMagnitudeInfo	TestStateInfo.Magnitude	info
clazz.extendsBlock.templateBody.orNull	ScTemplateBody	templateBody
new Specs2ConfigurationProducer	Specs2ConfigurationProducer	specs2ConfigurationProducer
ScalaTestAstTransformer.testSelection(location)	Selection	selection
new UTestConfigurationProducer	UTestConfigurationProducer	uTestConfigurationProducer
new ScalaTestConfigurationProducer	ScalaTestConfigurationProducer	scalaTestConfigurationProducer
element match { case dir: PsiDirectory => JavaDirectoryService.getInstance.getPackage(dir) case pack: PsiPackage => pack }	PsiPackage	pack
for { finder <- getFinder(clazz, location.getModule) selected <- getSelectedAstNode(clazz.qualifiedName, element) } yield { finder.find(selected) }	Option[Selection]	found
con.parameters	Seq[PsiParameter]	params
params.head	PsiParameter	firstParam
methodCall.argumentExpressions.collect { case block: ScBlockExpr => block.exprs }	IndexedSeq[Seq[ScExpression]]	childExpressions
td.element	ScTypeDefinition	clazz
body.exprs	Seq[ScExpression]	constructorExpressions
pDef.getLastChild.asInstanceOf[ScMethodCall]	ScMethodCall	methodCall
psiManager.getCachedClass(ProjectScope.getAllScope(project), "scala.collection.immutable.Map").orNull	PsiClass	mapPsiClass
Set()	Set[String]	EmptySet
Set("test")	Set[Nothing]	FunSuiteLeaves
Set("in", "of")	Set[Nothing]	FlatSpecLeaves
Seq(List("java.lang.String", "scala.collection.Seq<org.scalatest.Tag>"), List("void"))	Seq[List[Nothing]]	scMethodCallDefaultArg
Set("property")	Set[Nothing]	PropSpecLeaves
Set("describe")	Set[Nothing]	FunSpecNodes
ScalaType.designator(mapPsiClass)	ScType	mapClass
Set("it", "they")	Set[Nothing]	FunSpecLeaves
Seq(List("java.lang.String", "scala.collection.Seq<org.scalatest.Tag>"), List("java.lang.Object"))	Seq[List[Nothing]]	scMethodCallDefaultArgScalaTest3_v1
Set("when", "should", "must", "can", "which")	Set[Nothing]	WordSpecNodes
Set("in")	Set[Nothing]	WordSpecLeaves
Set("-")	Set[Nothing]	FreeSpecNodes
Seq(List("java.lang.String", "scala.collection.immutable.Seq<org.scalatest.Tag>"), List("java.lang.Object"))	Seq[List[Nothing]]	scMethodCallDefaultArgScalaTest3_v2
Set("in")	Set[Nothing]	FreeSpecLeaves
selection.testNames.toSeq.map(_.trim)	IndexedSeq[Any]	testNames
Set("feature")	Set[Nothing]	FeatureSpecNodes
testNames.mkString("\n")	String	testNamesConcat
Set("scenario")	Set[Nothing]	FeatureSpecLeaves
firstParam.getType.toScType()	ScType	paramClass
ScalaPsiManager.instance(clazz.getProject).getCachedClass(clazz.resolveScope, fqn)	Option[PsiClass]	suiteClazz
new PsiLocation(location.getProject, parent)	PsiLocation[PsiElement]	newLocation
paramClass match { case parameterizedType: ScParameterizedType => parameterizedType.designator case _ => paramClass }	ScType	conformanceType
ref.refName	String	middleName
Seq(ToLowerCase, Trim, ToString, StripMargin, Intern, Capitalize)	Seq[Nothing]	NoArgMethods
scalaSdk.compilerVersion	Option[String]	compilerVersion
Seq(StripSuffix, StripPrefix, Substring, StripMargin)	Seq[Nothing]	OneArgMethods
TestKind.CLASS	TestRunConfigurationForm.TestKind	testKind
new ClassTestData(this)	TestConfigurationData	testConfigurationData
Seq(Replace, Substring)	Seq[Nothing]	TwoArgMethods
getLibraryDependencies(compilerVersion)	Seq[String]	dependencies
refExpr.refName	String	methodName
getLibraryResolvers(compilerVersion)	Seq[String]	resolvers
expr.getEffectiveInvokedExpr.findFirstChildByType(ScalaElementType.REFERENCE_EXPRESSION)	PsiElement	methodExpr
getAdditionalBuildCommands(compilerVersion)	Seq[String]	buildCommands
namesSet(ref.refName)	Set[String]	fqns
new SimpleBuildFileModifier(libraries, resolvers, options)	SimpleBuildFileModifier	modifier
MixinNodes.linearization(clazz).flatMap(_.extractClass.toSeq)	IndexedSeq[PsiClass]	classes
expr.getEffectiveInvokedExpr match { case refExpr: ScReferenceExpression => refExpr case otherExpr => otherExpr.findFirstChildByType(ScalaElementType.REFERENCE_EXPRESSION) }	PsiElement	methodExpr
false	Boolean	addIntegrationTestsClasspath
getFinderClassFqn(td, module, "org.scalatest.Style", "org.scalatest.Finders")	String	finderFqn
""	String	generatedName
Class.forName(finderFqn)	Class[_]	finderClass
resolveResult.innerResolveResult match { case Some(innerResult) => innerResult.getActualElement case None => resolveResult.getElement }	PsiNamedElement	funElement
resolve match { case fun: ScMember => fun.containingClass case p: ScBindingPattern => p.nameContext match { case v: ScMember => v.containingClass case _ => null } case _ => null }	ScTemplateDefinition	containingClass
false	Boolean	failedToCheck
assignStmt.rightExpression.get	ScExpression	expr
new TestRunConfigurationForm(project, configuration)	TestRunConfigurationForm	form
methodCall.args	ScArgumentExprList	constructorArgs
configurationNameForPackage(packageName)	String	displayName
new ArrayBuffer[OrderEntry]	ArrayBuffer[OrderEntry]	orderEntries
methodCall.argumentExpressions.size	Int	argsCount
refExpr.refName	String	name
clauses.filterNot(_.parameters.forall(_.isImplicitParameter))	Seq[ScParameterClause]	filteredClauses
expr.getEffectiveInvokedExpr	ScExpression	methodExpr
TestFrameworks.detectFramework(clazz)	TestFramework	framework
if (!failedToCheck) { inv(call) match { case Some(invRes) => SuccessResult(call, invRes, middleName) case None => WrongResult } } else { WrongResult }	ReturnResult with Product with Serializable	result
call => { call.argumentExpressions .headOption .flatMap(endUpWithLiteral) }	MethodInvocation => Option[String]	inv
{ case i: ScInfixExpr => endUpWithLiteral(i.getBaseExpr) case call: MethodInvocation => call.getInvokedExpr match { case ref: ScReferenceExpression => ref.qualifier match { case Some(qual) => endUpWithLiteral(qual) case _ => None } case _ => None } }	MethodInvocation => Option[String]	inv
m => { def checkTagged(m: MethodInvocation): Option[String] = { m.getInvokedExpr match { case ref: ScReferenceExpression if ref.refName == "taggedAs" => val resolve = ref.resolve() resolve match { case fun: ScFunction => val clazz = fun.containingClass if (clazz != null && fqn.contains(clazz.qualifiedName)) { m match { case i: ScInfixExpr => endUpWithLiteral(i.getBaseExpr) case _ => m.getInvokedExpr match { case ref: ScReferenceExpression => ref.qualifier match { case Some(qual) => endUpWithLiteral(qual) case None => None } } } } else None case _ => None } case _ => None } } m match { case i: ScInfixExpr => i.getBaseExpr match { case m: MethodInvocation => checkTagged(m) case base => endUpWithLiteral(base) } case call: MethodInvocation => call.getInvokedExpr match { case ref: ScReferenceExpression => ref.qualifier match { case Some(qual: MethodInvocation) => checkTagged(qual) case Some(qual) => endUpWithLiteral(qual) case _ => None } case _ => None } } }	MethodInvocation => Option[String]	inv
for { entry <- orderEntries rawUrl <- entry.getFiles(OrderRootType.CLASSES).map(_.getPresentableUrl) } yield { val cpFile = new File(rawUrl) if (cpFile.exists && cpFile.isDirectory && !rawUrl.endsWith(File.separator)) { new URL(s"file:/$rawUrl/") } else { new URL(s"file:/$rawUrl") } }	IndexedSeq[Any]	loaderUrls
if (testNameIsAlwaysEmpty) _ => Some("") else inv	MethodInvocation => Option[String]	invActual
checkCall( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map("test" -> fqn, "ignore" -> fqn) )	ReturnResult	result
null	String	finderClassName
null	Array[Any]	annotations
suiteTypeDef.annotations(annotationFqn).headOption	Option[ScAnnotation]	annotationOption
annotationOption.get	ScAnnotation	styleAnnotation
generateTestInternal(project, d)	PsiFile	file
ScalaShortNamesCacheManager.getInstance(project).getClassesByFQName(className, scope)	Seq[PsiClass]	classes
checkCall( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map("property" -> fqn, "ignore" -> fqn) )	ReturnResult	result
new CreateTestAction { override protected def createTestDialog(project: Project, srcModule: Module, srcClass: PsiClass, srcPackage: PsiPackage) = new CreateTestDialog(project, getText, srcClass, srcPackage, srcModule) { override def suggestTestClassName(targetClass: PsiClass): String = targetClass match { case obj: ScObject => obj.getName.stripSuffix("$") + "Test" case _ => super.suggestTestClassName(targetClass) } } }	CreateTestAction { def createTestDialog(project: Project, srcModule: Module, srcClass: PsiClass, srcPackage: PsiPackage): CreateTestDialog { def suggestTestClassName(targetClass: PsiClass): String } }	action
checkCall( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map("scenario" -> fqn, "ignore" -> fqn) )	ReturnResult	result
d.getSelectedTestFrameworkDescriptor match { case f: AbstractTestFramework => f.getTestFileTemplateName case _ => ScalaFileTemplateUtil.SCALA_CLASS }	String	templateName
TestFrameworks.getInstance	TestFrameworks	frameworks
findElement(file, editor.getCaretModel.getOffset)	PsiElement	element
PsiShortNamesCache.getInstance(obj.getProject)	PsiShortNamesCache	cache
getSearchScope(obj, false)	GlobalSearchScope	scope
cache.getAllClassNames.distinct	Array[Nothing]	names
findSourceElement(element)	PsiClass	klass
getSearchScope(element, true)	GlobalSearchScope	scope
checkCall( PsiTreeUtil.getParentOfType(call, classOf[MethodInvocation], true), Map("feature" -> fqn) )	ReturnResult	innerResult
PsiShortNamesCache.getInstance(element.getProject)	PsiShortNamesCache	cache
styleAnnotation.annotationExpr	ScAnnotationExpr	annotationExpr
framework match { case _: ScalaTestTestFramework => Some(s"scalatest://TopOfClass:${clazz.qualifiedName}TestName:${clazz.name}") //FIXME: why the hell uTest url is reported with scalatest prefix? (see UTestReporter) case _: UTestTestFramework => Some(s"scalatest://TopOfClass:${clazz.qualifiedName}TestName:${clazz.qualifiedName}") // TODO: check maybe it should be clazz.name case _: Specs2TestFramework => Some(s"") // TODO: spec2 runner does not report location for class currently case _ => Some(s"java:suite://${clazz.qualifiedName}") }	Some[String]	url
ExtensionPointName.create("org.intellij.scala.testWorkingDirectoryProvider")	ExtensionPointName[TestWorkingDirectoryProvider]	EP_NAME
PsiTreeUtil.getParentOfType(method, classOf[PsiClass])	PsiClass	clazz
annotationExpr.getAttributes	Seq[ScNameValuePair]	valuePairs
checkCall( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map("it" -> fqn, "ignore" -> fqn) )	ReturnResult	result
_testName	String	testName
_call	MethodInvocation	call
framework match { case _: AbstractTestFramework => None case _ => Some(s"java:test://${clazz.qualifiedName}.${method.getName}") }	Option[String]	url
checkCall( PsiTreeUtil.getParentOfType(call, classOf[MethodInvocation], true), Map("describe" -> fqn) )	ReturnResult	innerResult
ScalaPsiManager.instance(project).getCachedClasses(getScope(withDependencies), path)	Array[PsiClass]	classes
configurationName(testClass, testName)	String	displayName
fqn + innerClassName	Set[String]	ifqn
CachesUtil.fileModCount(definition.getContainingFile)	Long	modCountCurrent
calculationState match { case null => calculateTestLocationsInBackgroundAndRestart(definition, None) None case Calculating(prevResult) => prevResult case Calculated(result, modCountCached, timestamp) => val modCountCurrent = CachesUtil.fileModCount(definition.getContainingFile) if (modCountCached != modCountCurrent) { //println(s"### recalculating test locations ($modCountCached -> $modCountCurrent) !") calculateTestLocationsInBackgroundAndRestart(definition, result, timestamp) } result }	Option[ScalaTestTestLocationsFinder.TestLocations]	testLocations
getText	String	name
configuration.testConfigurationData	TestConfigurationData	testDataOld
classes.filter(_.isInstanceOf[ScObject])	Array[PsiClass]	objectClasses
CachesUtil.fileModCount(definition.getContainingFile)	Long	modCount
signature.substitutor	ScSubstitutor	substitutor
for { module <- definition.module locations <- ScalaTestTestLocationsFinder.calculateTestLocations(definition, module) } yield locations	Option[Seq[PsiElement]]	testLocations
definition.getContainingFile	PsiFile	file
definition.getProject	Project	project
AllInPackageTestData(configuration, sanitize(testPackage.getQualifiedName))	AllInPackageTestData	testDataNew
checkInfix( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map("in" -> ifqn, "is" -> ifqn, "ignore" -> ifqn) )	ReturnResult	result
Option(method.getReturnType).getOrElse(PsiType.VOID)	PsiType	psiType
processChildren(getInnerInfixExprs(expr), extractFreeSpec, project)	Array[TreeElement]	children
classes.find(c => Option(c.getContainingFile).exists(_.name == fileName))	Option[PsiClass]	found
scalaTestLineUrl(element, definition, testName)	String	url
ClassTestData(configuration, sanitize(testClass.qualifiedName), testName)	ClassTestData	testDataNew
ScalaShortNamesCacheManager.getInstance(project).getClassesByFQName(classFqn, scope)	Seq[PsiClass]	classes
element.getFirstChild	PsiElement	firstChild
classes.filter(!_.isInstanceOf[ScObject])	Array[PsiClass]	nonObjectClasses
getModule match { case null => GlobalSearchScope.EMPTY_SCOPE case module => mScope(module, withDependencies) }	GlobalSearchScope	scope
classes.find(!_.isInstanceOf[ScObject]).orElse(classes.headOption)	Option[PsiClass]	clazz
FileTemplateManager.getInstance(project).getCodeTemplate(templateName)	FileTemplate	fileTemplate
GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module, true)	GlobalSearchScope	scope
ModuleManager.getInstance(getProject).getModules	Array[Module]	projectModules
_path	String	path
ScalaShortNamesCacheManager.getInstance(project). getClassesByFQName(classFqn, GlobalSearchScope.allScope(project))	Seq[PsiClass]	classes
current.argumentExpressions ++ previousArgs	IndexedSeq[ScExpression]	arguments
fqn + ".WordSpecStringWrapper"	Set[String]	wfqn
ScalaPsiManager.instance(module.getProject)	ScalaPsiManager	psiManager
configuration.clone.asInstanceOf[T]	T	configWithModule
classes.find(!_.isInstanceOf[ScObject]).orElse(classes.headOption)	Option[PsiClass]	methodOwner
confSettings.getConfiguration.asInstanceOf[T]	T	cfg
methodOwner.get.findMethodsByName(methodName, false)	Array[PsiMethod]	methods
Option(named.nameContext)	Option[PsiElement]	maybeContext
parameter.projectContext	ProjectContext	projectContext
isRunPossibleFor(configWithModule, testElement)	Boolean	runIsPossible
processChildren(getInnerInfixExprs(expr), extractWordSpec, project)	Array[TreeElement]	children
d.getTargetClass	PsiClass	targetClass
ref.resolve() match { case member: ScMember => Some(member) case pattern: ScBindingPattern => pattern.nameContext match { case member: ScMember => Some(member) case _ => None } case _ => None }	Option[ScMember]	member
testData.getClassPathClazz	PsiClass	testClass
createTestFileFromTemplate(d, project)	PsiFile	file
ScalaPsiManager.instance(project).getCachedClass(GlobalSearchScope.allScope(project), classFqn)	Option[PsiClass]	classes
checkInfixTagged( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map("in" -> ifqn, "is" -> ifqn, "ignore" -> ifqn), wfqn )	ReturnResult	result
getElement match { case fun: ScFunction => fun.returnType.getOrAny case method: PsiMethod => val psiType = Option(method.getReturnType).getOrElse(PsiType.VOID) psiType.toScType()(signature.projectContext) }	ScType	returnType
{ val returnType = getElement match { case fun: ScFunction => fun.returnType.getOrAny case method: PsiMethod => val psiType = Option(method.getReturnType).getOrElse(PsiType.VOID) psiType.toScType()(signature.projectContext) } substitutor(returnType) }	ScType	scType
SettingQueryHandler(setting, Some(showTaskName), projectUri, projectId, comm)	SettingQueryHandler	showHandler
element.getName	String	name
if (showTaskName == setTaskName) showHandler else SettingQueryHandler(setting, Some(setTaskName), projectUri, projectId, comm)	SettingQueryHandler	setHandler
substitutor(element.`type`().getOrAny)	ScType	scType
ExecutorAction.getActions(1)	Array[AnAction]	actions
member.flatMap(_.containingClass.toOption).map(_.qualifiedName).orNull	String	containingClassName
getTarget(containingClassName, current, selected)	AstNode	target
new ArrayBuffer[Module]()	ArrayBuffer[Module]	buffer
checkInfix( PsiTreeUtil.getParentOfType(call, classOf[MethodInvocation], true), Map("when" -> wfqn, "that" -> ifqn, "should" -> shouldFqn2, "must" -> mustFqn2, "can" -> canFqn2), checkFirstArgIsUnitOrString = true )	ReturnResult	checkInfixResult2
arguments.map { case literal: ScLiteral if literal.isString => new StStringLiteral(literal, containingClassName, literal.getValue.toString) case expr => new StToStringTarget(expr, containingClassName, expr.getText) }	IndexedSeq[AstNode]	argsAst
if (isImplement) getMembersToImplement(clazz, withSelfType = true) else getMembersToOverride(clazz)	Seq[overrideImplement.ClassMember]	classMembers
if (current.isApplyOrUpdateCall) "apply" else ref.refName	String	pName
if (current.isApplyOrUpdateCall) null else ref	PsiElement	nameSource
element.getParent	PsiElement	invocationParent
mutable.ListBuffer[ClassMember]()	ListBuffer[overrideImplement.ClassMember]	selectedMembers
element.name + ": " + scType.presentableText	String	text
file.depthFirst().instancesOf[ScTypeDefinition].next()	ScTypeDefinition	typeDefinition
suitePaths.map(getClazz(_, withDependencies = true)).filter(_ != null)	IndexedSeq[PsiClass]	suiteClasses
getElementNestedBlockChildren(element)	Seq[PsiElement]	nestedChildren
new ScalaMemberChooser[ClassMember](classMembers.toArray, false, true, isImplement, true, true, clazz)	ScalaMemberChooser[overrideImplement.ClassMember]	chooser
new SettingsEditorGroup	SettingsEditorGroup[AbstractTestRunConfiguration]	group
ElementScope(project).getCachedClass(fqName)	Option[PsiClass]	psiClass
PlatformDataKeys.FILE_EDITOR.getData(context.getDataContext)	FileEditor	fileEditor
checkInfix( PsiTreeUtil.getParentOfType(call, classOf[MethodInvocation], true), Map("when" -> wfqn, "that" -> ifqn, "should" -> shouldFqn, "must" -> mustFqn, "can" -> canFqn), checkFirstArgIsUnitOrString = true )	ReturnResult	checkInfixResult
methodDef.containingClass	ScTemplateDefinition	containingClass
containingClass.qualifiedName	String	className
getModule	Module	module
it	PsiElement	elem
typeDefinition.extendsBlock.templateBody.map(_.getFirstChild).getOrElse(typeDefinition)	PsiElement	positionElement
it.getParent	PsiElement	parent
editor.getEditor.getDocument	Document	document
CodeInsightUtil.positionCursor(project, file, positionElement)	Editor	editor
typeDefinition.extendsBlock	ScExtendsBlock	extendsBlock
PsiDocumentManager.getInstance(context.getProject).getPsiFile(document)	PsiFile	containingFile
owner.getClasses	Array[PsiClass]	psiClasses
elem.getPrevSiblingNotWhitespaceComment	PsiElement	sibling
new PsiClassListCellRenderer()	PsiClassListCellRenderer	renderer
name + ": " + scType.presentableText	String	text
null	Option[String]	result
getElement.getName	String	name
{ case i: ScInfixExpr => endUpWithLiteral(i.getBaseExpr) case call: MethodInvocation => call.getInvokedExpr match { case ref: ScReferenceExpression => ref.qualifier match { case Some(qual) => endUpWithLiteral(qual) case _ => None } case _ => None } }	MethodInvocation => Option[String]	infix
field.getProject	Project	project
new JBList(classesSorted:_*)	JBList[Nothing]	jbList
methodDef.parameters.flatMap(_.typeElement.map(_.getText)).toArray	Array[Nothing]	paramTypes
call.argumentExpressions.head	ScExpression	literal
call => { val literal = call.argumentExpressions.head endUpWithLiteral(literal) }	MethodInvocation => Option[String]	call
ScalaMemberChooser.sorted(selectedMembers, clazz)	Seq[overrideImplement.ClassMember]	sortedMembers
Option(TestStateStorage.getInstance(project).getState(url))	Option[TestStateStorage.Record]	testState
extendsBlock.addBefore(extendsToken, extendsBlock.getFirstChild)	PsiElement	extendsAdded
field.getType.toScType()	ScType	fieldType
extendsBlock.addAfter(classParents, extendsAdded)	PsiElement	res
testState.map(state => TestIconMapper.getMagnitude(state.magnitude))	Option[TestStateInfo.Magnitude]	testMagnitude
substitutor(fieldType)	ScType	scType
(_: PsiElement) => "Run Test"	Function[PsiElement, String]	TooltipProvider
Map( "should" -> (infix, Seq(shouldFqn, shouldFqn2)), "must" -> (infix, Seq(mustFqn, mustFqn2)), "can" -> (infix, Seq(canFqn, canFqn2)), "of" -> (call, Seq("org.scalatest.FlatSpec.BehaviorWord")) )	Map[Nothing, Nothing]	wordToFqns
new ScalaRecursiveElementVisitor { private val wordToFqns = Map( "should" -> (infix, Seq(shouldFqn, shouldFqn2)), "must" -> (infix, Seq(mustFqn, mustFqn2)), "can" -> (infix, Seq(canFqn, canFqn2)), "of" -> (call, Seq("org.scalatest.FlatSpec.BehaviorWord")) ) override def visitReferenceExpression(ref: ScReferenceExpression): Unit = wordToFqns.get(ref.refName) match { case Some((inv, fqns)) => ref.resolve() match { case fun: ScFunction if fun.containingClass != null && fqns.contains(fun.containingClass.qualifiedName) => if (result == null) { ref.getParent match { case m: MethodInvocation => result = inv(m) case _ => result = None } } case _ => } case _ => } }	ScalaRecursiveElementVisitor	visitor
new Key[TestLocationsCalculationState]("TestPositionsCalculationState")	Key[ScalaTestRunLineMarkerProvider.TestLocationsCalculationState]	TestPositionsCalculationStateKey
classes.find(c => c.containingFile.exists(_.name == fileName))	Option[PsiClass]	found
2000L	Long	TestPositionsCalculationDebounceMs
getFailedTests.groupBy(_._1).map { case (aClass, tests) => (aClass, tests.map(_._2).toSet) }.filter(_._2.nonEmpty)	IndexedSeq[(String, Set[String])]	failedTests
s"${field.getName}: ${scType.presentableText}"	String	text
PsiDocumentManager.getInstance(project).getDocument(psiFile)	Document	doc
doc.getLineCount	Int	lineCount
0	Int	lineStartOffset
0	Int	endOffset
{ case i: ScInfixExpr => i.getBaseExpr match { case ref: ScReferenceExpression if ref.refName == "it" || ref.refName == "ignore" || ref.refName == "they" => endUpWithIt(ref) case _ => endUpWithLiteral(i.getBaseExpr) } case call: MethodInvocation => call.getInvokedExpr match { case ref: ScReferenceExpression => ref.qualifier match { case Some(ref: ScReferenceExpression) if ref.refName == "it" || ref.refName == "ignore" || ref.refName == "they" => endUpWithIt(ref) case Some(qual) => endUpWithLiteral(qual) case _ => None } case _ => None } }	MethodInvocation => Option[String]	inv
testConfigurationData.getTestMap.keys.toSeq	Seq[String]	getClasses
lineStartOffset	Int	offset
addExtendsRef(cls.name)	PsiElement	classParents
null	PsiElement	elementAtLine
elementAtLine.getTextLength	Int	length
typeDef.extendsBlock.templateBody	Option[ScTemplateBody]	templateBody
FormatterUtil.getNormalIndentString(projectContext)	String	normalIndent
fqn + ".ItWord"	Set[String]	itFqn
sortedMembers.map(new ScalaGenerationInfo(_))	IndexedSeq[ScalaGenerationInfo]	genInfos
testConfigurationData.getJavaOptions	String	vmParams
typeDef.getContainingFile	PsiFile	file
fqn + ".ItVerbString"	Set[String]	itVFqn
testConfigurationData.getWorkingDirectory	String	wDir
templateBody.getLastChild	PsiElement	closingBrace
new NonFocusableCheckBox(ScalaBundle.message("add.override.modifier"))	NonFocusableCheckBox	addOverrideModifierChb
getAnchor(editor.getCaretModel.getOffset, clazz)	Option[ScMember]	anchor
new NonFocusableCheckBox(ScalaBundle.message("copy.scaladoc"))	NonFocusableCheckBox	copyScalaDocChb
classMember.getElement	PsiMember	myMember
new Consumer[PsiMethod] { def consume(t: PsiMethod) {} }	Consumer[PsiMethod]	emptyConsumer
Array[JComponent](copyScalaDocChb, addOverrideModifierChb, typePanel)	Array[Any]	otherComponents
configuration.runnerClassName	String	runnerClassName
configuration.getConfigurationModule.getModule	Module	configurationModule
methods.map("test" + _.getMember.getName.capitalize)	IndexedSeq[Any]	testNames
aClass match { case td: ScTemplateDefinition => td case _ => return }	ScTemplateDefinition	templDef
mutable.WeakHashMap[PsiMethod, PsiMethod]()	mutable.WeakHashMap[PsiMethod, PsiMethod]	prototypeToBaseMethod
fqn + ".ItVerbStringTaggedAs"	Set[String]	itVTFqn
processChildren(getInnerMethodCalls(expr), extractFunSpec, project)	Array[TreeElement]	children
fqn + ".TheyWord"	Set[String]	theyFqn
normalIndent + normalIndent	String	doubleIndent
fqn + ".TheyVerbString"	Set[String]	theyVFqn
isOverride || toAddOverrideToImplemented	Boolean	needsOverride
fqn + ".TheyVerbStringTaggedAs"	Set[String]	theyVTFqn
fqn + ".IgnoreVerbStringTaggedAs"	Set[String]	igVTFqn
processChildren(getInnerMethodCalls(expr), extractFeatureSpec, project)	Array[TreeElement]	children
fqn + ".IgnoreVerbString"	Set[String]	igVFqn
fqn + ".IgnoreWord"	Set[String]	igFqn
fqn + ".InAndIgnoreMethods"	Set[String]	inFqn
fqn + ".InAndIgnoreMethodsAfterTaggedAs"	Set[String]	inTFqn
processChildren(getInnerInfixExprs(expr), extractUnitSpec, project)	Array[TreeElement]	children
methodCall.getEffectiveInvokedExpr	ScExpression	literal
if (methods.nonEmpty) testNames.map(testName => doubleIndent + testName + " $" + testName). fold("\n" + normalIndent + "Methods of " + className + " should pass tests:")(_ + "\n" + _) else ""	String	checkMethodsString
ScalaMemberChooser.sorted(elements, targetClass)	Seq[T]	sortedElements
new ThreeStateCheckBox(ScalaBundle.message("specify.return.type.explicitly"))	ThreeStateCheckBox	mySpecifyTypeChb
elem.getParent	PsiElement	refPattern
refPattern.getParent.asInstanceOf[ScPatternsImpl]	ScPatternsImpl	patternsImpl
ScalaGenerationInfo.defaultValue(member.scType, inClass.getContainingFile)	String	body
checkInfixTagged( PsiTreeUtil.getParentOfType(element, classOf[MethodInvocation], false), Map( "in" -> Set(itVTFqn, itVFqn, igVFqn, igVTFqn, inFqn, inTFqn, theyVFqn, theyVTFqn), "is" -> Set(itVTFqn, itVFqn, igVFqn, igVTFqn, resFqn, resFqn2, theyVFqn, theyVTFqn), "ignore" -> Set(itVFqn, itVTFqn, inFqn, inTFqn, theyVFqn, theyVTFqn) ), Set(itVFqn, igVFqn, resFqn, resFqn2, theyVFqn), testNameIsAlwaysEmpty = true )	ReturnResult	result
createOverrideImplementType(alias, substitutor, needsOverride, comment)(alias.getManager)	ScTypeAlias	m
SbtProcessManager.forProject(project)	SbtProcessManager	sbtProcessManager
createTypeAnnotationsHLink(targetClass.getProject, ScalaBundle.message("default.ta.settings"))	HyperlinkLabel	link
sbtProcessManager.acquireShellRunner()	SbtShellRunner	shellRunner
call match { case i: ScInfixExpr => i.getBaseExpr case m: MethodInvocation => m.getInvokedExpr match { case ref: ScReferenceExpression => ref.qualifier.orNull case _ => null } }	ScExpression	base
templDef.addMember(m, Option(anchor))	ScMember	added
createVariable(comment, classMember)	ScMember	m
getPsiMember	PsiMember	element
new TreeSelectionListener { override def valueChanged(e: TreeSelectionEvent): Unit = { updateSpecifyTypeChb() } }	{ def valueChanged(e: Any): Unit }	selectionListener
patternsImpl.patterns.zipWithIndex. find{case (pat, _) => pat == refPattern}.get._2	Int	index
if (withSelfType) for { selfType <- definition.selfType clazzType = definition.getTypeWithProjections().getOrAny glb = selfType.glb(clazzType) if glb.isInstanceOf[ScCompoundType] } yield (glb.asInstanceOf[ScCompoundType], Some(clazzType)) else None	Option[(ScCompoundType, Some[ScType])]	maybeThisType
elements.head	TreeElement	head
Seq( Scala_2_9, Scala_2_10, Scala_2_11, Scala_2_12, Scala_2_13, Scala_3_0 )	Seq[ScalaVersion]	allScalaVersions
try CodeStyleManager.getInstance(element.getProject).reformat(element) catch { case _: AssertionError => /*\_()_/*/ element }	PsiElement	member
member match { case ta: ScTypeAliasDefinition => ta.aliasedTypeElement match { case Some(x) => x case None => return } case ScPatternDefinition.expr(expr) => expr case ScVariableDefinition.expr(expr) => expr case method: ScFunctionDefinition => method.body match { case Some(x) => x case None => return } case _ => return }	PsiElement	body
member.getTextRange.getStartOffset	Int	offset
createOverrideImplementMethod(member.signature, needsOverrideModifier = true, body)(inClass.getManager)	ScFunction	prototype
new TestNodeProvider	TestNodeProvider	nodeProvider
checkInfixWithIt( invocation, Map( "should" -> Set(shouldFqn, shouldFqn2, itFqn, igFqn, theyFqn), "must" -> Set(mustFqn, mustFqn2, itFqn, igFqn, theyFqn), "can" -> Set(canFqn, canFqn2, itFqn, igFqn, theyFqn) ), checkFirstArgIsUnitOrString = true )	ReturnResult	innerResult
e.statements	Seq[ScBlockStatement]	statements
new TextRange(statements.head.getTextRange.getStartOffset, statements.last.getTextRange.getEndOffset)	TextRange	range
st.extractClass.getOrElse(return "super.")	PsiClass	psiClass
td.selfType match { case None => "super." case Some(st: ScType) => val psiClass = st.extractClass.getOrElse(return "super.") def nonStrictInheritor(base: PsiClass, inheritor: PsiClass): Boolean = { if (base == null || inheritor == null) false else base == inheritor || inheritor.isInheritorDeep(base, null) } if (nonStrictInheritor(method.containingClass, psiClass)) td.selfTypeElement.get.name + "." else "super." }	String	superOrSelfQual
if (methods.nonEmpty) testNames.map(doubleIndent + "+ " + _). fold("\n" + normalIndent + "Methods of " + className + " should pass tests:")(_ + "\n" + _) else ""	String	checkMethodsString
ExtensionPointName.create(name)	ExtensionPointName[T]	extensionPointName
members.groupBy(cm => cm.getElement.getContainingClass)	Map[PsiClass, Seq[T]]	groupedMembers
mutable.LinkedHashSet[PsiClass]()	mutable.LinkedHashSet[PsiClass]	sortedClasses
targetClass.supers	Seq[PsiClass]	supers
Seq( (funSuiteBases, checkFunSuite _), (featureSpecBases, checkFeatureSpec _), (freeSpecBases, checkFreeSpec _), (JUnit3SuiteBases, checkJUnit3Suite _), (JUnitSuiteBases, checkJUnitSuite _), (propSpecBases, checkPropSpec _), /** * //TODO: actually implement checkSpec for scalatest 2.0 Spec * checkSpec("org.scalatest.Spec") ++ * checkSpec("org.scalatest.SpecLike") ++ * checkSpec("org.scalatest.fixture.Spec") ++ * checkSpec("org.scalatest.fixture.SpecLike") ++ */ //this is intended for scalatest versions < 2.0 (funSpecBasesPre2_0, checkFunSpec _), //this is intended for scalatest version 2.0 (funSpecBasesPost2_0, checkFunSpec _), //--- (testNGSuiteBases, checkTestNGSuite _), (flatSpecBases, checkFlatSpec _), (wordSpecBases, checkWordSpec _), )	Seq[(Seq[String], String => Option[String])]	suitsWithFinders
ScalaNamesUtil.escapeKeyword(param.name).toOption.getOrElse("")	String	name
prototypeToBaseMethod.get(method)	Option[PsiMethod]	baseMethod
c1.isInheritor(c2, /*checkDeep =*/ true)	Boolean	less
c2.isInheritor(c1, /*checkDeep =*/ true)	Boolean	more
for { (suites, findTestName) <- suitsWithFinders.iterator suite <- suites.iterator testName <- findTestName(suite) } yield (suite, testName)	Iterator[(String, String)]	searchResults
method	PsiMember	member
PsiTreeUtil.getPrevSiblingOfType(baseMethod, classOf[PsiMethod])	PsiMethod	prevBaseMethod
new IFileElementType(ScalaDocLanguage.INSTANCE)	IFileElementType	getFileNodeType
PsiTreeUtil.getNextSiblingOfType(baseMethod, classOf[PsiMethod])	PsiMethod	nextBaseMethod
new Ordering[PsiClass] { override def compare(c1: PsiClass, c2: PsiClass): Int = { val less = c1.isInheritor(c2, /*checkDeep =*/ true) val more = c2.isInheritor(c1, /*checkDeep =*/ true) if (less && more) 0 //it is possible to have cyclic inheritance for generic traits in scala else if (less) -1 else 1 } }	Ordering[PsiClass] { def compare(c1: PsiClass, c2: PsiClass): Int }	ordering
ScalaNamesUtil.escapeKeyword(method.name)	String	methodName
searchResults.headOption	Option[(String, String)]	suiteWithTestName
fun.paramClauses.clauses.filter(!_.isImplicit)	Seq[ScParameterClause]	clauses
suiteWithTestName.map(_._2)	Option[String]	testName
{ method match { case fun: ScFunction => val clauses = fun.paramClauses.clauses.filter(!_.isImplicit) clauses.map(_.parameters.map(_.name).mkString("(", ", ", ")")).mkString case method: PsiMethod => if (method.isAccessor && method.getParameterList.getParametersCount == 0) "" else method.parameters.map(paramText).mkString("(", ", ", ")") } }	String	parametersText
groupedMembers.getOrElse(c, Seq.empty)	Seq[T]	members
TokenSet.create(SCALA_DOC_COMMENT)	TokenSet	getCommentTokens
TokenSet.create()	TokenSet	getStringLiteralElements
new ScDocSyntaxElementImpl(node)	ScDocSyntaxElementImpl	result
FileTemplateManager.getInstance(td.getProject).getCodeTemplate(templateName)	FileTemplate	template
member.scType	ScType	returnType
Set("scala-library", "scala-reflect", "scala-compiler")	Set[String]	artifactBlackList
org.apache.ivy.util.Message.MSG_WARN	Int	logLevel
Seq( MavenResolver("central", "https://repo1.maven.org/maven2"), MavenResolver("scalaz-releases", "https://dl.bintray.com/scalaz/releases"), IvyResolver("typesafe-releases", "https://repo.typesafe.com/typesafe/ivy-releases/[organisation]/[module]/[revision]/[type]s/[artifact](-[classifier]).jar") )	Seq[DependencyManagerBase.Resolver]	resolvers
node	ASTNode	parentNode
getStandardValue(returnType)	String	standardValue
member.getElement	PsiMethod	method
maybeThisType.fold(getTypes(definition)) { case (compoundType, compoundTypeThisType) => getTypes(compoundType, compoundTypeThisType) }.allSignatures	Iterator[TypeSignature]	types
new IBiblioResolver	IBiblioResolver	iBiblioResolver
new URLResolver	URLResolver	urlResolver
parent != null && (parent.getPsi match { case tag: ScDocTag => tag.getName == MyScaladocParsing.THROWS_TAG case _ => false })	Boolean	isThrows
new IvySettings	IvySettings	ivySettings
maybeThisType.fold(getSignatures(definition)) { case (compoundType, compoundTypeThisType) => getSignatures(compoundType, compoundTypeThisType) }	TypeDefinitionMembers.TermNodes.Map	signatures
getMethodBody(member, td, !isOverride)	String	body
resolvers.map(mkResolver)	IndexedSeq[RepositoryResolver]	ivyResolvers
signature.method	PsiMethod	method
new ChainResolver	ChainResolver	chainResolver
if (testConfigurationData.useSbt) { //use a process running sbt val sbtProcessManager = SbtProcessManager.forProject(project) //make sure the process is initialized val shellRunner = sbtProcessManager.acquireShellRunner() //TODO: this null is really weird // null parameter does not affect anything, rethink API SbtProcessHandlerWrapper(shellRunner.createProcessHandler(null)) } else { startProcess() }	ProcessHandler	processHandler
getRunnerSettings	RunnerSettings	runnerSettings
mkIvySettings()	IvySettings	settings
createOverrideImplementMethod(signature, needsOverride, body, withComment = ScalaApplicationSettings.getInstance().COPY_SCALADOC, withAnnotation = false)(method.getManager)	ScFunction	m
new Ivy()	Ivy	ivy
null	Type.Name	res
getConfiguration	RunConfigurationBase[_]	config
signatures.allSignatures.filter { case signature: PhysicalMethodSignature if signature.namedElement.isValid => f1(signature) case _ => false }.map { case signature: PhysicalMethodSignature => val method = signature.method assert(method.containingClass != null, s"Containing Class is null: ${method.getText}") ScMethodMember(signature, isOverride) }	Iterator[ScMethodMember]	methods
new SMTRunnerConsoleProperties(currentConfiguration, "Scala", executor) with PropertiesExtension { override def getTestLocator = new ScalaTestLocationProvider def getRunConfigurationBase: RunConfigurationBase[_] = config }	SMTRunnerConsoleProperties with AbstractTestRunConfiguration.PropertiesExtension { def getTestLocator: ScalaTestLocationProvider def getRunConfigurationBase: RunConfigurationBase[_] }	consoleProperties
new ConsoleViewImpl(project, true)	ConsoleViewImpl	console
signatures.allSignatures.filter(isValSignature)	Iterator[TermSignature]	values
if (testConfigurationData.useSbt && !testConfigurationData.useUiWithSbt) { val console = new ConsoleViewImpl(project, true) console.attachToProcess(processHandler) console } else SMTestRunnerConnectionUtil.createAndAttachConsole("Scala", processHandler, consoleProperties)	ConsoleView with ObservableConsoleView	consoleView
new DefaultExecutionResult( consoleView, processHandler, createActions(consoleView, processHandler, executor): _*)	DefaultExecutionResult	res
new AbstractTestRerunFailedTestsAction(testConsole)	AbstractTestRerunFailedTestsAction	rerunFailedTestsAction
x.projectContext.stdTypes	StdTypes	stdTypes
td.addMember(m, Option(anchor))	ScMember	added
classMember.isInstanceOf[ScValueMember]	Boolean	isVal
(types ++ values).filter { case Signature(named, _) => named.isValid && f2(named) }.flatMap { toClassMember(_, isOverride) }	Iterator[overrideImplement.ClassMember]	aliasesAndValues
m.containingClass	PsiClass	clazz
sign.method	PsiMethod	m
if (m == null) "" else m.name	String	name
usingTempFile("ivy", ".xml") { ivyFile => Files.write(Paths.get(ivyFile.toURI), mkIvyXml(deps).getBytes) ivy.resolve(ivyFile.toURI.toURL, new ResolveOptions().setConfs(Array("compile"))) }	ResolveReport	report
clazz.extendsBlock	ScExtendsBlock	place
m.Term.Name("_root_")	Term.Name	rootPackageName
clazz.extendsBlock.templateBody match { case Some(x) => x case None => return None }	ScTemplateBody	body
body.getContainingFile.findElementAt(offset)	PsiElement	element
scalaTypeName("Any")	Type.Name	anyTypeName
scalaTypeName("AnyRef")	Type.Name	anyRefTypeName
scalaTypeName("AnyVal")	Type.Name	anyValTypeName
scalaTypeName("Nothing")	Type.Name	nothingTypeName
scalaTypeName("Null")	Type.Name	nullTypeName
scalaTypeName("Singleton")	Type.Name	singletonTypeName
scalaTypeName("Unit")	Type.Name	unit
scalaTypeName("Boolean")	Type.Name	boolean
ScalaPsiManager.instance(getCurrentProject).getCachedClass(GlobalSearchScope.allScope(getCurrentProject), s"scala.${x.name}")	Option[PsiClass]	clazz
scalaTypeName("Char")	Type.Name	char
scalaTypeName("Int")	Type.Name	int
scalaTypeName("Float")	Type.Name	float
scalaTypeName("Double")	Type.Name	double
scalaTypeName("Byte")	Type.Name	byte
scalaTypeName("Short")	Type.Name	short
classMember match { case x: ScValueMember => x.element case x: ScVariableMember => x.element }	ScTypedDefinition	value
new ScalaTypeVisitor { override def visitStdType(x: StdType) = { val stdTypes = x.projectContext.stdTypes import stdTypes._ res = x match { case Any => std.anyTypeName case AnyRef => std.anyRefTypeName case AnyVal => std.anyValTypeName case Nothing=> std.nothingTypeName case Null => std.nullTypeName case Unit => std.unit case Boolean=> std.boolean case Char => std.char case Int => std.int case Float => std.float case Double => std.double case Byte => std.byte case Short => std.short case _ => val clazz = ScalaPsiManager.instance(getCurrentProject).getCachedClass(GlobalSearchScope.allScope(getCurrentProject), s"scala.${x.name}") if (clazz != null) m.Type.Name(x.name) else null } } }	ScalaTypeVisitor { def visitStdType(x: StdType): Unit }	visitor
needsOverride || toAddOverrideToImplemented	Boolean	addOverride
buildSbtParams(suitesToTestsMap). map(SettingQueryHandler.getProjectIdPrefix(SbtUtil.getSbtProjectIdSeparated(getModule)) + "testOnly" + _)	IndexedSeq[String]	commands
toTermName(c)	Term.Name	resolved
expr match { case ts: ScTypedExpression => createTypeFromText(ts.getText, expr, null) case _ => None }	Option[ScType]	maybeType
expr.`type`()	result.TypeResult	tp
SbtShellCommunication.forProject(project)	SbtShellCommunication	comm
new SbtTestEventHandler(processHandler)	SbtTestEventHandler	handler
ScSubstitutor(ScSubstitutor.cache)	ScSubstitutor	substitutor
if (testConfigurationData.useUiWithSbt) for { _ <- initialize(comm) mod <- modifySbtSettingsForUi(comm) } yield mod else Future.successful(SettingMap())	Future[AbstractTestRunConfiguration.SettingMap]	oldSettings
createOverrideImplementVariable(value, substitutor, addOverride, isVal, comment)(value.getManager)	ScMember	m
toType(tpe)	Type	raw
TwoWayCache[ptype.ScType, m.Type]()	TwoWayCache[ScType, Type]	typeCache
TwoWayCache[ScTypeElement, m.Type]()	TwoWayCache[ScTypeElement, Type]	typeElementCache
TwoWayCache[PsiElement, m.Type]()	TwoWayCache[PsiElement, Type]	psiElementTypeChache
commands.map( comm.command(_, {}, SbtShellCommunication.listenerAggregator(handler), showShell = false) )	IndexedSeq[Future[Unit]]	cmdF
ScSubstitutor(ScSubstitutor.cache)	ScSubstitutor	s
{ lazy val oldSettings = if (testConfigurationData.useUiWithSbt) for { _ <- initialize(comm) mod <- modifySbtSettingsForUi(comm) } yield mod else Future.successful(SettingMap()) lazy val cmdF = commands.map( comm.command(_, {}, SbtShellCommunication.listenerAggregator(handler), showShell = false) ) for { old <- oldSettings _ <- Future.sequence(cmdF) reset <- resetSbtSettingsForUi(comm, old) } yield reset }	Future[Boolean]	sbtRun
new JavaCommandLineState(env) with AbstractTestRunConfiguration.TestCommandLinePatcher { private def suitesToTestsMap: Map[String, Set[String]] = { val failedTests = getFailedTests.groupBy(_._1).map { case (aClass, tests) => (aClass, tests.map(_._2).toSet) }.filter(_._2.nonEmpty) if (failedTests.nonEmpty) { failedTests } else { testConfigurationData.getTestMap } } override val getClasses: Seq[String] = testConfigurationData.getTestMap.keys.toSeq protected override def createJavaParameters: JavaParameters = { val params = new JavaParameters() params.setCharset(null) var vmParams = testConfigurationData.getJavaOptions //expand macros vmParams = PathMacroManager.getInstance(project).expandPath(vmParams) if (module != null) { vmParams = PathMacroManager.getInstance(module).expandPath(vmParams) } val mutableEnvVariables = testConfigurationData.envs params.setEnv(mutableEnvVariables) //expand environment variables in vmParams params.getEnv.entrySet.forEach { entry => vmParams = StringUtil.replace(vmParams, "$" + entry.getKey + "$", entry.getValue, false) } params.getVMParametersList.addParametersString(vmParams) val wDir = testConfigurationData.getWorkingDirectory params.setWorkingDirectory(expandPath(wDir)) // params.getVMParametersList.addParametersString("-agentlib:jdwp=transport=dt_socket,server=n,address=UNIT-549.Labs.IntelliJ.Net:5005,suspend=y") params.getClassPath.addRunners() //a workaround to add jars for integration tests if (addIntegrationTestsClasspath) { params.getClassPath.addRunners() } ManagingFS.getInstance match { case fs: PersistentFSImpl => fs.incStructuralModificationCount() case _ => } val maybeCustomSdk = for { path <- testConfigurationData.jrePath.toOption jdk <- ProjectJdkTable.getInstance().findJdk(path).toOption } yield jdk testConfigurationData.searchTest match { case SearchForTest.IN_WHOLE_PROJECT => val sdk = maybeCustomSdk.orElse( project .modules .iterator.map(JavaParameters.getValidJdkToRunModule(_, false)) .collectFirst { case jdk if jdk ne null => jdk } ) params.configureByProject(project, JavaParameters.JDK_AND_CLASSES_AND_TESTS, sdk.orNull) case _ => val sdk = maybeCustomSdk.getOrElse(JavaParameters.getValidJdkToRunModule(module, false)) params.configureByModule(module, JavaParameters.JDK_AND_CLASSES_AND_TESTS, sdk) } params.setMainClass(runnerClassName) def addParameters(add: String => Unit, after: () => Unit): Unit = { addClassesAndTests(suitesToTestsMap, add) if (reporterClass != null) { add("-C") add(reporterClass) } add("-showProgressMessages") add(testConfigurationData.showProgressMessages.toString) after() } val (myAdd, myAfter): (String => Unit, () => Unit) = if (JdkUtil.useDynamicClasspath(getProject)) { try { val fileWithParams: File = File.createTempFile("abstracttest", ".tmp") val outputStream = new FileOutputStream(fileWithParams) val printer: PrintStream = new PrintStream(outputStream) params.getProgramParametersList.add("@" + fileWithParams.getPath) (printer.println(_:String), () => printer.close()) } catch { case ioException: IOException => throw new ExecutionException("Failed to create dynamic classpath file with command-line args.", ioException) } } else { (params.getProgramParametersList.add(_), () => ()) } addParametersString(testConfigurationData.getTestArgs, myAdd) addParameters(myAdd, myAfter) for (ext <- RunConfigurationExtension.EP_NAME.getExtensionList.asScala) { ext.updateJavaParameters(currentConfiguration, params, getRunnerSettings) } params } override def execute(executor: Executor, runner: ProgramRunner[_ <: RunnerSettings]): ExecutionResult = { val processHandler = if (testConfigurationData.useSbt) { //use a process running sbt val sbtProcessManager = SbtProcessManager.forProject(project) //make sure the process is initialized val shellRunner = sbtProcessManager.acquireShellRunner() //TODO: this null is really weird // null parameter does not affect anything, rethink API SbtProcessHandlerWrapper(shellRunner.createProcessHandler(null)) } else { startProcess() } val runnerSettings = getRunnerSettings if (getConfiguration == null) setConfiguration(currentConfiguration) val config = getConfiguration JavaRunConfigurationExtensionManager.getInstance. attachExtensionsToProcess(currentConfiguration, processHandler, runnerSettings) val consoleProperties = new SMTRunnerConsoleProperties(currentConfiguration, "Scala", executor) with PropertiesExtension { override def getTestLocator = new ScalaTestLocationProvider def getRunConfigurationBase: RunConfigurationBase[_] = config } consoleProperties.setIdBasedTestTree(true) // console view val consoleView = if (testConfigurationData.useSbt && !testConfigurationData.useUiWithSbt) { val console = new ConsoleViewImpl(project, true) console.attachToProcess(processHandler) console } else SMTestRunnerConnectionUtil.createAndAttachConsole("Scala", processHandler, consoleProperties) val res = new DefaultExecutionResult( consoleView, processHandler, createActions(consoleView, processHandler, executor): _*) consoleView match { case testConsole: BaseTestsOutputConsoleView => val rerunFailedTestsAction = new AbstractTestRerunFailedTestsAction(testConsole) rerunFailedTestsAction.init(testConsole.getProperties) rerunFailedTestsAction.setModelProvider(new Getter[TestFrameworkRunningModel] { def get: TestFrameworkRunningModel = { testConsole.asInstanceOf[SMTRunnerConsoleView].getResultsViewer } }) res.setRestartActions(rerunFailedTestsAction, new ToggleAutoTestAction() { override def isDelayApplicable: Boolean = false override def getAutoTestManager(project: Project): AbstractAutoTestManager = JavaAutoRunManager.getInstance(project) }) case _ => } if (testConfigurationData.useSbt) { Stats.trigger(FeatureKey.sbtShellTestRunConfig) val commands = buildSbtParams(suitesToTestsMap). map(SettingQueryHandler.getProjectIdPrefix(SbtUtil.getSbtProjectIdSeparated(getModule)) + "testOnly" + _) val comm = SbtShellCommunication.forProject(project) val handler = new SbtTestEventHandler(processHandler) val sbtRun = { lazy val oldSettings = if (testConfigurationData.useUiWithSbt) for { _ <- initialize(comm) mod <- modifySbtSettingsForUi(comm) } yield mod else Future.successful(SettingMap()) lazy val cmdF = commands.map( comm.command(_, {}, SbtShellCommunication.listenerAggregator(handler), showShell = false) ) for { old <- oldSettings _ <- Future.sequence(cmdF) reset <- resetSbtSettingsForUi(comm, old) } yield reset } sbtRun.onComplete(_ => handler.closeRoot()) } res } }	JavaCommandLineState with AbstractTestRunConfiguration.TestCommandLinePatcher { def execute(executor: Executor, runner: ProgramRunner[_ <: RunnerSettings]): ExecutionResult def suitesToTestsMap: Map[String, Set[String]] val getClasses : Seq[String] def createJavaParameters: JavaParameters }	state
Seq()	Seq[(String, String)]	failedTests
_	RunConfigurationBase[_]	configuration
Seq(t.clause.declarations map { case tp: ScTypeAliasDeclaration => toTypeDecl(tp) case other => other ?! }: _*)	Seq[Decl.Type]	clauses
toType(t.quantified)	Type	quantified
clazz match { case c: ScClass => c.secondaryConstructors.toList ::: c.constructor.toList case _ => clazz.getConstructors.toList }	List[PsiMethod]	constructors
if (wc.upper.isAny) None else Some(toType(wc.upper))	Option[Type]	ubound
if (wc.lower.isNothing) None else Some(toType(wc.lower))	Option[Type]	lbound
new ResolveProcessor(reference.getKinds(incomplete = false), reference, reference.refName)	ResolveProcessor	processor
_	Tree	ret
m.Defn.Trait( convertMods(t), toTypeName(t), Seq(t.typeParameters map toTypeParams: _*), m.Ctor.Primary(Nil, m.Ctor.Ref.Name("this"), Nil), template(t.physicalExtendsBlock) )	Defn.Trait	defn
ret.asInstanceOf[m.Term]	Term	body
t.wildcards.map {wc => // val (name, args, lower, upper) = wc val ubound = if (wc.upper.isAny) None else Some(toType(wc.upper)) val lbound = if (wc.lower.isNothing) None else Some(toType(wc.lower)) m.Decl.Type(Nil, m.Type.Name(wc.name), //FIXME: pass actual prefix, when solution for recursive prefix computation is ready // .withAttrs(h.Denotation.Single(h.Prefix.None, toSymbolWtihParent(wc.name, pivot, h.ScalaSig.Type(wc.name)))) // .setTypechecked, Nil, m.Type.Bounds(lbound, ubound))//.setTypechecked }	IndexedSeq[Decl.Type]	wcards
if (tp.upperType.isAny) None else Some(toType(tp.upperType))	Option[Type]	ubound
if (tp.lowerType.isNothing) None else Some(toType(tp.lowerType))	Option[Type]	lbound
m.Defn.Class( convertMods(c), toTypeName(c), Seq(c.typeParameters map toTypeParams: _*), ctor(c.constructor), template(c.physicalExtendsBlock) )	Defn.Class	defn
t.templateBody map (it => Seq(it.exprs.map(expression): _*))	Option[Seq[Term]]	exprs
element.getParent match { case holder: ScAnnotationsHolder => holder.annotations.find(_.isMetaMacro) case _ => None }	Option[ScAnnotation]	maybeAnnotation
null	ScAnnotation	annotationToSkip
t.templateBody map (it => Seq(it.members.map(ideaToMeta(_).asInstanceOf[m.Stat]): _*))	Option[Seq[Stat]]	members
t.earlyDefinitions map (it => Seq(it.members.map(ideaToMeta(_).asInstanceOf[m.Stat]):_*)) getOrElse Seq.empty	Seq[Stat]	early
Option(fun.containingClass).flatMap(x=>Option(x.qualifiedName))	Option[String]	fqnO
mutable.WeakHashMap[T, U]()	mutable.WeakHashMap[T, U]	t2u
mutable.WeakHashMap[U, T]()	mutable.WeakHashMap[U, T]	u2t
t2u.getOrElseUpdate(t, op)	U	u
u2t.getOrElseUpdate(u, op)	T	t
new CompilationStatusListener { override def compilationFinished(aborted: Boolean, errors: Int, warnings: Int, context: CompileContext): Unit = { for { scope <- Option(context.getCompileScope) module <- scope.getAffectedModules } { invalidateModuleClassloader(module) } } }	CompilationStatusListener { def compilationFinished(aborted: Boolean, errors: Int, warnings: Int, context: CompileContext): Unit }	compilationStatusListener
OrderEnumerator.orderEntries(module).getClassesRoots.toList.map(toUrl)	List[Any]	dependencyCP
projectOutputDirs(module.getProject).map(str => new File(str).toURI.toURL)	List[Any]	outDirs
t.templateParents .flatMap(_.children.find(_.isInstanceOf[ScConstructorInvocation])) .map(c=>toCtor(c.asInstanceOf[ScConstructorInvocation])) .toSeq	Seq[Ctor.Call]	ctor
outDirs ++ dependencyCP :+ pluginCP	Seq[Any]	fullCP
for { ref <- annot.constructorInvocation.reference resolved <- ref.bind() parent <- resolved.parentElement.map(_.asInstanceOf[ScClass]) } yield parent	Option[ScClass]	annotClass
stringContextApplicationRef.qualifier match { case Some(mc: ScMethodCallImpl) => mc.argumentExpressions.zipWithIndex.foldLeft("") { case (a, (expr, i)) if i > 0 => s"$a$$__meta$i${unquoteString(expr.getText)}" case (_, (expr, i)) if i == 0 => unquoteString(expr.getText) } case _ => "" }	String	joined
VirtualFileManager.getInstance().findFileByUrl(path)	VirtualFile	virtualFile
t.templateParents.map(x=>x.typeElementsWithoutConstructor.map(toType).map(toCtor)).getOrElse(Seq.empty)	Seq[Term.Apply]	mixins
if (joined.contains("\n")) scala.meta.dialects.QuasiquoteTerm(m.Dialect.standards("Scala211"), multiline = true) else scala.meta.dialects.QuasiquoteTerm(m.Dialect.standards("Scala211"), multiline = false)	Dialect	qqdialect
collectQQParts(qqparts)	Seq[Quasi]	parts
parts.map(_.pt)	IndexedSeq[Class[_]]	classes
t.selfType match { case Some(tpe: ptype.ScType) => m.Term.Param(Nil, m.Term.Name("self"), Some(toType(tpe)), None) case None => m.Term.Param(Nil, m.Name.Anonymous(), None, None) }	Term.Param	self
parseQQExpr(stringContextApplicationRef.refName, joined, qqdialect) match { case Parsed.Success(qqparts) => val parts = collectQQParts(qqparts) val classes = parts.map(_.pt) classes.map(classToScTypeString) case Parsed.Error(_, cause, exc) => Seq.empty }	Seq[String]	typeStrings
expansion.body	String	body
annotClass.flatMap(_.module)	Option[Module]	metaModule
typeStrings.map(createTypeFromText(_, stringContextApplicationRef, null))	IndexedSeq[Option[ScType]]	types
createTypeFromText("scala.meta.Tree", stringContextApplicationRef, null)	Option[ScType]	treeType
ScalaPsiElementFactory.createBlockExpressionWithoutBracesFromText(body)	ScBlockImpl	newPsi
(exprs, members) match { case (Some(exp), Some(hld)) => Some(hld ++ exp) case (Some(exp), None) => Some(exp) case (None, Some(hld)) => Some(hld) case (None, None) => None }	Option[Seq[Stat]]	stats
maybeType.orElse(treeType).get	ScType	tp
pat.projectContext	ProjectContext	context
t.extendsBlock.earlyDefinitions map (it => Seq(it.members.map(ideaToMeta(_).asInstanceOf[m.Stat]):_*)) getOrElse Seq.empty	Seq[Stat]	early
escapeQQ(pat)	String	patternText
t.extendsBlock.templateParents match { case Some(parents) => parents.constructorInvocation match { case Some(constrInvocation) => toCtor(constrInvocation) case None => unreachable(s"no constructor found in class ${t.qualifiedName}") } case None => unreachable(s"Class ${t.qualifiedName} has no parents") }	Ctor.Call	ctor
if (pat.isMultiLineString) scala.meta.dialects.QuasiquoteTerm(m.Dialect.standards("Scala211"), multiline = true) else scala.meta.dialects.QuasiquoteTerm(m.Dialect.standards("Scala211"), multiline = false)	Dialect	qqdialect
annot.module.map(m=>outputDirs(m).map(new File(_).toURI.toURL)).getOrElse(Nil)	Seq[Any]	contextCP
s"/${TestUtils.getTestDataPath}/sbt/resolvers/testIvyCache"	String	root
new SbtIvyResolver("Test repo", root)	SbtIvyResolver	testResolver
parseQQExpr(prefix, patternText, qqdialect)	Parsed[Tree]	parsed
t.selfType match { case Some(tpe: ptype.ScType) => m.Term.Param(Nil, m.Term.Name("self")/*.withAttrsFor(t)*/, Some(toType(tpe)), None) case None => m.Term.Param(Nil, m.Name.Anonymous(), None, None) }	Term.Param	self
Sbt.Latest_0_13	Version	sbtVersion
metaModule .map(classLoaderForModule(_)(contextCP)) // try annotation's own module first - if it exists as a part of rhe codebase .orElse(annot.module.map(classLoaderForModule(_)(contextCP)))	Option[ScalaClassLoader.URLClassLoader]	classLoader
Sbt.LatestVersion	Version	sbtVersion
new ScalaRecursiveElementVisitor { var ret: m.Tree = _ override def visitTypeAliasDefinition(alias: ScTypeAliasDefinition) = super.visitTypeAliasDefinition(alias) override def visitElement(element: PsiElement) = { super.visitElement(element) } override def visitTypeAlias(alias: ScTypeAlias) = super.visitTypeAlias(alias) override def visitTypeAliasDeclaration(alias: ScTypeAliasDeclaration) = super.visitTypeAliasDeclaration(alias) override def visitParameters(parameters: ScParameters) = super.visitParameters(parameters) override def visitModifierList(modifierList: ScModifierList) = super.visitModifierList(modifierList) override def visitConstructorInvocation(constrInvocation: ScConstructorInvocation) = super.visitConstructorInvocation(constrInvocation) override def visitFunctionDefinition(fun: ScFunctionDefinition) = { fun.body.get.accept(this) val body = ret.asInstanceOf[m.Term] ret = m.Defn.Def(convertMods(fun), toTermName(fun), Seq(fun.typeParameters map toTypeParams:_*), Seq(fun.paramClauses.clauses.map(convertParamClause):_*), fun.definedReturnType.toOption.map(toType(_)), body ) } override def visitFunctionDeclaration(fun: ScFunctionDeclaration) = super.visitFunctionDeclaration(fun) override def visitMacroDefinition(fun: ScMacroDefinition) = super.visitMacroDefinition(fun) override def visitCatchBlock(c: ScCatchBlock) = super.visitCatchBlock(c) override def visitFile(file: PsiFile) = super.visitFile(file) //Override also visitReferenceExpression! and visitTypeProjection! override def visitReference(ref: ScReference) = super.visitReference(ref) override def visitParameter(parameter: ScParameter) = super.visitParameter(parameter) override def visitClassParameter(parameter: ScClassParameter) = super.visitClassParameter(parameter) override def visitPatternDefinition(pat: ScPatternDefinition) = super.visitPatternDefinition(pat) override def visitValueDeclaration(v: ScValueDeclaration) = super.visitValueDeclaration(v) override def visitVariableDefinition(varr: ScVariableDefinition) = super.visitVariableDefinition(varr) override def visitVariableDeclaration(varr: ScVariableDeclaration) = super.visitVariableDeclaration(varr) override def visitVariable(varr: ScVariable) = super.visitVariable(varr) override def visitValue(v: ScValue) = super.visitValue(v) override def visitCaseClause(cc: ScCaseClause) = super.visitCaseClause(cc) override def visitPattern(pat: ScPattern) = super.visitPattern(pat) override def visitForBinding(forBinding: ScForBinding) = super.visitForBinding(forBinding) override def visitGenerator(gen: ScGenerator) = super.visitGenerator(gen) override def visitGuard(guard: ScGuard) = super.visitGuard(guard) override def visitFunction(fun: ScFunction) = super.visitFunction(fun) override def visitTypeDefinition(typedef: ScTypeDefinition) = super.visitTypeDefinition(typedef) override def visitImportExpr(expr: ScImportExpr) = super.visitImportExpr(expr) override def visitSelfInvocation(self: ScSelfInvocation) = super.visitSelfInvocation(self) override def visitAnnotation(annotation: ScAnnotation) = super.visitAnnotation(annotation) // Expressions override def visitExpression(expr: ScExpression) = super.visitExpression(expr) override def visitThisReference(t: ScThisReference) = super.visitThisReference(t) override def visitSuperReference(t: ScSuperReference) = super.visitSuperReference(t) override def visitPostfixExpression(p: ScPostfixExpr) = super.visitPostfixExpression(p) override def visitPrefixExpression(p: ScPrefixExpr) = super.visitPrefixExpression(p) override def visitIf(stmt: ScIf) = super.visitIf(stmt) override def visitLiteral(l: ScLiteral) = super.visitLiteral(l) override def visitAssignment(stmt: ScAssignment) = super.visitAssignment(stmt) override def visitMethodCallExpression(call: ScMethodCall) = super.visitMethodCallExpression(call) override def visitGenericCallExpression(call: ScGenericCall) = super.visitGenericCallExpression(call) override def visitInfixExpression(infix: ScInfixExpr) = super.visitInfixExpression(infix) override def visitWhile(ws: ScWhile) = super.visitWhile(ws) override def visitReturn(ret: ScReturn) = super.visitReturn(ret) override def visitMatch(ms: ScMatch) = super.visitMatch(ms) override def visitFor(expr: ScFor) = super.visitFor(expr) override def visitDo(stmt: ScDo) = super.visitDo(stmt) override def visitFunctionExpression(stmt: ScFunctionExpr) = super.visitFunctionExpression(stmt) override def visitThrow(throwStmt: ScThrow) = super.visitThrow(throwStmt) override def visitTry(tryStmt: ScTry) = super.visitTry(tryStmt) override def visitParenthesisedExpr(expr: ScParenthesisedExpr) = super.visitParenthesisedExpr(expr) override def visitNewTemplateDefinition(templ: ScNewTemplateDefinition) = super.visitNewTemplateDefinition(templ) override def visitTypedStmt(stmt: ScTypedExpression) = super.visitTypedStmt(stmt) override def visitTuple(tuple: ScTuple) = super.visitTuple(tuple) override def visitBlockExpression(block: ScBlockExpr) = super.visitBlockExpression(block) override def visitUnderscoreExpression(under: ScUnderscoreSection) = super.visitUnderscoreExpression(under) override def visitConstrBlock(constr: ScConstrBlock) = super.visitConstrBlock(constr) //type elements override def visitTypeElement(te: ScTypeElement) = super.visitTypeElement(te) override def visitSimpleTypeElement(simple: ScSimpleTypeElement) = super.visitSimpleTypeElement(simple) override def visitWildcardTypeElement(wildcard: ScWildcardTypeElement) = super.visitWildcardTypeElement(wildcard) override def visitTupleTypeElement(tuple: ScTupleTypeElement) = super.visitTupleTypeElement(tuple) override def visitParenthesisedTypeElement(parenthesised: ScParenthesisedTypeElement) = super.visitParenthesisedTypeElement(parenthesised) override def visitParameterizedTypeElement(parameterized: ScParameterizedTypeElement) = super.visitParameterizedTypeElement(parameterized) override def visitInfixTypeElement(infix: ScInfixTypeElement) = super.visitInfixTypeElement(infix) override def visitFunctionalTypeElement(fun: ScFunctionalTypeElement) = super.visitFunctionalTypeElement(fun) override def visitExistentialTypeElement(exist: ScExistentialTypeElement) = super.visitExistentialTypeElement(exist) override def visitCompoundTypeElement(compound: ScCompoundTypeElement) = super.visitCompoundTypeElement(compound) override def visitAnnotTypeElement(annot: ScAnnotTypeElement) = super.visitAnnotTypeElement(annot) override def visitTypeVariableTypeElement(tvar: ScTypeVariableTypeElement) = super.visitTypeVariableTypeElement(tvar) //scaladoc override def visitDocComment(s: ScDocComment) = super.visitDocComment(s) override def visitScaladocElement(s: ScalaPsiElement) = super.visitScaladocElement(s) override def visitWikiSyntax(s: ScDocSyntaxElement) = super.visitWikiSyntax(s) override def visitInlinedTag(s: ScDocInlinedTag) = super.visitInlinedTag(s) override def visitTag(s: ScDocTag) = super.visitTag(s) //xml override def visitXmlStartTag(s: ScXmlStartTag) = super.visitXmlStartTag(s) override def visitXmlEndTag(s: ScXmlEndTag) = super.visitXmlEndTag(s) }	ScalaRecursiveElementVisitor { def visitGenericCallExpression(call: ScGenericCall): Unit def visitTuple(tuple: ScTuple): Unit def visitWikiSyntax(s: ScDocSyntaxElement): Unit def visitSuperReference(t: ScSuperReference): Unit def visitTypeAlias(alias: ScTypeAlias): Unit def visitWhile(ws: ScWhile): Unit def visitExistentialTypeElement(exist: ScExistentialTypeElement): Unit def visitLiteral(l: ScLiteral): Unit def visitMacroDefinition(fun: ScMacroDefinition): Unit def visitPattern(pat: ScPattern): Unit def visitMatch(ms: ScMatch): Unit def visitForBinding(forBinding: ScForBinding): Unit def visitThrow(throwStmt: ScThrow): Unit def visitFile(file: PsiFile): Unit var ret : Tree def visitTypeDefinition(typedef: ScTypeDefinition): Unit def visitInlinedTag(s: ScDocInlinedTag): Unit def visitTupleTypeElement(tuple: ScTupleTypeElement): Unit def visitSimpleTypeElement(simple: ScSimpleTypeElement): Unit def visitVariableDefinition(varr: ScVariableDefinition): Unit def visitInfixTypeElement(infix: ScInfixTypeElement): Unit def visitFunctionDeclaration(fun: ScFunctionDeclaration): Unit def visitDocComment(s: ScDocComment): Unit def visitTypeAliasDefinition(alias: ScTypeAliasDefinition): Unit def visitGenerator(gen: ScGenerator): Unit def visitIf(stmt: ScIf): Unit def visitFunctionExpression(stmt: ScFunctionExpr): Unit def visitParenthesisedExpr(expr: ScParenthesisedExpr): Unit def visitParameter(parameter: ScParameter): Unit def visitReference(ref: ScReference): Unit def visitThisReference(t: ScThisReference): Unit def visitSelfInvocation(self: ScSelfInvocation): Unit def visitFor(expr: ScFor): Unit def visitXmlStartTag(s: ScXmlStartTag): Unit def visitNewTemplateDefinition(templ: ScNewTemplateDefinition): Unit def visitWildcardTypeElement(wildcard: ScWildcardTypeElement): Unit def visitAssignment(stmt: ScAssignment): Unit def visitTypeAliasDeclaration(alias: ScTypeAliasDeclaration): Unit def visitMethodCallExpression(call: ScMethodCall): Unit def visitPatternDefinition(pat: ScPatternDefinition): Unit def visitGuard(guard: ScGuard): Unit def visitVariable(varr: ScVariable): Unit def visitPrefixExpression(p: ScPrefixExpr): Unit def visitCompoundTypeElement(compound: ScCompoundTypeElement): Unit def visitAnnotTypeElement(annot: ScAnnotTypeElement): Unit def visitTypeElement(te: ScTypeElement): Unit def visitModifierList(modifierList: ScModifierList): Unit def visitDo(stmt: ScDo): Unit def visitFunction(fun: ScFunction): Unit def visitValueDeclaration(v: ScValueDeclaration): Unit def visitCatchBlock(c: ScCatchBlock): Unit def visitUnderscoreExpression(under: ScUnderscoreSection): Unit def visitParameterizedTypeElement(parameterized: ScParameterizedTypeElement): Unit def visitConstructorInvocation(constrInvocation: ScConstructorInvocation): Unit def visitTypeVariableTypeElement(tvar: ScTypeVariableTypeElement): Unit def visitAnnotation(annotation: ScAnnotation): Unit def visitPostfixExpression(p: ScPostfixExpr): Unit def visitImportExpr(expr: ScImportExpr): Unit def visitConstrBlock(constr: ScConstrBlock): Unit def visitClassParameter(parameter: ScClassParameter): Unit def visitTag(s: ScDocTag): Unit def visitXmlEndTag(s: ScXmlEndTag): Unit def visitParameters(parameters: ScParameters): Unit def visitVariableDeclaration(varr: ScVariableDeclaration): Unit def visitValue(v: ScValue): Unit def visitParenthesisedTypeElement(parenthesised: ScParenthesisedTypeElement): Unit def visitExpression(expr: ScExpression): Unit def visitTypedStmt(stmt: ScTypedExpression): Unit def visitFunctionalTypeElement(fun: ScFunctionalTypeElement): Unit def visitFunctionDefinition(fun: ScFunctionDefinition): Unit def visitInfixExpression(infix: ScInfixExpr): Unit def visitTry(tryStmt: ScTry): Unit def visitBlockExpression(block: ScBlockExpr): Unit def visitElement(element: PsiElement): Unit def visitScaladocElement(s: ScalaPsiElement): Unit def visitCaseClause(cc: ScCaseClause): Unit def visitReturn(ret: ScReturn): Unit }	v
JvmMemorySize.Megabytes(1500)	JvmMemorySize	hiddenDefaultSize
pat.ref.refName	String	prefix
block.getChildren.dropWhile(filter).reverse.dropWhile(filter).reverse	Array[PsiElement]	children
annot	ScAnnotation	annotationToSkip
new SbtExecutionSettings(null, null, userOpts, hiddenDefaultSize, null, null, null, null, false, false, false, false, false ,false)	SbtExecutionSettings	settings
m.Term.Apply(ctorRef, Seq(constrInvocation.arguments.head.exprs.map(callArgs): _*))	Term.Apply	head
List("Marker: ScalaTest first test", "Marker: ScalaTest second test", "Marker: ScalaTest prefix test", "Marker: ScalaTest Other first test", "Marker: ScalaTest Other prefix test")	List[Nothing]	inScalaTestPackage
toCtorRef(tp)	Ctor.Call	ctor
List("Marker: Specs2 first test", "Marker: Specs2 second test", "Marker: Specs2 prefix test", "Marker: Specs2 Other first test", "Marker: Specs2 Other prefix test")	List[Nothing]	inSpecsPackage
new TreeConverter { override def getCurrentProject: Project = annot.getProject override def dumbMode: Boolean = true override protected val annotationToSkip: ScAnnotation = annot }	TreeConverter { val annotationToSkip : ScAnnotation def dumbMode: Boolean def getCurrentProject: Project }	converter
holder match { case td: ScTypeDefinition => td.baseCompanionModule case _ => None }	Option[ScTypeDefinition]	companion
List("Marker: uTest first test", "Marker: uTest second test", "Marker: uTest prefix test", "Marker: uTest Other first test")	List[Nothing]	inUTestPackage
converter.ideaToMeta(holder)	Tree	converted
SettingQueryHandler(settingName, taskName, projectUri, projectName, comm)	SettingQueryHandler	handler
if (expansion.removeCompanionObject) { val companion = holder match { case td: ScTypeDefinition => td.baseCompanionModule case _ => None } companion.map { o => o.getParent.getNode.removeChild(o.getNode) o.getText } } else None	Option[Nothing]	savedCompanion
converter.toAnnotCtor(annot)	Term.New	convertedAnnot
if (pat.isMultiLineString) scala.meta.dialects.QuasiquotePat(m.Dialect.standards("Scala211"), multiline = true) else scala.meta.dialects.QuasiquotePat(m.Dialect.standards("Scala211"), multiline = false)	Dialect	qqDialect
m.Lit.Unit(())	Lit.Unit	unit
dialect(text)	(Dialect, Input)	p
annot.typeElement match { case pe: ScParameterizedTypeElement => pe.typeArgList.typeArgs.map(converter.toType) case _ => Nil }	Seq[Type]	typeArgs
finallyBlock.collect { case ScFinallyBlock(expr) => expression(expr) }	Option[Term]	fblk
generateDoc(sbtContent)	String	actualDoc
convertedAnnot.asInstanceOf[AnyRef] +: typeArgs :+ converted.asInstanceOf[AnyRef]	IndexedSeq[AnyRef]	compiledArgs
Await.result( comm.command(commandBefore, showShell = false).flatMap { _ => handler.getSettingValue() }, Duration(timeoutSeconds, TimeUnit.SECONDS))	String	res
getCompiledMetaAnnotClass(annot)	Option[Class[_]]	maybeClass
logger.getLog	String	log
SettingQueryHandler(settingName, setTaskName, projectUri, projectName, comm)	SettingQueryHandler	setHandler
Await.result(setHandler.setSettingValue(expectedValue).flatMap { _ => handler.getSettingValue() }, Duration(timeoutSeconds, "second"))	String	res
ModuleManager.getInstance(getProject).findModuleByName(moduleName)	Module	module
config.getProject	Project	project
ProjectRootManager.getInstance(project).getProjectSdk	Sdk	sdk
Promise[Int]	Promise[Int]	runComplete
Executor.EXECUTOR_EXTENSION_NAME.findExtension(classOf[DefaultRunExecutor])	Executor	executor
SettingQueryHandler(settingName, addTaskName, projectUri, projectName, comm)	SettingQueryHandler	addHandler
new ExecutionEnvironmentBuilder(project, executor)	ExecutionEnvironmentBuilder	executionEnvironmentBuilder
SmartJDKLoader.getOrCreateJDK()	Sdk	sdk
new ImportSpecBuilder(project, SbtProjectSystem.Id).build()	ImportSpec	importSpec
executionEnvironmentBuilder .runProfile(config) .build()	ExecutionEnvironment	executionEnvironment
ProjectJdkTable.getInstance()	ProjectJdkTable	jdkTable
myRunner.getProcessHandler	ProcessHandler	handler
_	SbtShellCommunication	myComm
_	SbtShellRunner	myRunner
new ProcessLogger	ProcessLogger	logger
Version("0.13.18")	Version	sbtVersion
new StringBuilder()	StringBuilder	logBuilder
new ProcessAdapter { override def processTerminated(event: ProcessEvent): Unit = if (!runComplete.isCompleted) runComplete.success(event.getExitCode) }	ProcessAdapter { def processTerminated(event: ProcessEvent): Unit }	runCompleteListener
Promise.apply[Int]()	Promise[Int]	termination
createSbtFile(sbtContent)	PsiFile	file
new SbtDocumentationProvider	SbtDocumentationProvider	documentationProvider
new ProgramRunner.Callback { override def processStarted(descriptor: RunContentDescriptor): Unit = { descriptor.getProcessHandler.addProcessListener(runCompleteListener) } }	ProgramRunner.Callback { def processStarted(descriptor: RunContentDescriptor): Unit }	callback
(maybeClass, maybeClass.map(_.getClassLoader)) match { case (Some(clazz), Some(_: MetaClassLoader)) => Right(runAdapterString(clazz, compiledArgs)) case (Some(clazz), _) => Right(runDirect(clazz, compiledArgs)) case (None, _) => Left("Meta annotation class could not be found") }	Either[Nothing, Tree]	errorOrTree
s"""import sbt._ |import sbt.KeyRanks._ |$sbtContent |""".stripMargin.withNormalizedSeparator	String	fileText
catchBlock match { case Some(ScCatchBlock(clauses)) if clauses.caseClauses.size == 1 => m.Term.TryWithTerm(tryTerm, clauses.caseClause.expr.map(expression).getOrElse(unreachable), fblk) case Some(ScCatchBlock(clauses)) => m.Term.TryWithCases(tryTerm, Seq(clauses.caseClauses.map(caseClause):_*), fblk) case None => m.Term.TryWithCases(tryTerm, Seq.empty, fblk) case _ => unreachable }	Term	res
file.findElementAt(myFixture.getEditor.getCaretModel.getOffset)	PsiElement	elementAtCaret
Await.result(runComplete.future, 3.minutes)	Int	exitCode
new Attribute[String]("name") with ProjectAttribute with ModuleAttribute with LibraryAttribute	DslUtils.Attribute[String] with ExternalSystemDataDsl.ProjectAttribute with ExternalSystemDataDsl.ModuleAttribute with ExternalSystemDataDsl.LibraryAttribute	name
new Attribute[String]("projectId") with ProjectAttribute with ModuleAttribute	DslUtils.Attribute[String] with ExternalSystemDataDsl.ProjectAttribute with ExternalSystemDataDsl.ModuleAttribute	projectId
new Attribute[URI]("projectUri") with ProjectAttribute with ModuleAttribute	DslUtils.Attribute[Any] with ExternalSystemDataDsl.ProjectAttribute with ExternalSystemDataDsl.ModuleAttribute	projectURI
new Attribute[String]("ideDirectoryPath") with ProjectAttribute	DslUtils.Attribute[String] with ExternalSystemDataDsl.ProjectAttribute	ideDirectoryPath
new Attribute[String]("linkedProjectPath") with ProjectAttribute	DslUtils.Attribute[String] with ExternalSystemDataDsl.ProjectAttribute	linkedProjectPath
60	Int	timeout
e.expr.getOrElse(unreachable("generator has no expression"))	ScExpression	expr
new Attribute[String]("moduleFileDirectoryPath") with ModuleAttribute	DslUtils.Attribute[String] with ExternalSystemDataDsl.ModuleAttribute	moduleFileDirectoryPath
new Attribute[String]("externalConfigPath") with ModuleAttribute	DslUtils.Attribute[String] with ExternalSystemDataDsl.ModuleAttribute	externalConfigPath
new Attribute[Seq[library]]("libraries") with ProjectAttribute with ModuleAttribute	DslUtils.Attribute[Seq[ExternalSystemDataDsl.library]] with ExternalSystemDataDsl.ProjectAttribute with ExternalSystemDataDsl.ModuleAttribute	libraries
e.expr.getOrElse(unreachable("guard has no condition"))	ScExpression	expr
new Attribute[Seq[module]]("modules") with ProjectAttribute	DslUtils.Attribute[Seq[ExternalSystemDataDsl.module]] with ExternalSystemDataDsl.ProjectAttribute	modules
Seq( "-g:source", "-Xplugin:test-plugin.jar", "-Xexperimental", "-P:continuations:enable", "-deprecation", "-language:dynamics", "-language:existentials", "-explaintypes", "-feature", "-language:higherKinds", "-language:implicitConversions", "-language:macros", "-optimise", "-language:postfixOps", "-language:reflectiveCalls", "-no-specialization", "-unchecked", "-nowarn", "-XmyCoolAdditionalOption" )	Seq[Nothing]	options
new Attribute[Seq[module]]("moduleDependencies") with ModuleAttribute	DslUtils.Attribute[Seq[ExternalSystemDataDsl.module]] with ExternalSystemDataDsl.ModuleAttribute	moduleDependencies
e.expr.getOrElse(unreachable("forBinding has no expression"))	ScExpression	expr
new Attribute[Seq[library]]("libraryDependencies") with ModuleAttribute	DslUtils.Attribute[Seq[ExternalSystemDataDsl.library]] with ExternalSystemDataDsl.ModuleAttribute	libraryDependencies
ModuleManager.getInstance(getProject).findModuleByName("Module 1")	Module	module
sel.importedName.getOrElse { throw new AbortException("Imported name is null") }	String	importedName
new Attribute[Seq[Node[_]]]("arbitraryNodes") with ProjectAttribute with ModuleAttribute with LibraryAttribute	DslUtils.Attribute[Seq[Node[_]]] with ExternalSystemDataDsl.ProjectAttribute with ExternalSystemDataDsl.ModuleAttribute with ExternalSystemDataDsl.LibraryAttribute	arbitraryNodes
Seq( "-g:none", "-nowarn", "-deprecation", "-target", "1.8", "-Werror" )	Seq[Nothing]	options
new ProjectNode( attributes.getOrFail(name), attributes.getOrFail(ideDirectoryPath), attributes.getOrFail(linkedProjectPath))	ProjectNode	node
sel.reference.getOrElse { throw new AbortException("Reference is null") }	ScStableCodeReference	reference
attributes.get(modules).getOrElse(Seq.empty)	Seq[ExternalSystemDataDsl.module]	allModules
t.getModifierList.accessModifier match { case Some(mod) => mod.idText match { case Some(qual) => m.Name.Indeterminate(qual) case None => m.Name.Anonymous() } case None => m.Name.Anonymous() }	Name with Name.Qualifier	name
ScalaCompilerConfiguration.instanceIn(getProject).getSettingsForModule(module)	ScalaCompilerSettings	compilerConfiguration
t match { case param: params.ScClassParameter => extractClassParameter(param) case _ => Seq.empty }	Seq[Mod]	classParam
ModuleNode.combinedId(moduleName, Option(uri))	String	id
new project { name := getProject.getName ideDirectoryPath := getProject.getBasePath linkedProjectPath := getProject.getBasePath arbitraryNodes += new ModuleExtNode(ModuleExtData(Some("2.11.5"))) }.build.toDataNode	DataNode[ProjectData]	testProject
{ val allModules = attributes.get(modules).getOrElse(Seq.empty) allModules.map(m => (m, m.build)).toMap }	Map[ExternalSystemDataDsl.module, ModuleNode]	moduleToNode
ModuleManager.getInstance(getProject).findModuleByName("Module 1")	Module	sbtModule
ProjectJdkTable.getInstance().findJdk(IdeaTestUtil.getMockJdk18.getName)	Sdk	jdk
if (imports.nonEmpty) imports else Sbt.DefaultImplicitImports	Seq[String]	expected
attributes.get(libraries).getOrElse(Seq.empty)	Seq[ExternalSystemDataDsl.library]	allLibraries
new project { name := getProject.getName ideDirectoryPath := getProject.getBasePath linkedProjectPath := getProject.getBasePath arbitraryNodes += new SbtBuildModuleNode(SbtBuildModuleData(Seq("some import"), Set.empty[SbtResolver], new URI("somewhere"))) }.build.toDataNode	DataNode[ProjectData]	testProject
CompilerConfiguration.getInstance(getProject)	CompilerConfiguration	compilerConfiguration
new library { name := s"org.scala-lang:scala-library:$evictedVersion" }	ExternalSystemDataDsl.library	evictedScalaLibrary
new library { name := s"org.scala-lang:scala-library:$newVersion" }	ExternalSystemDataDsl.library	newScalaLibrary
for { modifier <- t.getModifierList.accessModifier.toSeq term = if (modifier.isThis) m.Term.This(name) else name newTerm = if (modifier.isPrivate) m.Mod.Private(term) else m.Mod.Protected(term) } yield newTerm	IndexedSeq[Mod]	common
new project { name := getProject.getName ideDirectoryPath := getProject.getBasePath linkedProjectPath := getProject.getBasePath arbitraryNodes += new SbtProjectNode(SbtProjectData(Seq.empty, None, Seq.empty, "", getProject.getBasePath)) val evictedScalaLibrary: library = new library { name := s"org.scala-lang:scala-library:$evictedVersion" } val newScalaLibrary: library = new library { name := s"org.scala-lang:scala-library:$newVersion" } libraries ++= Seq(evictedScalaLibrary, newScalaLibrary) modules += new javaModule { val uri = new File(getProject.getBasePath).toURI val moduleName = "Module 1" projectId := ModuleNode.combinedId(moduleName, Option(uri)) projectURI := uri name := moduleName moduleFileDirectoryPath := getProject.getBasePath + "/module1" externalConfigPath := getProject.getBasePath + "/module1" libraryDependencies += newScalaLibrary arbitraryNodes += new ModuleExtNode(ModuleExtData(Some(evictedVersion))) } }.build.toDataNode	DataNode[ProjectData]	projectData
Seq( "-Xmx2G", "-Dhoodlump=bloom" )	Seq[Nothing]	expected
if (t.hasModifierPropertyScala("case")) Seq(m.Mod.Case()) else Nil	Seq[Mod.Case]	caseMod
{ val allLibraries = attributes.get(libraries).getOrElse(Seq.empty) allLibraries.map(l => (l, l.build)).toMap }	Map[ExternalSystemDataDsl.library, LibraryNode]	libraryToNode
new AttributeMap	DslUtils.AttributeMap	attributes
new ModuleNode( typeId, attributes.getOrFail(projectId), attributes.getOrFail(projectURI), attributes.getOrFail(name), attributes.getOrFail(moduleFileDirectoryPath), attributes.getOrFail(externalConfigPath) )	ModuleNode	node
StdModuleTypes.JAVA.getId	String	typeId
new LibraryNode(attributes.getOrFail(name), true)	LibraryNode	node
args.map(_.toString).toArray	Array[Any]	convertedArgs
if (t.hasModifierPropertyScala("final")) Seq(m.Mod.Final()) else Nil	Seq[Mod.Final]	finalMod
JavacConfiguration.getOptions(getProject, classOf[JavacConfiguration])	JpsJavaCompilerOptions	compilerOptions
JvmOpts.loadFrom(optsDir)	Seq[String]	opts
SbtProjectSettings.default	SbtProjectSettings	projectSettings
if(t.hasModifierPropertyScala("implicit")) Seq(m.Mod.Implicit()) else Nil	Seq[Mod.Implicit]	implicitMod
Seq( "-Dsbt.boot.directory=/some/where/sbt/boot", "-Dsbt.global.base=/some/where/else/sbt", "-Dsbt.ivy.home=/some/where/ivy", "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=4711" )	Seq[Nothing]	expected
detectSbtVersion(tmpDirFile, launcherFile)	String	actualVersion
if (t.hasModifierPropertyScala("sealed")) Seq(m.Mod.Sealed()) else Nil	Seq[Mod.Sealed]	sealedMod
t match { case ah: ScAnnotationsHolder => Seq(ah.annotations.filterNot(_ == annotationToSkip).map(toAnnot):_*) case _ => Seq.empty }	Seq[Mod.Annot]	annotations
SbtOpts.loadFrom(optsDir)	Seq[String]	opts
if (t.hasModifierProperty("override")) Seq(m.Mod.Override()) else Nil	Seq[Mod.Override]	overrideMod
scala.collection.mutable.ListBuffer[m.Mod]()	ListBuffer[Mod]	mods
new Attribute[Seq[library]]("libraries") with ProjectAttribute with ModuleAttribute	DslUtils.Attribute[Seq[ProjectStructureDsl.library]] with ProjectStructureDsl.ProjectAttribute with ProjectStructureDsl.ModuleAttribute	libraries
new Attribute[Seq[module]]("modules") with ProjectAttribute	DslUtils.Attribute[Seq[ProjectStructureDsl.module]] with ProjectStructureDsl.ProjectAttribute	modules
detectSbtVersion(tmpDirFile, sbtLaunchJar)	String	actualVersion
new Attribute[SdkReference]("sdk") with ProjectAttribute with ModuleAttribute	DslUtils.Attribute[SdkReference] with ProjectStructureDsl.ProjectAttribute with ProjectStructureDsl.ModuleAttribute	sdk
Scala_2_11	Scala_2_11.type	scalaVersion
s"""|Manifest-Version: 1.0 |Implementation-Vendor: com.example |Implementation-Title: launcher |Implementation-Version: $implementationVersion |Main-Class: com.example.Main """.stripMargin	String	manifestContents
new Attribute[LanguageLevel]("languageLevel") with ProjectAttribute with ModuleAttribute	DslUtils.Attribute[LanguageLevel] with ProjectStructureDsl.ProjectAttribute with ProjectStructureDsl.ModuleAttribute	languageLevel
new Attribute[URI]("sbtBuildURI") with ModuleAttribute	DslUtils.Attribute[Any] with ProjectStructureDsl.ModuleAttribute	sbtBuildURI
new Attribute[String]("sbtProjectId") with ModuleAttribute	DslUtils.Attribute[String] with ProjectStructureDsl.ModuleAttribute	sbtProjectId
scalaLibraryDescription	DependencyManagerBase.DependencyDescription	dependency
{ val dependency = scalaLibraryDescription new library(s"sbt: $dependency:jar") { classes += DependencyManager.resolveSingle(dependency).file.getAbsolutePath } }	ProjectStructureDsl.library	scalaLibrary
new Attribute[Seq[String]]("contentRoots") with ModuleAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.ModuleAttribute	contentRoots
new Attribute[Seq[String]]("sources") with ModuleAttribute with LibraryAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.ModuleAttribute with ProjectStructureDsl.LibraryAttribute	sources
convertMods(param) ++ (if (param.isImplicitParameter) Seq(m.Mod.Implicit()) else Seq.empty)	IndexedSeq[Mod]	mods
new module("foo") { moduleDependencies += new dependency(bar) { isExported := true } }	ProjectStructureDsl.module	foo
new module("bar")	ProjectStructureDsl.module	bar
new Attribute[Seq[String]]("testSources") with ModuleAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.ModuleAttribute	testSources
new module("multiModule")	ProjectStructureDsl.module	root
new Attribute[Seq[String]]("resources") with ModuleAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.ModuleAttribute	resources
new library("sbt: unmanaged-jars") { classes += (testProjectDir / "lib" / "unmanaged.jar").getAbsolutePath }	ProjectStructureDsl.library	unmanagedLibrary
param.getActualDefaultExpression.map(expression)	Option[Term]	default
new Attribute[Seq[String]]("testResources") with ModuleAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.ModuleAttribute	testResources
new module("sharedSources-sources") { contentRoots += getProjectPath + "/shared" ProjectStructureDsl.sources += "src/main/scala" }	ProjectStructureDsl.module	sharedSourcesModule
new module("foo") { moduleDependencies += sharedSourcesModule }	ProjectStructureDsl.module	foo
new module("bar") { moduleDependencies += sharedSourcesModule }	ProjectStructureDsl.module	bar
Parse.parseStat.apply(scala.meta.Input.String(result), Dialect.standards("Scala212"))	Parsed[Stat]	parsed
new Attribute[Seq[String]]("excluded") with ModuleAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.ModuleAttribute	excluded
new Attribute[Seq[dependency[module]]]("moduleDependencies") with ModuleAttribute	DslUtils.Attribute[Seq[ProjectStructureDsl.dependency[ProjectStructureDsl.module]]] with ProjectStructureDsl.ModuleAttribute	moduleDependencies
new module("p1-sources") { contentRoots += getProjectPath + "/p1/shared" }	ProjectStructureDsl.module	sharedModule
new module("p1") { moduleDependencies += sharedModule contentRoots += getProjectPath + "/p1/jvm" }	ProjectStructureDsl.module	jvmModule
new Attribute[Seq[dependency[library]]]("libraryDependencies") with ModuleAttribute	DslUtils.Attribute[Seq[ProjectStructureDsl.dependency[ProjectStructureDsl.library]]] with ProjectStructureDsl.ModuleAttribute	libraryDependencies
new module("scl12520") {}	ProjectStructureDsl.module	rootModule
new module("scl12520-build") {}	ProjectStructureDsl.module	rootBuildModule
new Attribute[Seq[String]]("classes") with LibraryAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.LibraryAttribute	classes
(module: Module) => module.getName	ProjectStructureMatcher.HasName[Module]	ideaModuleNameImplicit
new module("root") { sbtBuildURI := buildURI sbtProjectId := "root" moduleDependencies += new dependency(c1) { isExported := true } moduleDependencies += new dependency(c2) { isExported := true } }	ProjectStructureDsl.module	base
new Attribute[Seq[String]]("javadocs") with LibraryAttribute	DslUtils.Attribute[Seq[String]] with ProjectStructureDsl.LibraryAttribute	javadocs
new module("root") { sbtBuildURI := buildURI.resolve("c1") sbtProjectId := "root" }	ProjectStructureDsl.module	c1
new module("root") { sbtBuildURI := buildURI.resolve("c2") sbtProjectId := "root" }	ProjectStructureDsl.module	c2
new Attribute[Boolean]("isExported") with DependencyAttribute	DslUtils.Attribute[Boolean] with ProjectStructureDsl.DependencyAttribute	isExported
(library: Library) => library.getName	ProjectStructureMatcher.HasName[Library]	ideaLibraryNameImplicit
scalaLibraryVersion.map { version => new library { name := "org.scala-lang:scala-library:" + version } }	Option[ExternalSystemDataDsl.library]	scalaLibrary
new Attribute[DependencyScope]("scope") with DependencyAttribute	DslUtils.Attribute[DependencyScope] with ProjectStructureDsl.DependencyAttribute	scope
(entry: roots.ModuleOrderEntry) => entry.getModuleName	ProjectStructureMatcher.HasName[ModuleOrderEntry]	ideaModuleEntryNameImplicit
(entry: roots.LibraryOrderEntry) => entry.getLibraryName	ProjectStructureMatcher.HasName[LibraryOrderEntry]	ideaLibraryEntryNameImplicit
reference.name	String	name
(module: Module) => module	ProjectStructureMatcher.HasModule[Module]	ideaModuleImplicit
(entry: roots.ModuleOrderEntry) => entry.getModule	ProjectStructureMatcher.HasModule[ModuleOrderEntry]	ideaModuleEntryModuleImplicit
SharedSourcesModuleType.instance.getId	String	typeId
new project { name := getProject.getName ideDirectoryPath := getProject.getBasePath linkedProjectPath := getProject.getBasePath modules += new module { val uri = new File(getProject.getBasePath).toURI val moduleName = "Module 1" val typeId: String = SharedSourcesModuleType.instance.getId projectId := ModuleNode.combinedId(moduleName, Option(uri)) projectURI := uri name := moduleName moduleFileDirectoryPath := getProject.getBasePath + "/module1" externalConfigPath := getProject.getBasePath + "/module1" } arbitraryNodes += new SbtProjectNode(SbtProjectData(Seq.empty, None, Seq.empty, "", getProject.getBasePath)) }.build.toDataNode	DataNode[ProjectData]	testProject
ProjectJdkTable.getInstance()	ProjectJdkTable	projectJdkTable
LanguageLevelProjectExtension.getInstance(getProject)	LanguageLevelProjectExtension	languageLevelProjectExtension
languageLevelProjectExtension.getLanguageLevel	LanguageLevel	actualLanguageLevel
new SbtProjectSettings	SbtProjectSettings	settings
ModuleManager.getInstance(project).getModules.toSeq	Seq[Module]	actualModules
s"$testdataPath/${getTestName(false)}.sbt"	String	filePath
ModuleManager.getInstance(getProject).newModule(moduleName, SbtModuleType.instance.getId)	Module	module
inWriteAction { val moduleName = getModule.getName + Sbt.BuildModuleSuffix + ".iml" val module = ModuleManager.getInstance(getProject).newModule(moduleName, SbtModuleType.instance.getId) ModuleRootModificationUtil.setModuleSdk(module, getTestProjectJdk) module }	Module	module
SbtBundle("sbt.annotation.unresolvedDependency")	String	msg
ModuleManager.getInstance(getProject)	ModuleManager	moduleManager
moduleManager.getModules	Array[Module]	modules
{ val moduleManager = ModuleManager.getInstance(getProject) val modules = moduleManager.getModules assertEquals(1, modules.length) modules(0) }	Module	module
ModuleRootManager.getInstance(getModule)	ModuleRootManager	moduleRootManager
LanguageLevelModuleExtensionImpl.getInstance(getModule)	LanguageLevelModuleExtensionImpl	languageLevelModuleExtension
languageLevelModuleExtension.getLanguageLevel	LanguageLevel	actualLanguageLevel
loadTestFile()	SbtFileImpl	testFile
LocalFileSystem.getInstance .findFileByPath(filePath.replace(File.separatorChar, '/'))	VirtualFile	file
new module("SCL-14635") { sbtBuildURI := buildURI sbtProjectId := "SCL-14635" }	ProjectStructureDsl.module	base
new module("sbt-idea-plugin") { sbtBuildURI := new URI("git://github.com/JetBrains/sbt-idea-plugin") }	ProjectStructureDsl.module	ideaPlugin
roots.ModuleRootManager.getInstance(module).getContentEntries.map(_.getUrl)	IndexedSeq[Nothing]	actualRoots
loadTestFile()	SbtFileImpl	file
new module("sbt-idea-plugin-build", buildModulesGroup) {}	ProjectStructureDsl.module	ideaPluginBuild
new module("sbt-idea-shell") { sbtBuildURI := new URI("git://github.com/JetBrains/sbt-idea-shell") }	ProjectStructureDsl.module	ideaShell
new module("sbt-idea-shell-build", buildModulesGroup) {}	ProjectStructureDsl.module	ideaShellBuild
new module("sbt-ide-settings") { sbtBuildURI := new URI("https://github.com/JetBrains/sbt-ide-settings.git") }	ProjectStructureDsl.module	ideSettings
getSingleContentRoot(module)	ContentEntry	contentRoot
new module("sbt-ide-settings-build", buildModulesGroup) {}	ProjectStructureDsl.module	ideSettingsBuild
super.loadTestFile()	SbtFileImpl	result
new module("crossplatform")	ProjectStructureDsl.module	root
new module("crossJS", Array("cross"))	ProjectStructureDsl.module	crossJS
new module("crossJVM", Array("cross"))	ProjectStructureDsl.module	crossJVM
new module("crossNative", Array("cross"))	ProjectStructureDsl.module	crossNative
testResolver.getIndex(myProject).get	ResolverIndex	index
new module("cross-sources", Array("cross"))	ProjectStructureDsl.module	crossSources
loadTestFile()	SbtFileImpl	element
new AnnotatorHolderMock(element)	AnnotatorHolderMock	mock
new SbtDependencyAnnotator	SbtDependencyAnnotator	annotator
new ScalaRecursiveElementVisitor { override def visitLiteral(lit: ScLiteral) { annotator.annotate(lit, mock) super.visitLiteral(lit) } }	ScalaRecursiveElementVisitor { def visitLiteral(lit: ScLiteral): Unit }	visitor
s"/${TestUtils.getTestDataPath + "/"}/sbt/resolvers/testIvyCache"	String	root
new SbtIvyResolver("Test repo", root)	SbtIvyResolver	resolver
resolver.getIndex(getProject).get	ResolverIndex	index
actual.map { folder => val folderUrl = folder.getUrl if (folderUrl.startsWith(contentRoot.getUrl)) folderUrl.substring(Math.min(folderUrl.length, contentRoot.getUrl.length + 1)) else folderUrl }	IndexedSeq[Any]	actualFolders
roots.ModuleRootManager.getInstance(module).getContentEntries	Array[ContentEntry]	contentRoots
ScalaPsiElementFactory.createExpressionFromText(text, file)	ScExpression	expression
getTopLevelLibraryDependencies(testFile)	Seq[ScInfixExpr]	topLevelDependencies
topLevelDependencies.head	ScInfixExpr	dep
dep.right.asInstanceOf[ScMethodCall]	ScMethodCall	call
roots.OrderEnumerator.orderEntries(module).moduleEntries	Seq[ModuleOrderEntry]	actualModuleEntries
ArtifactInfo("xx", "yy", "1.0")	ArtifactInfo	FakeArtifact_1
ArtifactInfo("xx", "yy", "2.0")	ArtifactInfo	FakeArtifact_2
SbtAnnotator.isTypeAllowed( expression, expression.`type`().get, expected )	Boolean	isAllowed
Version("0.12.4")	Version	sbtVersion
Map.empty[(Attribute[_], String), Any]	Map[(DslUtils.Attribute[_], String), Any]	attributes
Version("0.13.1")	Version	sbtVersion
Version("0.13.7")	Version	sbtVersion
attributes.get(attribute).getOrElse(Seq.empty) :+ newValue	IndexedSeq[T]	newSeq
attributes.get(attribute).getOrElse(Seq.empty) ++ newSeq	IndexedSeq[T]	seqConcat
pairModules(expected, actualModuleEntries)	Seq[(ProjectStructureDsl.dependency[ProjectStructureDsl.module], ModuleOrderEntry)]	paired
new AnnotatorHolderMock(file)	AnnotatorHolderMock	mock
new SbtAnnotator	SbtAnnotator	annotator
Version("0.12.0")	Version	v0120
Version("0.13.0")	Version	v0130
Version("0.13.17")	Version	v01317
Version("1.0.0")	Version	v100
SbtFileType	SbtFileType.type	fileType
Version("1.1.2")	Version	v112
Version("2.0.0")	Version	v200
roots.OrderEnumerator.orderEntries(module).libraryEntries	Seq[LibraryOrderEntry]	actualLibraryEntries
Version("2.2.3")	Version	v223
_	Boolean	excludeWhenTypeIsStable
factory.apply(2)	JvmMemorySize	memorySize
project.libraries	Seq[Library]	actualLibraries
new ParametersList()	ParametersList	params
Set.empty[String]	Set[String]	artifactBlackList
unit.byteMultiplier * size	Long	sizeInByte
roots.OrderEnumerator.orderEntries(module).libraryEntries.filter(_.isModuleLevel).map(_.getLibrary)	IndexedSeq[Library]	actualLibraries
ModuleManager.getInstance(actual.getProject).getModuleGroupPath(actual)	Array[Nothing]	actualPath
JavaAwareProjectJdkTableImpl.getInstanceEx	JavaAwareProjectJdkTableImpl	jdkTable
jdkTable.getAllJdks	Array[Sdk]	allJdks
Seq( Error("object Bar", SbtBundle("sbt.annotation.sbtFileMustContainOnlyExpressions")) )	Seq[Error]	sbtAll
sbtAll ++ Seq( Error("organization", SbtBundle("sbt.annotation.expressionMustConformSbt0136", "SettingKey[String]")), Error(""""some string"""", SbtBundle("sbt.annotation.expressionMustConformSbt0136", "String")), Error("null", SbtBundle("sbt.annotation.expectedExpressionTypeSbt0136")), Error("???", SbtBundle("sbt.annotation.expectedExpressionTypeSbt0136")) )	Seq[Error]	sbt_0_13_7
sbt_0_13_7	Seq[Error]	sbt_1_0
Seq( "/usr/lib/jvm", // linux style "C:\\Program Files\\Java\\", // windows style "C:\\Program Files (x86)\\Java\\", // windows 32bit style "/Library/Java/JavaVirtualMachines" // mac style )	Seq[Nothing]	candidates
e.get(sbtProjectId).get	String	id
DependencyManager	DependencyManagerBase	dependencyManager
new CommonProcessors.CollectProcessor[roots.OrderEntry]	CommonProcessors.CollectProcessor[OrderEntry]	processor
SmartJDKLoader.discoverJDK(jdkVersion)	Option[String]	pathOption
size + unit.unitSuffix	String	testString
JvmMemorySize.parse(testString)	Option[JvmMemorySize]	parsedOpt
parsedOpt.get	JvmMemorySize	parsed
binaryDependencies	List[DependencyManagerBase.DependencyDescription]	dependencies
DependencyManager.resolve(dependencies: _*)	Seq[DependencyManagerBase.ResolvedDependency]	resolved
s"$what mismatch\nExpected [ ${expected.toList} ]\nActual [ ${actual.toList} ]"	String	errorMessage
module.libraries.map(_.getName) .contains(name)	Boolean	alreadyExistsInModule
this.path	String	path
"Test has passed, but was supposed to fail"	String	failingPassed
allTestVersions.filter(supportedIn)	SortedSet[ScalaVersion]	allSupportedVersions
mutable.ListBuffer.empty[LibraryLoader]	ListBuffer[LibraryLoader]	myLoaders
ScalaSdkOwner.configuredScalaVersion.exists(!supportedIn(_))	Boolean	skip
Scala_2_10	ScalaVersion	defaultSdkVersion
SortedSet(ScalaVersion.allScalaVersions: _*)	SortedSet[ScalaVersion]	allTestVersions
{ scala.util.Properties.envOrNone("SCALA_SDK_TEST_VERSION").map( ScalaVersion.fromString(_).filter(allTestVersions.contains).getOrElse( throw new AssertionError( "Scala SDK Version specified in environment variable SCALA_SDK_TEST_VERSION is not one of " + allTestVersions.mkString(", ") ) ) ) }	Option[ScalaVersion]	configuredScalaVersion
Seq(s"1.$versionMajor", s"-$versionMajor")	Seq[String]	versionStrings
_	CodeInsightTestFixture	fixture
IdeaTestFixtureFactory.getFixtureFactory.createFixtureBuilder("SimpleTestCase")	TestFixtureBuilder[IdeaProjectTestFixture]	fixtureBuilder
getFixture.getEditor	Editor	editor
Seq( currentJava(), Option(sys.env.getOrElse(s"JDK_1${versionMajor}_x64", sys.env.getOrElse(s"JDK_1$versionMajor", null)) ).map(_+"/jre") // teamcity style )	Seq[Option[Any]]	priorityPaths
for { ResolvedDependency(_, file) <- resolved if file.exists() } yield file	IndexedSeq[Any]	compilerClasspath
false	Boolean	includeReflectLibrary
paths flatMap { p => versionStrings.map((p, _)) }	IndexedSeq[(String, String)]	fullSearchPaths
caretOffsets.map { offset => new CaretState(editor.offsetToLogicalPosition(offset), null, null) }	IndexedSeq[CaretState]	caretStates
false	Boolean	stripTrailingSpaces
_	Module	myModule
new ScalaSDKLoader(isIncludeReflectLibrary)	ScalaSDKLoader	scalaLoader
sourceRootPath	String	path
scala.collection.JavaConverters.asScalaBuffer(back)	mutable.Buffer[Nothing]	result
List.fill(level)(" ").mkString	String	indent
additionalLibraries	Seq[LibraryLoader]	addLibs
ProjectJdkTable.getInstance.getAllJdks	Array[Sdk]	allJdks
new Array[ThirdPartyLibraryLoader](0)	Array[ThirdPartyLibraryLoader]	EMPTY_LOADERS_ARRAY
parseText(before).asInstanceOf[ScalaFileImpl]	ScalaFileImpl	file
getFixture.configureByFile("foo/Definitions.scala")	PsiFile	currentFile
getFixture.configureByFile("foo/SamePackage.scala")	PsiFile	samePackage
getFixture.configureByFile("foo/bar/InnerPackage.scala")	PsiFile	innerPackage
(_: RecursiveReferences).tailRecursionOnly	statements.RecursiveReferences => Boolean	tailRecursion
getFixture.configureByFile("baz/OtherPackage.scala")	PsiFile	otherPackage
selectElement[ScNamedElement](file, origin)	ScNamedElement	originElem
(_: RecursiveReferences).ordinaryRecursive.nonEmpty	statements.RecursiveReferences => Boolean	ordinaryRecursion
overriding.map(selectElement[ScNamedElement](file, _))	IndexedSeq[ScNamedElement]	expectedOverridingMembers
parseAsFunction(code).returnUsages.map(_.getText)	IndexedSeq[Nothing]	actual
findByName[Named](currentFile, elementName)	Named	definition
normalize(text, stripTrailingSpaces)	String	textNormalized
parseAsFunction(code).body.get.calculateTailReturns.map(_.getText)	IndexedSeq[Nothing]	actual
ScalaOverridingMemberSearcher.search(originElem, withSelfType = true)	Array[PsiNamedElement]	foundOverridingMembers
origin.last	String	name
caretIndex(idx + 1)	Int	nextIdx
foundOverridingMembers.filter(!expectedOverridingMembers.contains(_))	Array[PsiNamedElement]	notFoundMembers
collectCaretIndices(caretIndex(0))(Seq[Int]())	Seq[Int]	caretIndices
parseAsFunction(code).recursiveReferencesGrouped	statements.RecursiveReferences	references
caretIndices.zipWithIndex.map { case (caretIdx, idx) => caretIdx - idx * CARET_TAG.length }	IndexedSeq[Int]	caretIndicesNormalized
psiFunction(named)	PsiElement	element
s""" |object Test { | private class A { | def ${CARET_TAG}foo() = 1 | } |} """.stripMargin	String	code
named.asInstanceOf[ScFunction].containingClass	ScTemplateDefinition	containingClass
containingClass.getContainingClass	PsiClass	topLevelObject
code.parse[ScExpression]	ScExpression	exp
exp.`type`().get	ScType	actual
LightPlatformTestCase.getSourceRoot match { case sourceRoot if packageName == null => sourceRoot case sourceRoot => sourceRoot.createChildDirectory(null, packageName) }	VirtualFile	root
root.createChildData(null, className + ".java")	VirtualFile	file
ScalaLibraryProperties( ScalaCompilerVersion(compilerClasspath.head), compilerClasspath )	ScalaLibraryProperties	properties
new ExistingLibraryEditor(library, null)	ExistingLibraryEditor	editor
typify(definition, application)	(Any, Any)	typified
s""" |{ | class Base | class A extends Base | class B extends Base | object A extends A | object B extends B | case class Fun[A, B](a: A, rest: B*) | | $code } """.stripMargin	String	testCode
configureFromFileText(testCode).asInstanceOf[ScalaFile]	ScalaFile	file
file.getFirstChild.asInstanceOf[ScalaPsiElement]	ScalaPsiElement	root
_	PsiElement	parent
_	PsiElement	prevSibling
_	PsiElement	nextSibling
children.headOption.orNull	PsiElement	firstChild
children.lastOption.orNull	PsiElement	lastChild
file.findElementAt(index)	PsiElement	element
new ScalaConstantExpressionEvaluator()	ScalaConstantExpressionEvaluator	evaluator
if(preface.isEmpty) code else preface + "; " + code	String	line
parseText(fileText)	ScalaFile	psiFile
(1 to types.size).map("T" + _)	IndexedSeq[Any]	ids
myFixture.getEditor match { case impl: EditorImpl => impl }	EditorImpl	editor
ids.toIterator	Iterator[Any]	id
psiFile.asInstanceOf[PsiFileImpl].calcStubTree()	StubTree	stubTree
classTag[T].runtimeClass.asInstanceOf[Class[T]]	Class[T]	psiClazz
editor.getHighlighter match { case impl: LexerEditorHighlighter => impl }	LexerEditorHighlighter	highlighter
segments()	SegmentArrayWithData	actualSegments
segments()	SegmentArrayWithData	expectedSegments
ScalaCompilerConfiguration.instanceIn(getProjectAdapter).defaultProfile	ScalaCompilerSettingsProfile	defaultProfile
defaultProfile.getSettings	ScalaCompilerSettings	newSettings
s""" |object dummy { | val a = 1 | val b = "ololo"$CARET_MARKER | val c = s"ololo$$a" |} """.stripMargin	String	text
ScalaCompilerConfiguration.instanceIn(getProject).defaultProfile	ScalaCompilerSettingsProfile	defaultProfile
s""" |object ololo { | val x = s"aaa $${val y = s"ccc $${val z = s"eee $CARET_MARKER fff"} ddd"} bbb" |} """.stripMargin	String	text
folderPath + getTestName(false) + ".scala"	String	filePath
s""" |class Test { | val test1 = <div></div> |} | |class Test2 {$CARET_MARKER} """.stripMargin	String	before
normalize(text)	String	normalized
s""" |class Test { | val test1 = <div></div> |} | |class Test2 { | $CARET_MARKER |} """.stripMargin	String	after
s"""package es.fcc.bibl.bd import javax.xml.parsers.DocumentBuilderFactory /** Sincronizacion bidireccional del contenido de tablas con el servidor. * * * Uso: * - Establecer antes autentificacion si es necesario: {{{ * Authenticator.setDefault(new Authenticator() { * override def getPasswordAuthentication() = new PasswordAuthentication("miusuario", "micontrasea") * }) * }}} * Pendiente: * - Soporte de redirecciones * Ver https://fccmadoc.atlassian.net/browse/RDS-4858 para especificaciones. * * @param servidor Servidor a donde enviar, sin dominio fccma.com * de las tablas de las que se depende. * @param mensaje Mensaje que aparecen en la notificacion de progreso.*/ class Sincronizador(servidor: String, ruta: String, soporte: String, tblsProcesar: Seq[TablaBase] = Seq(), params: Map[String, String] = Map.empty, mensaje: String = "Sincronizar datos")(implicit ctx: Activity) { protected val msj = ListBuffer[String]() /** Subconjunto de [[tblsProcesar]] que van sincronizadas bidireccionalmente.*/ protected val tblsEnviar = tblsProcesar.collect { case t: TablaSincronizada[_] => t } future { val url = s"https://$$servidor.fccma.com/fccma/" if (hayErrores) notif.setSmallIcon(R.drawable.stat_notify_sync_error) notif.setOngoing(false) if (msj.size > 0) { val detalles = new NotificationCompat.InboxStyle() detalles.setBigContentTitle("Avisos:") msj.foreach(detalles.addLine(_)) notif.setStyle(detalles) } notifica() } /** Fabrica el XML que va dentro de la peticion. * Metodo con test.*/ protected[bd] def fabricaXml(os: OutputStream) { val esc = new OutputStreamWriter(os, "UTF-8") esc.write(s"Content-Type: multipart/mixed;boundary=$$frontera\r\n") iniBloque() val totalFilas = (for (t <- tblsEnviar) yield t.cuantos).sum val gen = new GeneradorNombresFichero notif.setContentText("Enviando cambios locales") notif.setProgress(totalFilas, 0, false) notifica() var filas = 0 new EscritorXml(esc) { ele("Sincronizacion") { ele("soporte") { ele("nombre") { txt(soporte) } } } } if (gen.contador > 0) { notif.setContentTitle("Enviando binarios") notif.setProgress(gen.contador, 0, false) notifica() val gen2 = new GeneradorNombresFichero for { tbl <- tblsEnviar blob <- tbl.leeBlobs } { val fich = gen2.genera(blob) iniBloque(s${"\"\"\""}Content-Disposition:form-data;name="$$fich";filename="$$fich" $CARET_MARKER${"\"\"\""}, "Content-Transfer-Encoding:binary") // No hace falta seguramente pero por si acaso notif.setProgress(gen.contador, gen2.contador, false) notifica() } } // Cerrar multipart MIME esc.write(s"\r\n--$$frontera--\r\n") esc.close() } }"""	String	text
normalized.indexOf("<caret>")	Int	caretPos
getFileAdapter.asInstanceOf[ScalaFile]	ScalaFile	scalaFile
if (PsiTreeUtil.getParentOfType(scalaFile.findElementAt(startOffset), psiClazz) != null) 0 else 1	Int	addOne
PsiTreeUtil.findElementOfClassAtRange(scalaFile, startOffset + addOne, endOffset, psiClazz)	T	t
PsiTreeUtil.findElementOfClassAtOffset(getFileAdapter, caretPos, classOf[ScalaPsiElement], false).asInstanceOf[ScObject]	ScObject	exp
""" |import monocle.macros.Lenses | |object Main { | @Lenses | case class Person(name: String, age: Int, address: Address) | @Lenses | case class Address(streetNumber: Int, streetName: String) | | object <caret>Person { | import Main.Address._ | val john = Person("John", 23, Address(10, "High Street")) | age.get(john) | } |} """.stripMargin	String	fileText
scalaFile.findElementAt(scalaFile.getText.length - 1)	PsiElement	lastPsi
ScalaPsiUtil.getCompanionModule(clazz) .getOrElse(clazz.asInstanceOf[ScObject]) .allMethods .collect { case PhysicalMethodSignature(fun: ScFunctionDefinition, _) if fun.hasModifierProperty("implicit") => fun } .map(m => m.returnType) .toSet	Set[result.TypeResult]	implicitDefs0
""" package wibble import stalactite.deriving import simulacrum.typeclass @typeclass trait Wibble[T] {} object DerivedWibble { def gen[T]: Wibble[T] = new Wibble[T] {} } @deriving(Wibble) final case class <caret>Foo(string: String, int: Int) """	String	fileText
implicitDefs0.map(_.right.get.presentableText)	Set[String]	implicitDefs
""" package wibble import stalactite.deriving import simulacrum.typeclass @typeclass trait Wibble[T] {} object DerivedWibble { def gen[T]: Wibble[T] = new Wibble[T] {} } @deriving(Wibble) sealed trait <caret>Baz @deriving(Wibble) final case class Foo(string: String, int: Int) extends Baz """	String	fileText
""" package foo import io.circe.generic.JsonCodec @JsonCodec case class <caret>A(x: Int) """	String	fileText
""" package wibble import stalactite.deriving import simulacrum.typeclass @typeclass trait Wibble[T] {} object DerivedWibble { def gen[T]: Wibble[T] = new Wibble[T] {} } @deriving(Wibble) case object <caret>Caz """	String	fileText
""" package foo import io.circe.generic.extras.ConfiguredJsonCodec @ConfiguredJsonCodec case class <caret>B(x: Int) """	String	fileText
""" package foo import io.circe.generic.JsonCodec @JsonCodec case class <caret>C[A: Encoder: Decoder](x: A) """	String	fileText
configureFromFileText(normalized.replace("<caret>", ""))	PsiFile	file
PsiFileFactory.getInstance(fixture.getProject)	PsiFileFactory	fileFactory
""" package foo import io.circe.generic.JsonCodec @JsonCodec case class <caret>D[A: Encoder: Decoder, B: Encoder: Decoder](x: A, y: B) """	String	fileText
parseText("")	ScalaFile	context
""" package foo import io.circe.generic.JsonCodec @JsonCodec case object <caret>X """	String	fileText
""" package foo import io.circe.generic.JsonCodec @JsonCodec sealed trait <caret>Y """	String	fileText
""" package foo import io.circe.generic.JsonCodec @JsonCodec case class <caret>Boom(i: Int) object Boom { val something: String = "" } """	String	fileText
DummyHolderFactory.createHolder(context.getManager, context).getTreeElement	FileElement	holder
target.functions ++ target.syntheticMethods	IndexedSeq[ScFunction]	targetFunctions
new ScalaPsiBuilderImpl( PsiBuilderFactory.getInstance.createBuilder(context.getProject, holder, new ScalaLexer, ScalaLanguage.INSTANCE, s) )	ScalaPsiBuilderImpl	builder
target.allInnerTypeDefinitions	Seq[ScTypeDefinition]	targetInners
s""" |import simulacrum._ | |@typeclass trait Se${caret}migroup[A] { | @op("|+|") def append(x: A, y: A): A |} """.stripMargin	String	text
getSourceElement(text)	ScObject	semigroupObject
builder.getTreeBuilt	ASTNode	node
parseBlock(s)	PsiElement	elem
s"""def foo($CARET)"""	String	before
`object`("Semigroup")( applyMethod("Semigroup", "A"), `def`("apply", "[A] Semigroup[A] => Semigroup[A]"), `trait`("Ops[A]")( `def`("self", "A"), `def`("|+|", "A => A") ), `trait`("ToSemigroupOps") `with` `implicit`("toSemigroupOps", "[A] A => Semigroup[A] => Semigroup.Ops[A]"), `trait`("AllOps[A] extends Semigroup.Ops[A]"), `object`("nonInheritedOps extends Semigroup.ToSemigroupOps"), `object`("ops") `with` `implicit`("toAllSemigroupOps", "[A] A => Semigroup[A] => Semigroup.AllOps[A]") )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""def foo( | $CARET |)""".stripMargin	String	after
getCommonSettings(project)	CommonCodeStyleSettings	settings
s""" |import simulacrum._ | |@typeclass trait Semigroup[A] { | @op("|+|") def append(x: A, y: A): A |} | |@typeclass trait Mo${caret}noid[B] extends Semigroup[B] { | def id: A | @op(name = "<>", alias = true) | def mappend(x: B, y: B): B |} """.stripMargin	String	text
getSourceElement(text)	ScObject	monoidObject
targetFunctions.exists(_.toSynthetic == f)	Boolean	funExists
null	ScalaCodeStyleSettings	settings
ScalaApplicationSettings.getInstance.INSERT_MULTILINE_QUOTES	Boolean	settingBefore
s"""class A { | def bar = {${CARET}new T { | override def foo: Unit = () | } |} """.stripMargin	String	before
s"""def test = { | val x = if (true) 8 | else$CARET |}""".stripMargin	String	before
Seq(( s"""$qqq${CARET}some content$qqq""", s"""$qq${CARET}some content$qqq""" ), ( s"""$qqq$CARET"some content with 1 quote$qqq""", s"""$qq$CARET"some content with 1 quote$qqq""" ), ( s"""$qqq$CARET""some content with 2 quotes$qqq""", s"""$qq$CARET""some content with 2 quotes$qqq""" ), ( s"""$qqq$CARET$qqq$qqq""", s"""$qq$CARET$qqq$qqq""" ), ( s"""${qqq}some content$qqq$CARET$qqq""", s"""${qqq}some content$qq$CARET$qqq""" ), ( s"""$qqq$CARET |$qqq""".stripMargin, s"""$qq$CARET |$qqq""".stripMargin ))	Seq[(String, String)]	testData_NonEmptyString
s"""class A { | def bar = { | ${CARET}new T { | override def foo: Unit = () | } | } |} """.stripMargin	String	after
s"""def test = { | val x = if (true) 8 | else $CARET |}""".stripMargin	String	after
s"""def foo() = {$CARET | someMethod() |} """.stripMargin	String	before
Seq(( s"""$q$CARET$qq$qqq""", s"""$CARET$qq$qqq""" ), ( s"""$qq$CARET$q$qqq""", s"""$q$CARET$q$qqq""" ), ( s"""$qqq$q$CARET$qq""", s"""$qqq$CARET$qq""" ), ( s"""$qqq$q$CARET$qq |val x = 42""".stripMargin, s"""$qqq$CARET$qq |val x = 42""".stripMargin ), ( s"""$qqq$qq$CARET$q""", s"""$qqq$q$CARET$q""" ), ( s"""$qqq$qq$CARET$q |val x = 42""".stripMargin, s"""$qqq$q$CARET$q |val x = 42""".stripMargin ))	Seq[(String, String)]	testDataCaret_NotInTheMiddle
s"for (_ <- Seq()) $CARET"	String	before
s"""class A { | def bar = {$CARET??? |} """.stripMargin	String	before
`object`("Monoid")( applyMethod("Monoid", "B"), `trait`("Ops[B]")( `def`("self", "B"), `def`("<>", "B => B"), `def`("mappend", "B => B") ), `trait`("ToMonoidOps") `with` `implicit`("toMonoidOps", "[B] B => Monoid[B] => Monoid.Ops[B]"), `trait`("AllOps[B] extends Monoid.Ops[B] with Semigroup.AllOps[B]"), `object`("nonInheritedOps extends Monoid.ToMonoidOps"), `object`("ops") `with` `implicit`("toAllMonoidOps", "[B] B => Monoid[B] => Monoid.AllOps[B]"), )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""val x = 5 match { | case 1 => 2 | case$CARET |}""".stripMargin	String	before
s"for (_ <- Seq()) {$CARET}"	String	after
s"""class A { | def bar = { | $CARET??? | } |} """.stripMargin	String	after
s"""val x = 5 match { | case 1 => 2 | case $CARET |}""".stripMargin	String	after
s""" |import simulacrum._ | |@typeclass trait Functor[F[_]] { | def map[A, B](fa: F[A])(f: A => B): F[B] |} | |@typeclass trait Applicative[F[_]] extends Functor[F] { | def pure[A](a: => A): F[A] | def ap[A, B](fa: F[A])(f: F[A => B]): F[B] | override def map[A, B](fa: F[A])(f: A => B): F[B] = | ap(fa)(pure(f)) |} | |@typeclass trait Monad[F[_]] extends Applicative[F] { | @op(">>=", alias = true) def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B] | override def ap[A, B](fa: F[A])(f: F[A => B]): F[B] = | flatMap(f)(map(fa)) | override def map[A, B](fa: F[A])(f: A => B): F[B] = | flatMap(fa)(a => pure(f(a))) |} | |@typeclass trait PlusEmpty[F[_]] { | def empty[A]: F[A] |} | |@typeclass trait MonadPl${caret}us[F[_]] extends Monad[F] with PlusEmpty[F] { | self => | class WithFilter[A](fa: F[A], p: A => Boolean) { | def map[B](f: A => B): F[B] = self.map(filter(fa)(p))(f) | def flatMap[B](f: A => F[B]): F[B] = self.flatMap(filter(fa)(p))(f) | def withFilter(q: A => Boolean): WithFilter[A] = new WithFilter[A](fa, x => p(x) && q(x)) | } | | def withFilter[A](fa: F[A])(p: A => Boolean): WithFilter[A] = new WithFilter[A](fa, p) | def filter[A](fa: F[A])(f: A => Boolean) = | flatMap(fa)(a => if (f(a)) pure(a) else empty[A]) |} | """.stripMargin	String	text
s"""for (_ <- Seq()) $CARET | obj.method() | .method1() |""".stripMargin	String	before
s""" | 123 match { | case 321 =$CARET_MARKER | } """.stripMargin	String	before
getSourceElement(text)	ScObject	monadPlusObject
s"""def foo() = $CARET | someMethod() """.stripMargin	String	after
targetInners.find(_.sig == inner.sig)	Option[ScTypeDefinition]	maybeInner
s"""for (_ <- Seq()) { | ${CARET}obj.method() | .method1() |} |""".stripMargin	String	after
"\""	String	q
"\"\""	String	qq
"\"\"\""	String	qqq
s"""def foo() = {${CARET}someMethod()} """.stripMargin	String	before
tdef.name	String	name
s"""for { _ <- Seq() } $CARET | obj.method() | .method1() |""".stripMargin	String	before
s"""class A { | $qq$CARET |} |""".stripMargin	String	before
s"""for { _ <- Seq() } { | ${CARET}obj.method() | .method1() |} |""".stripMargin	String	after
s""" | 123 match { | case 321 ${ScalaTypedHandler.unicodeCaseArrow}$CARET_MARKER | } """.stripMargin	String	after
`object`("MonadPlus")( applyMethod("MonadPlus", "F"), `trait`("Ops[F[_], LP0]")( `def`("self", "F[LP0]"), `def`("withFilter", "(LP0 => Boolean) => MonadPlus.this.WithFilter[LP0]"), `def`("filter", "(LP0 => Boolean) => F[LP0]") ), `trait`("ToMonadPlusOps") `with` `implicit`("toMonadPlusOps", "[F, LP0] F[LP0] => MonadPlus[F] => MonadPlus.Ops[F, LP0]"), `trait`("AllOps[F[_], LP0] extends MonadPlus.Ops[F, LP0] with Monad.AllOps[F, LP0] with PlusEmpty.AllOps[F, LP0]"), `object`("nonInheritedOps extends MonadPlus.ToMonadPlusOps"), `object`("ops") `with` `implicit`("toAllMonadPlusOps", "[F, LP0] F[LP0] => MonadPlus[F] => MonadPlus.AllOps[F, LP0]"), )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""class A { | $qqq$CARET$qqq |} |""".stripMargin	String	after
s"""for (_ <- Seq()) yield $CARET | obj.method() | .method1() |""".stripMargin	String	before
s"""def foo() = ${CARET}someMethod() """.stripMargin	String	after
s""" |val b: Int =$CARET_MARKER """.stripMargin	String	before
s"""$qq$CARET""".stripMargin	String	before
s"""for (_ <- Seq()) yield { | ${CARET}obj.method() | .method1() |} |""".stripMargin	String	after
s""" |import simulacrum._ | |trait Applicative[F[_]] | |@typeclass trait Trav${caret}erse[F[_]] { | def sequence[G[_]: Applicative, A](fga: F[G[A]): G[F[A]] |} """.stripMargin	String	text
getSourceElement(text)	ScObject	traverseObject
s"""val x = {$CARET | someMethod() |} """.stripMargin	String	before
s"""for { _ <- Seq() } yield $CARET | obj.method() | .method1() |""".stripMargin	String	before
s""" |val b: Int ${ScalaTypedHandler.unicodeCaseArrow}$CARET_MARKER """.stripMargin	String	after
s"""$qqq$CARET$qqq""".stripMargin	String	after
s"""val x = $CARET | someMethod() """.stripMargin	String	after
s"""for { _ <- Seq() } yield { | ${CARET}obj.method() | .method1() |} |""".stripMargin	String	after
s"""var x = {$CARET | someMethod() |} """.stripMargin	String	before
s"def foo = $CARET"	String	before
s"def foo = {$CARET}"	String	after
s"""var x = $CARET | someMethod() """.stripMargin	String	after
`object`("Traverse")( applyMethod("Traverse", "F"), `trait`("Ops[F[_], LP0]")( `def`("self", "F[LP0]"), `def`("sequence", "[G, A] (Applicative[G], LP0 <:< G[A]) => G[F[A]]") ), `trait`("ToTraverseOps") `with` `implicit`("toTraverseOps", "[F, LP0] F[LP0] => Traverse[F] => Traverse.Ops[F, LP0]"), `trait`("AllOps[F[_], LP0] extends Traverse.Ops[F, LP0]"), `object`("nonInheritedOps extends Traverse.ToTraverseOps"), `object`("ops") `with` `implicit`("toAllTraverseOps", "[F, LP0] F[LP0] => Traverse[F] => Traverse.AllOps[F, LP0]"), )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""def foo = $CARET | obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	before
s""" $qq$CARET""".stripMargin	String	before
s"""def foo() = {$CARET | someMethod1() | someMethod2() |} """.stripMargin	String	before
s""" |import simulacrum._ | |@typeclass trait Func${caret}tor[F[_]] { | def map[A, B](fa: F[A])(f: A => B): F[B] |} """.stripMargin	String	text
getSourceElement(text)	ScObject	functorObject
s"""def foo = { | ${CARET}obj.method() | .method() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""def foo() = $CARET | someMethod1() | someMethod2() |} """.stripMargin	String	after
s""" $qqq$CARET$qqq""".stripMargin	String	after
s"""def foo =$CARET | obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	before
s"""def foo() = {$CARET | val x = 42 | someMethod() |} """.stripMargin	String	before
s"""$qq$CARET """.stripMargin	String	before
s"""def foo() = $CARET | val x = 42 | someMethod() |} """.stripMargin	String	after
s"""$qqq$CARET$qqq """.stripMargin	String	after
`object`("Functor")( applyMethod("Functor", "F"), `trait`("Ops[F[_], LP0]")( `def`("self", "F[LP0]"), `def`("map", "[B] (LP0 => B) => F[B]") ), `trait`("ToFunctorOps") `with` `implicit`("toFunctorOps", "[F, LP0] F[LP0] => Functor[F] => Functor.Ops[F, LP0]"), `trait`("AllOps[F[_], LP0] extends Functor.Ops[F, LP0]"), `object`("nonInheritedOps extends Functor.ToFunctorOps"), `object`("ops") `with` `implicit`("toAllFunctorOps", "[F, LP0] F[LP0] => Functor[F] => Functor.AllOps[F, LP0]"), )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""def foo = $CARET // comment line | obj.method() | .method | |someUnrelatedCode() |""".stripMargin	String	before
s"""def foo() = {$CARET | try { | someMethod1() | } | someMethod2() |} """.stripMargin	String	before
s""" val a = s"($$$CARET_MARKER)" """	String	text
s"""$qq$CARET |val x = 42 |""".stripMargin	String	before
s"""def foo() = $CARET | try { | someMethod1() | } | someMethod2() |} """.stripMargin	String	after
s"""def foo = { // comment line | ${CARET}obj.method() | .method |} | |someUnrelatedCode() |""".stripMargin	String	after
s""" val a = s"($${$CARET_MARKER})" """	String	assumed
s""" |import simulacrum._ | |@typeclass trait Str${caret}ong[F[_, _]] { | def first[A, B, C](fab: F[A, B]): F[(A, C), (B, C)] |} """.stripMargin	String	text
getSourceElement(text)	ScObject	strongObject
s""" |val map = Map(a -$CARET_MARKER) """.stripMargin	String	before
s""" val a = s"blah-blah $$$CARET_MARKER """	String	text
s"""def foo = $CARET | obj.method() // comment line | |someUnrelatedCode() |""".stripMargin	String	before
s"""class C { | def foo() = {$CARET | someMethod2() |}""".stripMargin	String	before
s"""$qqq$CARET$qqq |val x = 42 |""".stripMargin	String	after
s""" val a = s"blah-blah $${$CARET_MARKER} """	String	assumed
s"""class C { | def foo() = $CARET | someMethod2() |}""".stripMargin	String	after
s""" |val map = Map(a ${ScalaTypedHandler.unicodeMapArrow}$CARET_MARKER) """.stripMargin	String	after
s"""def foo = { | ${CARET}obj.method() // comment line |} | |someUnrelatedCode() |""".stripMargin	String	after
s""" $qq$CARET |val x = 42 |""".stripMargin	String	before
s"""val x = | if (false) 1 else 0 |val y = if (false) {$CARET | 0 |} |""".stripMargin	String	before
s"""def foo = $CARET /* block comment */ | obj.method() | .method | |someUnrelatedCode() |""".stripMargin	String	before
s""" | for (j <$CARET_MARKER ) """.stripMargin	String	before
`object`("Strong")( applyMethod("Strong", "F"), `trait`("Ops[F[_, _], LP0, LP1]")( `def`("self", "F[LP0, LP1]"), `def`("first", "[C] F[(LP0, C), (LP1, C)]") ), `trait`("ToStrongOps") `with` `implicit`("toStrongOps", "[F, LP0, LP1] F[LP0, LP1] => Strong[F] => Strong.Ops[F, LP0, LP1]"), `trait`("AllOps[F[_, _], LP0, LP1] extends Strong.Ops[F, LP0, LP1]"), `object`("nonInheritedOps extends Strong.ToStrongOps"), `object`("ops") `with` `implicit`("toAllStrongOps", "[F, LP0, LP1] F[LP0, LP1] => Strong[F] => Strong.AllOps[F, LP0, LP1]"), )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s""" $qqq$CARET$qqq |val x = 42 |""".stripMargin	String	after
s"""val x = | if (false) 1 else 0 |val y = if (false) $CARET | 0 |""".stripMargin	String	after
s"""def foo = { /* block comment */ | ${CARET}obj.method() | .method |} | |someUnrelatedCode() |""".stripMargin	String	after
s""" | for (j ${ScalaTypedHandler.unicodeForGeneratorArrow}$CARET_MARKER ) """.stripMargin	String	after
s"""val x = 42 |$qq$CARET |""".stripMargin	String	before
s""" |import simulacrum._ | |@typeclass trait Tri${caret}functor[F[_, _, _]] { | def trimap[A, B, C, D, E, G](fabc: F[A, B, C])(f: A => D, g: B => E, h: C => G): F[D, E, G] | @noop def first[A, B, C, D](fabc: F[A, B, C])(f: A => D): F[D, B, C] = trimap(fabc)(f, identity, identity) | @noop def second[A, B, C, D](fabc: F[A, B, C])(f: B => D): F[A, D, C] = trimap(fabc)(identity, f, identity) | @noop def third[A, B, C, D](fabc: F[A, B, C])(f: C => D): F[A, B, D] = trimap(fabc)(identity, identity, f) |} """.stripMargin	String	text
s"""def foo = $CARET |someUnrelatedCode1() |someUnrelatedCode2() |""".stripMargin	String	before
s"""class A { | if (true) {$CARET | someMethod1() | someMethod2() | } |} """.stripMargin	String	before
getSourceElement(text)	ScObject	trifunctorObject
s"$getTestDataPath/${getTestName(true)}.test"	String	fileName
s"""def foo = {$CARET} |someUnrelatedCode1() |someUnrelatedCode2() |""".stripMargin	String	after
s"""class A { | if (true) $CARET | someMethod1() | someMethod2() | } |} """.stripMargin	String	after
s"""val x = 42 |$qqq$CARET$qqq |""".stripMargin	String	after
s"""class A { | def foo = $CARET | someUnrelatedCode1() | someUnrelatedCode2() |} |""".stripMargin	String	before
s"""class A { | if (true) {$CARET | someMethod() | } else { | 42 | } |} """.stripMargin	String	before
s"""val x = 42 | $qq$CARET |""".stripMargin	String	before
s"""class A { | def foo = {$CARET} | someUnrelatedCode1() | someUnrelatedCode2() |} |""".stripMargin	String	after
s"""class A { | if (true) $CARET | someMethod() | else { | 42 | } |} """.stripMargin	String	after
`object`("Trifunctor")( applyMethod("Trifunctor", "F"), `trait`("Ops[F[_, _, _], LP0, LP1, LP2]")( `def`("self", "F[LP0, LP1, LP2]"), `def`("trimap", "[D, E, G] (LP0 => D, LP1 => E, LP2 => G) => F[D, E, G]"), ), `trait`("ToTrifunctorOps") `with` `implicit`("toTrifunctorOps", "[F, LP0, LP1, LP2] F[LP0, LP1, LP2] => Trifunctor[F] => Trifunctor.Ops[F, LP0, LP1, LP2]"), `trait`("AllOps[F[_, _, _], LP0, LP1, LP2] extends Trifunctor.Ops[F, LP0, LP1, LP2]"), `object`("nonInheritedOps extends Trifunctor.ToTrifunctorOps"), `object`("ops") `with` `implicit`("toAllTrifunctorOps", "[F, LP0, LP1, LP2] F[LP0, LP1, LP2] => Trifunctor[F] => Trifunctor.AllOps[F, LP0, LP1, LP2]") )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""val x = 42 | $qqq$CARET$qqq |""".stripMargin	String	after
getCommonSettings.getIndentOptions	CommonCodeStyleSettings.IndentOptions	indentOptions
s"""class A { | if (true) {$CARET | someMethod1() | someMethod2() | } else { | 42 | } |} """.stripMargin	String	before
s"""val x = 42 |$qq$CARET""".stripMargin	String	before
s""" |package foo.bar |import simulactum._ | |@typeclass trait Fo${caret}o[T] { | private[bar] def foo(t1: T, t2: T): T |} |""".stripMargin	String	text
s"""class A { |\t{ |\t\tdef foo = $CARET |\t\tobj.methodCall |\t} |}""".stripMargin	String	before
getSourceElement(text)	ScObject	fooObject
s"""class A { | if (true) $CARET | someMethod1() | someMethod2() | } else { | 42 | } |} """.stripMargin	String	after
r.multiResolveScala(false)	Array[ScalaResolveResult]	results
results(0)	ScalaResolveResult	srr
`object`("Foo")( `trait`("Ops[T]")( `def`("foo", "T => T") ) )	SynteticInjectorsTestUtils.SyntheticTypeDef	syntheticStructure
s"""val x = 42 |$qqq$CARET$qqq""".stripMargin	String	after
s"""class A { |\t{ |\t\tdef foo = {$CARET} |\t\tobj.methodCall |\t} |}""".stripMargin	String	after
r.resolve	PsiElement	resolve
s"""class A { | if (true) { | 42 | } else {$CARET | someMethod() | } |} """.stripMargin	String	before
s"""def foo = ${CARET}obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | if (true) { | 42 | } else $CARET | someMethod() |} """.stripMargin	String	after
s"""def foo = {${CARET}obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | if (true) { | 42 | } else {$CARET | someMethod() | someMethod1() | } |} """.stripMargin	String	before
s"""def foo = | ${CARET}obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | if (true) { | 42 | } else $CARET | someMethod() | someMethod1() | } |} """.stripMargin	String	after
s"""def foo = | {${CARET}obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | if (true) 42 else if(false) 23 else {$CARET | 42 |}""".stripMargin	String	before
srr.importsUsed	Set[ImportUsed]	imports
s"""def foo = ${CARET}obj.method() | |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | if (true) 42 else if(false) 23 else $CARET | 42 |}""".stripMargin	String	after
s"""def foo = {${CARET}obj.method() | |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | { | if (true) 42 else if(false) 23 else {$CARET | 42 | } |}""".stripMargin	String	before
s"""def foo = $CARET obj.method() | |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | { | if (true) 42 else if(false) 23 else $CARET | 42 | } |}""".stripMargin	String	after
s"""def foo = {$CARET obj.method() | |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try {$CARET | 42 | } |} """.stripMargin	String	before
s"""val x = $CARET | obj.method() | .method() | |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try $CARET | 42 |} """.stripMargin	String	after
s"""val x = { | ${CARET}obj.method() | .method() |} | |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try {$CARET | 42 | 422 | } |} """.stripMargin	String	before
s"""var x = $CARET | obj.method() | .method() | |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try $CARET | 42 | 422 | } |} """.stripMargin	String	after
s"""var x = { | ${CARET}obj.method() | .method() |} | |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try {$CARET | 42 | } catch { | case _ => | } |} """.stripMargin	String	before
findReferenceAtCaret	PsiReference	ref
ref.resolve	PsiElement	resolved
s"""lazy val x = $CARET | obj.method() | .method() |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try $CARET | 42 | catch { | case _ => | } |} """.stripMargin	String	after
s"""lazy val x = { | ${CARET}obj.method() | .method() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try {$CARET | 42 | } | catch { | case _ => | } |} """.stripMargin	String	before
s"""val (x, y) = $CARET | (42, 23) | |someUnrelatedCode() |""".stripMargin	String	before
s"""val (x, y) = { | (42, 23) |} | |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try {$CARET | 42 | | } | catch { | case _ => | } |} """.stripMargin	String	before
s"""val x = $CARET |obj.method() | .method() | |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try $CARET | 42 | | catch { | case _ => | } |} """.stripMargin	String	after
s"""val x = {$CARET} |obj.method() | .method() | |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try {$CARET | 42 | 23 | } catch { | case _ => | } |} """.stripMargin	String	before
findReferenceAtCaret()	PsiReference	ref
ref.resolve	PsiElement	psiElement
s"""if (true) $CARET | obj.method() |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try $CARET | 42 | 23 | } catch { | case _ => | } |} """.stripMargin	String	after
s"""if (true) { | ${CARET}obj.method() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try { | 42 | } finally {$CARET | 42 | } | | | someUnrelatedCode() |} """.stripMargin	String	before
s"""class A { | try { | 42 | } finally $CARET | 42 | | | someUnrelatedCode() |} """.stripMargin	String	after
s"""class A { | try { | 42 | } finally {$CARET | 42 | | | } | someUnrelatedCode() |} """.stripMargin	String	before
psiElement.asInstanceOf[ScPrimaryConstructor]	ScPrimaryConstructor	aClass
s"""if (true) $CARET //comment | obj.method() |someUnrelatedCode() |""".stripMargin	String	before
s"""if (true) { //comment | ${CARET}obj.method() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try { | 42 | } finally {$CARET | 42 | 23 | } | | | someUnrelatedCode() |} """.stripMargin	String	before
s"""if (true) $CARET | obj.method() //comment |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try { | 42 | } finally $CARET | 42 | 23 | } | | | someUnrelatedCode() |} """.stripMargin	String	after
s"""if (true) { | ${CARET}obj.method() //comment |} |someUnrelatedCode() |""".stripMargin	String	after
s"""do {$CARET | someMethod1() | |} while (true) """.stripMargin	String	before
folderPath + File.separator + fileName + extention	String	filePath
s"""if (true) $CARET /* block comment */ | obj.method() |someUnrelatedCode() |""".stripMargin	String	before
s"""do $CARET | someMethod1() | |while (true) """.stripMargin	String	after
s"""if (true) { /* block comment */ | ${CARET}obj.method() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""do {$CARET | someMethod1() | someMethod2() |} while (true) """.stripMargin	String	before
s"""if (true) $CARET | obj.method() |else | obj.method2() |someUnrelatedCode() |""".stripMargin	String	before
s"""do $CARET | someMethod1() | someMethod2() |} while (true) """.stripMargin	String	after
s"""if (true) { | ${CARET}obj.method() |} else | obj.method2() |someUnrelatedCode() |""".stripMargin	String	after
s"""while (true) {$CARET | 42 | |} | |println() |""".stripMargin	String	before
s"""if (true) $CARET | obj.method() | |else | obj.method2() |someUnrelatedCode() |""".stripMargin	String	before
s"""while (true) $CARET | 42 | | |println() |""".stripMargin	String	after
s"""if (true) { | ${CARET}obj.method() |} |else | obj.method2() |someUnrelatedCode() |""".stripMargin	String	after
s"""while (true) {$CARET | 42 | 23 | |} | |println() |""".stripMargin	String	before
s"""while (true) $CARET | 42 | 23 | |} | |println() |""".stripMargin	String	after
s"for (_ <- Seq()) {$CARET}"	String	before
s"for (_ <- Seq()) $CARET"	String	after
s"""for (_ <- Seq()) {$CARET | obj.method() | .method1() | |} |""".stripMargin	String	before
s"""if (true) $CARET | obj.method() //comment |else | obj.method2() |someUnrelatedCode() |""".stripMargin	String	before
st.resolveAllConstructors	Array[ScalaResolveResult]	variants
s"""for (_ <- Seq()) $CARET | obj.method() | .method1() | |""".stripMargin	String	after
s"""if (true) { | ${CARET}obj.method() //comment |} else | obj.method2() |someUnrelatedCode() |""".stripMargin	String	after
s"""for { _ <- Seq() } {$CARET | obj.method() | .method1() |} |""".stripMargin	String	before
s"""if (true) | obj.method() |else $CARET | obj.method2() |someUnrelatedCode() |""".stripMargin	String	before
null	ScReference	src
null	PsiElement	tgt
s"""for { _ <- Seq() } $CARET | obj.method() | .method1() |""".stripMargin	String	after
s"""if (true) | obj.method() |else { | ${CARET}obj.method2() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""for (_ <- Seq()) yield {$CARET | obj.method() | .method1() |} | |""".stripMargin	String	before
s"""if (true) | obj.method() |else $CARET | obj.method2() //comment |someUnrelatedCode() |""".stripMargin	String	before
s"""for (_ <- Seq()) yield $CARET | obj.method() | .method1() | |""".stripMargin	String	after
s"""if (true) | obj.method() |else { | ${CARET}obj.method2() //comment |} |someUnrelatedCode() |""".stripMargin	String	after
s"""for { _ <- Seq() } yield {$CARET | obj.method() | .method1() |} |""".stripMargin	String	before
s"""if (true) ${CARET}obj.method() |else | obj.method2() //comment |someUnrelatedCode() |""".stripMargin	String	before
s"""if (true) {${CARET}obj.method() |else | obj.method2() //comment |someUnrelatedCode() |""".stripMargin	String	after
s"""for { _ <- Seq() } yield $CARET | obj.method() | .method1() |""".stripMargin	String	after
s"""class A { | if (true) 42 | else if(false) 23 | else $CARET | 42 |}""".stripMargin	String	before
s"""for { | _ <- Option(42) |} {$CARET | println(42) |} |""".stripMargin	String	before
s"""class A { | if (true) 42 | else if(false) 23 | else {$CARET} | 42 |}""".stripMargin	String	after
s"""for { | _ <- Option(42) |} $CARET | println(42) |""".stripMargin	String	after
configureFun(fileName, trimmed.replaceAll(REFSRC, "").replaceAll(REFTGT,""))	PsiFile	psiFile
src.resolve()	PsiElement	result
s"""class A { | { | if (true) 42 | else if(false) 23 | else $CARET | 42 | } |}""".stripMargin	String	before
s"""for { | _ <- Option(42) |} yield {$CARET | println(42) |} |""".stripMargin	String	before
s"""class A { | { | if (true) 42 | else if(false) 23 | else {$CARET} | 42 | } |}""".stripMargin	String	after
s"""for { | _ <- Option(42) |} yield $CARET | println(42) |""".stripMargin	String	after
FileUtil.loadFile(ioFile, CharsetToolkit.UTF8)	String	fileText
s"""try $CARET | obj.method() |someUnrelatedCode() |""".stripMargin	String	before
s"""for { _ <- Seq() } yield {$CARET | obj.method() | obj.method1() |} |""".stripMargin	String	before
s"""try { | ${CARET}obj.method() |} |someUnrelatedCode() |""".stripMargin	String	after
s"""for { _ <- Seq() } yield $CARET | obj.method() | obj.method1() |} |""".stripMargin	String	after
s"""class A { | try $CARET | obj.method() | someUnrelatedCode() |} |""".stripMargin	String	before
s"""def foo(name: String): Unit = {$CARET | |} |""".stripMargin	String	before
s"""class A { | try { | ${CARET}obj.method() | } | someUnrelatedCode() |} |""".stripMargin	String	after
s"""def foo(name: String): Unit = $CARET | |""".stripMargin	String	after
myFixture.getFile.asInstanceOf[ScalaFile]	ScalaFile	file
s"""try $CARET | obj.method() |catch { | case _ => |} |someUnrelatedCode() |""".stripMargin	String	before
s"""def foo(name: String) = {$CARET |} |""".stripMargin	String	before
myFixture.getEditor.getSelectionModel	SelectionModel	model
s"""try { | ${CARET}obj.method() |} catch { | case _ => |} |someUnrelatedCode() |""".stripMargin	String	after
s"""def foo(name: String) = $CARET |""".stripMargin	String	after
file.findElementAt(if (model.hasSelection) model.getSelectionStart else 0)	PsiElement	start
file.findElementAt(if (model.hasSelection) model.getSelectionEnd - 1 else file.getTextLength - 1)	PsiElement	end
PsiTreeUtil.getParentOfType(PsiTreeUtil.findCommonParent(start, end), classOf[ScControlFlowOwner], false)	ScControlFlowOwner	owner
s"""try $CARET | obj.method() | |catch { | case _ => |} |someUnrelatedCode() |""".stripMargin	String	before
s"""class A { | try {$CARET | } catch { | case _ => | } |} """.stripMargin	String	before
ScalaCodeStyleSettings.getInstance(getProjectAdapter)	ScalaCodeStyleSettings	settings
Seq("java\\..+", "scala\\..+", ".+").map(Pattern.compile)	Seq[Any]	groups
settings.REPLACE_CASE_ARROW_WITH_UNICODE_CHAR	Boolean	old
s"""try { | ${CARET}obj.method() |} |catch { | case _ => |} |someUnrelatedCode() |""".stripMargin	String	after
s"""class A { | try $CARET | catch { | case _ => | } |} """.stripMargin	String	after
s"""def foo = {$CARET | 42 |} |""".stripMargin	String	before
getSelection(file)	TextRange	selection
builder.buildControlflow(owner)	Seq[Instruction]	instructions
ScalaPsiUtil.getElementsRange(startElement, endElement)	Seq[PsiElement]	selectedElements
s"""def foo = $CARET | 42 |""".stripMargin	String	afterWithEnabled
PsiTreeUtil.findCommonParent(startElement, endElement)	PsiElement	commonParent
s"""try | obj.method() |finally $CARET | obj.method2() |someUnrelatedCode() |""".stripMargin	String	before
s"""def foo = $CARET | 42 |} |""".stripMargin	String	afterWithDisabled
ScalaApplicationSettings.getInstance	ScalaApplicationSettings	settings
settings.WRAP_SINGLE_EXPRESSION_BODY	Boolean	settingBefore
s"""try | obj.method() |finally { | ${CARET}obj.method2() |} |someUnrelatedCode() |""".stripMargin	String	after
{ val commonParent = PsiTreeUtil.findCommonParent(startElement, endElement) val cfowner = PsiTreeUtil.getParentOfType(commonParent, classOf[ScControlFlowOwner], false) cfowner.getParent.asInstanceOf[ScalaPsiElement] }	ScalaPsiElement	scope
scalaFile.findElementAt(offset).getParent	PsiElement	elem
s"""class A { | try { | println(42) | } catch { | case _ => | } finally $CARET | println(23) |} |""".stripMargin	String	before
elem.asInstanceOf[ScReference]	ScReference	ref
PsiTreeUtil.getParentOfType(ref.resolve(), classOf[PsiMember], false)	PsiMember	resolve
s"""class A { | try { | println(42) | } catch { | case _ => | } finally {$CARET} | println(23) |} |""".stripMargin	String	after
new DfaEngine(instructions, ReachingDefinitionsInstance, ReachingDefinitionsLattice)	DfaEngine[ReachingDefinitions.RDSet]	engine
s"""try | obj.method() |finally $CARET | obj.method2() //comment |someUnrelatedCode() |""".stripMargin	String	before
s"""try | obj.method() |finally { | ${CARET}obj.method2() //comment |} |someUnrelatedCode() |""".stripMargin	String	after
ReachingDefinitionsCollector.collectVariableInfo(selectedElements, scope)	FragmentVariableInfos	infos
dumpDefInfos(infos)	String	actualCfOutput
engine.performDFA	mutable.Map[Instruction, Set[Instruction]]	markup
dumpDataFlow(markup)	String	cf
s"""do $CARET | 42 |while (true) |someUnrelatedCode() |""".stripMargin	String	before
markup(instruction)	Set[Instruction]	defs
ResolveUtils.isAccessible(resolve, elem)	Boolean	actual
info.map(_.element.toString).toSeq	Seq[Nothing]	elementStrings
s"""do { | ${CARET}42 |} while (true) |someUnrelatedCode() |""".stripMargin	String	after
variablesText(infos.inputVariables)	String	inputElements
variablesText(infos.outputVariables)	String	outputElements
s"""do $CARET | 42 | |while (true) |someUnrelatedCode() |""".stripMargin	String	before
s"""do { | ${CARET}42 |} |while (true) |someUnrelatedCode() |""".stripMargin	String	after
s"""do $CARET//comment | 42 |while (true) |someUnrelatedCode() |""".stripMargin	String	before
s"""do {//comment | ${CARET}42 |} while (true) |someUnrelatedCode() |""".stripMargin	String	after
LocalFileSystem.getInstance.refreshAndFindFileByPath(filePath.replace(File.separatorChar, '/'))	VirtualFile	file
s"""do $CARET | 42 //comment |while (true) |someUnrelatedCode() |""".stripMargin	String	before
List(Resolved, Name, File, Line, Offset, Length, Type, Path, Applicable, Accessible)	List[Nothing]	Parameters
s"""do { | ${CARET}42 //comment |} while (true) |someUnrelatedCode() |""".stripMargin	String	after
List()	List[ResolveTestBase.this.Parameters]	options
null	String	res
TreeUtil.findLastLeaf(scalaFile.getNode).getPsi	PsiElement	lastPsi
List()	List[PsiReference]	references
s"""while(false) $CARET | 42 |someUnrelatedCode() |""".stripMargin	String	before
parseParameters(m.group(1))	ResolveTestBase.this.Parameters	parameters
getFileAdapter.findReferenceAt(m.end)	PsiReference	reference
s"""while(false) { | ${CARET}42 |} |someUnrelatedCode() |""".stripMargin	String	after
s"""while(false) $CARET//comment | 42 |someUnrelatedCode() |""".stripMargin	String	before
s"""while(false) {//comment | ${CARET}42 |} |someUnrelatedCode() |""".stripMargin	String	after
s"""while(false) $CARET | 42 //comment |someUnrelatedCode() |""".stripMargin	String	before
s"""while(false) { | ${CARET}42 //comment |} |someUnrelatedCode() |""".stripMargin	String	after
s"""val x = | $quotes | |$CARET | $quotes |""".stripMargin	String	before
s"""val x = | $quotes | |{$CARET | $quotes |""".stripMargin	String	after
s"""def foo = $CARET | 42 |""".stripMargin	String	before
s"""def foo = {$CARET | 42 |} |""".stripMargin	String	afterWithEnabled
s"""def foo = {$CARET} | 42 |""".stripMargin	String	afterWithDisabled
ref.getReferences	Array[PsiReference]	hostReferences
reference.refName	String	referenceName
reference.bind()	Option[ScalaResolveResult]	result
if (!options.contains(File) || options(File) == "this") { reference.getElement.getContainingFile.getVirtualFile.getNameWithoutExtension } else options(File)	String	expected
if (options.contains(Name)) options(Name) else referenceName	String	expectedName
s"/** [[java.lang.String$CARET_MARKER]] */"	String	text
target.getClass	Class[_ <: AnyVal]	targetClass
s"/** [[java.lang.String]$CARET_MARKER] */"	String	assumedStub
normalize(text, stripTrailingSpaces)	String	normalizedText
configureByText(text, stripTrailingSpaces)	Seq[PsiElement]	elements
surroundWith(text, surrounder)	String	surrounded
EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_ENTER)	EditorActionHandler	enterHandler
normalize(surrounded, stripTrailingSpaces)	String	expected
QuickDocTest.quickDocGenerator.generateDoc(docElement, docElement)	String	generatedText
configureByText(text, stripTrailingSpaces = false)	Seq[PsiElement]	elements
getFileAdapter.getLastChild	PsiElement	element
text.linesIterator.zipWithIndex.map(p => if (p._2 + 1 == line) p._1 + " // " + message else p._1)	Iterator[String]	lines
getFileAdapter.asInstanceOf[ScalaFile].getClasses collectFirst { case a: ScTemplateDefinition if a.name == className => a }	Option[ScTemplateDefinition]	td
getScalaSettings	ScalaCodeStyleSettings	scalaSettings
println	Any => Unit	log
td flatMap (c => c.membersWithSynthetic.find(_.getName == elementName))	Option[ScMember]	member
getFileAdapter.getLastChild.getLastChild	PsiElement	element
s"""trait X { | def foo = 42 |} |def zoo(): Int = 42""".stripMargin	String	before
QuickDocTest.quickDocGenerator.generateDoc(element, element)	String	generated
s"""trait X { | def foo = 42 |} |def zoo(): Int = 42""".stripMargin	String	after
s""" |/** | * b${START}lah b${END}lah | * blah blah blah | */""".stripMargin	String	text
s"""trait X { |def foo = 42 |} |def zoo(): Int = 42""".stripMargin	String	before
s""" |/** blah lb${START}lah akfhsdhfsadhf | * skjgh dfsg shdfa hsdaf jhsad fsd | * dfgas dfhgsajdf sad${END}jfjsd | */""".stripMargin	String	text
s""" |def x = 42 |// """.stripMargin	String	before
s""" |/** | * __blah blah | * dfgasdhgfjk ^ashgdfkjgds| * ''aaaaaa'' sdkfhsadjkh^ ll | * sd${START}hfkhsa${END}dl__ | */""".stripMargin	String	text
s""" |def x = 42 |// """.stripMargin	String	after
s"class Test { val v = ${startMarker}1 + 22 $endMarker}"	String	before
s""" |/** | * __blah blah | * blkjhsd${START}asdhajs ''sdfsddlk'' | * shfg`sad`jhg${END}f__ | */""".stripMargin	String	text
s""" |class C { | def foo = 1 to 42 |} """.stripMargin	String	before
s""" |class Test { | def foo(): Unit = { | ${startMarker}println(42 + 22)$endMarker | } |} """.stripMargin	String	before
s""" |class C { | def foo = 1.to(42) |} """.stripMargin	String	after
s"Downloading default scalafmt version $DefaultVersion"	String	downloadingMessage
s""" |/** | * $START datadatad${END}atadata | */""".stripMargin	String	text
s""" |import a.{ | b, | c | }, h.{ | k, l | } | import d.e.{f, g} | import a.{ | foo => bar, | zzzz => _, | _ | } |class C {} """.stripMargin	String	before
progressMessage => { log(progressMessage) }	ScalafmtDynamicDownloader.DownloadProgressListener	stringToUnit
s"""class Test2 { | def foo(): Unit = | ${startMarker}println(42 + 22)$endMarker |}""".stripMargin	String	before
getCommonSettings	CommonCodeStyleSettings	settings
s""" |import a.b |import a.c |import h.k |import h.l |import d.e.f |import d.e.g |import a.{foo => bar, zzzz => _, _} |class C {} """.stripMargin	String	after
getFileAdapter.getLastChild.asInstanceOf[ScObject].getMethods.head	PsiMethod	element
s"""class Test2 { | def foo(): Unit = | println(42 + 22) |}""".stripMargin	String	after
new ScalaDocumentationProvider	ScalaDocumentationProvider	quickDocGenerator
s""" |/** | * ${START}comment_data$END | */""".stripMargin	String	text
s""" |import foo.{Zilch, bar, Random, sand} """.stripMargin	String	before
s""" |class Test { | def foo(): Unit = { | ${startMarker}pri${endMarker}ntln(42 + 2) | } |} """.stripMargin	String	before
s""" |import foo.{bar, sand, Random, Zilch} """.stripMargin	String	after
s""" |/** | * @param a aaa${START}aa | * aaaaa${END}aaa | */""".stripMargin	String	text
s""" |class Test { | def foo(): Unit = { | println( 42 $startMarker + 43 + 28$endMarker ) | } |} """.stripMargin	String	before
s""" |class Test { | def bar(): Test = | foo( "a" )$startMarker | .foo( "a" ) | .foo( " a "$endMarker) |} """.stripMargin	String	before
s""" |/** | * @todo blah ${START}blah b${END}lah | */""".stripMargin	String	text
s""" |class Test { | def bar(): Test = { | ${startMarker}foo { | val x = "a" | x + "b" | $endMarker} | } |} """.stripMargin	String	before
s""" |/** | * blah $START^blah blah | * jhsdbjbhsafd^$END dajsdgf | */""".stripMargin	String	text
s""" |class { | val foo = pri${startMarker}ntln( 42 + 43 )$endMarker |} """.stripMargin	String	before
s"/** 2^2$CARET_MARKER^ = 4 */"	String	text
s" ${startMarker}type T = String$endMarker"	String	before
s"/** 2^2^$CARET_MARKER = 4 */"	String	assumedStub
s""" |/** | * blah ,,${START}blah blha | * blah blah$END,, blah | */""".stripMargin	String	text
s"""object TestClass { | ${startMarker}type T = String |type X = Int$endMarker |}""".stripMargin	String	before
new TrailingCommaPanel(getSettings)	TrailingCommaPanel	panel
s"""object TestClass { | type T = String | type X = Int |}""".stripMargin	String	after
s""" |/** | * aa${START}aa__sahdkljahskdhasd | * dajs${END}kjhd__kas | */""".stripMargin	String	text
s" ${startMarker}val x=42$endMarker"	String	before
s""" |/** | * b${START}lah blah | * | * blah blah$END blah | */""".stripMargin	String	text
s" ${startMarker}def foo= 42$endMarker"	String	before
s" ${startMarker}import foo.bar.{baz, foo, bar}$endMarker"	String	before
s""" |/** | * bla${START}h blah blah | * @see some${END}thing | */""".stripMargin	String	text
s""" |${startMarker}import foo.bar. {baz, foo } |import foo.baz.{bar,baz}$endMarker |println(2 + 3) """.stripMargin	String	before
s""" |/** | * blah${START}__blah${END}blah__ | */""".stripMargin	String	text
s"""$startMarker ${startMarker(0)}import foo.bar. {baz, foo } | import foo.baz.{bar,baz}$endMarker${endMarker(0)} |println(2 + 3) """.stripMargin	String	before
s""" |/** | * blah blah ${START}__blah blah | * blah bl${END}ah blah __ | */""".stripMargin	String	text
ScalaSurroundDescriptors.getSurroundDescriptors()(1)	SurroundDescriptor	descriptor
s""" |class MyClass { | val a: Int = 1 | val b: Int = 2 | def foo() = ${startMarker}a+b$endMarker | def bar() = a+b |} """.stripMargin	String	before
s""" |class Foo { | println( 1 + 2) |println( 3 $startMarker + 4) | println(5+6)$endMarker | println(7+8) |} """.stripMargin	String	before
descriptor.getSurrounders .collect { case surrounder: ScalaDocWithSyntaxSurrounder => surrounder }	Seq[ScalaDocWithSyntaxSurrounder]	surrounders
s""" |class Foo { | println( 1 + 2) |println( 3 + 4) | println(5 + 6) | println(7+8) |} """.stripMargin	String	after
CommonCodeStyleSettings.WRAP_ON_EVERY_ITEM	Int	CHOP_DOWN_IF_LONG
s""" |class MyClass { | val a: Int = 1 | val b: Int = 2 | a+b | |$startMarker def foo() = a+b$endMarker | def bar() = a+b |} """.stripMargin	String	before
surrounder.getSyntaxTag	String	tag
s""" |class Foo { | println( 1 + 2) | ${startMarker}println( 3 + 4) |println( 4 +5) | println(5+6)$endMarker | println(7+8) |} """.stripMargin	String	before
s"/** '''blah blah blah'$CARET_MARKER'' */"	String	text
s""" |class MyClass { |$startMarker/** | * @param x | * @param y | * @return x+y | */$endMarker |def foo(x: Int, y: Int): Int = x+y |} """.stripMargin	String	before
s""" |class Foo { | println( 1 + 2) | println(3 + 4) | println(4 + 5) | println(5 + 6) | println(7+8) |} """.stripMargin	String	after
s"/** '''blah blah blah''$CARET_MARKER' */"	String	assumedStub
s""" |class Foo { | println( 1 + 2) |${startMarker}println( 3 + 4) | println( 4 +5) |println(5+6)$endMarker | println(7+8) |} """.stripMargin	String	before
s""" |class MyClass { |$startMarker/** | * @param x | @param y | @return x+y | */$endMarker |def foo(x: Int, y: Int): Int = x+y |} """.stripMargin	String	before
s""" |class Foo { | println( 1 + 2) | ${startMarker}println( 3 + 4) | println( 4 +5) |println(5+6)$endMarker | println(7+8) |} """.stripMargin	String	before
s""" |class Test { |//someComment | def foo() = $startMarker{ |}$endMarker |} """.stripMargin	String	before
s""" |object Test { | null match { | case _ => |$startMarker val nameOpt = { | "foo" | } | val sourceCode = new StringBuilder()$endMarker | } |} """.stripMargin	String	before
s""" |class Foo { | $qqq $startMarker aaa |aaa$endMarker | $qqq |} """.stripMargin	String	before
s""" |class Foo { | $qqq aaa |aaa | $qqq |} """.stripMargin	String	after
s""" |object Foo { | ${startMarker}def toString() = "Foo"}$endMarker """.stripMargin	String	before
s""" |object Foo { | def toString() = "Foo" |} """.stripMargin	String	after
s"object O {$startMarker $endMarker}"	String	before
s"object O {}"	String	after
s"def foo$startMarker $endMarker= 42"	String	before
s"def foo = 42"	String	after
s"1 +$startMarker ${endMarker}3 + 4"	String	before
s"1 + 3 + 4"	String	after
s"/** '''$CARET_MARKER''' */"	String	text
s"/** ''''$CARET_MARKER'' */"	String	assumedStub
s""" |class T { |$startMarker ${endMarker}def foo = 42 |} """.stripMargin	String	before
s"/** ''some text$CARET_MARKER'' */"	String	before
s"/** ''some text'$CARET_MARKER' */"	String	after1
s""" |class T { | def foo = 42 |} """.stripMargin	String	after
s"/** ''some text''$CARET_MARKER */"	String	after2
s"/** ''$CARET_MARKER'' */"	String	before
s"""val x = | $Quotes || | | | | | | | | | |$Quotes.stripMargin |""".stripMargin	String	before
s""" |package foo |${startMarker}object O { | def foo = bar |} |$endMarker | """.stripMargin	String	before
s"""class A { | myObject.method1() | .method2().method3().method4()$startMarker | $endMarker.method5().method6() |}""".stripMargin.withNormalizedSeparator	String	before
implicitly[ClassTag[Psi]].runtimeClass.asInstanceOf[Class[Psi]]	Class[Psi]	classOfPsi
s"/** '''$CARET_MARKER''' */"	String	after
s""" |package foo |object O { | def foo = bar |} """.stripMargin	String	after
s"""val x = | $Quotes | | | | | | | | | | | |$Quotes.stripMargin |""".stripMargin	String	after
s""" |package foo$startMarker | $endMarker import bar._ |class C {} """.stripMargin	String	before
s"""class A { |val x = |s$Quotes one || || two || ||$Quotes.stripMargin |} """.stripMargin	String	before
s""" |package foo |import bar._ |class C {} """.stripMargin	String	after
s"""class A { | val x = | s$Quotes one | | | | two | | | |$Quotes.stripMargin |}""".stripMargin	String	after
s""" |package foo |import bar._$startMarker | ${endMarker}class C{} """.stripMargin	String	before
s"""class A { | myObject.method1() | .method2().method3().method4() | $startMarker.method5().method6()$endMarker |}""".stripMargin.withNormalizedSeparator	String	before
s""" |package foo |import bar._ |class C{} """.stripMargin	String	after
s"""class A { |val x = |$Quotes||Name (String) | Level (Integer) | |||Squirtle | 1 | |||Balbasaur | 1 | |||Charmander | 2 |$Quotes.stripMargin |} """.stripMargin	String	before
s""" |class A[T]$startMarker |${endMarker}class B """.stripMargin	String	before
s"""class A { | val x = | $Quotes||Name (String) | Level (Integer) | | ||Squirtle | 1 | | ||Balbasaur | 1 | | ||Charmander | 2 |$Quotes.stripMargin |} """.stripMargin	String	after
s""" |class A[T] |class B """.stripMargin	String	after
s"""val myRegex = new Regex($Quotes first line of regex | |foo (.*) | | br (.*) | | bz ( .*) | |$Quotes.stripMargin) |""".stripMargin	String	sameLine
s""" |class C { | ${startMarker}def foo = 1 to 42$endMarker |} """.stripMargin	String	before
s"""val myRegex = new Regex( $Quotes first line of regex | |foo (.*) | | br (.*) | | bz ( .*) | |$Quotes.stripMargin) |""".stripMargin	String	sameLineIndented
s"""val myRegex = new Regex( | $Quotes first line of regex | |foo (.*) | | br (.*) | | bz ( .*) | |$Quotes.stripMargin) |""".stripMargin	String	nextLine
s""" |class C { | def foo = ${startMarker}1 ${endMarker}to 42 |} """.stripMargin	String	before
elementsInScalaLibrary(intKey("scala.math"), PACKAGE_FQN_KEY)	Seq[ScPackaging]	packagings
s""" |class C { | def foo = 1 to 42 |} """.stripMargin	String	after
s""" |class C { | def foo = ${startMarker}1 to $endMarker 42 |} """.stripMargin	String	before
elementsInScalaLibrary("implicitNotFound", ANNOTATED_MEMBER_KEY)	Seq[ScAnnotation]	annotations
s""" |class C { | def foo = ${startMarker}1 to 42$endMarker |} """.stripMargin	String	before
if(PsiTreeUtil.getParentOfType(scalaFile.findElementAt(startOffset),classOf[ScExpression]) != null) 0 else 1	Int	addOne
s""" |class C { | def foo = $startMarker ( 1 to 42 ) + $endMarker 11 |} """.stripMargin	String	before
PsiTreeUtil.findElementOfClassAtRange(scalaFile, startOffset + addOne, endOffset, classOf[ScExpression])	ScExpression	expr
s""" |class C { | def foo = 1.to(42) + 11 |} """.stripMargin	String	after
s""" |object Outer { |trait T { | val foo: Int | val bar: Int |} | ${startMarker}class T1 extends T { |override val foo: Int = ??? |override val bar: Int = ??? |}$endMarker |} """.stripMargin	String	before
s""" |object Outer { |trait T { | val foo: Int | val bar: Int |} | class T1 extends T { | override val foo: Int = ??? | override val bar: Int = ??? | } |} """.stripMargin	String	after
expr.implicitConversions()	Seq[PsiNamedElement]	conversions
computeElementsFeatures(fileText)	Map[String, Any]	elementsFeatures
computeElementsFeatures(fileText)	Map[String, Any]	elementFeatures
new ScalaElementFeatureProvider	ScalaElementFeatureProvider	original
mutable.Map.empty[String, util.Map[String, MLFeatureValue]]	mutable.Map[String, Any]	elements
s""" |${startMarker}import a.{ | b, | c | }, h.{ | k, l | } | import d.e.{f, g} | import a.{ | foo => bar, | zzzz => _, | _ | }$endMarker |class C {} """.stripMargin	String	before
FileUtil.loadFile(new File(testPath() + getTestName(true) + ".test"), CharsetToolkit.UTF8)	String	fileText
s""" |import h.l |import h.k |import a.c |import a.b |import d.e.g |import d.e.f |import a.{foo => bar, zzzz => _, _} |class C {} """.stripMargin	String	after
s""" |val myString = ${startMarker}s"prefix$${myHello}"$endMarker """.stripMargin	String	before
s""" |val myString = s"prefix$$myHello" """.stripMargin	String	after
s""" |val myString = s"pre${startMarker}fix$${myHello}$endMarker" """.stripMargin	String	before
s""" |val myString = s"prefix$${myHello}" """.stripMargin	String	after
s""" |def foo $startMarker= { | List(1, 2, 3).sum |}$endMarker """.stripMargin	String	before
selectElement[ScReference](file, refPath)	ScReference	ref
s""" |def foo = List(1, 2, 3).sum """.stripMargin	String	after
possibilities.reverse	Seq[String]	imports
s""" |import foo.{Zilch,$startMarker bar, Random, ${endMarker}sand} """.stripMargin	String	before
s""" |import foo.{Zilch, bar, Random, sand} """.stripMargin	String	after
s"""class TestClass { | def parentScope: Unit = { | ${startMarker}Option(1) match { | case Some(value) => | case None => | }$endMarker | } |}""".stripMargin	String	before
new ScalaElementFeatureProviderWrapper	ScalaElementFeatureProviderWrapper	provider
s"""class TestClass { | def parentScope: Unit = { | Option(1) match { | case Some(value) => | case None => | } | } |}""".stripMargin	String	after
new CodeCompletionHandlerBase(CompletionType.BASIC, false, false, true)	CodeCompletionHandlerBase	handler
localOrdering(ref)	Ordering[String]	ordering
imports.sorted(ordering)	Seq[String]	result
s"""class TestClass { | def parentScope: Unit = { | Option(1) match $startMarker{ | case Some(value) => | case None => | }$endMarker | } |}""".stripMargin	String	before
_ => OrderingUtil.orderingByPackageName	PsiElement => Ordering[String]	alphabeticalSort
OrderingUtil.orderingByRelevantImports	PsiElement => Ordering[String]	packageDistSort
s"""class TestClass { | def parentScope: Unit = { |${startMarker}Option(1) match { |case Some(value) => |case None => |}$endMarker | } |} | |val x = 2 - "string" |trait X {}!#@""".stripMargin	String	before
fileText.indexOf("----")	Int	separatorIndex
s"""class TestClass { | def parentScope: Unit = { | Option(1) match { | case Some(value) => | case None => | } | } |} | |val x = 2 - "string" |trait X {}!#@""".stripMargin	String	after
Option(value.asBinary()) orElse Option(value.asCategorical()) orElse Option(value.asFloat())	Option[B]	actualValue
s"""object ${startMarker}O$endMarker {} |class ${startMarker(0)}C${endMarker(0)} {} |trait ${startMarker(1)}T${endMarker(1)} {} """.stripMargin	String	before
s"""object O {} |class C {} |trait T {} """.stripMargin	String	after
PsiTreeUtil.getParentOfType(scalaFile.findElementAt(offset), classOf[ScReference])	ScReference	ref
getProjectAdapter	Project	project
s"""object Outer { | |${startMarker}val x = 2 + 2$endMarker | |}""".stripMargin	String	before
SmartPointerManager.getInstance(project).createSmartPsiElementPointer(ref)	SmartPsiElementPointer[ScReference]	refPointer
s"""object Outer { | | val x = 2 + 2 | |}""".stripMargin	String	after
s""" ${startMarker}val x=2 + 2 |val y = 4+4$endMarker """.stripMargin	String	before
getTypesToImport(ref)	Array[ElementToImport]	classes
prepareTest(inputText)	PostfixTemplateTest.TemplateDescriptor	descriptor
s"""val x = 2 + 2 |val y = 4 + 4 """.stripMargin	String	after
getFile	PsiFile	file
s""" |${startMarker}val x = 2 + 2 |val y = 4 + 4$endMarker | """.stripMargin	String	before
s""" |val x = 2 + 2 |val y = 4 + 4 | """.stripMargin	String	after
s"""${startMarker}trait X { | def xFoo = 42 | } |object O { } |class C { } |val x=println(2+2) |def foo (): Unit = { | 42 | }$endMarker """.stripMargin	String	before
s"""trait X { | def xFoo = 42 |} |object O {} |class C {} |val x = println(2 + 2) |def foo(): Unit = { | 42 |} """.stripMargin	String	after
s"""object Outer { |${startMarker}val x = |2 + 2$endMarker |}""".stripMargin	String	before
FileEditorManager.getInstance(project) .openTextEditor(new OpenFileDescriptor(project, getVFileAdapter, offset), false)	Editor	editor
s"""object Outer { | val x = | 2 + 2 |}""".stripMargin	String	after
s"""object Outer { |${startMarker} val x = |2+2$endMarker |}""".stripMargin	String	before
"scala"	String	extension
s"""object Outer { |${startMarker} val x = | 2 + 2$endMarker |}""".stripMargin	String	before
configureFromFileText( s"""sealed trait Foo { | def foo: Int |} | |final case class Bar(foo: Int) extends Foo | |case object Baz extends Foo { | override def foo = 42 |}""".stripMargin )	PsiFile	file
getImportHolder(ref, project)	ScImportsHolder	holder
configureFromFileText( s"""class Foo { | type Alias = Int | | val value: Alias = 42 | var variable: Alias = 42 | | def method(): Unit = {} | | class Bar { | private val baz = 42 | } |}""".stripMargin )	PsiFile	file
lastPsi.getNode.getElementType match { case `tLINE_COMMENT` => 0 case `tBLOCK_COMMENT` | `tDOC_COMMENT` => 2 case _ => throw new AssertionError("Test result must be in last comment statement.") }	Int	trimRight
s""" |${startMarker}object Outer { | val x=2+2 |}${endMarker} |""".stripMargin	String	before
s""" |object Outer { | val x = 2 + 2 |} |""".stripMargin	String	after
PlainTextSymbolCompletionContributorEP.forLanguage(ScalaLanguage.INSTANCE)	PlainTextSymbolCompletionContributor	contributor
new PlainPrefixMatcher(prefix)	PlainPrefixMatcher	matcher
s""" |${startMarker} object Outer { |val x=2+2 | }${endMarker} |""".stripMargin	String	before
s"""object Outer { | object Inner { |${startMarker}def bar (args:Array[String]):Unit={ |val x = 42 |}${endMarker} | } |}""".stripMargin	String	before
s"""object Outer { | object Inner { | def bar(args: Array[String]): Unit = { | val x = 42 | } | } |}""".stripMargin	String	after
scalaFile.findElementAt(scalaFile.getTextLength - 1)	PsiElement	lastPsi
lastPsi.getNode.getElementType match { case ScalaTokenTypes.tLINE_COMMENT => 0 case ScalaTokenTypes.tBLOCK_COMMENT | ScalaTokenTypes.tDOC_COMMENT => 2 case _ => -1 }	Int	delta
s"""object Outer { | object Inner { |${startMarker}val x = |2+2${endMarker} | } |}""".stripMargin	String	before
s"""object Outer { | object Inner { | val x = | 2 + 2 | } |}""".stripMargin	String	after
s"""object Test { | sealed trait SuperName | case class Name(firstName: String, lastName: String) extends SuperName | | def behavior(sn: SuperName): String = { | sn match { | case ${startMarker}Name${endMarker}(firstName, lastName) => | s"$$firstName$$lastName" | } | } |} """.stripMargin	String	before
myFixture.getElementAtCaret	PsiElement	elem
parseText(code)	ScalaFile	file
Migrations.all.map(_.version)	IndexedSeq[Int]	versions
LocalFileSystem.getInstance.findFileByPath(filePath)	VirtualFile	file
new ScalaTypeDefinitionFindUsagesOptions(getProject)	ScalaTypeDefinitionFindUsagesOptions	options
new ScalaFindUsagesHandler(named, ScalaFindUsagesHandlerFactory.getInstance(getProject))	ScalaFindUsagesHandler	handler
_ => true	Processor[UsageInfo]	dummyProcessor
Dependency.collect(file.getTextRange)(file).map { case (path, _) => path.asString() }.toSet	Set[String]	descriptors
new ScalaCodeStyleSettings()	ScalaCodeStyleSettings	settings
new SAXBuilder()	SAXBuilder	saxBuilder
saxBuilder.build(new StringReader(input))	Document	document
{ val saxBuilder = new SAXBuilder() val document = saxBuilder.build(new StringReader(input)) document.getRootElement }	Element	element
{ import templates.ScalaExhaustiveMatchPostfixTemplate def presentableName: PostfixTemplate => String = { case _: ScalaExhaustiveMatchPostfixTemplate => ScalaExhaustiveMatchPostfixTemplate.exhaustiveAlias case template => template.getPresentableName } ScalaPostfixTemplateProvider.Templates.map { template => presentableName(template) -> template }.toMap }	Map[String, PostfixTemplate]	Templates
getEditor	Editor	editor
conversions.map(_.name).mkString("Seq(", ",\n ", ")") + ",\n" + ( expr.implicitElement() match { case None => "None" case Some(elem: PsiNamedElement) => "Some(" + elem.name + ")" case _ => assert(assertion = false, message = "elem is not PsiNamedElement") } )	String	res
template.isApplicable(element, file.getViewProvider.getDocument, endOffset)	Boolean	isApplicable
inputText.indexOf(StartMarker)	Int	startOffset
new GotoImplementationHandler() .getSourceAndTargetElements(getEditor, getFile) .targets .length	Int	targetsCount
s"""val value = $literalText"""	String	text
configureFromFileText(text)	PsiFile	psiFile
inputText.indexOf(TagStart, startOffset + StartMarker.length)	Int	nameStartIndex
inputText.indexOf(TagEnd, nameStartIndex)	Int	nameEndIndex
_	ChooseByNamePopup	myPopup
new Semaphore(1)	Semaphore	semaphore
null	Null	bar
null	Null	moo
1	Int	foo
findAllTargetElements( getProject, editor, editor.getCaretModel.getOffset ).toSet	Set[PsiElement]	targets
null	Set[Any]	result
gotoClassElements("GoToClassS")	Set[Any]	elements
gotoClassElements("GTCS")	Set[Any]	elements
myFixture.addFileToProject("TestStatic.java", """public class TestStatic { | | public static int staticField = 0; | | public static int staticMethod() { | return 1; | } | | enum Enum { | A1; | | public static String enumStaticField = ""; | public String enumField = ""; | | enum Enum2 { | B1; | } | } | | interface Interface { | String interfaceField = ""; | } | | class Inner { | public int innerField = 1; | | public static int innerStaticField = 2; //compile error | } | | public static class StaticInner { | public int staticClassField = 1; | | public static int staticClassStaticField = 2; | } |}""".stripMargin.replace("\r", ""))	PsiFile	file
gotoClassElements("someP")	Set[Any]	elements
gotoSymbolElements("foo")	Set[Any]	elements
gotoClassElements("::")	Set[Any]	elements
gotoSymbolElements("::")	Set[Any]	elements
for { (actualElement, (predicate, expectedName)) <- targets.zip(expected) if !(predicate(actualElement) && hasExpectedName(actualElement, expectedName)) } yield actualElement	IndexedSeq[PsiElement]	wrongTargets
extractReferences(psiFile).filterBy[WebReference].map(_.getUrl)	IndexedSeq[Nothing]	urlReferencesActual
mutable.Buffer()	mutable.Buffer[PsiReference]	found
file.depthFirst().collect { case named: PsiNamedElement if ScalaPsiUtil.hasStablePath(named) => named.name }	Iterator[String]	hasStablePaths
elementsInScalaLibrary("Option", SUPER_CLASS_NAME_KEY).map(classFQN).sorted	IndexedSeq[String]	optionInheritors
new ScalaRecursiveElementVisitor { override def visitLiteral(literal: ScLiteral): Unit = { if (literal.isString) { found ++= literal.getReferences } super.visitLiteral(literal) } }	ScalaRecursiveElementVisitor { def visitLiteral(literal: ScLiteral): Unit }	visitor
elementsInScalaLibrary("Function2", SUPER_CLASS_NAME_KEY).map(classFQN).sorted	IndexedSeq[String]	function2Inheritors
2	Int	DEFAULT_TIME
tailText != null	Boolean	grayed
elementsInScalaLibrary("Runnable", SELF_TYPE_CLASS_NAME_KEY)	Seq[ScSelfTypeElement]	elements
getEditor.getCaretModel	CaretModel	caretModel
caretModel.getOffset	Int	caretOffset
getEditor.getDocument	Document	document
document.getLineStartOffset(document.getLineNumber(caretOffset))	Int	lineStart
elements.map(PsiTreeUtil.getParentOfType(_, classOf[ScTypeDefinition])).map(_.qualifiedName)	IndexedSeq[Any]	containingClass
completeBasic(0)	Array[LookupElement]	lookups
getFixture.completeBasic()	Array[LookupElement]	lookups
new CodeCompletionHandlerBase(CompletionType.BASIC, /*invokedExplicitly*/ false, /*autopopup*/ true, /*synchronous*/ true)	CodeCompletionHandlerBase	completionHandler
getModule.getModuleWithDependenciesAndLibrariesScope(true)	GlobalSearchScope	scope
getFixture.complete(`type`, invocationCount)	Array[LookupElement]	lookups
getFixture.complete(BASIC, invocationCount)	Array[LookupElement]	lookups
1	Int	DEFAULT_TIME
new LookupElementPresentation	LookupElementPresentation	presentation
ImplicitConversionIndex.allElements(moduleWithLibraries)(getProject).flatMap(_.qualifiedNameOpt).toSet	Set[String]	all
forClassFqn("scala.math.Ordering")	IndexedSeq[String]	orderings
forClassFqn("scala.math.Ordering.BooleanOrdering")	IndexedSeq[String]	booleanOrdering
forClassFqn("scala.concurrent.ExecutionContext")	IndexedSeq[String]	executionContext
items.exists(hasItemText(_, "foo")(itemTextBold = true, tailText = "(x: Int*)"))	Boolean	condition
for { item <- items itemElement = item.getPsiElement if (itemElement match { case _: SyntheticNamedElement | _: PsiPackage => false case _: PsiNamedElement => true case _ => false }) } yield itemElement.asInstanceOf[PsiNamedElement]	IndexedSeq[PsiNamedElement]	namedElements
Array.empty	Array[String]	importsWithPrefix
codeStyleSettings	ScalaCodeStyleSettings	settings
false	Boolean	isAddFullQualifiedImports
Seq( "asScalaBufferConverter", "collectionAsScalaIterableConverter", "iterableAsScalaIterableConverter" ).map(shortName => s"scala.collection.JavaConverters.$shortName")	Seq[String]	convertersNames
convertersNames.map { qualifiedName => s""" |import $qualifiedName |$expectedFileText """.stripMargin }	IndexedSeq[String]	expected
s""" |class Test { | def method(): Unit ={ | val doubleValue = 34.4 | if (doubleValue > intValue) { | methodWithParams("Hey!") | } else { | methodWithoutParams() | } | } | | val $CARET |} """.stripMargin	String	fileText
s""" |def foo(a: Int, b: Int): Unit = { | val mid = a + (b - a) / 2 | | if (mid == value) { | field1 = "got result" | println(field1) | } else if (mid > value) { | foo1(a, mid - 1) | } else { | foo2(mid + 1, value) | } | | var $CARET |} """.stripMargin	String	fileText
s""" |def foo(a: Int, b: Int): Unit = { | val mid = a + (b - a) / 2 | | if (mid == value) { | field1 = "got result" | println(field1) | } else if (mid > value) { | foo1(a, mid - 1) | } else { | foo2(mid + 1, value) | } | | def $CARET |} """.stripMargin	String	fileText
myFixture.copyFileToProject(path, getShortName(path, '/'))	VirtualFile	projectFile
getLookup	LookupImpl	lookup
s""" |class Test { | def method(): Unit ={ | val doubleValue = 34.4 | if (doubleValue > intValue) { | methodWithParams("Hey!") | } else { | methodWithoutParams() | } | } | | def $CARET |} """.stripMargin	String	fileText
s""" |class Test { | def method(): Unit = { | val doubleValue = 34.4 | if (doubleValue > intValue) { | methodWithParams(a = "Hey!", b = 4, 23) | } else { | methoda(12, 23, " ", 23.3, 34, " ") | } | } | | def $CARET |} """.stripMargin	String	fileText
completeBasic(3)	Array[LookupElement]	lookups
s""" |case class I(k: Int) { | I(1) add 3 | | def $CARET |} """.stripMargin	String	fileText
s""" |class Test { | def method(): Unit ={ | val doubleValue = 34.4 | if (doubleValue > intValue) { | methodWithoutParams("Hey!") | } else { | methodWithoutParams() | } | } | | object $CARET |} """.stripMargin	String	fileText
s""" |class Test { | def method(): Unit = { | methodWithoutParams("Hey!") | object $CARET | } |} """	String	fileText
s""" |class Test { | def method(): Unit ={ | val doubleValue = 34.4 | if (doubleValue > intValue) { | methodWithParams("Hey!") | } else { | methodWithoutParams() | } | } | | case class $CARET |} """.stripMargin	String	fileText
s""" |object Test{ | sealed trait $CARET | | case class ClassWithParams(firstParam: Long, secondParam: Option[String]) extends Base | | println(foo(3, 4)) | | val typedVal: NewType = "Hey!" |} """.stripMargin	String	fileText
s""" |object Test{ | type $CARET | | case class ClassWithParams(firstParam: Long, secondParam: Option[String]) extends Base | | val typedVal: NewType = "Hey!" | | println(unresolved) |} """.stripMargin	String	fileText
s""" |class $CARET |new Test(12, "hi!") """.stripMargin	String	fileText
new SelectionModelStub()	SelectionModelStub	selection
s""" |class X { | printX(12) | printX("Sfd") | | case class I(k: Int) { | def addd(i: Int) = ??? | | 3, 4) tail | | def tt: Seq[Int] = ??? | | } | | def foo(a: Int, b: Int): Unit = { | val mid = a + (b - a) / 2 | | if (mid == value) { | field1 = "got result" | println(field1) | } else if (mid > value) { | foo1(a, mid - 1) | } else { | foo2(mid + 1, value) | } | | def $CARET | } |} """.stripMargin	String	fileText
configureFromFileText(fileText).getVirtualFile	VirtualFile	file
getFixture	JavaCodeInsightTestFixture	fixture
owner.getControlFlow	Seq[Instruction]	instructions
dumpControlFlow(instructions)	String	cf
text.take(offset)	String	s
complete(fileText).collect { case item: ScalaTextLookupItem => item.getLookupString }.sorted	IndexedSeq[String]	actualSet
expected.sorted	Seq[String]	expectedSet
text.indexOf(CARET_MARKER)	Int	index
sourceRootPath + name	String	filePath
LocalFileSystem.getInstance.findFileByPath(filePath.replace(File.separatorChar, '/'))	VirtualFile	vFile
new EditorMock(cleanCode, offset)	EditorMock	editor
new ScalaStatementMover()	ScalaStatementMover	mover
new StatementUpDownMover.MoveInfo()	StatementUpDownMover.MoveInfo	info
createFile(fileName, text)	PsiFile	file
myFile.findElementAt(offset)	PsiElement	el
completeBasic(3).toSet .filterBy[ScalaLookupItem] .map { lookup => s"${lookup.containingClass.name}.${lookup.getLookupString}" }	IndexedSeq[String]	actual
Set( "D1.zeeGlobalDef", "D1.zeeGlobalVal", "D2.zeeGlobalDefInherited", "D2.zeeGlobalValInherited" )	Set[Nothing]	expected
LocalFileSystem.getInstance.findFileByPath(filePath.replace(File.separatorChar, '/'))	VirtualFile	answerFile
true	Boolean	includeReflectLibrary
mover.checkAvailable(editor, file, info, direction == Down)	Boolean	available
new AnnotatorHolderMock(getFile)	AnnotatorHolderMock	mock
method.superSignaturesIncludingSelfType	Seq[TermSignature]	signs
new StringBuilder("")	StringBuilder	res
Array[String]("<if>", "<else>", "<while>", "<do>", "<for>", "<yield>" , "<catch>", "<finally>", "<try>", "<braces>", "<match>", "<parenthesis>", "<if_cond>", "<else_cond>", "<unary>")	Array[String]	endMarkers
text	String	workingText
text.indexOf(startMarker)	Int	start
endMarkers.indexWhere(text.indexOf(_) != -1)	Int	t
endMarkers(t)	String	s
text.indexOf(s) - startMarker.length	Int	end
text.indexOf(marker)	Int	i
ScalaAnnotator.forProject	ScalaAnnotator	annotator
PsiManager.getInstance(myProject).asInstanceOf[PsiManagerEx].getFileManager	FileManager	fileManager
ScalaPsiUtil.nameContext(sign.namedElement) match { case member: PsiMember => val clazz = member.containingClass if (clazz != null) clazz.qualifiedName + "." else "" case _ => "" }	String	s
s"${getTestName(false)}.scala"	String	filePath
configureFile()	PsiFile	file
getFixture.getCaretOffset	Int	offset
new ShowParameterInfoContext(getEditor, getProject, file, offset, -1)	ShowParameterInfoContext	context
createHandler	ParameterInfoHandlerWithTabActionSupport[Owner, Any, _ <: PsiElement]	handler
handleUI(handler, context)	Seq[String]	actual
expectedSignatures(lastElement())	Seq[Seq[String]]	expected
handleUpdateUI(handler, context)	Seq[String]	actualAfterUpdate
0	Int	percent
0	Int	errorCount
files.size()	Int	size
handler.findElementForParameterInfo(context)	Owner	parameterOwner
Option(context.getItemsToShow).getOrElse(Array.empty)	Array[Nothing]	items
updateContext(context)	UpdateParameterInfoContext	updatedContext
handler.findElementForUpdatingParameterInfo(updatedContext)	Owner	parameterOwner
context.getItemsToShow	Array[Nothing]	itemsToShow
fileManager.findFile(file)	PsiFile	psi
itemsToShow	Array[AnyRef]	items
myFixture.configureByText(fileName, fileText.get.trim.replace("\r", "")).asInstanceOf[ScalaFile]	ScalaFile	file
mutable.SortedSet.empty[String]	mutable.SortedSet[String]	result
new AnnotatorHolderMock(psi) { override def createErrorAnnotation(range: TextRange, message: String): Annotation = { errorCount += 1 println(s"Error in ${file.getName}. Range: $range. Message: $message.") super.createErrorAnnotation(range, message) } override def createErrorAnnotation(elt: PsiElement, message: String): Annotation = { errorCount += 1 println(s"Error in ${file.getName}. Range: ${elt.getTextRange}. Message: $message.") super.createErrorAnnotation(elt, message) } }	AnnotatorHolderMock { def createErrorAnnotation(elt: PsiElement, message: String): Annotation def createErrorAnnotation(range: TextRange, message: String): Annotation }	mock
new ScalaRecursiveElementVisitor { override def visitScalaElement(element: ScalaPsiElement) { try { annotator.annotate(element, mock) } catch { case e: Throwable => println(s"Exception in ${file.getName}, Stacktrace: ") e.printStackTrace() assert(false) } super.visitScalaElement(element) } }	ScalaRecursiveElementVisitor { def visitScalaElement(element: ScalaPsiElement): Unit }	visitor
createInfoUIContext(parameterOwner) { result += _ }	ParameterInfoUIContext { def getDefaultParameterColor: Any def isSingleOverload: Boolean def isSingleParameterInfo: Boolean def isUIComponentEnabled: Boolean def setUIComponentEnabled(enabled: Boolean): Unit def setupUIComponentPresentation(text: String, highlightStartOffset: Int, highlightEndOffset: Int, isDisabled: Boolean, strikeout: Boolean, isDisabledBeforeHighlight: Boolean, background: Any): String def getParameterOwner: PsiElement def setupRawUIComponentPresentation(htmlText: String): Unit def getCurrentParameterIndex: Int }	uiContext
lastElement.getNode.getElementType match { case ScalaTokenTypes.tLINE_COMMENT => 0 case ScalaTokenTypes.tBLOCK_COMMENT | ScalaTokenTypes.tDOC_COMMENT => 2 }	Int	dropRight
myFixture.addFileToProject("com/example/other/packaje/UseCaseClassFromPackageObject.scala", """ |package com.example.other.packaje | |import com.example.packaje._ | |object UseCaseClassFromPackageObject { | def main(args: Array[String]) = { | println(CaseClassWithOverloads(107, "a")) | //println(CaseClassWithOverloads(new IntWithString(21, "b"))) | } |} | """.stripMargin)	PsiFile	fileToCheck
new ScalaRecursiveElementVisitor { override def visitReferenceExpression(ref: ScReferenceExpression): Unit = { if (ref.refName == "CaseClassWithOverloads") { assert(ref.bind().nonEmpty && ref.bind().get.isApplicable(), "Resolve is not applicable") } super.visitReferenceExpression(ref) } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	visitor
s"""class Base |class Sub extends Base | |class B[B <: Base](val a: B) | |class Test { | val a: Sub = null | val b: B[a.type] = ${START}new B(a)$END |} |//B[Test.this.a.type]""".stripMargin	String	text
configureFromFileText(fileName, fileText)	ScalaFile	scalaFile
myFixture.addFileToProject("tuff/MyTest.scala", """ |package tuff | |import scl8850._ | |class MyTest { | A.a |} """.stripMargin)	PsiFile	fileToCheck
findExpression(scalaFile)	ScExpression	expr
new ScalaRecursiveElementVisitor { override def visitReferenceExpression(ref: ScReferenceExpression): Unit = { assert(ref.resolve() != null, s"Can't resolve reference ${ref.refName}") } }	ScalaRecursiveElementVisitor { def visitReferenceExpression(ref: ScReferenceExpression): Unit }	visitor
s""" |trait AA[T] |trait QQ[T] extends AA[T] | |class Z extends QQ[AnyRef] | |object Example { | def asFA[F[_], A](fa: F[A]): F[A] = fa | | val z: QQ[AnyRef] = asFA(new Z) // sometimes type of the rhs is AA[T] instead of QQ[T] |} """.stripMargin	String	fileText
Extensions.getRootArea.getExtensionPoint(SyntheticMembersInjector.EP_NAME)	ExtensionPoint[SyntheticMembersInjector]	extensionPoint
expr.`type`() match { case Right(t) if t.isUnit => expr.getTypeIgnoreBaseType case x => x }	result.TypeResult	typez
ttypez.presentableText	String	res
extractTextForCurrentVersion(text.substring(2, text.length - 2).trim, version)	String	resText
folderPath + fileName	String	filePath
s""" |object Foo { | final class Example[A] { | def map[B](f: A => B): Example[B] = ??? | def flatMap[B](f: A => Example[B]): Example[B] = ??? | def withFilter(p: A => Boolean): Example[A] = ??? | } | | val x: Example[A] = ??? | | class A | | class B extends A | | def foo: Example[A] = $fooBody |} """.stripMargin	String	code
pat.getStringParts.mkString.split(':').last	String	resultingType
Extensions.getRootArea.getExtensionPoint(InterpolatedStringMacroTypeProvider.EP_NAME)	ExtensionPoint[InterpolatedStringMacroTypeProvider]	extensionPoint
""" object O { def unary_! {} def !(p: A) {} } """	String	header
""" object O { def apply(p: A) {} def apply(p1: A, p2: A) {} def f(p: A) {} } """	String	header
""" object O { var v1: A = _ var v2: A private[this] var v3: A = _ } """	String	header
s""" |implicit class StringToType(val sc: StringContext) extends AnyVal { | def toType(args: Any*): Any = sys.error("Here would be macro code") |} |val r = toType"2:Long" |println(${START}r${END}) |//Long """.stripMargin	String	text
expr.expectedType().map(_.presentableText).getOrElse("<none>")	String	actualExpectedTypeText
s""" |implicit class AnotherMacro(val sc: StringContext) extends AnyVal { | def foo(args: Any*): Any = sys.error("Here would be macro code") |} |val r = foo"2:Long" |println(${START}r${END}) |//Any """.stripMargin	String	text
if (PsiTreeUtil.getParentOfType(scalaFile.findElementAt(startOffset), classOf[ScExpression]) != null) 0 else 1	Int	addOne
""" object O { def update(k: A, v: B) {} def update(k1: A, k2: A, v: B) {} def f(k: A, v: B) {} } """	String	header
""" object O { def f(p: A) {} def ::(p: A) {} } """	String	header
""" object O { def f(v: Any) {} } """	String	header
""" object O extends Dynamic { def applyDynamic(s: String)(args: Any*) {} def applyDynamicNamed(s: String)(args: (String, Any)*) {} def selectDynamic(s: String): Any = _ def updateDynamic(s: String)(arg: Any) {} def f() {} } """	String	header
""" object O { def f: A = _ } """	String	header
""" class T { def +(p: A) = new T() def ::(p: A) = new T() } var t = new T() """	String	header
""" object O { def f(v: A*) {} def g(v1: A, v2: B*) {} } """	String	header
""" object O { def f(): A = _ def g: A = _ } """	String	header
"implicit val v: A = _"	String	header
_	Any => Any	f
f(a)	Any => Any	v
f	Any => Any	v
f _	Any => Any	v
f(a) _	Any => Any	v
""" object O { def apply(v: A => Unit) {} } """	String	header
a => f(a)	Any => Any	v
f	() => Any	v
(a, b) => f(a, b)	(Any, Any) => Any	v
f	Any => Any => Any	v
b => f(a)(b)	Any => Any	v
f	(Any, Any) => Any	v
a	() => Any	v
""	String	header
(createHeader(header), footer)	(String, String)	headerAndFooter
a => b => f(a)(b)	Any => Any => Any	v
configureByText(before)	PsiFile	actualFile
1	Int	v
s"""trait Test { | self: Outer => | | val inner: Inner = new Inner | ${caretMarker}val outerInner: Outer#Inner = inner |} | |class Outer { | class Inner |} |//true """.stripMargin	String	text
List.empty[TextRange]	List[TextRange]	actualRewriteTextRanges
s""" |trait T | |trait C { | self: T => | | ${caretMarker}val y: T = (this: this.type) |} |//true """.stripMargin	String	text
2	Int	y
3	Int	z
expectedResult	Boolean	expected
s""" |trait T | |trait C { | self: T => | | ${caretMarker}val y: T = (this: C) |} |//false """.stripMargin	String	text
resultListWithoutLast :+ (lastVer -> lastText)	IndexedSeq[(Option[ScalaVersion], String)]	resultList
ScalaFileType.INSTANCE	LanguageFileType	fileType
JavaFileType.INSTANCE	LanguageFileType	fileType
(textRanges, _, _) => actualRewriteTextRanges :::= textRanges	Transformer.ReformatAction	reformat
resultList .flatMap { case (Some(v), text) => Some(v -> text) case (None, text) => Some(ScalaSdkOwner.allTestVersions.head -> text) }	IndexedSeq[(ScalaVersion, String)]	resultsWithVersions
"" + code + Suffix	String	text
text.parse	ScalaFile	file
file.children.instancesOf[ScTemplateDefinition].toSeq	Seq[ScTemplateDefinition]	templateDefinitions
templateDefinitions.last	ScTemplateDefinition	lastDefinition
expectedReformatRanges.map(adjustMarkerRanges)	IndexedSeq[TextRange]	expectedReformatRangesWithHeader
configureByText(afterCode)	PsiFile	expectedFile
myFixture.getElementAtCaret	PsiElement	atCaret
rhsType.equiv(declaredType)	Boolean	equiv1
declaredType.equiv(rhsType)	Boolean	equiv2
s"""$header |$text |$footer""".stripMargin.withNormalizedSeparator	String	fileText
s"""class A { def a(): Unit = _ } |class B { def b(): Unit = _ } |class C { def c(): Unit = _ } |object A extends A |object B extends B |object C extends C""".stripMargin.withNormalizedSeparator	String	PredefinedHeader
rhsType.conforms(declaredType)	Boolean	conforms
rhsType.conforms(declaredType)	Boolean	res
ScalaCompilerConfiguration.instanceIn(project).defaultProfile	ScalaCompilerSettingsProfile	defaultProfile
ScalaOIUtil.getMembersToImplement(lastDefinition)	Seq[overrideImplement.ClassMember]	members
new StringBuilder("\n")	StringBuilder	report
s""" |package test | |class Foo extends b { | $CARET_TAG |} |abstract class b { | def foo(x: b): b |} """.stripMargin	String	fileText
s""" |package test | |class Foo extends b { | def foo(x: b): b = $SELECTION_START_TAG???$SELECTION_END_TAG |} |abstract class b { | def foo(x: b): b |} """.stripMargin	String	expectedText
"foo"	String	methodName
true	Boolean	isImplement
mutable.Map.empty	mutable.Map[String, Seq[(TextRange, String)]]	errorMessages
s""" |package test |class Empty extends b { | def foo(): Int = 3 | | | $CARET_TAG | | |} |abstract class b { | def too: b |} """.stripMargin	String	fileText
escapeTC(message)	String	escaped
myFixture.configureByText("ScalaDummy.scala", scalaText.replace("\r", "").stripMargin.trim)	PsiFile	scalaFile
-1	Int	oldPercent
(fraction * 100).toInt	Int	percent
s""" |package test |class Empty extends b { | def foo(): Int = 3 | | def too: b = $SELECTION_START_TAG???$SELECTION_END_TAG |} |abstract class b { | def too: b |} """.stripMargin	String	expectedText
"too"	String	methodName
s"$name.$fileName${range.toString}"	String	testName
(percent / 10) * 10	Int	rounded
TypeAnnotationSettings.alwaysAddType(ScalaCodeStyleSettings.getInstance(getProject))	ScalaCodeStyleSettings	settings
unexpectedErrors.size	Int	totalErrors
"putAll"	String	methodName
unexpectedSuccess	Set[String]	fixedFiles
s""" |package test | |class MethodsNewLine extends b { | def foo(): Int = 3$CARET_TAG |} |abstract class b { | def too: b |} """.stripMargin	String	fileText
fixedFiles.mkString(", ")	String	filesString
expectedErrorsTip(expectedErrors ++ unexpectedErrors)	String	errorsTip
unexpectedSuccess	Set[String]	noErrorsButExpected
testsWithProblems.mkString(", ")	String	testNames
noErrorsButExpected.mkString( "Looks like you've fixed highlighting in files: \n", "\n", "\nRemove them from `filesWithProblems` of a test case.\n\n")	String	reportSuccess
inputText	String	input
s""" |package test | |class MethodsNewLine extends b { | def foo(): Int = 3 | | def too: b = $SELECTION_START_TAG???$SELECTION_END_TAG |} |abstract class b { | def too: b |} """.stripMargin	String	expectedText
new TextBasedProgressIndicator { override def setText(text: String): Unit = { if (getText != text) { super.setText(text) tcPrint(s"progressMessage '$text'") } } override def setText2(text: String): Unit = setText(text) }	ProgressIndicator	progressIndicator
Set.empty	Set[String]	testsWithProblems
mutable.Map[String, Int]()	mutable.Map[String, Int]	markerPositions
mutable.Buffer.empty[TextRange]	mutable.Buffer[TextRange]	textRanges
expectedErrors.map((formatMessage _).tupled)	IndexedSeq[String]	expected
7	Int	maxErrorsPerTip
s""" |package test | |class UpperNewLine extends b { | $CARET_TAG | def foo(): Int = 3 |} |abstract class b { | def too: b |} """.stripMargin	String	fileText
EnumSet(A, B, B, B, B, A, B)	EnumSet.EnumSet[JavaEnum]	ab
s""" |package test | |class UpperNewLine extends b { | | def too: b = $SELECTION_START_TAG???$SELECTION_END_TAG | | def foo(): Int = 3 |} |abstract class b { | def too: b |} """.stripMargin	String	expectedText
detectMarker(startMarker, endMarker)	Boolean	hasStartMarker
detectNumberedMarkers(0)	Int	index
s""" |package test | |class A { | def foo(): A = null |} |class FunctionOverride extends A { | val t = foo() | | | $CARET_TAG |} """.stripMargin	String	fileText
LightPlatformTestCase.getSourceRoot	VirtualFile	sourceRoot
if (fileErrors.length > maxErrorsPerTip) "" else fileErrors.map(_._2).toSet.map((r: TextRange) => s"(${r.getStartOffset}, ${r.getEndOffset})").mkString(",")	String	errorsSeq
for ((fileName, fileErrors) <- errors.groupBy(_._1)) yield getEntryText(fileName, fileErrors)	Iterable[String]	errorRanges
s""" |package test | |class A { | def foo(): A = null |} |class FunctionOverride extends A { | val t = foo() | | override def foo(): A = ${SELECTION_START_TAG}super.foo()$SELECTION_END_TAG |} """.stripMargin	String	expectedText
new TextBasedProgressIndicator	ProgressIndicator	progressIndicator
false	Boolean	isImplement
settings.clone().asInstanceOf[ScalaCodeStyleSettings]	ScalaCodeStyleSettings	coppedSettings
EnumSet.empty[JavaEnum] ++ A ++ B	EnumSet.EnumSet[JavaEnum]	ab2
s""" |package Y |trait Aa { | type K |} |class TypeAlias extends Aa { | val t = foo() | $CARET_TAG | def y(): Int = 3 |} """.stripMargin	String	fileText
dirNames(path).foldLeft(sourceRoot)(createDir)	VirtualFile	dir
makePsiElement()	PsiElement	psi
s""" |package Y |trait Aa { | type K |} |class TypeAlias extends Aa { | val t = foo() | | type K = ${SELECTION_START_TAG}this.type$SELECTION_END_TAG | | def y(): Int = 3 |} """.stripMargin	String	expectedText
"K"	String	methodName
Seq.empty[CachedRecursiveFunction]	Seq[CacheTestUtils.this.CachedRecursiveFunction]	innerCalls
0	Int	calcCounter
calcCounter	Int	oldCount
call()	String	result
EnumSet(B) ++ EnumSet(C)	EnumSet.EnumSet[JavaEnum]	bc
sortMarkers(markerPositions.toList.sortBy(_._2)).toMap	Map[String, Int]	adjustedMarkers
s""" |package test | |class A { | val foo: A = new A |} |class OverrideValue extends A { | val t = foo() | $CARET_TAG |} """.stripMargin	String	fileText
ab ++ bc	EnumSet.EnumSet[JavaEnum]	abc
dir.createChildData(null, fileName)	VirtualFile	vFile
createVFile(path)	VirtualFile	vFile
if (caretIndex > 0) { PsiTreeUtil.findElementOfClassAtOffset(scalaFile, caretIndex, classOf[ScPatternDefinition], false) } else scalaFile.findLastChildByType[PsiElement](ScalaElementType.PATTERN_DEFINITION)	PsiElement	patternDef
PsiManager.getInstance(project).findFile(vFile)	PsiFile	psiFile
Func("a")	CacheWithinRecursionTest.this.CachedRecursiveFunction	a
patternDef.asInstanceOf[ScPatternDefinition]	ScPatternDefinition	valueDecl
s""" |package test | |class A { | val foo: A = new A |} |class OverrideValue extends A { | val t = foo() | override val foo: A = ${SELECTION_START_TAG}_$SELECTION_END_TAG |} """.stripMargin	String	expectedText
oldCount == calcCounter && !result.startsWith("#")	Boolean	wasCached
collectMarkerOffsets(|)	Array[Int]	caretOffsets
Func("b")	CacheWithinRecursionTest.this.CachedRecursiveFunction	b
collectMarkerOffsets(^^)	Array[Int]	offsetsToChange
Func("c")	CacheWithinRecursionTest.this.CachedRecursiveFunction	c
collectMarkerOffsets(~~)	Array[Int]	offsetsToStay
getFile.findElementAt(caretOffset)	PsiElement	elementAtCaret
getFile.findElementAt(psiOffset)	PsiElement	psiElement
s""" |package test | |trait A { | var foo: A |} |class VarImplement extends A { | val t = foo() | $CARET_TAG | def y(): Int = 3 |} """.stripMargin	String	fileText
RecursionManager .RecursionGuard[PsiElement, String]("callcacheKey$macro$1") .getFromLocalCache(psi)	String	localResult
testFixtureProvider.getFixture.getProject	ProjectContext	projectContext
EnumSet(D) ++ EnumSet(A) ++ C	EnumSet.EnumSet[JavaEnum]	acd
getFile.findElementAt(offset)	PsiElement	leaf
valueDecl.declaredType.getOrElse(sys.error("Must provide type annotation for LHS"))	ScType	declaredType
EnumSet.empty[JavaEnum]	EnumSet.EnumSet[JavaEnum]	empty1
s""" |package test | |trait A { | var foo: A |} |class VarImplement extends A { | val t = foo() | | var foo: A = ${SELECTION_START_TAG}_$SELECTION_END_TAG | | def y(): Int = 3 |} """.stripMargin	String	expectedText
EnumSet[JavaEnum]()	EnumSet.EnumSet[JavaEnum]	empty2
valueDecl.expr.getOrElse(sys.error("Expression not found"))	ScExpression	expr
EnumSet.readFromInt[JavaEnum](0)	EnumSet.EnumSet[JavaEnum]	empty3
s""" |package test | |trait A { | def foo: Int |} |trait B { | self: A => | $CARET_TAG |} """.stripMargin	String	fileText
Func("a2")	CacheWithinRecursionTest.this.CachedRecursiveFunction	a2
s""" |package test | |trait A { | def foo: Int |} |trait B { | self: A => | def foo: Int = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |package test | |trait A { | def foo: Int = 1 |} |trait B { | self: A => | $CARET_TAG |} """.stripMargin	String	fileText
s"a(b(#a+c(#b)+@@c(#b))+c(@@b(#a+c(#b)+@@c(#b))))"	String	expectA
new ArrayBuffer[TextRange]()	ArrayBuffer[TextRange]	myRegions
new StringBuilder(fileText.length)	StringBuilder	myFileText
s"b(@$expectA+c(#b)+@@c(#b))"	String	expectB
mutable.Stack[Int]()	mutable.Stack[Int]	myOpenMarkers
s""" |package test | |trait A { | def foo: Int = 1 |} |trait B { | self: A => | override def foo = ${SELECTION_START_TAG}self.foo$SELECTION_END_TAG |} """.stripMargin	String	expectedText
fileText indexOf FOLD_START_MARKER	Int	i1
if (caretIndex > 0) { PsiTreeUtil.findElementOfClassAtOffset(scalaFile, caretIndex, classOf[ScMethodCall], false) } else scalaFile.findLastChildByType[PsiElement](ScalaElementType.METHOD_CALL)	PsiElement	element
fileText indexOf FOLD_END_MARKER	Int	i2
0	Int	overallFixOffset
element.asInstanceOf[ScMethodCall]	ScMethodCall	application
s""" |class ImplementTypeAlias extends b { | $CARET_TAG |} |abstract class b { | type L |} """.stripMargin	String	fileText
scala.collection.mutable.ArrayBuffer[String]()	ArrayBuffer[String]	errors
myOpenMarkers.pop()	Int	st
i2	Int	i2Old
i1	Int	i1Old
configureFromFileText(text)	PsiFile	file
ranges	Seq[TextRange]	expectedTodoRanges
s""" |class ImplementTypeAlias extends b { | type L = ${SELECTION_START_TAG}this.type$SELECTION_END_TAG |} |abstract class b { | type L |} """.stripMargin	String	expectedText
extractActualTodoRanges	Seq[TextRange]	actualTodoRanges
"L"	String	methodName
ScalaPsiElementFactory.createScalaFileFromText("class Test")	ScalaFile	file
s""" |package test | |class Val extends b { | $CARET_TAG |} |abstract class b { | val too: b |} """.stripMargin	String	fileText
myRegions.result().sortWith((x, y) => x.getStartOffset < y.getStartOffset)	ArrayBuffer[TextRange]	assumedRegionRanges
new ScalaFoldingBuilder	ScalaFoldingBuilder	myBuilder
Some(Ordering.String)	Some[Ordering.String.type]	lexOrdering
s""" |package test | |class Val extends b { | val too: b = ${SELECTION_START_TAG}_$SELECTION_END_TAG |} |abstract class b { | val too: b |} """.stripMargin	String	expectedText
TodoCacheManager.SERVICE.getInstance(getProject).getTodoCount(vFile, TodoIndexPatternProvider.getInstance)	Int	todosInIndex
Some(ScalastyleSettings.nameOrdering)	Some[Ordering[String]]	scalastyleOrdering
PsiTodoSearchHelper.SERVICE.getInstance(getProject).findTodoItems(getFile).length	Int	todosInHighlighting
new ImportTextCreator()	ScalaImportOptimizer.ImportTextCreator	textCreator
s""" |package test | |class Var extends b { | $CARET_TAG |} |abstract class b { | var too: b |} """.stripMargin	String	fileText
myBuilder.buildFoldRegions(myFixture.getFile.getNode, myFixture getDocument myFixture.getFile)	Array[FoldingDescriptor]	regions
expr.`type`().getOrElse(throw new RuntimeException(s"Failed to get type of expression(${expr.getText})"))	ScType	exprTp
s""" |package test | |class Var extends b { | var too: b = ${SELECTION_START_TAG}_$SELECTION_END_TAG |} |abstract class b { | var too: b |} """.stripMargin	String	expectedText
exprTp.conforms(param.paramType)	Boolean	res
variants(0).getElement.getContainingFile	PsiFile	elementFile
s""" |class A[T] { | def foo: T = new T |} | |class ClassTypeParam extends A[Int] { | $CARET_TAG |} """.stripMargin	String	fileText
ImportInfo("scala.collection", hasWildcard = true, rootUsed = true)	ImportInfo	info
elementFile == ref.getContainingFile	Boolean	res
ImportInfo("scala", hiddenNames = Set("Long"))	ImportInfo	info
messages( """ |trait Foo { | class A | class B | var foo:A | def foo_=(f: B) | foo = new B |} """.stripMargin)	List[Message]	messages1
s""" |class A[T] { | def foo: T = new T |} | |class ClassTypeParam extends A[Int] { | override def foo: Int = ${SELECTION_START_TAG}super.foo$SELECTION_END_TAG |} """.stripMargin	String	expectedText
ImportInfo("java.lang", renames = Map("Long" -> "JLong"))	ImportInfo	info
s""" |class A[T] { | def foo(x: (T) => T, y: (T, Int) => T): Double = 1.0 |} | |class Substituting extends A[Float] { | $CARET_TAG |} """.stripMargin	String	fileText
ImportInfo("java.lang", singleNames = Set("Long", "Integer", "Float", "Short"))	ImportInfo	info
code.parse	ScalaFile	file
s""" |class A[T] { | def foo(x: (T) => T, y: (T, Int) => T): Double = 1.0 |} | |class Substituting extends A[Float] { | override def foo(x: Float => Float, y: (Float, Int) => Float): Double = ${SELECTION_START_TAG}super.foo(x, y)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
file.depthFirst().find(_.isInstanceOf[ScAssignment]).get.asInstanceOf[ScAssignment]	ScAssignment	assignment
s""" |abstract class A { | def foo[T](x: T): T |} |class SimpleTypeParam extends A { | $CARET_TAG |} """.stripMargin	String	fileText
ImportInfo("java.lang", singleNames = Set("Integer", "Character", "Runtime"), renames = Map("Long" -> "JLong", "Float" -> "JFloat"), hiddenNames = Set("System"), hasWildcard = true)	ImportInfo	info
psi.findElementAt(pos) match { case e: LeafPsiElement => Some(e.getParent.asInstanceOf[ScStableCodeReference].resolve()) case other => None }	Option[PsiElement]	expr
classOf[AnnotatorBasedErrorInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
"Cannot resolve symbol hello"	String	description
s""" |abstract class A { | def foo[T](x: T): T |} |class SimpleTypeParam extends A { | def foo[T](x: T): T = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |package test | |trait Foo { | def foo(a: Any*): Any |} | |trait Sub extends Foo { | $CARET_TAG |} """.stripMargin	String	fileText
ImportInfo("java.io", singleNames = Set("InputStream", "IOException", "SequenceInputStream"))	ImportInfo	info
s""" |package test | |trait Foo { | def foo(a: Any*): Any |} | |trait Sub extends Foo { | def foo(a: Any*): Any = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
ImportInfo("java.io", singleNames = Set("IOException", "InputStream", "SequenceInputStream"))	ImportInfo	info
s""" |package test | |trait Parent { | def m(p: T forSome {type T <: Number}) |} | |class Child extends Parent { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |package test | |trait Parent { | def m(p: T forSome {type T <: Number}) |} | |class Child extends Parent { | def m(p: (T) forSome {type T <: Number}): Unit = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
"m"	String	methodName
s""" |class A { | def foo(x_ : Int) = 1 |} | |class B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |class A { | def foo(x_ : Int) = 1 |} | |class B extends A { | override def foo(x_ : Int): Int = ${SELECTION_START_TAG}super.foo(x_)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |package test | |class Parent { | def doSmth(smth: => String) {} |} | |class Child extends Parent { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |package test | |class Parent { | def doSmth(smth: => String) {} |} | |class Child extends Parent { | override def doSmth(smth: => String): Unit = ${SELECTION_START_TAG}super.doSmth(smth)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
"doSmth"	String	methodName
s""" |class A { | type ID[X] = X | def foo(in: ID[String]): ID[Int] = null |} | |class B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |class A { | type ID[X] = X | def foo(in: ID[String]): ID[Int] = null |} | |class B extends A { | override def foo(in: ID[String]): ID[Int] = ${SELECTION_START_TAG}super.foo(in)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |class A { | type ID[X] = X | val foo: ID[Int] = null |} | |class B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
myFixture.getFile	PsiFile	file
s""" |class A { | type ID[X] = X | val foo: ID[Int] = null |} | |class B extends A { | override val foo: ID[Int] = ${SELECTION_START_TAG}_$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |// private constructor |class Recipe private(val ingredients: List[String] = List.empty, | val directions: List[String] = List.empty) { | println("something") |} | |object Recipe { | def make(ingredients: List[String], directions: List[String]): Recipe = | new Recipe(ingredients, directions) |} | |object Cookbook { | // no warnings | val pbj = ${CARET_MARKER}new Recipe( | List("peanut butter", "jelly", "bread"), | List("put the peanut butter and jelly on the bread")) |} """.stripMargin	String	text
s""" |class A { | type F = (Int => String) | def foo(f: F): Any = null |} | |object B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |class A { | type F = (Int => String) | def foo(f: F): Any = null |} | |object B extends A { | override def foo(f: B.F): Any = ${SELECTION_START_TAG}super.foo(f)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |trait TC[_] | |class A { | def foo[M[X], N[X[_]]: TC]: String = "" |} | |object B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s"""object ErrorHighlightingExample extends App { | import scala.language.existentials | | class Network { | | class Member(val name: String) | | def join(name: String) = ??? | } | | def processSpecificNetwork[M <: n.Member forSome {val n : Network}](m1: M, m2: M) = (m1, m2) | | val chatter = new Network | val myFace = new Network | | val fred: chatter.Member = chatter.join("Fred") | val barney: myFace.Member = myFace.join("Barney") | | processSpecificNetwork(fred, bar${CARET_MARKER}ney) |} """.stripMargin	String	text
text.indexOf(CARET_MARKER)	Int	caretIndex
s"""trait Semigroup[F] { | def zero: F = ??? | | def append(f1: F, f2: => F): F = ??? |} | |object Test { | def foo(i: Iterator[String], s: Semigroup[String]) = i.fold(s.zero)(s.ap${CARET_MARKER}pend) |}""".stripMargin	String	text
s""" |trait TC[_] | |class A { | def foo[M[X], N[X[_]]: TC]: String = "" |} | |object B extends A { | override def foo[M[X], N[X[_]] : TC]: String = ${SELECTION_START_TAG}super.foo$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s"""trait Semigroup[F] { | def zero: F = ??? | | def append(f1: F, f2: => F): F = ??? |} | |object Test { | def foo(i: Iterator[String], s: Semigroup[String]) = i.fold(s.zero)(s.ap${CARET_MARKER}pend _) |}""".stripMargin	String	text
s""" |package test | |object A { | | object Nested { | | class Nested2 | | } | |} | |abstract class B { | def foo(v: A.Nested.Nested2) |} | |class C extends B { | $CARET_TAG |} """.stripMargin	String	fileText
new ConsoleReporter(filesWithProblems)	ConsoleReporter	reporter
s""" |package test | |import test.A.Nested | |object A { | | object Nested { | | class Nested2 | | } | |} | |abstract class B { | def foo(v: A.Nested.Nested2) |} | |class C extends B { | def foo(v: Nested.Nested2): Unit = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |package test | |class Foo extends b { | $CARET_TAG |} |abstract class b { | def foo(x: b): Unit |} """.stripMargin	String	fileText
s""" |package test | |class Foo extends b { | def foo(x: b): Unit = $SELECTION_START_TAG???$SELECTION_END_TAG |} |abstract class b { | def foo(x: b): Unit |} """.stripMargin	String	expectedText
file.depthFirst().instancesOf[PsiErrorElement].map(_.getText).toList	List[Nothing]	errorElements
s""" |package test | |class Foo extends b { | $CARET_TAG |} |abstract class b { | def foo(x: b) = () |} """.stripMargin	String	fileText
s""" |package test | |class Foo extends b { | override def foo(x: b): Unit = ${SELECTION_START_TAG}super.foo(x)$SELECTION_END_TAG |} |abstract class b { | def foo(x: b) = () |} """.stripMargin	String	expectedText
s""" |package test | |class Foo extends b { | $CARET_TAG |} |abstract class b { | def foo(x: b) = 1 |} """.stripMargin	String	fileText
s""" |package test | |class Foo extends b { | override def foo(x: b): Int = ${SELECTION_START_TAG}super.foo(x)$SELECTION_END_TAG |} |abstract class b { | def foo(x: b) = 1 |} """.stripMargin	String	expectedText
file.depthFirst().instancesOf[PsiReference]. filter(_.resolve == null).map(_.getElement.getText).toList	List[Nothing]	unresolvedElements
NameTransformer.decode(fileName)	String	decoded
s""" |class A { | def foo(x : Int): Int = 1 |} | |class B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s"""object Test { | def processStrings(strings: String*) = 1.23 | | val processAny = processStrings(${CARET_MARKER}_: _*) |} """.stripMargin	String	text
testDataDir + decoded	String	dirPath
"overriding variable name in class Abs of type String"	String	description
s""" |class A { | def foo(x : Int): Int = 1 |} | |class B extends A { | override def foo(x: Int): Int = ${SELECTION_START_TAG}super.foo(x)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s"""class Foo(x: Int)(y: Int) |val foo = new Foo$CARET_MARKER(1) """.stripMargin	String	text
s"""List("A", "B").foreach {it => | println("it = " + ${CARET_MARKER}_) | } """.stripMargin	String	text
!prevCond	Boolean	cond
s""" |trait A { | def foo(x : Int)(implicit name: String): Int = name + x |} | |class B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |trait A { | def foo(x : Int)(implicit name: String): Int = name + x |} | |class B extends A { | override def foo(x: Int)(implicit name: String): Int = ${SELECTION_START_TAG}super.foo(x)$SELECTION_END_TAG |} """.stripMargin	String	expectedText
new Base() { def foo(default: Int): Any = () }	{ def foo(default: Int): Any }	anonClass
s""" |abstract class A { | protected def foo(): Unit |} | |class B extends A { | $CARET_TAG |} """.stripMargin	String	fileText
s"""object Test extends App{ | class A | class B extends A | def foo(x: A, y: B) = print(1) | object foo { | def apply(x: B, y: B) = print(3) | def apply(x: A, y: A) = print(5) | } | | ${CARET_MARKER}foo(new B, new B) |} """.stripMargin	String	text
s"""object Test { | def apply[T](x1: T) = "one arg" // A | def apply[T](x1: T, x2: T) = "two args" // B | def apply[T](elems: T*) = "var-args: " + elems.size // C |} | |object Exec { | ${CARET_MARKER}Test(1) |} """.stripMargin	String	text
s""" |abstract class A { | protected def foo(): Unit |} | |class B extends A { | protected def foo() = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s""" |abstract class A { | protected def foo(): Unit |} | |class B$CARET_TAG extends A """.stripMargin	String	fileText
s""" |abstract class A { | protected def foo(): Unit |} | |class B extends A { | protected def foo(): Unit = $SELECTION_START_TAG???$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s"""object IntelliJ { | trait Base[T] | case object StringExample extends Base[String] | | implicit val baseStringEvidence = StringExample | | def apply[T: Base](semantic: Base[T]): T = semantic match { | case StringExample => $START"string"$END | } |} |//T""".stripMargin	String	text
expression match { case b: ScBlockExpr => b.getRBrace.map(_.getPsi).getOrElse(b) case _ => expression }	PsiElement	expr
s""" |abstract class A { | protected def foo(): Unit = {} |} | |class B$CARET_TAG extends A """.stripMargin	String	fileText
s""" |abstract class A { | protected def foo(): Unit = {} |} | |class B extends A { | override protected def foo(): Unit = ${SELECTION_START_TAG}super.foo()$SELECTION_END_TAG |} """.stripMargin	String	expectedText
s"""import scala.collection.immutable.NumericRange | |val seq = Seq("") |val x = seq match { | case nr: NumericRange[_] => ${START}nr$END | case _ => null |} |//NumericRange[_]""".stripMargin	String	text
s""" |abstract class A { | | /** | * qwerty | * | * @return | */ | protected def foo(): Unit = {} |} | |class B$CARET_TAG extends A """.stripMargin	String	fileText
s""" |abstract class A { | | /** | * qwerty | * | * @return | */ | protected def foo(): Unit = {} |} | |class B extends A { | /** | * qwerty | * | * @return | */ | override protected def foo(): Unit = ${SELECTION_START_TAG}super.foo()$SELECTION_END_TAG |} """.stripMargin	String	expectedText
true	Boolean	copyScalaDoc
s""" |import scala.collection.Seq | |class Test { | def foo: Seq[Int] = Seq(1) |} | |class Test2 extends Test { |$CARET_TAG |} """.stripMargin	String	fileText
s""" |import scala.collection.Seq | |class Test { | def foo: Seq[Int] = Seq(1) |} | |class Test2 extends Test { | override def foo: Seq[Int] = super.foo |} """.stripMargin	String	expectedText
s""" |class Parent(val param1: Int, var param2: String) | |class Child extends Parent(4, "") { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |class Parent(val param1: Int, var param2: String) | |class Child extends Parent(4, "") { | override val param1: Int = _ |} """.stripMargin	String	expectedText
s""" |trait Base { | @throws(classOf[Exception]) | @deprecated | def annotFoo(int: Int): Int = 45 |} | |class Inheritor extends Base { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |trait Base { | @throws(classOf[Exception]) | @deprecated | def annotFoo(int: Int): Int = 45 |} | |class Inheritor extends Base { | override def annotFoo(int: Int): Int = super.annotFoo(int) |} """.stripMargin	String	expectedText
"annotFoo"	String	methodName
s""" |val s1 : Set[Class[_]] = Set() |val s2 : Set[java.lang.Class[_]] = Set() | |if(!s1.union(${START}s2$END).isEmpty) println(5) |//GenSet[Class[_]]""".stripMargin	String	text
holder.createErrorAnnotation(expr, ScalaBundle.message("type.mismatch.found.required", actualText, expText))	Annotation	annotation
s""" |def second[T]: Seq[T] => Option[T] = _.drop(1).headOption |second(${START}Seq("one", "two")$END) |//Seq[T]""".stripMargin	String	text
s""" |import tag._ | |object tag { | trait Tagged[U] | type @@[+T, U] = T with Tagged[U] |} | | |trait UserRepo { | sealed trait UserId // used for tagging | | def deleteUser(userId: Int @@ UserId) |} | |class UserRepoImpl extends UserRepo { | $CARET_TAG |} """.stripMargin	String	fileText
s""" |import tag._ | |object tag { | trait Tagged[U] | type @@[+T, U] = T with Tagged[U] |} | | |trait UserRepo { | sealed trait UserId // used for tagging | | def deleteUser(userId: Int @@ UserId) |} | |class UserRepoImpl extends UserRepo { | def deleteUser(userId: Int @@ UserId): Unit = ??? |} """.stripMargin	String	expectedText
s""" |abstract class ClassToOverride { | abstract def methodToOverride(): Unit |} | |class OverridingClass extends ClassToOverride { | $CARET_TAG |}""".stripMargin	String	fileText
s""" |abstract class ClassToOverride { | abstract def methodToOverride(): Unit |} | |class OverridingClass extends ClassToOverride { | def methodToOverride(): Unit = ??? |}""".stripMargin	String	expectedResult
"A has itself as bound"	String	description
"Type mismatch: expected (=> TicketTester.A) => TicketTester.B, found: TicketTester.A => TicketTester.B"	String	description
"Type mismatch: expected Future[?], found Option[Int]"	String	description
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[Either[String, ?]] { | $CARET_TAG |} """.stripMargin	String	text
s"""class Data{ | override def clone(): this.type = new Data().asInstanceOf[this.type] |} |class Handshake[T <: Data](dataType: T){ | val data = dataType.clone() |} | |object Test{ | def doit[T <: Data](handshake : Handshake[T]): Handshake[T] ={ | val ret = new Handshake(handshake.data) | return ${START}ret$END | // <- ret is marked red "Expression of type Handshake[that.dataType.type] doesn't conform to expected type Handshake[T] | //If i write return new Handshake(handshake.data) all is ok | } |} | |//Handshake[T]""".stripMargin	String	text
s"""object Test { | class A | class C | class B extends C | | class Z[-T] //in case of covariant or invariant, all is ok | | def goo[A, BB >: A](x: A): Z[BB] = new Z[BB] | val zzzzzz = goo(new B) //here type is Z[Any], according to the compiler it's Z[B] | ${START}zzzzzz$END |} | |//Test.Z[B]""".stripMargin	String	text
"Reference to a is ambiguous; it is both a method parameter and a variable in scope."	String	description
"Type mismatch, expected: M[T], actual: Main.B4"	String	description
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[Either[String, ?]] { | def monad: Monad[Either[String, ?]] = ??? |} """.stripMargin	String	expected
"Type mismatch, expected: Foo, actual: String"	String	description
"class type required but Hello.type found"	String	description
"Type mismatch, expected: (String, Any), actual: String(\"b\")"	String	description
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[Lambda[A => (A, A)]] { | $CARET_TAG |} """.stripMargin	String	text
"Type mismatch, expected: Option[?], actual: Seq[Int]"	String	description
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[Lambda[A => (A, A)]] { | def monad: Monad[Lambda[A => (A, A)]] = ??? |} """.stripMargin	String	expected
"Type mismatch, expected: Int, actual: Unit"	String	description
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[Lambda[`+A` => Either[List[A], List[A]]]] { | $CARET_TAG |} """.stripMargin	String	text
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[Lambda[`+A` => Either[List[A], List[A]]]] { | def monad: Monad[Lambda[`+A` => Either[List[A], List[A]]]] = ??? |} """.stripMargin	String	expected
s""" |trait Foo[F[_, _]] { | def foo: F[Double, String] |} | |class Bar extends Foo[[(-[A], +[B]) => (A, Int) => B]] { | $CARET_TAG |} """.stripMargin	String	text
s""" |trait Foo[F[_, _]] { | def foo: F[Double, String] |} | |class Bar extends Foo[[(-[A], +[B]) => (A, Int) => B]] { | def foo: (Double, Int) => String = ??? |} """.stripMargin	String	expected
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[({ type L[A] = List[(String, A)] })#L] { | $CARET_TAG |} """.stripMargin	String	text
s""" |trait Monad[F[_]] |trait Foo[F[_]] { | def monad: Monad[F] |} | |class Bar extends Foo[({ type L[A] = List[(String, A)] })#L] { | def monad: Monad[Lambda[A => List[(String, A)]]] = ??? |} """.stripMargin	String	expected
s""" |trait ~>[F[_], G[_]] |trait Monad[F[_]] |type ReaderT[F[_], A, B] = F | |trait Unlift[F[_], G[_]] { | self => | def unlift: G[G ~> F] |} | |implicit def reader[F[_]: Monad, R]: Unlift[F, ReaderT[F, R, ?]] = | new Unlift[F, ReaderT[F, R, ?]] { | $CARET_TAG | } """.stripMargin	String	text
configureFromFileText( "dummy.scala", Some(ScalaLightCodeInsightFixtureTestAdapter.normalize(fileText)) )	ScalaFile	scalaFile
s""" |object Foo { | sealed trait Bar { | private[Foo] def foo: Unit | } | | class Baz extends Bar { | $CARET_TAG | } |} """.stripMargin	String	text
seq.exists(_.isImplicitParameterProblem)	Boolean	hasProblems
s""" |object Foo { | sealed trait Bar { | private[Foo] def foo: Unit | } | | class Baz extends Bar { | private[Foo] def foo: Unit = ??? | } |} """.stripMargin	String	expected
s"""import scala.language.{existentials, implicitConversions} | |object Main extends App { | Tag("key", Set[Value[Value.T]](${START}123$END)) |} | |case class Tag(key: String, values: Set[Value[Value.T]]) | |object Value { | type T = X forSome { type X <: AnyVal } | | implicit def number2Value(v: Long): Value[T] = LongValue(v) | | def apply(v: Long): Value[T] = LongValue(v) |} | |sealed trait Value[+T <: AnyVal] { | def v: T |} | |case class LongValue(v: Long) extends Value[Long] | |//Value.Value.T""".stripMargin	String	text
file.depthFirst().instanceOf[ScClass]	Option[ScClass]	seq
literal(content, formatted, multiline)	ScInterpolatedStringLiteral	element
Text("\n")	Text	text
Seq(Text("$ "), Injection(exp("amount"), None))	Seq[StringPart with Product with Serializable]	parts
Injection(exp("foo"), None)	Injection	injection
arguments.map(it => createExpressionFromText(it.toString))	IndexedSeq[Any]	expressions
Value("example")	A.Value	EXAMPLE
Injection(exp("foo"), Some(Specifier(null, "%d")))	Injection	injection
Injection(exp("foo"), Some(Specifier(null, "%2d")))	Injection	injection
Injection(exp("123"), Some(Specifier(null, "%d")))	Injection	injection
Injection(exp("123"), Some(Specifier(null, "%2d")))	Injection	injection
Injection(exp("foo.bar"), None)	Injection	injection
new ThreadsDebuggerTree(getProject)	ThreadsDebuggerTree	frameTree
Injection(exp("foo.bar"), Some(Specifier(null, "%d")))	Injection	injection
waitForBreakpoint()	SuspendContextImpl	breakpointCtx
getDebugProcess.createStepIntoCommand(breakpointCtx, false, null)	DebugProcessImpl#ResumeCommand	stepIntoCommand
Injection(exp("foo.bar"), Some(Specifier(null, "%2d")))	Injection	injection
Injection(exp("{foo.bar}"), None)	Injection	injection
evaluationContext()	EvaluationContextImpl	context
waitForBreakpoint()	SuspendContextImpl	stepIntoCtx
Injection(exp("{foo.bar}"), Some(Specifier(null, "%d")))	Injection	injection
Injection(exp("{foo.bar}"), Some(Specifier(null, "%2d")))	Injection	injection
DebuggerSettings.getInstance()	DebuggerSettings	debuggerSettings
debuggerSettings.SKIP_SYNTHETIC_METHODS	Boolean	old
Seq(Text("foo "), Injection(exp("exp"), None), Text(" bar"))	Seq[StringPart with Product with Serializable]	parts
exp(quoted("foo"))	ScExpression	stringLiteral
Injection(exp("123L"), None)	Injection	longLiteralInjection
Injection(exp("true"), None)	Injection	booleanLiteralInjection
localVar(frameTree, context, variableName)	LocalVariableDescriptorImpl	testVariable
testVariable.getRenderer(getDebugProcess)	NodeRenderer	renderer
testVariable.calcValue(context)	Value	value
inSuspendContextAction(10.seconds, s"Too long rendering of $variableName") { val context = evaluationContext() val testVariable = localVar(frameTree, context, variableName) val renderer = testVariable.getRenderer(getDebugProcess) testVariable.setRenderer(renderer) testVariable.updateRepresentation(context, DescriptorLabelListener.DUMMY_LISTENER) val value = testVariable.calcValue(context) renderer.buildChildren(value, new ChildrenBuilder { override def setChildren(children: util.List[_ <: DebuggerTreeNode]): Unit = {testVariableChildren = children} override def getDescriptorManager: NodeDescriptorFactory = frameTree.getNodeFactory override def getNodeManager: NodeManager = frameTree.getNodeFactory override def setRemaining(remaining: Int): Unit = {} override def initChildrenArrayRenderer(renderer: ArrayRenderer, arrayLength: Int): Unit = {} override def getParentDescriptor: ValueDescriptor = testVariable override def setErrorMessage(errorMessage: String): Unit = {} override def setErrorMessage(errorMessage: String, link: XDebuggerTreeNodeHyperlink): Unit = {} override def addChildren(children: XValueChildrenList, last: Boolean): Unit = {} override def tooManyChildren(remaining: Int): Unit = {} override def setMessage(message: String, icon: Icon, attributes: SimpleTextAttributes, link: XDebuggerTreeNodeHyperlink): Unit = {} override def setAlreadySorted(alreadySorted: Boolean): Unit = {} override def isObsolete: Boolean = false }, context) testVariable }	LocalVariableDescriptorImpl	testVariable
evaluationContext.getFrameProxy	StackFrameProxyImpl	frameProxy
frameTree.getNodeFactory.getLocalVariableDescriptor(null, frameProxy visibleVariableByName name)	LocalVariableDescriptorImpl	local
NodeRendererSettings.getInstance().getClassRenderer	ClassRenderer	classRenderer
getDebugProcess.createStepOverCommand(currentSuspendContext(), false)	DebugProcessImpl#ResumeCommand	stepOverCommand
s"$collectionName = {$typeName@$UNIQUE_ID}$afterTypeLabel"	String	expectedLabel
s"{$intType@$UNIQUE_ID}"	String	intLabel
0	Int	testIndex
s"$testIndex = $intLabel${testIndex + 1}"	String	expectedChildLabel
using(Source.fromFile(file))(_.getLines().toSeq)	Seq[String]	lines
currentLineNumber	Int	actualLineNumber
lines(actualLineNumber)	String	actualLine
lines(expectedLineNumber)	String	expectedLine
inReadAction { availableSmartStepTargets().map(_.getPresentation) }	IndexedSeq[Nothing]	targets
ScalaCollectionRenderer.transformName(collectionClass)	String	shortClassName
s"$shortClassName size = $collectionLength"	String	afterTypeLabel
{ val actualLine = lines(actualLineNumber) val expectedLine = lines(expectedLineNumber) s"""Wrong line number. |Expected $expectedLineNumber: $expectedLine |Actual $actualLineNumber: $actualLine""".stripMargin }	String	message
inReadAction { availableSmartStepTargets().find(_.getPresentation == target) }	Option[SmartStepTarget]	sst
doSmartStepInto(sst.get)	SuspendContextImpl	ctx
expectedLineNumbers.toIterator	Iterator[Int]	expectedNumbers
currentLineNumber	Int	lineNumber
currentLocation()	Location	location
Set.empty[Loc]	Set[Loc]	noLocations
mutable.HashMap[String, Seq[Int]]()	mutable.HashMap[String, Seq[Int]]	sourcePositionsOffsets
sourcePositionsInFile(fileName)	IndexedSeq[SourcePosition]	sourcePositions
XDebuggerUtil.getInstance().createPosition(getVirtualFile(getFileInSrc(mainFileName)), lineNumber)	XSourcePosition	xSourcePosition
positionManager.getSourcePosition(location)	SourcePosition	sourcePosition
highlightedText(sourcePosition)	String	text
SourcePositionHighlighter.getHighlightRangeFor(sourcePosition)	TextRange	elemRange
PsiDocumentManager.getInstance(getProject).getDocument(sourcePosition.getFile)	Document	document
DocumentUtil.getLineTextRange(document, sourcePosition.getLine)	TextRange	lineRange
if (elemRange != null) elemRange.intersection(lineRange) else lineRange	TextRange	textRange
sourcePositionsInFile(mainFileName)	IndexedSeq[SourcePosition]	sourcePositions
positionManager.getSourcePosition(location)	SourcePosition	newPosition
Breakpoint(4, null)	ExactBreakpointTest_with_SAM_abstraction.this.Breakpoint	printlnBp
Breakpoint(8, null)	ExactBreakpointTest_with_SAM_abstraction.this.Breakpoint	testParseBp
Breakpoint(10, 0)	ExactBreakpointTest_with_SAM_abstraction.this.Breakpoint	firstCharLambda
Breakpoint(15, null)	ExactBreakpointTest_with_SAM_abstraction.this.Breakpoint	firstCharMethod
managed { val classes = positionManager.getAllClasses(position) val locations = classes.asScala.flatMap(refType => positionManager.locationsOfLine(refType, position).asScala) locations.foreach(checkSourcePosition(position, _)) locations.map(toSimpleLocation).toSet }	Set[Loc]	foundLocations
fileText.linesIterator.indexWhere(_.contains(bp))	Int	breakpointLine
ArrayBuffer[Int]()	ArrayBuffer[Int]	offsets
SourcePosition.createFromOffset(file, offset)	SourcePosition	fromOffset
PsiManager.getInstance(getProject)	PsiManager	psiManager
VfsUtil.findFileByIoFile(getFileInSrc(fileName), false)	VirtualFile	vFile
psiManager.findFile(vFile)	PsiFile	psiFile
sourcePositionsOffsets(fileName)	Seq[Int]	offsets
sys.props.get("IJ_scala_tests_cache.debug").nonEmpty	Boolean	cacheDebug
computeHash()	String	hash
fun	T	result
new FilenameFilter { override def accept(file: File, s: String): Boolean = s.endsWith(".class") }	{ def accept(file: Any, s: String): Boolean }	filter
ScalaCompileServerSettings.getInstance()	ScalaCompileServerSettings	compileServerSettings
false	Boolean	deleteProjectAtTearDown
SmartJDKLoader.getOrCreateJDK(JavaSdkVersion.JDK_1_8)	Sdk	jdk8
getOrCreateChildDir("src")	VirtualFile	srcRoot
_	Checksums	checksums
false	Boolean	needMake
mutable.HashMap[String, String]()	mutable.HashMap[String, String]	sourceFiles
getOrCreateChildDir("out")	VirtualFile	output
getBaseDir	VirtualFile	baseDir
testDataProjectIsValid()	Boolean	testDataValid
new ErrorReportingCallback(semaphore)	ScalaCompilerTestBase.this.ErrorReportingCallback	callback
6000	Int	maxCompileTime
new ApplicationConfiguration("app", module.getProject, ApplicationConfigurationType.getInstance)	ApplicationConfiguration	configuration
_	Try[Seq[String]]	result_
mutable.Set.empty	mutable.Set[(String, Int, Any)]	breakpoints
_	ScalaDebuggerTestCase.this.BreakpointTracker	breakpointTracker
new TestDisposable	ScalaDebuggerTestCase.this.TestDisposable	threadLeakDisposable
getVirtualFile(file)	VirtualFile	vFile
runProcess(mainClass, debug)	ProcessHandler	processHandler
getDebugProcess	DebugProcessImpl	debugProcess
getBasePath + getTestName(false) + ".test"	String	path
new mutable.HashMap[String, Array[Byte]]	mutable.HashMap[String, Array[Byte]]	result
10.seconds	FiniteDuration	timeout
s""" |trait A |class B extends A { | override $keyword <selection>sample</selection>: Int = 1 |} """	String	code
s""" |class A extends scala.App { | override $keyword <selection>sample</selection>: Int = 1 |} """	String	code
s""" |trait A { | $keyword sample: Int |} |class B extends A { | override $keyword <selection>sample</selection>: Int = 1 |} """	String	code
try { val obj = ois.readObject() obj match { case cs: Checksums => checksums = cs; true case _ => false } } catch { case _: IOException => false } finally ois.close()	Boolean	result
using(Source.fromFile(new File(path)))(_.getLines().mkString("\n"))	String	input
numberOfFiles(srcDir)	Int	existingFilesNumber
null	Holder.Object	v
for { category <- CompilerMessageCategory.values compilerMessage <- compileContext.getMessages(category) message = compilerMessage.getMessage if !(category == CompilerMessageCategory.INFORMATION && message.startsWith("Compilation completed successfully")) } yield category + ": " + message	IndexedSeq[String]	messages
ProgramRunner.PROGRAM_RUNNER_EP.getExtensions.find { _.getClass == classOf[GenericDebuggerRunner] }.get	ProgramRunner[RunnerSettings]	runner
Ref.create[ProcessHandler]	Ref[ProcessHandler]	processHandler
myProject.baseDir	VirtualFile	baseDir
ApplicationManagerEx.getApplicationEx	ApplicationEx	applicationEx
applicationEx.isSaveAllowed	Boolean	setting
Executor.EXECUTOR_EXTENSION_NAME.findExtension(executorClass)	Executor	executor
new ExecutionEnvironmentBuilder(module.getProject, executor)	ExecutionEnvironmentBuilder	executionEnvironmentBuilder
{ case Error("C", `message`) :: Nil => }	PartialFunction[List[Message], Unit]	expectation
descriptor.getProcessHandler	ProcessHandler	handler
getDebugProcess	DebugProcessImpl	process
objectCreationImpossibleMessage(("f: Unit", "Holder.T"))	String	Message
getDebugProcess.createResumeCommand(currentSuspendContext())	DebugProcessImpl#ResumeCommand	resumeCommand
objectCreationImpossibleMessage( ("b: Unit", "Holder.B"), ("a: Unit", "Holder.A"))	String	Message
objectCreationImpossibleMessage( ("a: Unit", "Holder.A"), ("b: Unit", "Holder.B"))	String	ReversedMessage
getVirtualFile(ioFile)	VirtualFile	file
createTestMap(5)	ScalaRefCountHolderComponent.TimestampedValueMap[ScalaRefCountHolderMapTest.this.Key, String]	map
XDebuggerManager.getInstance(getProject).getBreakpointManager	XBreakpointManager	xBreakpointManager
new JavaLineBreakpointProperties	JavaLineBreakpointProperties	properties
Key(1)	ScalaRefCountHolderMapTest.this.Key	key1
Key(2)	ScalaRefCountHolderMapTest.this.Key	key2
Key(3)	ScalaRefCountHolderMapTest.this.Key	key3
Key(4)	ScalaRefCountHolderMapTest.this.Key	key4
StartWith("'final' modifier is redundant")	ModifierCheckerTest.this.StartWith	RedundantFinal
Key(5)	ScalaRefCountHolderMapTest.this.Key	key5
map.getOrCreate(key1, "new1")	String	resultBefore1
map.getOrCreate(key2, "new2")	String	resultBefore2
map.getOrCreate(key3, "new3")	String	resultBefore3
map.getOrCreate(key4, "new4")	String	resultBefore4
map.getOrCreate(key5, "new5")	String	resultBefore5
map.getOrCreate(key1, "new1")	String	resultAfter1
0	Int	a
map.getOrCreate(key2, "new2")	String	resultAfter2
map.getOrCreate(key3, "new3")	String	resultAfter3
map.getOrCreate(key4, "new4")	String	resultAfter4
map.getOrCreate(key5, "new5")	String	resultAfter5
createTestMap(4)	ScalaRefCountHolderComponent.TimestampedValueMap[ScalaRefCountHolderMapTest.this.Key, String]	map
map.getOrCreate(key2, "new2")	String	result2
map.getOrCreate(key3, "new3")	String	result3
map.getOrCreate(key4, "new4")	String	result4
map.getOrCreate(key5, "new5")	String	result5
map.getOrCreate(key1, "new1")	String	result1
s"Create method '$methodName'"	String	hint
s"Cannot resolve symbol $methodName"	String	description
s"""object Bar { |} |object Usage { | Bar.$Caret$methodUsageText |}""".stripMargin	String	before
"With annotation there is no inlining"	String	constant
s"""object Bar { | $methodDefinitionText |} |object Usage { | Bar.$methodUsageText |}""".stripMargin	String	after
s"""class Bar { |} |object Usage { | new Bar().$Caret$methodUsageText |}""".stripMargin	String	before
Prefix + code + Suffix	String	s
s"""class Bar { | $methodDefinitionText |} |object Usage { | new Bar().$methodUsageText |}""".stripMargin	String	after
s.parse	ScalaFile	file
new com.intellij.lang.annotation.Annotation( 0, 0, HighlightSeverity.WEAK_WARNING, "message", "tooltip")	Annotation	FakeAnnotation
List[Message]()	List[Message]	myAnnotations
ScalaPsiManager.instance.getCachedClass(GlobalSearchScope.allScope(getProject), classQName)	Option[PsiClass]	psiClass
Map( HighlightSeverity.ERROR -> Error.apply, HighlightSeverity.WARNING -> Warning.apply, HighlightSeverity.WEAK_WARNING -> Warning.apply, HighlightSeverity.INFORMATION -> Info.apply, HighlightSeverity.INFO -> Info.apply )	Map[HighlightSeverity, (String, String) => Message]	severityMapping
pairs.flatMap(p => List(p, p))	IndexedSeq[String]	expectation
new AnnotatorHolderMock(getFileAdapter)	AnnotatorHolderMock	mock
s	S	k
null	Array[T]	arr
(Header + code).parse	ScalaFile	file
ContainsPattern("occurs in contravariant position")	VarianceTestBase.this.ContainsPattern	ContravariantPosition
ContainsPattern("occurs in covariant position")	VarianceTestBase.this.ContainsPattern	CovariantPosition
ContainsPattern("Abstract member may not have private modifier")	VarianceTestBase.this.ContainsPattern	AbstractModifier
ContainsPattern("doesn't conform to upper bound")	VarianceTestBase.this.ContainsPattern	NotConformsUpper
clashesOf(code)	IndexedSeq[Any]	clashes
P(CharPred(_.isLetterOrDigit).rep(1)).!.map(s => Leaf(Match(s)))	Parser[Tree.Leaf[TypeDiff.Match], Char, String]	element
P(", ".rep(0))	all.Parser[Nothing]	comma
errorsFromScalaCode(text)	List[Message]	errors
P("(" ~ parser.rep(0) ~ ")").map(Node(_: _*))	Parser[Tree.Node[Nothing], Char, String]	group
(Header + code).parse	ScalaFile	parse
new AnnotatorHolderMock(parse)	AnnotatorHolderMock	mock
ContainsPattern("Type mismatch")	FunctionAnnotatorTest.this.ContainsPattern	TypeMismatch
ContainsPattern("Unit result type")	FunctionAnnotatorTest.this.ContainsPattern	RedundantReturnData
P((group | element) ~ comma)	all.Parser[Tree[TypeDiff]]	parser
ContainsPattern("has return statement")	FunctionAnnotatorTest.this.ContainsPattern	NeedsResultType
ContainsPattern("Recursive method")	FunctionAnnotatorTest.this.ContainsPattern	Recursive
StartWith("Type mismatch")	AssignmentAnnotatorTest.this.StartWith	TypeMismatch
StartWith("Reassignment to val")	AssignmentAnnotatorTest.this.StartWith	ReassignmentToVal
BundleMessagePattern("integer.literal.is.out.of.range")	IntegerLiteralCheckTest.this.BundleMessagePattern	OverflowIntPattern
BundleMessagePattern("long.literal.is.out.of.range")	IntegerLiteralCheckTest.this.BundleMessagePattern	OverflowLongPattern
getFileAdapter.depthFirst().instancesOf[ScPattern]	Iterator[ScPattern]	patterns
"val Some(x) = None"	String	code
"val Vector(a) = Nil"	String	code
"val Vector(a) = List(1)"	String	code
"val List(seq: Seq[Int]) = List(List(\"\"))"	String	code
"val \"a\" :: xs = 1 :: Nil"	String	code
"val null :: xs = 1 :: Nil"	String	code
"val (x, y) = (1, 2, 3)"	String	code
"val (x: String, y) = (1, 2)"	String	code
"val Some(x: Int) = \"\""	String	code
"val (x: Int) :: xs = List(\"1\", \"2\")"	String	code
group.parse("(" + elements + ")").get.value.flattenTo(lengthOf(nodeLength), maxChars)	Seq[Tree[Nothing]]	result
file.depthFirst().instancesOf[PsiReference].filter(_.resolve == null).map(_.getElement.getText).toList	List[Nothing]	notResolved
Error("ONE", ScalaBundle.message("stable.identifier.required", "ONE")) :: Error("`two`", ScalaBundle.message("stable.identifier.required", "`two`")) :: Error("this.two", ScalaBundle.message("stable.identifier.required", "this.two")) :: Nil	List[Error]	errors
asString(actualDiffData1)	String	actualDiff1
asString(actualDiffData2)	String	actualDiff2
actualDiffData1.flatten	Seq[Tree[TypeDiff]]	flattenDiff1
actualDiffData2.flatten	Seq[Tree[TypeDiff]]	flattenDiff2
diff.flatten.map { case Leaf(Match(text, _)) => text case Leaf(Mismatch(text, _)) => s"~$text~" }	IndexedSeq[String]	parts
(PredefinedInts ++ randomInts) .flatMap(integerRepresentations) .flatMap(prependSign)	IndexedSeq[String]	intStrings
errorsFromScalaCode(Header + code)	List[Message]	result
e.typeElement.getOrElse(throw new IllegalArgumentException("No type element: " + e.getText))	ScTypeElement	typeElement
ContainsPattern("Value classes can have only one non-private val parameter")	ValueClassAnnotatorTest.this.ContainsPattern	NonPrivateValParameter
ContainsPattern("Value classes can have only one parameter")	ValueClassAnnotatorTest.this.ContainsPattern	OnlyOneParameter
ContainsPattern("Secondary constructors are not allowed in value classes")	ValueClassAnnotatorTest.this.ContainsPattern	SecondaryConstructor
ContainsPattern("Value classes cannot have nested classes, objects or traits")	ValueClassAnnotatorTest.this.ContainsPattern	InnerObjects
ContainsPattern("Value classes cannot redefine equals and hashCode")	ValueClassAnnotatorTest.this.ContainsPattern	RedefineEqualsHashCode
ContainsPattern("Field definitions are not allowed in value classes")	ValueClassAnnotatorTest.this.ContainsPattern	ValueClassCanNotHaveFields
s""" |trait Base { | def foo: Int = 42 |} | |class AClass extends Base { | override def foo: String = "42" |} """.stripMargin	String	code
new { def update(x: Int): Unit = () }	{ def update(x: Int): Unit }	a
intStrings ++ (PredefinedLongs ++ randomLongs) .flatMap(longRepresentations) .flatMap(prependSign)	IndexedSeq[String]	longStrings
s""" |trait T1 { | val foo: T1 |} |trait T2 extends T1 { | override val foo: T2 |} """.stripMargin	String	code
new { var a = (); a = () }	{ var a : Unit }	outer
s""" |trait Base { | def foo(x: Int): Int = 42 | def foo(x: String): String = "42" |} |class AClass extends Base { | override def foo(x: Int): Int = 42 |} """.stripMargin	String	code
s""" |trait Base[c] { | def foo: c |} | |class AClass[a] extends Base[a]{ | override val foo: a = ??? |} """.stripMargin	String	code
s""" |abstract class A() { | var x: Int |} | |abstract class B() extends A() { | var xx: Int = 0; | def x: Int = xx | def x_=(y: Int) = xx = y; |} """.stripMargin	String	code
List()	List[Nothing]	someOtherValue
Some { "public interface StringSupplier extends java.util.function.Supplier<String> {}" }	Some[Nothing]	javaCode
PredefinedLongs.map(_.toString) ++ randomLongs.flatMap(longRepresentations)	IndexedSeq[Any]	longStrings
""" |def a = () => println() |def b() = () => println() |def c = println() |def d() = println() |def e: () => Unit = () => println() |def f(): () => Unit = () => println() |def g(): Unit = println() |def h(): Unit = println() """.stripMargin	String	etaExpansionTestPrefix
etaExpansionTestPrefix + """ |val a1: Runnable = a |val a2: Runnable = a() |val b2: Runnable = b() |val c1: Runnable = c |val c2: Runnable = c() |val d2: Runnable = d() |val e1: Runnable = e |val e2: Runnable = e() |val f2: Runnable = f() |val g2: Runnable = g() |val h2: Runnable = h() """.stripMargin	String	code
false	Boolean	filesCreated
parseText(scalaCode)	ScalaFile	file
mock.annotations.filter { case Error(_, null) | Error(null, _) => false case Error(_, _) => true case _ => false }	List[Message]	messages
ContainsPattern("Cannot resolve symbol")	SingleAbstractMethodTestBase.this.ContainsPattern	cannotResolveSymbol
ContainsPattern("doesn't conform to expected type")	SingleAbstractMethodTestBase.this.ContainsPattern	doesNotConform
ContainsPattern("Type mismatch")	SingleAbstractMethodTestBase.this.ContainsPattern	typeMismatch
ContainsPattern("Cannot upcast")	SingleAbstractMethodTestBase.this.ContainsPattern	cannotUpcast
ContainsPattern("does not take parameters")	SingleAbstractMethodTestBase.this.ContainsPattern	doesNotTakeParameters
s""" |val test = <selection>'$symbolName</selection> """	String	code
ContainsPattern("Missing parameter type")	SingleAbstractMethodTestBase.this.ContainsPattern	missingParameterType
new OverridingAnnotator() {}	OverridingAnnotator	annotator
etaExpansionTestPrefix + """ |val b1: Runnable = b |val d1: Runnable = d |val f1: Runnable = f |val g1: Runnable = g |val h1: Runnable = h """.stripMargin	String	code
new AnnotatorHolderMock(getFileAdapter)	AnnotatorHolderMock	holder
annotate(text)	AnnotatorHolderMock	holder
(PredefinedLongs ++ randomLongs) .flatMap { long => longRepresentations(long) .zip { 21 :: 24 :: 19 :: Nil }.map { case (string, length) => string.padTo(length, '1') } }	IndexedSeq[String]	overflowLongStrings
overflowLongStrings .flatMap(appendL)	IndexedSeq[String]	overflowLongStringsWithL
("val x = " + literalText).parse	ScalaFile	file
BundleMessagePattern("lowercase.long.marker")	IntegerLiteralCheckTest.this.BundleMessagePattern	LowerCaseLongMarkerPattern
Set( 0, -0, 1, -1, 1234, -1234, IntMinValue, IntMaxValue )	Set[Int]	PredefinedInts
Set( 1l + IntMaxValue, 12345l + IntMaxValue, -1l + IntMinValue, -1234l + IntMinValue, LongMinValue, LongMaxValue )	Set[Long]	PredefinedLongs
ScalaCompilerConfiguration.instanceIn(myFixture.getProject).defaultProfile	ScalaCompilerSettingsProfile	defaultProfile
s""" |object T { | $etaExpansionTestPrefix | val b1: Runnable = b | val d1: Runnable = d | val f1: Runnable = f | val g1: Runnable = g | val h1: Runnable = h |} """.stripMargin	String	code
psiClass.map(_.getNavigationElement.asInstanceOf[ScTypeDefinition]).flatMap(_.functions.find(_.name == methodName))	Option[ScFunction]	method
method.get.getContainingFile	PsiFile	file
PsiDocumentManager.getInstance(getProject).getDocument(file)	Document	document
document.getLineNumber(method.get.getTextRange.getStartOffset)	Int	methodLine
methodLine + relativeLineNumber	Int	lineNumber
waitForBreakpointInner()	SuspendContextImpl	suspendContext
Option(getDebugProcess).map(_.getSuspendManager)	Option[SuspendManager]	manager
manager.flatMap(_.getPausedContext.toOption)	Option[SuspendContextImpl]	context
currentSuspendContext()	SuspendContextImpl	suspendContext
ContainsPattern("Cannot upcast")	TypedStatementAnnotatorTest.this.ContainsPattern	UpcastingError
getFile.elements .flatMap(AnnotatorHints.in(_).toSeq.flatMap(_.hints)) .map(hint => Hint(hint.element.getText, hint.parts.map(_.string).mkString, offsetDelta = hint.offsetDelta)).toList	List[Hint]	hints
evaluationContext()	EvaluationContextImpl	ctx
new ScalaCodeFragmentFactory()	ScalaCodeFragmentFactory	factory
new CodeFragmentFactoryContextWrapper(factory)	CodeFragmentFactoryContextWrapper	factoryWrapper
factory.getEvaluatorBuilder	EvaluatorBuilder	evaluatorBuilder
if (codeText.contains("\n")) CodeFragmentKind.CODE_BLOCK else CodeFragmentKind.EXPRESSION	CodeFragmentKind	kind
managed { ContextUtil.getContextElement(ctx) }	PsiElement	contextElement
new TextWithImportsImpl(kind, codeText)	TextWithImportsImpl	textWithImports
factoryWrapper.createCodeFragment(textWithImports, contextElement, getProject)	JavaCodeFragment	fragment
_	Boolean	savedIsTypeMismatchHints
inReadAction { val fragment = factoryWrapper.createCodeFragment(textWithImports, contextElement, getProject) fragment.forceResolveScope(GlobalSearchScope.allScope(getProject)) DebuggerUtils.checkSyntax(fragment) fragment }	JavaCodeFragment	fragment
inReadAction { evaluatorBuilder.build(fragment, currentSourcePosition) }	ExpressionEvaluator	evaluator
ScalaAnnotator.forProject(ctx)	ScalaAnnotator	annotator
s"$prefix$code$postfix".parse	ScalaFile	file
ContainsPattern("Type mismatch")	PatternDefinitionAnnotatorTest.this.ContainsPattern	TypeMismatch
ContainsPattern("Wrong forward reference")	ForwardReferenceAnnotatorTest.this.ContainsPattern	ForwardReference
Try { val evaluator = inReadAction { evaluatorBuilder.build(fragment, currentSourcePosition) } evaluator.evaluate(ctx) }	Try[Value]	value
Ref.create[T]()	Ref[T]	result
new Semaphore()	Semaphore	semaphore
semaphore.waitFor(timeout.toMillis)	Boolean	finished
A	A.type	x
messages( """ |implicit def int: Int = 1 |implicit def bool(implicit int: Int): Boolean = true | |def foo(j: Int)(implicit b: Boolean) = j | |def test(): Unit = { | foo(1) | | { | implicit val secondInt: Int = 2 | foo(2) | } | | foo(3) |} """.stripMargin).get	List[Message]	actualMessages
messages( """object Test { | | class MyClass(implicit number: Int) | | class MyClassWithArgs(x: Int)(implicit number: Int) | | class MySecondClass extends MyClass() | | class MyThirdClass extends MyClassWithArgs(42) | | new MyClass() | new MyClass | new MyClassWithArgs(43) |} |""".stripMargin ).get	List[Message]	actualMessages
messages( """|object A { | | class B | class MyClass { | def apply(i: Int)(implicit b: B) = b | } | | new MyClass()(2) |} |""".stripMargin).get	List[Message]	actualMessages
messages( """ |object ImplicitAbstract { | def bar(implicit i: Int) = i | trait Actor { implicit def context: Int } | trait Stash { def context: Int = 1 } | trait ActorImpl extends Stash with Actor { bar } |} """.stripMargin )	Option[List[Message]]	implicitAbstract
s"""$timeoutMsg | |${ThreadDumper.dumpThreadsToString()} """.stripMargin	String	messageWithDump
messages( """ |object BothAbstract { | def bar(implicit i: Int) = i | trait Actor { implicit def context: Int } | trait Stash { def context: Int } | trait ActorImpl extends Stash with Actor { bar } |} """.stripMargin )	Option[List[Message]]	bothAbstract
currentSuspendContext()	SuspendContextImpl	context
evalResult(codeText)	String	result
messages( """ |object ImplicitConcrete { | def bar(implicit i: Int) = i | trait Actor { implicit def context: Int = 1 } | trait Stash { def context: Int } | trait ActorImpl extends Stash with Actor { bar } |} """.stripMargin )	Option[List[Message]]	implicitConcrete
messages( """ |object BothAbstract { | def bar(implicit i: Int) = i | trait Actor { implicit def context: Int } | trait Stash { def context: Int } | trait ActorImpl extends Actor with Stash { bar } |} """.stripMargin )	Option[List[Message]]	bothAbstract
messages( """ |object ImplicitAbstract { | def bar(implicit i: Int) = i | trait Actor { implicit def context: Int } | trait Stash { def context: Int = 1 } | trait ActorImpl extends Actor with Stash { bar } |} """.stripMargin )	Option[List[Message]]	implicitAbstract
messages( """ |object ImplicitConcrete { | def bar(implicit i: Int) = i | trait Actor { implicit def context: Int = 1 } | trait Stash { def context: Int } | trait ActorImpl extends Actor with Stash { bar } |} """.stripMargin )	Option[List[Message]]	implicitConcrete
file.depthFirst().instanceOf[ScVariableDefinition].get	ScVariableDefinition	definition
ContainsPattern("Type mismatch")	VariableDefinitionAnnotatorTest.this.ContainsPattern	TypeMismatch
collectAnnotatorMessages(text)	List[Message]	annotatorMessages
errorsFromScalaCode(code)	List[Message]	msgs
format(source, methodName, lineNumber)	String	expected
Error("bar", notFound("Int")) :: Nil	List[Error]	error
folderPath + getTestName(true) + ".scala"	String	filePath
inReadAction { positionManager.getSourcePosition(location).getLine }	Int	actualLine
format(location.sourceName, location.method().name(), actualLine + 1)	String	actual
if (settingOn) errorsFromScalaCode(text) else super.errorsFromScalaCode(text)	List[Message]	errors
Seq( "new Simple", "new Simple()", "new Complex(1.0, 1.0)", "new A(0)", "new A(a = 0)", "new B[Int](0)", "new B(0)", "new C(0)", "new C()", "new C", "new D(0)", "new D(false)", "new DD(0)", "new DD(false, 1)", "new DDD(1)(2)", "new FFF(1)(2)", "new GGG(1)(true)", "new E[Int](new Y[Int])", "new E[Int](new Z[Int])", "new E(new Y[Int])", "new E(new Z[Int])", "new Alias[Int](0)" )	Seq[Nothing]	codes
Error("-1", messageNoSupport("-1")) :: Error("1", messageNoSupport("1")) :: Nil	List[Error]	expectedErrors
Some { """ |object SimpleTest { | val v: 42 = 42 |}""" .stripMargin }	Some[Any]	fileText
(Header + code).parseWithEventSystem	ScalaFile	file
for { (line, idx) <- fileText.linesIterator.zipWithIndex if line.contains(bp) } yield idx	Iterator[Int]	breakpointLines
s"${TestUtils.getTestDataPath}/libextension/librarymanager-test-ijext.jar"	String	jarPath
getClassFilePath(fileName, getName)	String	classFilePath
classFilePath + ".test"	String	expectedFilePath
LibraryExtensionsManager.getInstance(fixture.getProject)	LibraryExtensionsManager	manager
manager.getExtensions(classOf[Inspection])	Seq[Nothing]	extensions
new Semaphore()	Semaphore	breakpointSemaphore
false	Boolean	_wasAtBreakpoint
new DebugProcessAdapterImpl { override def resumed(suspendContext: SuspendContextImpl): Unit = { breakpointSemaphore.down() } override def paused(suspendContext: SuspendContextImpl): Unit = { _wasAtBreakpoint = true breakpointSemaphore.up() } override def processDetached(process: DebugProcessImpl, closedByUser: Boolean): Unit = { breakpointSemaphore.up() } }	DebugProcessAdapterImpl { def processDetached(process: DebugProcessImpl, closedByUser: Boolean): Unit def resumed(suspendContext: SuspendContextImpl): Unit def paused(suspendContext: SuspendContextImpl): Unit }	breakpointListener
implicitly[Int]	Int	implicitInt
if (testName.isEmpty) "" else { assert(testName.startsWith("test") && testName.length > 4) testName(4).toLower + testName.substring(5) }	Int	name
s"$basePath/$name"	String	dirPath
new File(new jFile(classFilePath))	io.File	file
parse("2018.2.3")	Option[ScalaPluginVersionVerifier.Version]	current
parse("2013.1.1")	Option[ScalaPluginVersionVerifier.Version]	old
parse("2020.7.4")	Option[ScalaPluginVersionVerifier.Version]	future
parse("2018.0.0")	Option[ScalaPluginVersionVerifier.Version]	since
42	Int	implicitInt
parse("2019.0.0")	Option[ScalaPluginVersionVerifier.Version]	until
implicitly	Int	v1
2	Int	secondInt
implicitly[Int]	Int	v2
parse("0 (1.1 (2.1, 2.2), 1.2 (2.3, 2.4), 1.3 (2.5, 2.6))")	PsiElementMock	element
new ShouldBeSearchedInBytecode(new CompilerIndicesSettings(getProject))	SearchTargetExtractors.ShouldBeSearchedInBytecode	targetExtractor
_	Module	moduleA
_	Module	moduleB
false	Boolean	indexReadyPredicate
myFixture.addFileToProject("Foo.scala", "trait Foo")	PsiFile	rootFile
_	CompilerTester	compiler
getFileAdapter.findElementAt(getEditorAdapter.getCaretModel.getOffset)	PsiElement	place
mutable.Set.empty[LibraryLoader]	mutable.Set[LibraryLoader]	myLoaders
myFixture.addFileToProject(name, code)	PsiFile	psiFile
s"for$CARET_MARKER{i <- 1 to 10} yield i + 1"	String	text
s"""for$CARET_MARKER{ | i <- 1 to 10 | c <- 'a' to 'e' |} yield "" + c + i""".stripMargin	String	text
rest.map { case (name, code) => val psiFile = myFixture.addFileToProject(name, code) name -> psiFile.getVirtualFile }.toMap + { val file = myFixture.configureByText(targetFile._1, targetFile._2) targetFile._1 -> file.getVirtualFile }	Map[String, VirtualFile]	filesMap
ScalaCompilerReferenceService(getProject)	ScalaCompilerReferenceService	service
OptionWithLiteralToSomeIntention.familyName	String	familyName
indicesQuery(service, target).map(_.unwrap)	IndexedSeq[compilerReferences.UsagesInFile]	usages
parsed.classInfo	ClassInfo	classInfo
Seq( methodRefOf[Predef.type]("Map", 88, 0), fieldRefOf[WithRefs]("noGetter", 96), methodRefOf[MapLike[_, _, _]]("contains", 88, 1), methodRefOf[WithRefs]("s", 92, 0), methodRefOf[Predef.type]("augmentString", 98, 1), methodRefOf[Map.type]("apply", 88, 1), methodRefOf[Predef.type]("println", 90, 1), methodRefOf[StringOps]("toInt", 98, 0) )	Seq[MemberReference]	expectedRefs
"foo"	String	s
UsagesInFile(filesMap(filename), lines)	compilerReferences.UsagesInFile	usage
42	Int	noGetter
123	Int	x
s"(${CARET}1 + 1)"	String	text
s"1 + (1 * 2$CARET)"	String	text
s""" |def f(n: Int): Int = n match { | case even if (${CARET}even % 2 == 0) => (even + 1) | case odd => 1 + (odd * 3) |} """	String	text
CreateCompanionObjectIntention.getFamilyName	String	familyName
s""" |def f(n: Int): Int = n match { | case even if (even % 2 == 0) => (even + 1$CARET) | case odd => 1 + (odd * 3) |} """	String	text
myFixture.addFileToProject("A/test/Bar.scala", "trait Bar extends Foo")	PsiFile	aFile
s""" |def f(n: Int): Int = n match { | case even if (even % 2 == 0) => (even + 1) | case odd => 1 + (odd * 3$CARET) |} """	String	text
s""" |class B<caret>ar {} """.stripMargin	String	text
s""" |trait A { | def f: Int |} | |class AA extends A { | override def f = $START???$END |}"""	String	result
s"val a = (($CARET(1)))"	String	text
s""" |class Bar {} | |object Bar { |<caret> |} """.stripMargin	String	expected
s""" |abstract class A { | def f: Int |} | |class AA extends A { | override def f: Int = $START???$END |}"""	String	result
s""" |trait B<caret>ar {} """.stripMargin	String	text
s""" |trait A[T] { | def f: T |} | |class AA extends A[Int] { | override def f: Int = $START???$END |}"""	String	result
null	(C) forSome {type C}	x
null	Null	v
s""" |trait Bar {} | |object Bar { |<caret> |} """.stripMargin	String	expected
null	Null	p
s""" |trait A { | def f |} | |class AA extends A { | override def f: Unit = $START???$END |}"""	String	result
null	Null	a
null	Null	b
service.usagesOf(searchTarget)	Set[Timestamped[compilerReferences.UsagesInFile]]	dirtyUsages
null	Null	x
service.usagesOf(searchTarget).map(_.unwrap)	IndexedSeq[compilerReferences.UsagesInFile]	usages
FileDocumentManager.getInstance().getDocument(getFile.getVirtualFile)	Document	document
{ case v => }	Any => Unit	x
before	String	current
after(i)	String	prev
1	Int	x
normalize(resultText)	String	normalizedResultText
Set(UsagesInFile(file.getVirtualFile, Seq(5)))	Set[compilerReferences.UsagesInFile]	expected
myFixture.findClass("scala.collection.convert.Decorators.AsJava")	PsiClass	aClass
service.usagesOf(searchTarget)	Set[Timestamped[compilerReferences.UsagesInFile]]	usages
s"${getTestName(false)}.scala"	String	fileName
150 milliseconds	Duration	typingTimeout
' '	Char	SPACE
createHandler	HighlightUsagesHandlerBase[PsiElement]	handler
{ case v =>; case v => }	Any => Unit	x
s""" |object AAA { | def foo(i: Int): Int = i | implicit val implicit${CARET}Int = 0 |} """.stripMargin	String	code
handler.getReadUsages.asScala.map(_.substring(getFile.getText))	Seq[String]	actualUsages
{ case _: Foo | _: Bar => }	Any => Unit	f
null	Null	f
{ case _ => class C; class C }	Any => Unit	x
2	Int	a
s""" |object AAA { | def foo()(implicit i: Int): Int = i | implicit val impl${CARET}icitInt = 0 | foo() |} """.stripMargin	String	code
s""" |object AAA { | implicit def stri${CARET}ngToInt(s: String): Int = Integer.parseInt(s) | def inc(i: Int): Int = i + 1 | inc("123") |} """.stripMargin	String	code
s""" |object AAA { | implicit def stri${CARET}ngToInt(s: String): Int = Integer.parseInt(s) | def inc(i: Int): Int = i + 1 | def foo(s: String)(implicit converter: String => Int): Int = converter(s) | inc("123") | foo("42") |} """.stripMargin	String	code
ProjectManager.getInstance.loadAndOpenProject(projectPath.toString)	Project	project
s""" |object AAA { | implicit val theAn${CARET}swer: Int = 42 | def increase(i: Int)(implicit summand: Int): Int = i + summand | increase(0) | this.increase(0) | (this.increase)(0) | increase (0) |} """.stripMargin	String	code
s""" |object AAA { | implicit val theAn${CARET}swer: Int = 42 | def apply(i: Int)(implicit suffix: Int): Int = i + suffix | this(0) |} """.stripMargin	String	code
s""" |trait Semigroup[T] { | def op(a: T, b: T): T |} | |implicit val intSem${CARET}igroup: Semigroup[Int] = (a: Int, b: Int) => a + b | |def double[T : Semigroup](t: T) = implicitly[Semigroup[T]].op(t, t) | |double(1) """.stripMargin	String	code
manager.getAction(IdeActions.GROUP_MAIN_TOOLBAR).asInstanceOf[ActionGroup]	ActionGroup	actionGroup
_	CodeInsightTestFixture	codeInsightFixture
IdeaTestFixtureFactory.getFixtureFactory	IdeaTestFixtureFactory	factory
s""" |trait Semigroup[T] { | def op(a: T, b: T): T |} | |implicit val intSemigroup: Semigroup[Int] = (a: Int, b: Int) => a + b | |def double[T $CARET: Semigroup](t: T) = implicitly[Semigroup[T]].op(t, t) """.stripMargin	String	code
factory.createFixtureBuilder(getName).getFixture	IdeaProjectTestFixture	projectFixture
findFile(filename)	VirtualFile	file
s""" |trait Semigroup[T] { | def op(a: T, b: T): T |} | |implicit val intSemigroup: Semigroup[Int] = (a: Int, b: Int) => a + b | |def double[T:$CARET Semigroup](t: T) = implicitly[Semigroup[T]].op(t, t) """.stripMargin	String	code
s""" |object Test { | implicit class ${CARET}StringExt(val s: String) { | def twice: String = s + s | } | val string = "a" | string.twice |} """.stripMargin	String	code
ModuleManager.getInstance(project).getModules()(0)	Module	module
loadAndSetupProject()	Project	project
s""" |object Test { | implicit val ${CARET}theAnswer: Int = 42 | | class AB(i: Int)(implicit j: Int) { | def this(ints: Array[Int])(implicit j: Int) = this(ints(0)) | } | | new AB(1) | new AB(Array(1)) | new AB(2) with Serializable | | class AC extends AB(3) with Serializable |} """.stripMargin	String	code
s""" |object Test { | trait Ordering[T] | | implicit def seqDerivedOrdering[CC[X] <: scala.collection.Seq[X], T](implicit ord: Ordering[T]): Ordering[CC[T]] = ??? | implicit def tuple2Ordering[T1, T2](implicit ord1: Ordering[T1], ord2: Ordering[T2]): Ordering[(T1, T2)] = ??? | | implicit object ${CARET}BooleanOrdering extends Ordering[Boolean] | implicit object IntOrdering extends Ordering[Int] | | def sort[T](t: Seq[T])(implicit ordering: Ordering[T]) = ??? | | sort(Seq((Seq(12), (true, Seq(false))))) | sort(Seq((Seq(12), false))) | sort(Seq(false)) | sort(Seq((Seq(12), (1, Seq(2))))) |} """.stripMargin	String	code
s""" |object Test { | trait Ordering[T] | | implicit def seqDerivedOrdering[CC[X] <: scala.collection.Seq[X], T](implicit ord: Ordering[T]): Ordering[CC[T]] = ??? | implicit def ${CARET}tuple2Ordering[T1, T2](implicit ord1: Ordering[T1], ord2: Ordering[T2]): Ordering[(T1, T2)] = ??? | | implicit object BooleanOrdering extends Ordering[Boolean] | implicit object IntOrdering extends Ordering[Int] | | def sort[T](t: Seq[T])(implicit ordering: Ordering[T]) = ??? | | sort(Seq((Seq(12), (true, Seq(false))))) | sort(Seq((Seq(12), false))) | sort(Seq(false)) | sort(Seq((Seq(12), (1, Seq(2))))) |} """.stripMargin	String	code
15000	Int	TIMEOUT
s""" |object AAA { | def foo(i: Int)(implicit converter: Int => String): String = { | 111.toUpperCase() | ${CARET}converter(i) | } | } """.stripMargin	String	code
13000	Int	TIMEOUT
s"TypingTest${getTestName(false)}"	String	testName
SbtSettings.getInstance(myProject)	SbtSettings	sbtSettings
() => { stringsToType.foreach(myFixture.`type`) PsiDocumentManager.getInstance(myFixture.getProject).commitAllDocuments() if (expectedOutput != null) { myFixture.checkResult(expectedOutput.withNormalizedSeparator.trim) myFixture.configureByText(fileName, input.withNormalizedSeparator.trim) //reset fixture file text } }	ThrowableRunnable[_]	testBody
s""" |import java.util |import scala.collection.JavaConversions.${CARET}mapAsScalaMap | |object Test { | def env: util.Map[String, String] = System.getenv() // Java map | val term: String = env("TERM") | val term2: String = env.apply("TERM") |} """.stripMargin	String	code
s""" |class A(val n: Int) | |class B(val m: Int, val n: Int) | |class C(val m: Int, val n: Int, val o: Int) { | def total = m + n + o |} | |object O { | implicit def ${CARET}toA(n: Int): A = new A(n) | | implicit def aToB[A1](a: A1)(implicit f: A1 => A): B = | new B(a.n, a.n) | | implicit def bToC[B1](b: B1)(implicit f: B1 => B): C = | new C(b.m, b.n, b.m + b.n) | | 5.total | new A(5).total | new B(5, 5).total | new C(5, 5, 10).total |} """.stripMargin	String	code
s""" |class A(val n: Int) | |class B(val m: Int, val n: Int) | |class C(val m: Int, val n: Int, val o: Int) { | def total = m + n + o |} | |object O { | implicit def toA(n: Int): A = new A(n) | | implicit def ${CARET}aToB[A1](a: A1)(implicit f: A1 => A): B = | new B(a.n, a.n) | | implicit def bToC[B1](b: B1)(implicit f: B1 => B): C = | new C(b.m, b.n, b.m + b.n) | | 5.total | new A(5).total | new B(5, 5).total | new C(5, 5, 10).total |} """.stripMargin	String	code
s""" |class A(val n: Int) | |class B(val m: Int, val n: Int) | |class C(val m: Int, val n: Int, val o: Int) { | def total = m + n + o |} | |object O { | implicit def toA(n: Int): A = new A(n) | | implicit def aToB[A1](a: A1)(implicit f: A1 => A): B = | new B(a.n, a.n) | | implicit def ${CARET}bToC[B1](b: B1)(implicit f: B1 => B): C = | new C(b.m, b.n, b.m + b.n) | | 5.total | new A(5).total | new B(5, 5).total | new C(5, 5, 10).total |} """.stripMargin	String	code
if (internalSdk == null) IdeaTestUtil.getMockJdk18 else internalSdk	Sdk	sdk
handler.getReadUsages.map(_.substring(getFile.getText))	Seq[String]	actualUsages
ElementScope(getProjectAdapter)	ElementScope	projectScope
ScalaAnnotator.forProject(myProject)	ScalaAnnotator	annotator
fileManager.findFile(file)	PsiFile	psiFile
new AnnotatorHolderMock(psiFile)	AnnotatorHolderMock	mock
ProgressReporter.newInstance(getClass.getSimpleName, filesWithProblems)	ProgressReporter	reporter
new ScalaRecursiveElementVisitor { override def visitScalaElement(element: ScalaPsiElement) { try { annotator.annotate(element, mock) super.visitScalaElement(element) } catch { case ignored: Throwable => //this should be checked in AllProjectHighlightingTest } } }	ScalaRecursiveElementVisitor { def visitScalaElement(element: ScalaPsiElement): Unit }	visitor
projectScope.getCachedObject(fromObject).orNull	ScObject	source
projectScope.getCachedObject(toObject).orNull	ScObject	target
findFile("HelloWorld.scala").asInstanceOf[ScalaFile]	ScalaFile	file
createRunConfiguration(file)	RunnerAndConfigurationSettings	settings
SourceFilterScope(GlobalSearchScopesCore.directoryScope(myProject, myProjectRoot, true))(myProject)	SourceFilterScope	searchScope
project.project.baseDir.findChild("src").findChild(fileName)	VirtualFile	file
file.typeDefinitions.head	ScTypeDefinition	clazz
LocalFileSystem.getInstance.findFileByPath(path.replace(File.separatorChar, '/'))	VirtualFile	vFile
_	VirtualFile	rootDirBefore
_	VirtualFile	rootDirAfter
VfsTestUtil.findFileByCaseSensitivePath(s"$projectDirPath/$filename")	VirtualFile	file
root + "/before"	String	rootBefore
root + "/after"	String	rootAfter
settings.MOVE_COMPANION	Boolean	moveCompanionOld
new ArrayBuffer[PsiClass]()	ArrayBuffer[PsiClass]	classes
JavaPsiFacade.getInstance(getProjectAdapter).findPackage(newPackageName)	PsiPackage	aPackage
aPackage.getDirectories(GlobalSearchScope.moduleScope(getModuleAdapter))	Array[PsiDirectory]	dirs
myFixture.getElementAtCaret	PsiElement	valElement
myFixture.getElementAtCaret	PsiElement	defElement
myFixture.getElementAtCaret	PsiElement	objectElement
_	Map[VirtualFile, Editor]	myEditors
_	VirtualFile	myDirectory
getEditorAdapter	Editor	editor
_	Array[VirtualFile]	filesBefore
TestUtils.getTestDataPath + "/rename3/"	String	folderPath
source.membersWithSynthetic.find(_.names.contains(memberName)).get	ScMember	member
findCaretsAndRemoveMarkers(filesBefore)	Seq[ScalaRenameTestBase.this.CaretPosition]	caretPositions
clazz.membersWithSynthetic.collectFirst { case function: ScFunctionDefinition if function.name == "main" => function }.get	ScFunctionDefinition	mainMethod
fileText.indexOf(caretMarker) + caretMarker.length + 1	Int	offset
ScalaMoveMembersDialog.createProcessor(target, member)	MoveMembersProcessor	processor
getPsiManagerAdapter.findFile(vFile)	PsiFile	file
myEditors(vFile)	Editor	editor
TargetElementUtil.findTargetElement( InjectedLanguageUtil.getEditorForInjectedLanguageNoCommit(getEditorAdapter, scalaFile), TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED | TargetElementUtil.ELEMENT_NAME_ACCEPTED)	PsiElement	element
doRename(editor, file, newName)	String	oldName
createInspectionTools .filter(_.getLanguage == ScalaLanguage.INSTANCE.getID) .collect { case toolWrapper: LocalInspectionToolWrapper => toolWrapper.getTool }	IndexedSeq[LocalInspectionTool]	tools
InspectionManager.getInstance(file.getProject)	InspectionManager	inspectionManager
RenamePsiElementProcessor.forElement(element).substituteElementToRename(element, getEditorAdapter)	PsiElement	subst
new InspectionProfileImpl("test")	InspectionProfileImpl	result
TypeAnnotationSettings.alwaysAddType(ScalaCodeStyleSettings.getInstance(getProjectAdapter))	ScalaCodeStyleSettings	settings
CommonDataKeys.EDITOR.getData(DataManager.getInstance().getDataContextFromFocus.getResult)	Editor	editor
CommonDataKeys.PSI_ELEMENT.getData(DataManager.getInstance().getDataContextFromFocus.getResult)	PsiElement	element
scalaFile.findElementAt(0)	PsiElement	firstPsi
firstPsi.getNode.getElementType match { case ScalaTokenTypes.tLINE_COMMENT => ScalaBundle.message(firstPsi.getText.substring(2).trim) case _ => null }	Null	warning
null	PsiMember	targetMethod
false	Boolean	isAddDefaultValue
new JavaChangeSignatureHandler().findTargetMember(getFileAdapter, getEditorAdapter)	PsiElement	element
Seq( new ParameterInfoImpl(0, "ii", PsiType.INT), new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true"))	Seq[ParameterInfoImpl]	params
secondFileName(testName)	String	secondName
Seq( new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true"), new ParameterInfoImpl(0, "ii", PsiType.INT) )	Seq[ParameterInfoImpl]	newParams
Seq(new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true"))	Seq[ParameterInfoImpl]	params
LocalFileSystem.getInstance.findFileByPath(filePath)	VirtualFile	vFile
new ScalaChangeSignatureHandler().findTargetMember(getFileAdapter, getEditorAdapter)	PsiElement	element
Seq(new ParameterInfoImpl(0, "i", PsiType.INT), new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true"))	Seq[ParameterInfoImpl]	params
Seq( new ParameterInfoImpl(0, "i", PsiType.INT), new ParameterInfoImpl(1, "j", PsiType.INT), new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true") )	Seq[ParameterInfoImpl]	params
createTypeElementFromText(typeElementText)(getProject)	ScTypeElement	typeElement
secondName != null	Boolean	checkSecond
Seq(new ParameterInfoImpl(0, "i", PsiType.INT))	Seq[ParameterInfoImpl]	params
LocalFileSystem.getInstance.refreshAndFindFileByPath(rootAfter)	VirtualFile	dirAfter
Seq( new ParameterInfoImpl(0, "t", getPsiTypeFromText("T", targetMethod)), new ParameterInfoImpl(-1, "s", getPsiTypeFromText("S", targetMethod)))	Seq[ParameterInfoImpl]	params
Seq( new ParameterInfoImpl(0, "i", PsiType.INT), new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true"), new ParameterInfoImpl(1, "strs", new PsiEllipsisType(getPsiTypeFromText("String", targetMethod))) )	Seq[ParameterInfoImpl]	params
ScalaRefactoringUtil.possibleExpressionsToExtract(file, offset)	Seq[ScExpression]	expressions
fileText(file)	String	text
Seq( new ParameterInfoImpl(0, "i", PsiType.INT), new ParameterInfoImpl(-1, "b", PsiType.BOOLEAN, "true") )	Seq[ParameterInfoImpl]	params
text.length	Int	fileLength
Seq( new ParameterInfoImpl(0, "i", PsiType.INT), new ParameterInfoImpl(2, "b", PsiType.BOOLEAN), new ParameterInfoImpl(1, "js", new PsiEllipsisType(PsiType.INT)) )	Seq[ParameterInfoImpl]	params
Seq( new ParameterInfoImpl(2, "s", getPsiTypeFromText("String", targetMethod)), new ParameterInfoImpl(3, "b", PsiType.BOOLEAN), new ParameterInfoImpl(-1, "b2", PsiType.BOOLEAN, "true") )	Seq[ParameterInfoImpl]	params
ListBuffer[Int]()	ListBuffer[Int]	result
if (checkSecond) { val secondFileText = getTextFromTestData(secondName) addFileToProject(secondName, secondFileText) } else null	PsiFile	secondFile
Seq(new ParameterInfoImpl(0, "i", PsiType.INT), new ParameterInfoImpl(-1, "j", PsiType.INT, "0"))	Seq[ParameterInfoImpl]	params
mainFileName(testName)	String	fileName
Seq(new ParameterInfoImpl(0, "newName", PsiType.INT))	Seq[ParameterInfoImpl]	params
text.indexOf(caretMarker)	Int	occ
JavaCodeFragmentFactory.getInstance(getProjectAdapter)	JavaCodeFragmentFactory	factory
FileEditorManager.getInstance(project)	FileEditorManager	editorManager
if (fileText.contains(initInDeclarationMarker)) Some(true) else if (fileText.contains(initLocallyMarker)) Some(false) else None	Option[Boolean]	initInDecl
targetMethod.asInstanceOf[PsiMethod]	PsiMethod	psiMethod
editorManager.openTextEditor(new OpenFileDescriptor(project, getVFileAdapter, startOffset), false)	Editor	editor
new ScalaIntroduceFieldFromExpressionHandler	ScalaIntroduceFieldFromExpressionHandler	handler
findOffsets(text).map(offset => CaretPosition(file, offset))	IndexedSeq[ScalaRenameTestBase.this.CaretPosition]	result
{ file => var text = fileText(file) val fileLength = text.length def findOffsets(s: String): Seq[Int] = { val result = ListBuffer[Int]() val length = caretMarker.length var occ = text.indexOf(caretMarker) while(occ > 0) { result += occ text = text.substring(0, occ) + text.substring(occ + length) occ = text.indexOf(caretMarker) } result } val result = findOffsets(text).map(offset => CaretPosition(file, offset)) if (result.nonEmpty) { inWriteAction(FileDocumentManager.getInstance().getDocument(file).replaceString(0, fileLength, text)) } result }	VirtualFile => Seq[ScalaRenameTestBase.this.CaretPosition]	caretsInFile
TargetElementUtil.findTargetElement( InjectedLanguageUtil.getEditorForInjectedLanguageNoCommit(editor, file), TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED | TargetElementUtil.ELEMENT_NAME_ACCEPTED)	PsiElement	element
"/*begin*/"	String	BEGIN_MARKER
"/*end*/"	String	END_MARKER
element.getText != null && element.getText.contains("Comments")	Boolean	searchInComments
""	String	oldName
new ScalaExtractMethodHandler	ScalaExtractMethodHandler	handler
if (newReturnType != null) getPsiTypeFromText(newReturnType, psiMethod) else psiMethod.getReturnType	PsiType	retType
PsiDocumentManager.getInstance(getProjectAdapter).getDocument(file)	Document	document
Seq(parameterInfo("ii", 0, Int), parameterInfo("b", 2, Boolean))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("i", -1, Int, "1"))	Seq[ScalaParameterInfo]	params
newParams.flatten.map(_.asInstanceOf[ParameterInfoImpl]).toArray	Array[ParameterInfoImpl]	params
Seq(parameterInfo("i", 0, Int), parameterInfo("s", -1, AnyRef, "\"hi\""), parameterInfo("b", 1, Boolean))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("i", 0, Int), parameterInfo("b", 1, Boolean), parameterInfo("xs", -1, Int, isRep = true, defVal = "1"))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("i", 0, Int), parameterInfo("xs", -1, Int, isRep = true))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("i", 0, Int), parameterInfo("b", 1, Boolean, isRep = true))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("x", 0, Int), parameterInfo("s", 1, AnyRef, isByName = true))	Seq[ScalaParameterInfo]	params
myEditor.getSelectionModel.getSelectionStart	Int	startOffset
Seq(Seq.empty)	Seq[Seq[Nothing]]	params
myEditor.getSelectionModel.getSelectionEnd	Int	endOffset
Seq(parameterInfo("i", 0, Int), parameterInfo("b", 1, Boolean))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("i", 0, Int), parameterInfo("j", -1, Int, "0"))	Seq[ScalaParameterInfo]	params
_	Editor	myEditor
Seq(parameterInfo("i", 0, Int), parameterInfo("b", -1, Boolean, "true"))	Seq[ScalaParameterInfo]	params
_	FileEditorManager	fileEditorManager
Seq(parameterInfo("i", 0, Int), parameterInfo("j", -1, Int))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("newName", 0, Int))	Seq[ScalaParameterInfo]	params
_	PsiFile	myFile
ScopeSuggester.suggestScopes(new EmptyConflictsReporter {}, element.getProject, editor, element.getContainingFile, element.asInstanceOf[ScTypeElement])	Array[ScopeItem]	scopes
Seq(Seq(parameterInfo("b", -1, Boolean, "true")), Seq(parameterInfo("x", 0, Int), parameterInfo("y", -1, Int, "0")))	Seq[Seq[ScalaParameterInfo]]	params
targetMethod match { case fun: ScFunction => Option(newReturnType).flatMap { createTypeFromText(_, fun, fun) }.orElse { fun.returnType.toOption } case _ => None }	Option[ScType]	maybeReturnType
text.indexOf(ALL_MARKER)	Int	index
false	Boolean	replaceAllOccurrences
Seq(parameterInfo("j", 1, Int), parameterInfo("b", 2, Boolean), parameterInfo("s", -1, AnyRef, "\"\""))	Seq[ScalaParameterInfo]	params
fileText	String	testFileText
testFileText.indexOf(BEGIN_MARKER)	Int	startOffset
Seq(parameterInfo("i", 0, Int), parameterInfo("s", -1, Boolean, "true"))	Seq[ScalaParameterInfo]	params
testFileText.indexOf(END_MARKER)	Int	endOffset
Seq(parameterInfo("b", 1, Boolean), parameterInfo("i", 0, Int))	Seq[ScalaParameterInfo]	params
Seq(parameterInfo("i", -1, Int, "0"))	Seq[ScalaParameterInfo]	params
getValidator(myFile)(project, myEditor)	Option[ScalaValidator]	maybeValidator
file.findElementAt(selectionModel.getSelectionStart)	PsiElement	origin
file.findElementAt(selectionModel.getSelectionEnd - 1)	PsiElement	bound
Seq(parameterInfo("number", 1, Int), parameterInfo("char", 0, Char), parameterInfo("b", -1, Boolean, "true"))	Seq[ScalaParameterInfo]	params
findCommonParent(origin, bound)	PsiElement	commonParentOne
newParams.map(_.map(_.asInstanceOf[ScalaParameterInfo]))	IndexedSeq[IndexedSeq[ScalaParameterInfo]]	params
Seq(Seq(parameterInfo("b", 0, Boolean)), Seq(parameterInfo("x", -1, Int, "10"), parameterInfo("i", 1, Int, isRep = true)))	Seq[Seq[ScalaParameterInfo]]	params
expr.parents.toList.filter(_.isInstanceOf[ScTemplateDefinition])(selectedClassNumber).asInstanceOf[ScTemplateDefinition]	ScTemplateDefinition	aClass
new IntroduceFieldContext[ScExpression](getProjectAdapter, editor, scalaFile, expr, types, aClass)	IntroduceFieldContext[ScExpression]	ifc
Seq( Seq(parameterInfo("ii", 0, Int), parameterInfo("argss", 2, Int, isRep = true)), Seq(parameterInfo("cc", 1, Char), parameterInfo("b", -1, Boolean, "true")) )	Seq[Seq[ScalaParameterInfo]]	params
new IntroduceFieldSettings[ScExpression](ifc)	IntroduceFieldSettings[ScExpression]	settings
classOf[ScalaXmlUnmatchedTagInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
Seq(classOf[ScalaFile], classOf[ScBlock], classOf[ScTemplateBody])	Seq[(Class[_ >: ScTemplateBody <: _$1]) forSome {type _$1 >: ScalaFile with ScBlock <: ScImportsHolder}]	classes
ScalaBundle.message("xml.no.opening.tag")	String	description
ScalaBundle.message("xml.rename.opening.tag")	String	hint
s"val xml = <aaa>blah blah$START</aab>$END"	String	text
ScalaBundle.message("xml.no.closing.tag")	String	description
ScalaBundle.message("xml.rename.closing.tag")	String	hint
ScalaTypeAnnotationSettings(targetMethod.getProject).isTypeAnnotationRequiredFor( Declaration(targetMethod, Visibility(newVisibility)), Location(targetMethod), Some(Definition(targetMethod)))	Boolean	annotationNeeded
getOccurrenceRanges(expression, fileEncloser(file).orNull)	Seq[TextRange]	occurrences
classOf[ScalaRedundantConversionInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
getContainerOne(file, occurrences.length)	PsiElement	containerOne
psiFileOf(code)(getProject)	ScalaFile	file
new ScalaStructureViewModel(file)	ScalaStructureViewModel	model
commonParent(file, occurrences)	PsiElement	parent
getTypeElementOccurrences(typeElement, fileEncloser(file).orNull)	Array[ScTypeElement]	occurrences
classOf[AppliedTypeLambdaCanBeSimplifiedInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("applied.type.lambda.can.be.simplified")	String	description
InspectionBundle.message("simplify.type")	String	hint
classOf[KindProjectorSimplifyTypeProjectionInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("kind.projector.simplify.type")	String	description
s"def a: $START({type l[a] = Either[String, a]})#l[Int]$END)"	String	text
s"def a: ${START}Lambda[A => (A, A)][Int]$END"	String	text
s"def a: $START({type A[Beta] = Either[Int, Beta]})#A$END"	String	code
null	Null	description
s"def a: ${START}Either[+?, -?][String, Int]$END"	String	text
classOf[ScalaMalformedFormatStringInspection]	Class[ScalaMalformedFormatStringInspection]	classOfInspection
s"def a: $START({type L[A, B] = Either[B, A]})#L$END"	String	code
Seq( "%b", "%h", "%s", "%c", "%d", "%e", "%f", "%ts" )	Seq[Nothing]	formatSpecifiers
s"def a: $START({type A[-Alpha, +Gamma] = Function2[Alpha, String, Gamma]})#A$END"	String	code
classOf[NestedStatefulMonadsInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
findCommonParent(occurrences: _*)	PsiElement	parent
NestedStatefulMonadsInspection.Description	String	description
s"def a: $START({type A[A] = (A, A)})#A$END"	String	code
s"def a: $START({type A[+A, B] = Either[A, Option[B]]})#A$END"	String	code
classOf[ReferenceMustBePrefixedInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"def a: $START({type A[A, B[_]] = B[A]})#A$END"	String	code
s"def a: $START({type B[A <: Any] = (A, A)})#B$END"	String	code
settings.getImportsWithPrefix	Array[Nothing]	patterns
s"def a: $START({type B[A >: Int <: Any] = (A, A)})#B$END"	String	code
FileEditorManager.getInstance(project)	FileEditorManager	fileEditorManager
fileEditorManager .openTextEditor(new OpenFileDescriptor(project, getVFileAdapter, startOffset), false)	Editor	editor
InspectionBundle.message("specs2.use.builtin.matcher")	String	annotation
ScalaChangeInfo(newVisibility, targetMethod.asInstanceOf[ScMethodLike], newName, maybeReturnType.getOrElse(Any), params, isAddDefaultValue, Some(annotationNeeded))	ScalaChangeInfo	changeInfo
s"def a: $START({type B[-C >: Int, +A <: Any] = (A, A, C)})#B$END"	String	code
scalaFile.findElementAt(offset)	PsiElement	comment
s"def a: ({type B[C >: List[Int], +A <: Any] = (A, A, C)})#B"	String	code
classOf[BuiltinMatcherExistsInspection]	Class[BuiltinMatcherExistsInspection]	classOfInspection
s"def a: ({type B[C >: Int with String] = (C, C)})#B"	String	code
Seq( "null" -> null, "true" -> true, "0.toByte" -> 0.toByte, "'c'" -> 'c', "0.toShort" -> 0.toShort, "0" -> 0, "0L" -> 0L, "0.0F" -> 0.0F, "0D" -> 0D, "\"\"" -> "", "\"\".asInstanceOf[CharSequence]" -> "".asInstanceOf[CharSequence], "StringBuilder.newBuilder" -> StringBuilder.newBuilder, "new java.lang.StringBuilder()" -> new java.lang.StringBuilder(), "BigInt(0)" -> BigInt(0), "BigDecimal(0)" -> BigDecimal(0), "new java.math.BigInteger(\"0\")" -> new java.math.BigInteger("0"), "java.util.Calendar.getInstance" -> java.util.Calendar.getInstance, "new java.util.Date" -> new java.util.Date(), "new java.lang.Boolean(true)" -> new java.lang.Boolean(true), "new java.lang.Byte(0.toByte)" -> new java.lang.Byte(0.toByte), "new java.lang.Character('c')" -> new java.lang.Character('c'), "new java.lang.Short(0.toShort)" -> new java.lang.Short(0.toShort), "new java.lang.Integer(0)" -> new java.lang.Integer(0), "new java.lang.Long(0L)" -> new java.lang.Long(0L), "new java.lang.Float(0.0)" -> new java.lang.Float(0.0), "new java.lang.Double(0D)" -> new java.lang.Double(0D), "new java.lang.Object" -> new java.lang.Object, )	Seq[Nothing]	arguments
s"def a: ({type B[C >: Array[X] forSome { type x }] = (C, C)})#B"	String	code
s"def a: $START({type R[A] = Tuple2[A, Double]})#R$END"	String	code
StringBuilder.newBuilder	mutable.StringBuilder	codeBuilder
getSetting(allMarker, "true").toBoolean	Boolean	replaceAllOccurrences
getSetting(nameMarker, "param")	String	paramName
Seq.newBuilder[String]	mutable.Builder[String, Seq[String]]	testBuilder
s"def d: $START({type R[F[_], +B] = Either[F, B]})#R$END"	String	code
classOf[VarCouldBeValInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
model.getSorters.filterNot(_.isVisible).reverse.map(_.getComparator.asInstanceOf[Comparator[TreeElement]])	IndexedSeq[Any]	comparators
s"def w: $START({type R[A <: String] = List[A]})#R$END"	String	code
getSetting(defaultMarker, "false").toBoolean	Boolean	isDefaultParam
s""" |expr must $START$matcher(Some("123"))$END """.stripMargin	String	code
elements => { val comparators = model.getSorters.filterNot(_.isVisible).reverse.map(_.getComparator.asInstanceOf[Comparator[TreeElement]]) comparators.foldLeft(elements)((elements, comparator) => elements.sortWith((e1, e2) => comparator.compare(e1, e2) <= 0)) }	Seq[TreeElement] => Seq[TreeElement]	sorter
getSetting(constructorMarker, "false").toBoolean	Boolean	toPrimaryConstructor
Try(specifier.format(repr)).isFailure	Boolean	shouldHaveInspection
new ScalaIntroduceParameterHandler()	ScalaIntroduceParameterHandler	handler
s"Format specifier $specifier cannot be used for an argument $arg (---)"	String	hintForSpecifier
classOf[ScalaUnusedSymbolInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
ScalaUnusedSymbolInspection.Annotation	String	description
s"Argument $arg (---) cannot be used for a format specifier $specifier"	String	hintForArg
s""" |expr must $START$matcher(None)$END """.stripMargin	String	code
DeleteUnusedElementFix.Hint	String	hint
findInspections(code)	Seq[String]	inspectionHints
inspectionHints.map(" \\(.*\\)".r.replaceFirstIn(_, " (---)"))	IndexedSeq[Any]	inspectionHintsWithoutTypes
s""" |expr must $START$matcher(Left("123"))$END """.stripMargin	String	code
s""" |class Foo { | private val ${START}s$END = 0 |} """.stripMargin	String	code
s""" |object Foo { | def foo(): Unit = { | val ${START}s$END = 0 | } |} """.stripMargin	String	code
s""" |expr must $START$matcher(Right("123"))$END """.stripMargin	String	code
{ val file = psiFileOf(code)(getProject) val model = new ScalaStructureViewModel(file) val sorter: Seq[TreeElement] => Seq[TreeElement] = elements => { val comparators = model.getSorters.filterNot(_.isVisible).reverse.map(_.getComparator.asInstanceOf[Comparator[TreeElement]]) comparators.foldLeft(elements)((elements, comparator) => elements.sortWith((e1, e2) => comparator.compare(e1, e2) <= 0)) } Node(model.getRoot, sorter) }	ScalaStructureViewTest.Node	actualNode
new Node(ScalaFileType.INSTANCE.getIcon, "foo.scala", nodes: _*).toString	String	expected
classOf[LanguageFeatureInspection]	Class[LanguageFeatureInspection]	classOfInspection
new Regex("(?<=/)[^/]+(?=\\.png)")	Regex	IconFileName
element.getPresentation	ItemPresentation	presentation
s""" |class Foo { | private val (${START}a$END, b): String = ??? | println(b) |} """.stripMargin	String	code
classOf[DoubleNegationInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s""" |${START}expr must_=== Some("123")$END """.stripMargin	String	code
"Double negation"	String	description
s""" |class Bar { | def aa(): Unit = { | var (${START}d$END, a) = 10 | } |} """.stripMargin	String	code
s""" |${START}expr must_=== None$END """.stripMargin	String	code
classOf[SimplifyBooleanInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"$START!(!true)$END"	String	selectedText
s""" |class Bar { | def aa(): Unit = { | var (d, a) = 10 | println(a) | } |} """.stripMargin	String	before
s"val flag: Boolean = $START!(a != b)$END"	String	selectedText
s""" |class Bar { | def aa(): Unit = { | var (_, a) = 10 | println(a) | } |} """.stripMargin	String	after
classOf[SimplifyBooleanMatchInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"$START!true$END"	String	selectedText
s""" |${START}expr must_=== $either("123")$END """.stripMargin	String	code
s"if ($START!a != b$END) true else false"	String	selectedText
s""" |class Moo { | Option(null) match { | case Some(${START}s$END: String) => | println("AA") | } |} """.stripMargin	String	code
s"$START!a == !b$END"	String	selectedText
s""" |expr must be$either("123") """.stripMargin	String	expected
InspectionBundle.message("specs2.use.builtin.matcher")	String	description
s"$START!a != !b$END"	String	selectedText
s""" |val a = true |val b = a ${START}match$END { | case true => 1 |} """.stripMargin	String	selectedText
s"""val a = true |${START}true == a$END""".stripMargin	String	selectedText
s""" |class Moo { | Option(null) match { | case Some(${START}s$END) => | println("AA") | } |} """.stripMargin	String	code
sorter(element.getChildren).map { case element: StructureViewTreeElement => Node(element, sorter) }	IndexedSeq[ScalaStructureViewTest.Node]	children
s""" |class Moo { | Option("").map { | case ${START}a$END: String => | } |} """.stripMargin	String	code
new LayeredIcon(icons.length)	LayeredIcon	result
s"""val a = true |${START}true && a$END""".stripMargin	String	selectedText
s""" |val a = true |val b = a ${START}match$END { | case true => { | 1 | } |} """.stripMargin	String	selectedText
classOf[RedundantDefaultArgumentInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s""" |class Moo { | Option(null) match { | case ${START}s$END@Some(a) => println(a) | } |} """.stripMargin	String	code
s""" |val a = true |val b = a ${START}match$END { | case false => 1 |} """.stripMargin	String	selectedText
<scalastyle commentFilter="enabled"> <name>Scalastyle standard configuration</name> <check level="warning" class="org.scalastyle.scalariform.ClassNamesChecker" enabled="true"> <parameters> <parameter name="regex">[A-Z][A-Za-z]*</parameter> </parameters> </check> </scalastyle>	Elem	config
s""" |class Moo { | Option(null) match { | case s@Some(${START}a$END) => println(s) | } |} """.stripMargin	String	code
s""" |val a = true |val b = a ${START}match$END { | case false => 1 | case true => 4 |} """.stripMargin	String	selectedText
s""" |def f(x: Int = 0) {} |f(${START}0$END) """.stripMargin	String	selectedText
s"""val a = true |${START}a | false$END""".stripMargin	String	selectedText
s""" |class Moo { | def foo(s: Seq[(Int, Int)]): Seq[Int] = { | s.map { | case (a, ${START}b$END) => a | } | } |} """.stripMargin	String	code
s""" |val a = true |val b = a ${START}match$END { | case true => 1 | case _ => 4 |} """.stripMargin	String	selectedText
classOf[CaseClassParamInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
ScalaBundle.message("val.on.case.class.param.redundant")	String	description
s""" |def f(x: Int, y: Int = 0, z: Int) {} |f(1, ${START}y=0$END, z=1) """.stripMargin	String	selectedText
s""" |class Moo { | def foo(s: Seq[(Int, Int)]): Seq[Int] = { | s.map (${START}a$END => 1) | } |} """.stripMargin	String	code
s""" |val a = true |val b = a ${START}match$END { | case false => 1 | case _ => 4 |} """.stripMargin	String	selectedText
config.toString()	String	configString
classOf[RedundantNewCaseClassInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"case class A(${START}val$END x: Int = 1)"	String	text
s""" |class Moo { | val s = Seq("") | for (${START}j$END <- s) { | println(s) | } |} """.stripMargin	String	code
s""" |val a = true |val b = a ${START}match$END { | case true => { | 1 | } | case false => { | val t = 1 | t + 2 | } |} """.stripMargin	String	selectedText
ScalaBundle.message("new.on.case.class.instantiation.redundant")	String	description
classOf[ScalastyleCodeInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s""" |def f(x: Int, y: Int = 0) {} |f(1, ${START}0$END) """.stripMargin	String	selectedText
s""" |val a = true |${START}true && (a || false)$END """.stripMargin	String	selectedText
s""" |val a = true |val b = a match { | case true => { | 1 | } | case false => { | val t = 1 | t + 2 | } |} """.stripMargin	String	text
VfsUtil.createDirectoryIfMissing(getProject.getBasePath)	VirtualFile	baseDir
s""" |def f(x: Int, y: Int = 0, z: Int, t: Int) {} |f(1, ${START}0$END, z = 1, t = 2) """.stripMargin	String	selectedText
classOf[MapKeysInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s""" |val b = 1 + 2 == 3 ${START}match$END { | case true => 1 |} """.stripMargin	String	selectedText
getOrCreateFile(baseDir, "scalastyle-config.xml")	VirtualFile	file
InspectionBundle.message("replace.with.keys")	String	hint
s""" |val a = true |true && (a || false)""".stripMargin	String	text
classOf[MapLiftInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.with.get")	String	hint
s""" |class Person() { | def func() = { | object ${START}A$END | } |} """.stripMargin	String	code
InspectionBundle.message("replace.with.keySet")	String	hint
InspectionBundle.message("replace.with.keysIterator")	String	hint
s""" |case class A(x: Int) |val a = ${START}new$END A(5) """.stripMargin	String	program
handler.collectData(exprWithTypes, elems, methodLike, editor)	Option[ScalaIntroduceParameterData]	collectedData
s""" |val b = 1 + 2 == 3 ${START}match$END { | case false => 1 |} """.stripMargin	String	selectedText
s""" |class Person() { | private object ${START}A$END |} """.stripMargin	String	code
s""" |val a = true |true && (${START}a || false$END) """.stripMargin	String	selectedText
s""" |case class A(x: Int) |val a = A(5) """.stripMargin	String	expected
s""" |def f(x: Int = 0) |f(${START}0$END) """.stripMargin	String	selectedText
s""" |val a = true |val b = a match { | case a + 2 == 3 => { | 1 | } |} """.stripMargin	String	text
s""" |case class A[T](x: T) |val a = ${START}new$END A(5) """	String	program
s""" |val a = true |true && (${CARET_MARKER}a || false) """.stripMargin	String	text
s""" |val a = 1 |val b = a match { | case a + 2 == 3 => { | 1 | } | case a + 2 == 4 => { | 2 | } | case _ => |} """.stripMargin	String	text
s""" |case class A[T](x: T) |val a = A(5) """.stripMargin	String	expected
s""" |val a = 1 + 2 |val b = a match { | case a + 2 == 3 => { | 1 | } |} """.stripMargin	String	text
s""" |val a = true |true && a """.stripMargin	String	result
classOf[MapValuesInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s""" |val a = true |val b = a match { | case _ => { | 1 | } |} """.stripMargin	String	text
s""" |abstract class List |case class Node (value: Int, next: List) extends List |object Empty extends List | |${START}new$END Node(1, new Node(2, Empty)) """.stripMargin	String	program
InspectionBundle.message("replace.with.values")	String	hint
classOf[UnitInMapInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"""val a = true |val flag: Boolean = ${START}true != a$END""".stripMargin	String	selectedText
InspectionBundle.message("expression.unit.return.in.map")	String	description
s""" |val a = true |val b = a match { | case _ => { | 1 | } | case _ => { | 2 | } |} """.stripMargin	String	text
InspectionBundle.message("use.foreach.instead.of.map")	String	hint
InspectionBundle.message("replace.with.valuesIterator")	String	hint
s""" |abstract class List |case class Node (value: Int, next: List) extends List |object Empty extends List | |Node(1, new Node(2, Empty)) """.stripMargin	String	expected
s"""val a = true |val flag: Boolean = true != a""".stripMargin	String	text
s""" |val a = true |val c = false |val b = a match { | case true if c => 1 | case false => 4 |} """.stripMargin	String	text
s""" |abstract class List |case class Node (value: Int, next: List) extends List |object Empty extends List | |Node(1, ${START}new$END Node(2, Empty)) """.stripMargin	String	program
classOf[EmptyCheckInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"""val a = true |!(${START}true != a$END)""".stripMargin	String	selectedText
s""" |abstract class List |case class Node (value: Int, next: List) extends List |object Empty extends List | |Node(1, Node(2, Empty)) """.stripMargin	String	expected
InspectionBundle.message("replace.with.isEmpty")	String	hint
collectedData.get.copy(paramName = paramName, replaceAll = replaceAllOccurrences)	ScalaIntroduceParameterData	data
classOf[HeadOrLastOptionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"$START!Seq().nonEmpty$END"	String	selected
s"Array().${START}filter(x => true).size$END"	String	selected
handler.createMethodDescriptor(data.methodToSearchFor, paramInfo)	ScalaMethodDescriptor	descriptor
InspectionBundle.message("replace.with.headOption")	String	hint
s"List().${START}filter(x => true).length$END"	String	selected
InspectionBundle.message("replace.with.lastOption")	String	hint
s"$START!Option(1).isDefined$END"	String	selected
s"Map() ${START}filter (x => true) size$END"	String	selected
s"Seq()$START.size == 0$END"	String	selected
classOf[MapGetGetInspection]	Class[MapGetGetInspection]	classOfInspection
s"List().${START}filter {x => true}.size$END"	String	selected
classOf[MapFlattenInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"Option(1)$START == None$END"	String	selected
InspectionBundle.message("replace.map.flatten.with.flatMap")	String	hint
s"""Map("a"->"x").${START}get("a").get$END"""	String	selected
s"$START!(Seq().size != 0)$END"	String	selected
classOf[SortFilterInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("sort.filter.hint")	String	hint
s""" |trait LengthTest { | def foo(): Unit = { | Seq().${START}filter(_ => true).size$END | | | } |} """.stripMargin	String	selected
s"Seq(1)$START.headOption == None$END"	String	selected
s"""val m = Map("a" -> "b") |m.${START}get("a").get$END""".stripMargin	String	selected
s"$START!Seq(1).lastOption.isDefined$END"	String	selected
s"""val m = Map("a" -> "b") |m.get("a").get""".stripMargin	String	text
InspectionBundle.message("replace.with.isDefined")	String	hint
classOf[FilterSizeInspection]	Class[FilterSizeInspection]	classOfInspection
s"List(0, 1).${START}sorted.filter(_ => true)$END"	String	selected
s"""val m = Map("a" -> "b") |m("a")""".stripMargin	String	result
s"Option(1)$START != None$END"	String	selected
s"List(0, 1).${START}sortWith((x, y) => x < y).filter(_ => true)$END"	String	selected
s"${START}None != ${END}Option(1)"	String	selected
s"""val m = Map(1 -> "b") |m.${START}get(1).get$END""".stripMargin	String	selected
classOf[FoldTrueAndInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("fold.true.and.hint")	String	hint
s"Option(1)$START.exists(_ => true)$END"	String	selected
s"""val m = Map(1 -> "b") |m.get(1).get""".stripMargin	String	text
s"Option()$START.exists(scala.Function.const(true))$END"	String	selected
s"List(0, 1).${START}sortBy[String](_.toString).filter(_ => true)$END"	String	selected
InspectionBundle.message("replace.with.nonEmpty")	String	hint
s"""val m = Map(1 -> "b") |m(1)""".stripMargin	String	result
s"List(false).${START}foldLeft(true){_ && _}$END"	String	selected
s"""Map("a"->"x").${START}get(0).get$END"""	String	selected
s"List(0, 1).${START}sortBy[String](_.toString) filter (_ => true)$END"	String	selected
s"$START!Seq().isEmpty$END"	String	selected
s"Seq()$START.size > 0$END"	String	selected
s"""def a(x: String) = false |List("a").$START/:(true) (_ && a(_))$END""".stripMargin	String	selected
s"Seq()$START.length >= 1$END"	String	selected
classOf[MapGetOrElseInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("map.getOrElse.hint")	String	hint
s"Seq()$START.size != 0$END"	String	selected
s"""def a(x: String) = false |List("a").${START}fold(true) ((x,y) => x && a(y))$END""".stripMargin	String	selected
s"Seq()$START.exists(_ => true)$END"	String	selected
classOf[GetGetOrElseInspection]	Class[GetGetOrElseInspection]	classOfInspection
s"import scala.Function.const; List()$START.exists(const(true))$END"	String	selected
s"None.${START}map(x => 1).getOrElse(0)$END"	String	selected
ScalaChangeInfo(descriptor.getVisibility, data.methodToSearchFor, descriptor.getName, returnType, descriptor.parameters, isDefaultParam)	ScalaChangeInfo	changeInfo
s"""Map().${START}get(0).getOrElse("")$END"""	String	selected
classOf[SizeToLengthInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"Stream(1)$START.exists(scala.Function.const(true))$END"	String	selected
InspectionBundle.message("size.to.length")	String	hint
s"""Map("a" -> "A") ${START}get "b" getOrElse "B"$END"""	String	selected
s"""class Test { | Some(0) ${START}map (_ => true) getOrElse false$END |}""".stripMargin	String	selected
classOf[ToSetAndBackInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.toSet.and.back.with.distinct")	String	hint
InspectionBundle.message("getOrElse.null.hint")	String	hint
s"""val function: (Any) => Boolean = _ => true |(None ${START}map function).getOrElse(false)$END""".stripMargin	String	selected
classOf[IfElseToOptionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
"Replace with Option(x)"	String	hint
classOf[FindEmptyCheckInspection]	Class[FindEmptyCheckInspection]	classOfInspection
classOf[RangeToIndicesInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"None ${START}map {_ => 1} getOrElse {1}$END"	String	selected
"Replace with seq.indices"	String	hint
s"None.${START}getOrElse(null)$END"	String	selected
classOf[ComparingLengthInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"None ${START}getOrElse null$END"	String	selected
s"""val valueIsGoodEnough: (Any) => Boolean = _ => true |Nil$START.find(valueIsGoodEnough).isDefined$END""".stripMargin	String	selected
s"""Some(1) ${START}map (s => s + 1) getOrElse { | val x = 1 | x |}$END""".stripMargin	String	selected
s"Some(1) orElse Some(2) ${START}getOrElse null$END"	String	selected
s"(Nil$START find (_ => true)) isDefined$END"	String	selected
s"(Nil$START find (_ => true)) != None$END"	String	selected
classOf[GetOrElseNullInspection]	Class[GetOrElseNullInspection]	classOfInspection
s"Nil$START.find(_ => true) != None$END"	String	selected
classOf[DropTakeToSliceInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.drop.take.with.slice")	String	hint
InspectionBundle.message("replace.take.drop.with.slice")	String	hint
s"Nil$START.find(_ => true) == None$END"	String	selected
classOf[LastIndexToLastInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.with.last")	String	hint
s"Nil$START.find(_ => true).isEmpty$END"	String	selected
classOf[ZeroIndexToHeadInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.with.head")	String	hint
classOf[FilterEmptyCheckInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("filter.empty.check.hint")	String	hint
classOf[ExistsEqualsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("exists.equals.hint")	String	hint
s"List(0).${START}filter(x => true).headOption$END"	String	selected
classOf[IndexBoundsCheckInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("ifstmt.to.lift")	String	hint
s"(Map()$START filter (x => true)).size == 0$END"	String	selected
s"(List(0) ${START}filter (x => true)).headOption$END"	String	selected
s"Option(1)$START.filter(x => true) == None$END"	String	selected
s"List(0).${START}exists(x => x == 1)$END"	String	selected
classOf[MapToBooleanContainsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"List(0).${START}filter(x => true).headOption$END.isDefined"	String	selected
InspectionBundle.message("replace.map.contains.true.with.exists")	String	hint
s"List(0).${START}exists(_ == 1)$END"	String	selected
classOf[FilterHeadOptionInspection]	Class[FilterHeadOptionInspection]	classOfInspection
InspectionBundle.message("replace.map.contains.false.with.not.forall")	String	hint
s"Seq(1)$START.filter(x => true).headOption == None$END"	String	selected
s"List(0) ${START}exists (x => x == 1)$END"	String	selected
InspectionBundle.message("filter.nonempty.check.hint")	String	hint
s"List(0).${START}exists(1 == _)$END"	String	selected
classOf[OptionEqualsSomeToContainsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"Array()$START.filter(x => true).size > 0$END"	String	selected
OptionEqualsSomeToContains.hint	String	hint
s"Some(0).${START}exists(_ == 1)$END"	String	selected
s"List()$START.filter(x => true).length >= 1$END"	String	selected
classOf[CollectHeadOptionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
OptionNotEqualsSomeToNotContains.hint	String	hint
InspectionBundle.message("forall.notEquals.hint")	String	hint
InspectionBundle.message("replace.collect.headOption.with.collectFirst")	String	hint
s"List()$START.filter(x => true).nonEmpty$END"	String	selected
s"Seq(1, 2).${START}forall(_ != 2)$END"	String	selected
s"Option(1)$START filter (x => true) isDefined$END"	String	selected
classOf[FindAndMapToApplyInspection]	Class[FindAndMapToApplyInspection]	classOfInspection
s"Seq(1)$START.filter(x => true).lastOption.isDefined$END"	String	selected
"Replace find and map with apply"	String	hint
classOf[ReplaceToWithUntilInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.to.with.until")	String	hint
classOf[ReverseTakeReverseInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"Map().${START}find(_ == 1).map(_._2)$END"	String	selected
InspectionBundle.message("replace.reverse.take.reverse.with.takeRight")	String	hint
classOf[FilterEmptyCheckInspection]	Class[FilterEmptyCheckInspection]	classOfInspection
s"""val m = Map("k" -> "5", "v" -> "6") m.${START}find(_ == "5").map(_._2)$END"""	String	selected
classOf[UnzipSingleElementInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"List()$START.filterNot(x => true).size == 0$END"	String	selected
InspectionBundle.message("replace.with.map")	String	hint
s"""val m = Map("k" -> "5", "v" -> "6") m.find(_ == "5").map(_._2)""".stripMargin	String	text
s"""val m = Map("k" -> "5", "v" -> "6") m("5")""".stripMargin	String	result
s"List()$START.filterNot(x => true).isEmpty$END"	String	selected
classOf[ExistsForallReplaceInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.with.exists")	String	hint
s"List()$START.filterNot(x => true).headOption.isEmpty$END"	String	selected
classOf[FilterOtherContainsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
classOf[MapGetOrElseBooleanInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("map.getOrElse.false.hint")	String	hint
InspectionBundle.message("replace.filter.with.intersect")	String	hint
InspectionBundle.message("replace.filter.with.diff")	String	hint
s"""$START!Seq("").forall(!_.isEmpty)$END"""	String	selected
classOf[RedundantCollectionConversionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("redundant.collection.conversion")	String	hint
s"List()$START.filterNot(x => true).size > 0$END"	String	selected
s"None.${START}map(x => true).getOrElse(false)$END"	String	selected
classOf[SameElementsToEqualsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.with.forall")	String	hint
classOf[CorrespondsUnsortedInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"List()$START.filterNot(x => true).nonEmpty$END"	String	selected
InspectionBundle.message("replace.sameElements.with.equals")	String	hint
InspectionBundle.message("replace.corresponds.with.equals")	String	hint
InspectionBundle.message("sameElements.unsorted")	String	hint
s"""$START!Seq("").exists(!_.isEmpty)$END"""	String	selected
s"Option(1)$START filterNot (x => true) isDefined$END"	String	selected
InspectionBundle.message("corresponds.unsorted")	String	hint
s"List()$START.filterNot(x => true).headOption != None$END"	String	selected
s"""val valueIsGoodEnough: (Any) => Boolean = _ => true |(None ${START}map valueIsGoodEnough).getOrElse(false)$END""".stripMargin	String	selected
InspectionBundle.message("map.getOrElse.true.hint")	String	hint
classOf[EqualityToSameElementsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.equals.with.sameElements")	String	hint
s"""val valueIsGoodEnough: (Any) => Boolean = _ => true |(None ${START}map valueIsGoodEnough).getOrElse(true)$END""".stripMargin	String	selected
classOf[SomeToOptionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.with.option")	String	hint
classOf[SortedMaxMinInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.sorted.head.with.min")	String	hint
classOf[EmulateFlattenInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("replace.sorted.last.with.max")	String	hint
InspectionBundle.message("replace.sortBy.head.with.minBy")	String	hint
classOf[SimplifiableFoldOrReduceInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("fold.sum.hint")	String	hint
InspectionBundle.message("replace.sortBy.last.with.maxBy")	String	hint
InspectionBundle.message("replace.with.flatten")	String	hint
s"List(0).$START/:(0)(_ + _)$END"	String	selected
classOf[RedundantHeadOrLastOptionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
s"Array(0).${START}fold(0) ((_:Int) + _)$END"	String	selected
RedundantHeadOption.hint	String	hint
s"List(0).${START}foldLeft[Int](0) {(x,y) => x + y}$END"	String	selected
RedundantLastOption.hint	String	hint
s"""List("a").foldLeft(0)(_ + _)"""	String	text
s"Seq(Seq(1), Seq(2), Seq(2)).${START}flatMap(identity)$END"	String	selected
hint	String	description
s"Seq(Seq(1, 2, 3), Seq(4, 5), Seq(6, 7)).${START}flatMap(x => identity(x))$END"	String	selected
InspectionBundle.message("reduce.min.hint")	String	hint
classOf[FilterSetContainsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
classOf[IfElseToFilteredOptionInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("remove.redundant.contains")	String	hint
"Replace if with filtered option"	String	hint
InspectionBundle.message("reduce.product.hint")	String	hint
classOf[SideEffectsInMonadicTransformationInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
InspectionBundle.message("side.effects.in.monadic")	String	hint
s"Seq(Seq(3, 1, 4), Seq(1, 5), Seq(9, 2)).${START}flatMap(identity(_))$END"	String	selected
s"Seq(Seq(2, 7, 1), Seq(8, 2), Seq(8, 1)).${START}flatMap(x => x)$END"	String	selected
classOf[ComparingDiffCollectionKindsInspection]	Class[_ <: OperationOnCollectionInspection]	classOfInspection
convertHint(side, toCollection)	String	hint
s"Iterator(Iterator(1), Iterator(2), Iterator(3)).${START}flatMap(identity)$END"	String	selected
"left"	String	side
s"Iterator(Seq(1), Seq(2), Seq(3)).${START}flatMap(identity)$END"	String	selected
"Set"	String	toCollection
classOf[ScalaUnusedExpressionInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
"right"	String	side
classOf[ScalaDeprecationInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"Set(Set(1), Set(2), Set(3)).${START}flatMap(identity)$END"	String	selected
"Seq"	String	toCollection
"is deprecated"	String	description
s"Set(Set(1), Set(2), Set(3)).${START}flatMap(x => x)$END"	String	selected
"Iterator"	String	toCollection
s"Set(Set(1), Set(2), Set(3)).${START}flatMap(identity[Set[Int]])$END"	String	selected
classOf[DeprecatedKindProjectorSyntaxInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
"Usage of `?` placeholder is going to be deprecated. Consider using `*` instead."	String	description
s"Set(Set(1), Set(2), Set(3)).${START}flatMap(identity _)$END"	String	selected
"Map"	String	toCollection
s"Set(Set(1), Set(2), Set(3)) ${START}flatMap identity$END"	String	selected
s""" |@deprecated("Deprecated", "0.0.1") |object Util { } | |import ${START}Util$END._ """.stripMargin	String	code
classOf[ScalaUnnecessaryParenthesesInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"val o = Option(Option(1)); o.${START}getOrElse(None)$END"	String	selected
s"Option(Option(1)).${START}getOrElse(None)$END"	String	selected
"Array"	String	toCollection
s""" |object Test { | trait F[A[_]] | val a: F[List[$START?$END]] = ??? |} |""".stripMargin	String	code
s"val o = Option(Option(1)); o.${START}map(_.get)$END"	String	selected
s""" |object Test { | trait F[A[_]] | val a: F[Either[String, $START+?$END]] = ??? |} """.stripMargin	String	code
s"Option(Option(1)).${START}map(_.get)$END"	String	selected
s""" |trait T[A] { | @deprecated("Use bar()", "1.0") | def foo(): Unit |} | |object Test { | val t: T[Int] = ??? | t.${START}foo$END() |} """.stripMargin	String	code
classOf[TypeCheckCanBeMatchInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
TypeCheckCanBeMatchInspection.inspectionName	String	description
TypeCheckCanBeMatchInspection.inspectionName	String	hint
s"Seq(Seq(1), Seq(2), Seq(3)).flatMap(x => identity(Seq(1, 2, 3)))"	String	text
InspectionProfileManager.getInstance(getProject) .getCurrentProfile .getInspectionTool("ScalaUnnecessaryParentheses", getProject) .getTool	InspectionProfileEntry	tool
"Usage of `?` placeholder is going to be deprecated. Consider updating kind-projector plugin and using `*` instead."	String	description
s"Seq(Seq(9), Seq(8, 1), Seq(5, 9, 9)).flatMap(_.map(_ * 2))"	String	text
s"Set(Set(1), Set(2), Set(3)).flatMap { x => println(x); x }"	String	text
s""" |$commonCode |object Test { | val f = new ${START}Foo$END(123) |} """.stripMargin	String	primaryConstructor
s"List(List(1), List(2), List(3)).flatMap(1 :: _ )"	String	text
null	String	side
null	String	toCollection
s"Option(Option(1)).getOrElse(Option(2))"	String	text
s"""val x = 0 |if (${START}x.isInstanceOf[Int]$END) { | x.asInstanceOf[Int].toString | println(x.asInstanceOf[Int]) |}"""	String	selected
s"Option(Option(1), 2).getOrElse(None)"	String	text
s""" |$commonCode { | def this() = this(123) |} |object Test { | val f = new ${START}Foo$END() |} """.stripMargin	String	nonPrimaryConstructor
s"""val x = 0 |if (${START}x.isInstanceOf[Int]$END) { | val y = x.asInstanceOf[Int] | x.asInstanceOf[Int].toString | println(y) |}"""	String	selected
s"Option(List(1)).getOrElse(None)"	String	text
check.currentSettings()	UnnecessaryParenthesesSettings	oldSettings
s"""val x = 0 |if (${START}x.isInstanceOf[Int]$END && x.asInstanceOf[Int] == 1) { | val y = x.asInstanceOf[Int] | println(y) |}"""	String	selected
s""" |$commonCode { | def methodOfDeprecatedClass(n: Int): Unit = println(n) | | methodOfDeprecatedClass(123) |} """.stripMargin	String	methodOfDeprecatedClass
s""" |object Test { | trait F[A[_]] | val a: F[Either[String, +?]] = ??? |} """.stripMargin	String	code
s"""val x = 0 |if (x > 0 && (${START}x.isInstanceOf[Int]$END && x.asInstanceOf[Int] == 1)) { | val y = x.asInstanceOf[Int] | println(y) |}"""	String	selected
s"""val x = 0 |if (${START}x.isInstanceOf[Int]$END) { | val y = x.asInstanceOf[Int] | println(y) |} else if (x.isInstanceOf[Long]) { | println(x) |} else println()"""	String	selected
findRanges(text)	Seq[TextRange]	actualRanges
s""" |def inc(x: Int, @deprecatedName('y, "FooLib 12.0") n: Int): Int = x + n |inc(1, ${START}y$END = 2) """.stripMargin	String	code
s"""val x = 0 |if (${START}x.isInstanceOf[Int]$END && x.asInstanceOf[Long] == 1) { | val y = x.asInstanceOf[Int] | println(y) |} else if (x.isInstanceOf[Long]) { | val y = x.asInstanceOf[Int] | println(y) |} else { | println(x) | println() |}"""	String	selected
s"""val x1 = 0 |val x2 = 0 |if (${START}x1.isInstanceOf[Int]$END && x2.isInstanceOf[Int]) { | val y1 = x1.asInstanceOf[Int] | val y2 = x2.asInstanceOf[Int] | println(y1 + y2) |} else if (x1.isInstanceOf[Long] && x2.isInstanceOf[Long]) { | val y1 = x1.asInstanceOf[Int] | val y2 = x2.asInstanceOf[Int] | println(y1 + y2) |}"""	String	selected
selectedRange(getEditor.getSelectionModel)	TextRange	range
TextRange.from(range.getStartOffset, 1)	TextRange	left
TextRange.from(range.getEndOffset - 1, 1)	TextRange	right
s"""val x1 = 0 |val x2 = 0 |if (x1.isInstanceOf[Int] && x2.isI${CARET_MARKER}nstanceOf[Int]) { | val y1 = x1.asInstanceOf[Int] | val y2 = x2.asInstanceOf[Int] | println(y1 + y2) |} else if (x1.isInstanceOf[Long] && x2.isInstanceOf[Long]) { | val y1 = x1.asInstanceOf[Int] | val y2 = x2.asInstanceOf[Int] | println(y1 + y2) |}"""	String	selected
s"""val x1 = 0 |val x2 = 0 |if (x1.isInstanceOf[Int] && x2.isInstanceOf[Int]) { | val y1 = x1.asInstanceOf[Int] | val y2 = x2.asInstanceOf[Int] | println(y1 + y2) |} else if (x1.isIn${CARET_MARKER}stanceOf[Long] && x2.isInstanceOf[Long]) { | val y1 = x1.asInstanceOf[Int] | val y2 = x2.asInstanceOf[Int] | println(y1 + y2) |}"""	String	selected
s"""val x = 0 |val i = 0 |if (${START}x.isInstanceOf[Int]$END) { | x.asInstanceOf[Int].toString | println(x.asInstanceOf[Int]) |}"""	String	selected
s"""val x = 0 |if (${START}x.isInstanceOf[Int]$END) x else if (x.isInstanceOf[Long]) x else 0"""	String	selected
classOf[ComparingUnrelatedTypesInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
classOf[SourceNotClosedInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("source.not.closed")	String	description
s"""import java.util |val foo = (p: AnyVal) => { | if (${START}p.isInstanceOf[util.ArrayList[_]]$END) {} | else if (p.isInstanceOf[scala.util.control.Breaks]) {} |}"""	String	selected
InspectionBundle.message("comparing.unrelated.types.hint", "Short", "Int")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Double", "Int")	String	description
range.shrink(2)	TextRange	middle
InspectionBundle.message("comparing.unrelated.types.hint", "Double", "Byte")	String	description
{ val range = selectedRange(getEditor.getSelectionModel) val left = TextRange.from(range.getStartOffset, 1) val right = TextRange.from(range.getEndOffset - 1, 1) if (range.getLength >= 4) { val middle = range.shrink(2) Seq(left, middle, right) } else { Seq(left, right) } }	Seq[TextRange]	expectedRanges
InspectionBundle.message("comparing.unrelated.types.hint", "Int", "Double")	String	description
s"""def test2(p: AnyVal) { | if (${START}p.isInstanceOf[T forSome {type T <: Number}]$END) {} | else if (p.isInstanceOf[Int]) {} |}"""	String	selected
InspectionBundle.message("comparing.unrelated.types.hint", "Int", "Boolean")	String	description
s"$START(1 + 1)$END"	String	selected
classOf[TypeAnnotationInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("comparing.unrelated.types.hint", "Boolean", "Double")	String	description
TypeAnnotationInspection.DescriptionPrefix	String	description
s"(${CARET_MARKER}1 + 1)"	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "Boolean", "Int")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Array[Char]", "String")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "String", "Int")	String	description
s""" |def f(n: Int): Int = n match { | case even if $START(even % 2 == 0)$END => (even + 1) | case odd => 1 + (odd * 3) |} """	String	selected
InspectionBundle.message("comparing.unrelated.types.hint", "String", "Char")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "CharSequence", "String")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "scala.collection.Iterable", "scala.collection.List")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "A", "B")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "B", "A")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "A", "B.type")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "C", "B.type")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Int", "java.lang.Integer")	String	description
classOf[HashCodeUsesVarInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
"Non-value field is accessed in 'hashCode()'"	String	description
s""" |def f(n: Int): Int = n match { | case even if (${CARET_MARKER}even % 2 == 0) => (even + 1) | case odd => 1 + (odd * 3) |} """	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "Boolean", "java.lang.Boolean")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "java.lang.Integer", "Null")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Seq[Int]", "List[_]")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Some[Int]", "List[_]")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Some[_]", "Some[Int]")	String	description
s"""class A { | var a = 1 | | override def hashCode(): Int = { | ${START}a$END | } |}"""	String	text
s""" |def f(n: Int): Int = n match { | case even if (even % 2 == 0) => $START(even + 1)$END | case odd => 1 + (odd * 3) |} """	String	selected
InspectionBundle.message("comparing.unrelated.types.hint", "Some[_]", "Seq[Int]")	String	description
s""" |def f(n: Int): Int = n match { | case even if (even % 2 == 0) => (even + 1$CARET_MARKER) | case odd => 1 + (odd * 3) |} """	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "BigInt", "Int")	String	description
s"""class A { | val a = 1 | | override def hashCode(): Int = { | ${START}a$END | } |}"""	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "BigInt", "Long")	String	description
s"""class A { | var a = 1 | | override def hashCode(): Int = { | val c = ${START}a$END | c | } |}"""	String	text
s"val a = $START(((1)))$END"	String	selected
InspectionBundle.message("comparing.unrelated.types.hint", "BigInt", "java.lang.Integer")	String	description
s"""class A { | var a = 1 |} |class B extends A { | override def hashCode(): Int = { | ${START}a$END | } |}"""	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "BigInt", "Boolean")	String	description
s"val a = (($CARET_MARKER(1)))"	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "BigInt", "String")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "A.Coord", "Int")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "Dummy", "Int")	String	description
s"1 to $START((1, 2))$END"	String	selected
s"""class A { | var a = (1, 2) | | override def hashCode(): Int = { | ${START}a$END._1 | } |}"""	String	text
InspectionBundle.message("comparing.unrelated.types.hint", "FooBinder", "String")	String	description
InspectionBundle.message("comparing.unrelated.types.hint", "abc.Dummy", "cde.Dummy")	String	description
s"""class A { | var a = 1 | | override def hashCode(): Int = { | (7 + 14 * ${START}a$END) / 21 | } |}"""	String	text
s"$START(/*b*/ 1 + /*a*/ 1 /*comment*/)$END"	String	selected
InspectionBundle.message("comparing.unrelated.types.hint", "Int", "Some[Int]")	String	description
s"($CARET_MARKER/*b*/ 1 + /*a*/ 1 /*comment*/)"	String	text
s"""class A { | var a = 1 | | override def hashCode(): Unit = { | ${START}a$END | } |}"""	String	text
s"$START(/*1*/ 6 /*2*/ /*3*/)$END"	String	selected
s"""class A { | var a = 1 | | override def hashCode(): Int = { | def f(): Int = ${START}a$END | f() | } |}"""	String	text
s"($CARET_MARKER/*1*/ 6 /*2*/ /*3*/)"	String	text
s"""class A { | var a = 1 | | override def hashCode(): Int = { | class B { | def f(): Int = ${START}a$END | } | new B().f() | } |}"""	String	text
s"""class A { | val a = 1 | val b = 1 | | override def hashCode(): Int = { | var r = 0 | r += a | r += b | r | } |}"""	String	text
s"val i: $START(Int)$END = 3"	String	selected
s"val i: ($CARET_MARKER Int) = 3"	String	text
s"val i: $START(((Int)))$END = 3"	String	selected
classOf[UnitMethodInspection.ExplicitType]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.unit.explicit.type")	String	description
s"val i: Int => $START(Int => String)$END = _"	String	selected
classOf[UnitMethodInspection.Parameterless]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.unit.parameterless")	String	description
s"val i: $START(Int => String)$END = _"	String	selected
s"val i: $START(Int)$END => String = _"	String	selected
s"val i: Int => $START(A op B)$END = _"	String	selected
s"val f: Int <<: $START(Unit <<: Unit)$END = _"	String	selected
s"val f: Int <<: ($CARET_MARKER Unit <<: Unit) = _"	String	text
s"val f: (Int <<: Unit) <<: Void"	String	correct
s"val f: $START(Int op Unit)$END op Unit = _"	String	selected
s"val f: ($CARET_MARKER Int op Unit) op Unit = _"	String	text
classOf[AccessorLikeMethodInspection.UnitReturnType]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.accessor.unit.return.type")	String	description
classOf[ParameterlessOverrideInspection.EmptyParenMethod]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.parameterless.override.empty.paren")	String	description
classOf[AccessorLikeMethodInspection.EmptyParentheses]	Class[_ <: LocalInspectionTool]	classOfInspection
s"val f: $START((Int, String))$END = _"	String	selected
InspectionBundle.message("method.signature.accessor.empty.parenthesis")	String	description
classOf[ParameterlessAccessInspection.JavaMutator]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.parameterless.access.java.mutator")	String	description
s"val f: ($CARET_MARKER(Int, Unit)) = _"	String	text
classOf[ParameterlessOverrideInspection.MutatorLikeMethod]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.parameterless.override.mutator.like")	String	description
s"val a +: $START(b +: c)$END = _ "	String	selected
s"val a +: ($CARET_MARKER b +: c) = _ "	String	text
s"Seq(1) map { $START(i)$END => i + 1 }"	String	r1
s"Seq(1) map { $START(i: Int)$END => i + 1 }"	String	r2
s"Seq(1) map ($START(i)$END => i + 1)"	String	r3
s"Seq(1) map { (${CARET_MARKER}i: Int) => i + 1 }"	String	text
s"Seq(1) map { i: Int => i + 1 }"	String	result
s"val a +: $START(b *: c)$END = _ "	String	selected
s"val a +: ($CARET_MARKER b *: c) = _ "	String	text
classOf[UnitMethodInspection.ExplicitAssignment]	Class[_ <: LocalInspectionTool]	classOfInspection
classOf[UnitMethodInspection.FunctionDefinition]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.unit.functional.definition")	String	description
InspectionBundle.message("method.signature.unit.explicit.assignment")	String	description
s"1 + ((${CARET_MARKER}1 + 1))"	String	text
classOf[UnitMethodInspection.ProcedureDefinition]	Class[_ <: LocalInspectionTool]	classOfInspection
classOf[ParameterlessAccessInspection.EmptyParenMethod]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.procedure.definition")	String	description
InspectionBundle.message("method.signature.parameterless.access.empty.paren")	String	description
s"class A; def apply(pairs: $CARET_MARKER(A)*): A = new A"	String	text
classOf[UnitMethodInspection.ProcedureDeclaration]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.procedure.declaration")	String	description
classOf[OverrideAbstractMemberInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.override.abstract.member")	String	description
s""" |object Test { | trait **[A, B] | val a: $START(123123)$END ** (123) = () |} |""".stripMargin	String	code
classOf[JavaAccessorEmptyParenCallInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.java.accessor.empty.paren")	String	description
s""" |object Test { | trait **[A, B] | val a: $CARET_MARKER(123123) ** (123) = () |} |""".stripMargin	String	text
classOf[ApparentResultTypeRefinementInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.result.type.refinement")	String	description
s""" |object Test { | trait **[A, B] | val a: 123123 ** (123) = () |} |""".stripMargin	String	result
classOf[EmptyParenOverrideInspection.JavaAccessorMethodOverriddenAsEmptyParenInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.empty.paren.override.java.accessor")	String	description
classOf[ParameterlessOverrideInspection.JavaMutator]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.parameterless.override.java.mutator")	String	description
classOf[EmptyParenOverrideInspection.ParameterlessMemberOverriddenAsEmptyParenInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
InspectionBundle.message("method.signature.empty.paren.override.parameterless")	String	description
classOf[MatchToPartialFunctionInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
classOf[UnnecessaryPartialFunctionInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
UnnecessaryPartialFunctionInspection.inspectionName	String	description
classOf[AutoTuplingInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
AutoTuplingInspection.message	String	description
classOf[VariableNullInitializerInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
VariableNullInitializerInspection.inspectionName	String	description
s""" |def foo(a: Any) = {} |foo$START(1, 2)$END """.stripMargin	String	text
classOf[ConvertExpressionToSAMInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s"val f: Int => String = {${START}case$END x => x.toString}"	String	text
InspectionBundle.message("convert.expression.to.sam")	String	description
s""" |object Moo { | var x: $typeName = ${START}null$END |} """.stripMargin	String	declaration
s"""val f: Int => String = { | ${START}case$END x => x.toString |}""".stripMargin	String	text
s""" |def foo(a: Any) = {} |foo$START(() => println("foo"), () => 2)$END """.stripMargin	String	text
s""" |object Moo { | var x: $typeName = _ |} """.stripMargin	String	result
s"""val f: Int => String = { | ${START}case$END x => | val value = x.toString | s"value of x is $$value" |}""".stripMargin	String	text
s""" |object Koo { | def foo(r: Runnable) = r.run() |} |Koo foo ${START}new Runnable $END{ | override def run(): Unit = ??? |} """.stripMargin	String	code
s"""val f: Int => String = { | x => | val value = x.toString | s"value of x is $$value" |}""".stripMargin	String	fixed
s""" |object Moo { | var a, b, c: String = ${START}null$END |} """.stripMargin	String	declaration
s""" |new Thread(${START}new Runnable $END{ |override def run() = println() |} """.stripMargin	String	code
s"""val f: Int => String = { | ${START}case$END x => { | val value = x.toString | s"value of x is $$value" | } |}""".stripMargin	String	text
wrapInObject(s"private var x: String = ${START}null$END")	String	code
classOf[ConvertibleToMethodValueInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s""" |new Thread(new Runnable { |override def run() = println() |}) """.stripMargin	String	text
s"""val f: Int => String = { | x => { | val value = x.toString | s"value of x is $$value" | } |}""".stripMargin	String	fixed
s"val f: PartialFunction[Int, String] = {case x => x.toString}"	String	text
s""" |val y: Runnable = ${START}new Runnable $END{ | override def run(): Unit = ??? |} """.stripMargin	String	code
s"""type Baz = PartialFunction[Int, String] |val f: Baz = {case x => x.toString}""".stripMargin	String	text
s"def f: Int => String = {${START}case$END x: Int => x.toString}"	String	text
s"""object A { | def f(x: Int, y: Int) { | } | val f1 = ${START}A.f(_, _)$END |} |"""	String	selected
s"def f: Any => String = {case x: Int => x.toString}"	String	text
s""" |trait A { | def foo(): String |} |def bar(a: A) = println() |bar(${START}new A $END{ | override def foo(): String = "something" |}) """.stripMargin	String	code
s"""object A { | def f(x: Int, y: Int) { | } | val f1: (Int, Int) => Unit = ${START}A.f(_, _)$END |}"""	String	selected
s"def f: Int => String = {${START}case$END x: Any => x.toString}"	String	text
classOf[ForwardReferenceInspection]	Class[_ <: LocalInspectionTool]	classOfInspection
s""" |sealed trait A { | def foo(): String |} |def bar(a: A) = println() |bar(new A { | override def foo(): String = "something" |}) """.stripMargin	String	code
s"def f[T]: Option[T] => String = {${START}case$END x: Option[_] => x.toString}"	String	text
s"""object A { | def f(x: Int, y: Int) { | } | val f1: (Int, Int) => Unit = ${START}A.f _$END |}"""	String	selected
s"""var f: Int => String = {${START}case$END _ => "foo"}"""	String	text
s"""object A { | def f(x: Int, y: Int = 0) { | } | val f1 = ${START}A.f(_, _)$END |}"""	String	selected
s""" |final class A { | def foo(): String |} |def bar(a: A) = println() |bar(new A { | override def foo(): String = "something" |}) """.stripMargin	String	code
s"""def f: Int => String = {case 1 => "one"}"""	String	text
s"""def f: Int => String = {case x if x % 2 == 0 => "one"}"""	String	text
s"def f: Option[Int] => String = {case Some(x) => x.toString}"	String	text
s"""class A(s: String) { | def foo(x: String) = x |} | |object Test { | def test(a: A) { | val list = "1" :: "2" :: Nil | list.map(${START}a.foo(_)$END) | } |} """.stripMargin	String	text
s""" |new Thread(${START}new Runnable $END{ | def run() { | def foo(i: Int) = i | | println(foo(10)) | } |}) """.stripMargin	String	code
s"""class A(s: String) { | def foo(x: String) = x |} | |object Test { | def test(a: A) { | val list = "1" :: "2" :: Nil | list.map(a.foo) | } |} """.stripMargin	String	result
s""" |new Thread(new Runnable { | def run() { | def foo(i: Int) = i | | println(foo(10)) | } |}) """.stripMargin	String	text
s"""def foo(bar: Int => String) = bar(42) |foo{${START}case$END x => x.toString}""".stripMargin	String	text
s""" |new Thread(() => { | def foo(i: Int) = i | | println(foo(10)) |}) """.stripMargin	String	res
s"""class A(s: String) { | def foo(x: String) = x |} | |object Test { | val newA = new A("") | | val list = "1" :: "2" :: Nil | | list.map(${START}newA.foo(_)$END) |} """.stripMargin	String	text
s"""def foo(bar: Int => String) = bar(42) |foo{${START}case$END x: Any => x.toString}""".stripMargin	String	text
s"""class A(s: String) { | def foo(x: String) = x |} | |object Test { | val newA = new A("") | | val list = "1" :: "2" :: Nil | | list.map(newA.foo) |} """.stripMargin	String	result
s""" |new Thread(${START}new Runnable $END{ | override def run(): Unit = { | val i = 2 + 3 | val z = 2 | println(i - z) | } |}) """.stripMargin	String	code
s""" |new Thread(new Runnable { | override def run(): Unit = { | val i = 2 + 3 | val z = 2 | println(i - z) | } |}) """.stripMargin	String	text
s"""class A(s: String) { | def foo(x: String) = x |} | |object AObj extends A("a") {| | val list = "1" :: "2" :: Nil | | list.map(${START}AObj.foo(_)$END) |} """.stripMargin	String	text
s"""trait SAM { def test(s: => String, x: Int = 0): Unit } | |val sm: SAM = ${START}new SAM $END{ | override def test(s: => String, x: Int = 1): Unit = println(s) |} """.stripMargin	String	code
s"""def foo(input: Int, bar: Int => String, prefix: String) = prefix + bar(input) |foo(42, {${START}case$END x => x.toString}, "value: ")""".stripMargin	String	text
s"""class A(s: String) { | def foo(x: String) = x |} | |object AObj extends A("a") {| | val list = "1" :: "2" :: Nil | | list.map(AObj.foo) |} """.stripMargin	String	result
s"""def foo(input: Int, bar: Int => String, prefix: String) = prefix + bar(input) |foo(42, {${START}case$END x: Any => x.toString}, "value: ")""".stripMargin	String	text
s""" |object Foo { | new MyObservable[String].addListener(${START}new MyChangeListener[String] $END{ | override def changed(observable: MyObservable[_ <: String], oldValue: String, newValue: String): Unit = ??? | }) |} | |trait MyChangeListener[T] { | def changed(observable: MyObservable[_ <: T], oldValue: T, newValue: T) |} | |class MyObservable[T] { | def addListener (listener: MyChangeListener[_ >: T]) = ??? |} """.stripMargin	String	code
s"""val list = "a" :: "b" :: Nil |list.filter($START("a" + "b").contains _$END) """.stripMargin	String	text
findRanges(text)	Seq[TextRange]	ranges
s"""def foo(bar: PartialFunction[Int, String]) = bar(42) |foo{case x => x.toString}""".stripMargin	String	text
s""" |object Foo { | new MyObservable[String].addListener(new MyChangeListener[String] { | override def changed(observable: MyObservable[_ <: String], oldValue: String, newValue: String): Unit = ??? | }) |} | |trait MyChangeListener[T] { | def changed(observable: MyObservable[_ <: T], oldValue: T, newValue: T) |} | |class MyObservable[T] { | def addListener (listener: MyChangeListener[_ >: T]) = ??? |} """.stripMargin	String	text
s"""class A { | def foo(s: String) = s | Seq("aa").map(${START}foo _$END) |} """.stripMargin	String	text
s"""type Baz = PartialFunction[Int, String] |def foo(bar: Baz) = bar(42) |foo{case x => x.toString}""".stripMargin	String	text
s"""class A { | def foo(s: String) = s | Seq("aa").map(foo) |} """.stripMargin	String	result
new ScalaTestTestFramework	ScalaTestTestFramework	scalaTestFramework
s"""object A { | def sum(s: String, s2: String) = s + s2 |} |object B { | import A.sum | Seq("aa", "bb").fold("")(${START}sum(_, _)$END) |} """.stripMargin	String	text
s""" |new Thread(${START}new Runnable $END{ | | println("Creating runnable") | | def run() { | println(foo(10)) | } |}) """.stripMargin	String	code
selectedRange(getEditor.getSelectionModel)	TextRange	expectedRange
s"""object A { | def sum(s: String, s2: String) = s + s2 |} |object B { | import A.sum | Seq("aa", "bb").fold("")(sum) |} """.stripMargin	String	result
new LocalInspectionToolWrapper(inspectionEP)	LocalInspectionToolWrapper	inspectionWrapper
expectedHighlightRanges.filterNot(actualHighlightRanges.contains)	Seq[TextRange]	expectedRangesNotFound
s"""trait Semigroup[F] { | def zero: F = ??? | | def append(f1: F, f2: => F): F = ??? |} | |object Test { | def foo(i: Iterator[String], s: Semigroup[String]) = i.fold(s.zero)(s.append(_, _)) |}""".stripMargin	String	text
s"""trait Semigroup[F] { | def zero: F = ??? | | def append(f1: F, f2: => F): F = ??? |} | |object Test { | def foo(i: Iterator[String], s: Semigroup[String]) = i.fold(s.zero)(s.append _) |}""".stripMargin	String	text
testsTestName + ".scala"	String	testsTestFileName
actualHighlightRanges .groupBy(identity) .mapValues(_.length) .toSeq .collect { case (highlight, count) if count > 1 => highlight }	IndexedSeq[TextRange]	duplicatedHighlights
acquireAllScalaInspectionEPs().filter { inspectionEP => val inspectionWrapper = new LocalInspectionToolWrapper(inspectionEP) val description = inspectionWrapper.loadDescription() description == null || description.length <= 5 }.sortBy(_.shortName) .map(insp => s"${insp.getShortName} (${insp.getDisplayName})")	IndexedSeq[String]	inspectionsWithoutProperDescription
createTestText(text)	String	fileText
acquireAllInspectionEPs().map(_.shortName).groupBy(identity).mapValues(_.length)	Map[Nothing, Int]	allShortNames
acquireAllScalaInspectionEPs().map(_.shortName)	IndexedSeq[Nothing]	scalaShortNames
findQuickFix(text, hint)	Option[IntentionAction]	maybeAction
createTestText(expected)	String	expectedFileText
_	HighlightDisplayLevel	oldLevel
inspectionToolState	ScopeToolState	toolState
ProjectInspectionProfileManager.getInstance(getFixture.getProject).getCurrentProfile	InspectionProfileImpl	profile
TestConfigurationUtil.uTestConfigurationProducer	AbstractTestConfigurationProducer[_]	configurationProducer
s"$StaticStringTestName.scala"	String	StaticStringTestFileName
List("[root]", uTestTestName, "tests", "outer2", "inner2_1")	List[Nothing]	inner2_1Path
"3.0.1"	String	specsVersion
List("[root]", uTestTestName, "tests", "outer1")	List[Nothing]	outer1_Path
List("[root]", uTestTestName, "sameName", "sameName", "sameName")	List[Nothing]	sameNamePath
List("[root]", uTestTestName, "otherTests", "outer1", "inner1_1")	List[Nothing]	inner1_1Path
List("[root]", uTestTestName, "failedTest", "failed")	List[Nothing]	failedPath
true	Boolean	useDynamicClassPath
createTestFromLocation(lineNumber, position, StaticStringTestFileName)	RunnerAndConfigurationSettings	configuration
"4.0.0"	String	specsVersion
TestConfigurationUtil.specs2ConfigurationProducer	AbstractTestConfigurationProducer[_]	configurationProducer
List( List("[root]", "FeatureSpecTest", "Feature 1 Scenario: Scenario A"), List("[root]", "FeatureSpecTest", "Feature 1 Scenario: Scenario B"), List("[root]", "FeatureSpecTest", "Feature 2 Scenario: Scenario C") )	List[List[Nothing]]	featureSpecTestPaths
List( List("[root]", "FlatSpecTest", "A FlatSpecTest should be able to run single test"), List("[root]", "FlatSpecTest", "A FlatSpecTest should not run other tests") )	List[List[Nothing]]	flatSpecTestPaths
List("[root]", "IgnoredTestSpec", "An IgnoredTestSpec should be ignored and have proper suffix !!! IGNORED !!!")	List[Nothing]	ignoredTestPath
List( List("[root]", "FreeSpecTest", "A FreeSpecTest should be able to run single tests"), List("[root]", "FreeSpecTest", "A FreeSpecTest should not run tests that are not selected") )	List[List[Nothing]]	freeSpecTestPaths
List("[root]", "IgnoredTestSpec", "An IgnoredTestSpec should run tests")	List[Nothing]	succeededTestPath
List( List("[root]", "FunSpecTest", "FunSpecTest should launch single test"), List("[root]", "FunSpecTest", "FunSpecTest should not launch other tests") )	List[List[Nothing]]	funSpecTestPaths
List("[root]", "Feature 1 Scenario: Scenario A")	List[Nothing]	featureSpecTestPath
List("[root]", "FunSpecTest FunSpecTest FunSpecTest")	List[Nothing]	testPath
List("[root]", "Feature 3 Scenario: Tagged")	List[Nothing]	featureSpecTaggedTestPath
List("[root]", "A FreeSpecTest should be able to run single test")	List[Nothing]	freeSpecPathTestPath
List( List("[root]", "WordSpecTest", "WordSpecTest should Run single test"), List("[root]", "WordSpecTest", "WordSpecTest should ignore other tests") )	List[List[Nothing]]	wordSpecTestPaths
List("[root]", "should run single test")	List[Nothing]	funSuiteTestPath
List("[root]", "A FreeSpecTest should be able to run single tests")	List[Nothing]	freeSpecTestPath
List("[root]", "tagged")	List[Nothing]	funSuiteTaggedTestPath
List("[root]", "FunSpecTest should launch single test")	List[Nothing]	funSpecTestPath
List("[root]", "taggedScope is tagged")	List[Nothing]	funSpecTaggedTestPath
List("[root]", "Single tests should run")	List[Nothing]	propSpecTestPath
List("[root]", "tagged")	List[Nothing]	propSpecTestTaggedPath
List("[root]", "Comma , test should contain , comma")	List[Nothing]	commaTestPath
List("[root]", "! test should contain !")	List[Nothing]	exclamationTestPath
List("[root]", "tick ' test should contain '")	List[Nothing]	tickTestPath
createLocation(lineNumber, offset, fileName)	PsiLocation[PsiElement]	location
List("[root]", "tilde ~ test should contain ~")	List[Nothing]	tildeTestPath
List("[root]", "WordSpecTest should Run single test")	List[Nothing]	wordSpecTestPath
List("[root]", "backtick ` test should contain `")	List[Nothing]	backtickTestPath
null	Selection	selection
List("[root]", "tagged should be tagged")	List[Nothing]	wordSpecTestTaggedPath
List("[root]", "test should work")	List[Nothing]	classTestTreePath1
Set(testName1, testName2, testName3)	Set[Nothing]	testNamesAll1
Set(testName4, testName5)	Set[Nothing]	testNamesAll2
ProjectScope.getProjectScope(project)	GlobalSearchScope	projectScope
new ScalaTestFailureLocationFilter(projectScope)	ScalaTestFailureLocationFilter	filter
null	Filter.Result	filterRes
Seq("FunSpecTest should launch single test", "FunSpecTest should not launch other tests")	Seq[Nothing]	testNames
s"$flatSpecScopeTestClassName.scala"	String	fileName
Seq("A ComplexFreeSpec Outer scope 2 Inner scope 2 Another innermost scope", "A ComplexFreeSpec Outer scope 2 Inner test")	Seq[Nothing]	testNames
Seq("WordSpecTest should Run single test", "WordSpecTest should ignore other tests")	Seq[Nothing]	testNames
List("[root]", funSpecClassName, "FunSpecTest", "should launch single test")	List[Nothing]	path1
List("[root]", funSpecClassName, "FunSpecTest", "should not launch other tests")	List[Nothing]	path2
List("[root]", wordSpecClassName, "WordSpecTest", "Run single test")	List[Nothing]	path1
List("[root]", complexFreeSpecClassName, "A ComplexFreeSpec", "Outer scope 2", "Inner scope 2", "Another innermost scope")	List[Nothing]	path1
List("[root]", wordSpecClassName, "WordSpecTest", "ignore other tests")	List[Nothing]	path2
List("[root]", complexFreeSpecClassName, "A ComplexFreeSpec", "Outer scope 2", "Inner test")	List[Nothing]	path2
Seq("Feature: Feature 1 Scenario: Scenario A", "Feature: Feature 1 Scenario: Scenario B")	Seq[Nothing]	testNames
funSpecClassName + ".scala"	String	funSpecFileName
Seq( Seq("[root]", className, "should test name without behaviour with it"), Seq("[root]", className, "should test name without behaviour with it tagged"), Seq("[root]", className, "Test Prefix", "should test name with string prefix"), Seq("[root]", className, "Test Prefix", "should test name with it and string prefix above"), Seq("[root]", className, "Behaviour Descriptor", "should test name with it behaviour") )	Seq[Seq[Nothing]]	testPaths
List("[root]", featureSpecClassName, "Feature: Feature 1", "Scenario: Scenario A")	List[Nothing]	aPath
List("[root]", featureSpecClassName, "Feature: Feature 1", "Scenario: Scenario B")	List[Nothing]	bPath
testPaths.map(_.drop(2).mkString(" "))	IndexedSeq[String]	testNames
testPaths.filterNot(path => checkResultTreeHasExactNamedPath(root, path: _*))	Seq[Seq[Nothing]]	pathsNotInTree
wordSpecClassName + ".scala"	String	wordSpecFileName
List("[root]", flatSpecClassName, "A FlatSpecTest", "should run tagged tests")	List[Nothing]	flatSpecTaggedTestPath
List("[root]", funSpecClassName, "FunSpecTest", "should launch single test")	List[Nothing]	funSpecTestPath
List("[root]", funSpecClassName, "taggedScope", "is tagged")	List[Nothing]	funSpecTaggedTestPath
List("[root]", funSuiteClassName, "should run single test")	List[Nothing]	funSuiteTestPath
List("[root]", flatSpecClassName, "A FlatSpecTest", "should be able to run single test")	List[Nothing]	flatSpecTestPath
List("[root]", funSuiteClassName, "tagged")	List[Nothing]	funSuiteTaggedTestPath
List("[root]", freeSpecClassName, "A FreeSpecTest", "should be able to run single tests")	List[Nothing]	freeSpecTestPath
List("[root]", freeSpecClassName, "A FreeSpecTest", "can be tagged")	List[Nothing]	freeSpecTaggedTestPath
List("[root]", propSpecClassName, "Single tests should run")	List[Nothing]	propSpecTestPath
List("[root]", propSpecClassName, "tagged")	List[Nothing]	propSpecTestTaggedPath
List("[root]", wordSpecClassName, "WordSpecTest", "Run single test")	List[Nothing]	wordSpecTestPath
List("[root]", wordSpecClassName, "tagged", "be tagged")	List[Nothing]	wordSpecTestTaggedPath
List("[root]", featureSpecClassName, "Feature: Feature 1", "Scenario: Scenario A")	List[Nothing]	featureSpecTestPath
List("[root]", freeSpecPathClassName, "A FreeSpecTest", "should be able to run single test")	List[Nothing]	freeSpecPathTestPath
List("[root]", featureSpecClassName, "Feature: Feature 3", "Scenario: Tagged")	List[Nothing]	featureSpecTaggedTestPath
preprocessSingleFlatSpecExpectedPath(expectedTestPath)	Seq[String]	expectedTestPathFinal
TestConfigurationUtil.scalaTestConfigurationProducer	AbstractTestConfigurationProducer[_]	configurationProducer
status match { case NormalStatusId => tests case IgnoredStatusId => tests.map(_ + TestNodeProvider.ignoredSuffix) case PendingStatusId => tests.map(_ + TestNodeProvider.pendingSuffix) case unknownStatus => fail(s"unknown status code: $unknownStatus").asInstanceOf[Nothing] }	Seq[String]	testsModified
List("[root]", "FunSpecTest", "FunSpecTest", "FunSpecTest", "FunSpecTest")	List[Nothing]	testPath
List( List("[root]", featureSpecClassName, "Feature: Feature 1", "Scenario: Scenario A"), List("[root]", featureSpecClassName, "Feature: Feature 1", "Scenario: Scenario B"), List("[root]", featureSpecClassName, "Feature: Feature 2", "Scenario: Scenario C") )	List[List[Nothing]]	featureSpecTestPaths
List( List("[root]", flatSpecClassName, "A FlatSpecTest", "should be able to run single test"), List("[root]", flatSpecClassName, "A FlatSpecTest", "should not run other tests") )	List[List[Nothing]]	flatSpecTestPaths
List( List("[root]", freeSpecClassName, "A FreeSpecTest", "should be able to run single tests"), List("[root]", freeSpecClassName, "A FreeSpecTest", "should not run tests that are not selected") )	List[List[Nothing]]	freeSpecTestPaths
false	Boolean	useDynamicClassPath
List( List("[root]", funSpecClassName, "FunSpecTest", "should launch single test"), List("[root]", funSpecClassName, "FunSpecTest", "should not launch other tests"), List("[root]", funSpecClassName, "OtherScope", "is here") )	List[List[Nothing]]	funSpecTestPaths
root.getValue.asInstanceOf[TreeElement].getPresentation	ItemPresentation	presentation
List( List("[root]", funSuiteClassName, "should run single test"), List("[root]", funSuiteClassName, "should not run other tests") )	List[List[Nothing]]	funSuiteTestPaths
configAndSettings.getConfiguration	RunConfiguration	config
config.asInstanceOf[AbstractTestRunConfiguration]	AbstractTestRunConfiguration	testConfig
List( List("[root]", propSpecClassName, "Single tests should run"), List("[root]", propSpecClassName, "other test should not run") )	List[List[Nothing]]	propSpecTestPaths
myFixture.addFileToProject(javaClassName + JavaFileType.DOT_DEFAULT_EXTENSION, javaFileText)	PsiFile	myFile
List( List("[root]", wordSpecClassName, "WordSpecTest", "Run single test"), List("[root]", wordSpecClassName, "WordSpecTest", "ignore other tests"), List("[root]", "WordSpecTest", "outer", "inner") )	List[List[Nothing]]	wordSpecTestPaths
PsiManager.getInstance(project)	PsiManager	manager
new Foo	Foo	foo
foo.currentTime()	Long	firstRes
Foo.currentTime()	Long	firstRes
foo.getModTracker	PsiModificationTrackerImpl	tracker
tracker.getModificationCount	Long	oldModCount
tracker.getModificationCount	Long	newModCount
parseTestName(testData.testName)	Seq[String]	configTests
foo.currentTime()	Long	secondRes
Foo.currentTime	Long	firstRes
Foo.currentTime("1")	Long	firstRes
Foo.currentTime("2")	Long	secondRes
Foo.currentTime(0, 0)	Long	firstRes
new ProjectUserDataHolder[Foo] { override def dataHolder(e: Foo): UserDataHolder = getProject override def project(e: Foo): Project = getProject }	ProjectUserDataHolder[Foo]	fooHolder
Foo.currentTime(0, 0)	Long	secondRes
new Elem	Elem	elem
elem.recursiveFunction	Either[Long, String]	firstRes
(node: AbstractTestProxy) => node.getName == head && (node.isLeaf || allowTail)	AbstractTestProxy => Boolean	cond
elem.recursiveFunction	Either[Long, String]	secondRes
s"""sealed trait Foo |sealed class Bar """.stripMargin	String	scalaFileText
(node: AbstractTestProxy) => node.getName == head && !node.isLeaf	AbstractTestProxy => Boolean	cond
s"""public class Baz extends Bar implements Foo { | | public static Foo createFoo() { | return new Foo() {}; | } |} """.stripMargin	String	javaFileText
Map( "scala/Responder.scala" -> Set[TextRange]((1987, 1988), (2133, 2134), (2278, 2279)) )	Map[Nothing, Nothing]	filesWithProblems
createTestFromLocation(lineNumber, offset, fileName)	RunnerAndConfigurationSettings	runConfig
recursiveFunction(None, depth)	String	res
createTestFromLocation(lineNumber, offset, fileName)	RunnerAndConfigurationSettings	config1
createTestFromLocation(lineNumber, offset, fileName)	RunnerAndConfigurationSettings	config2
getExactNamePathFromResultTree(testRoot, testNames, allowTail = true)	Option[List[AbstractTestProxy]]	testPathOpt
testPathOpt.get.last	AbstractTestProxy	test
test.getLocation(project, GlobalSearchScope.projectScope(project))	Location[_ <: PsiElement]	location
location.getPsiElement	PsiElement	psiElement
psiElement.getContainingFile	PsiFile	psiFile
psiElement.getTextRange	TextRange	textRange
PsiDocumentManager.getInstance(project).getDocument(psiFile)	Document	document
document.getLineNumber(textRange.getStartOffset)	Int	startLineNumber
SourceFilterScope(scalaFileTypes :+ JavaFileType.INSTANCE)(getProject)	SourceFilterScope	scope
buildFileStructure(testClassName + ".scala")	TreeElementWrapper	structureViewRoot
null	TreeElementWrapper	wrapper
PsiManager.getInstance(getProject).findFile(getVirtualFile(ioFile))	PsiFile	file
new ScalaStructureViewModel(file.asInstanceOf[ScalaFile]) { override def isEnabled(provider: NodeProvider[_ <: TreeElement]): Boolean = provider.isInstanceOf[TestNodeProvider] }	ScalaStructureViewModel { def isEnabled(provider: NodeProvider[_ <: TreeElement]): Boolean }	treeViewModel
PsiManager.getInstance(project)	PsiManager	myManager
null	PsiElement	psiElement
myManager.findViewProvider(file).getPsi(ScalaLanguage.INSTANCE)	PsiFile	psiFile
ProgressReporter.newInstance(getClass.getSimpleName, filesWithProblems = Map.empty, reportStatus = false)	ProgressReporter	reporter
null	RunnerAndConfigurationSettings	res
null	Module	module
new TestResultListener(runConfig.getName)	TestResultListener	testResultListener
None	Option[AbstractTestProxy]	testTreeRoot
PsiManager.getInstance(getProject).asInstanceOf[PsiManagerEx].getFileManager	FileManager	fileManager
files.size	Int	size
TextRange.create(highlightInfo.getStartOffset, highlightInfo.getEndOffset)	TextRange	range
new Regex(".*/projects/.*?/(.*)")	Regex	RemotePath
new Regex(".*/localProjects/.*?/(.*)")	Regex	LocalPath
new Regex("temp:///.*?/(.*)")	Regex	ScalacPath
ProgressReporter.newInstance( getClass.getSimpleName, filesWithProblems, reportStatus = false )	ProgressReporter	reporter
CustomSDKLoader.sourceRoot	VirtualFile	sourceRoot
file.getViewProvider.getPsi(ScalaLanguage.INSTANCE) match { case f: ScalaFile => f case _ => return }	ScalaFile	scalaFile
ProgramRunner.PROGRAM_RUNNER_EP.getExtensions.find { _.getClass == classOf[DefaultJavaProgramRunner] }.get	ProgramRunner[RunnerSettings]	runner
relPath.getOrElse(relativePathOf(scalaFile))	String	fileName
runConfiguration.getConfiguration	RunConfiguration	configuration
new ExecutionEnvironmentBuilder(configuration.getProject, executor)	ExecutionEnvironmentBuilder	executionEnvironmentBuilder
1	Int	v1
filesToHighlight .filter(f => f.isDirectory || isScalaFile(f) || isFlagsFile(f)) .groupBy(f => FilenameUtils.removeExtension(f.getPath))	Map[Nothing, Array[Any]]	allFiles
content(file)	String	text
1	Int	v2
PsiFileTestUtil.addFileToProject(path, text, getProject)	PsiFile	psiFile
{ {} var v1: Int = 1 val v2: Int = 1 type A = Int def m: Int = 1 class C trait T object O }	Int	v
new AnnotatorHolderMock(scalaFile){ override def createErrorAnnotation(range: TextRange, message: String): Annotation = { reporter.reportError(fileName, range, message) super.createErrorAnnotation(range, message) } override def createErrorAnnotation(elt: PsiElement, message: String): Annotation = { createErrorAnnotation(elt.getTextRange, message) } }	AnnotatorHolderMock { def createErrorAnnotation(elt: PsiElement, message: String): Annotation def createErrorAnnotation(range: TextRange, message: String): Annotation }	mock
1	Int	r1
1	Int	l1
1	Int	l2
1	Int	r2
ScalaAnnotator.forProject(scalaFile)	ScalaAnnotator	annotator
new Random(0)	Random	random
Key.create("original.dir.name")	Key[String]	originalDirNameKey
myFixture.completeBasic()	Array[LookupElement]	result
s""" |@main |class Foo """.stripMargin	String	fileText
myFixture.findClass("Test").asInstanceOf[ScClass]	ScClass	clazz
myFixture.findClass("Foo").asInstanceOf[ScClass]	ScClass	foo
myFixture.findClass("Bar$").asInstanceOf[ScObject]	ScObject	bar
s"/addFoo_${version.major}_$PARADISE_VERSION.jar"	String	testJarPath
sourceFiles.map(addFileToProject(_, relativeTo = root))	IndexedSeq[PsiFile]	addedFiles
myFixture.findClass("foo").asInstanceOf[ScClass]	ScClass	clazz
new CompilationCache(getModule, Seq(version.minor, META_MINOR_VERSION))	CompilationCache	cache
s""" |q"class $testClassName { def foo = 42 }" """.stripMargin	String	annotText
s""" |@$annotName |class $testClassName """.stripMargin	String	testFileText
s""" |q$tq |class $testClassName { def foo = 42 } |object $testClassName { def bar = 42 } |$tq """.stripMargin	String	annotText
normalize(testFileText)	String	trimmed
getGutter	GutterIconRenderer	expandGutter
s""" |@$annotName |class $testClassName """.stripMargin	String	fileText
normalize(myFixture.getEditor.getDocument.getText)	String	expandedText
getGutter	GutterIconRenderer	collapseGutter
normalize(myFixture.getEditor.getDocument.getText)	String	collapsedText
s""" |@$annotName |class $testClassName | |object $testClassName """.stripMargin	String	fileText
cache.withModuleOutputCache(Iterable[String]()) { enableParadisePlugin() compiler.make() .asScala .filter(_.getCategory == CompilerMessageCategory.ERROR) .map(_.getMessage) }	Iterable[String]	errors
DependencyManager.resolve("org.scalameta" % s"paradise_${version.minor}" % PARADISE_VERSION)	Seq[DependencyManagerBase.ResolvedDependency]	pluginArtifact
ScalaCompilerConfiguration.instanceIn(getProject).defaultProfile	ScalaCompilerSettingsProfile	profile
profile.getSettings	ScalaCompilerSettings	settings
if (unrelated.size > 1) s"\nOther errors found:\n${unrelated.mkString("\n")}" else ""	String	suffix
parseTextToFile(text)	ScalaFile	file
file.findElementAt(startPos)	PsiElement	element
convert(text)	Tree	converted
psiFromText(text)	ScalaPsiElement	psi
new IDEAContext(fixture.getProject) { override def dumbMode: Boolean = true override def getCurrentProject: Project = myFixture.getProject }	IDEAContext { def dumbMode: Boolean def getCurrentProject: Project }	context
if (!isTopLevel) s""" |object Dummy { |${if (!str.contains(startToken)) startToken else ""} |$str |} """.stripMargin else str	String	text
Seq( scalaVersion := "2.11.8", organization := "silly", version := "42" )	Seq[Def.Setting[String]]	sharedSettings
foo.fakeCompanionModule .getOrElse(fail("No companion generated by annotation")) .membersWithSynthetic .find(_.getName == "foo") .map(_.asInstanceOf[ScFunction].returnType) .getOrElse(fail("Method not generated by annotation")) match { case Right(res) => res case Failure(cause) => fail(s"Failed to infer generated method type: $cause") }	ScType	fooType
bar.membersWithSynthetic .find(_.getName == "fooA").get .asInstanceOf[ScFunction].returnType match { case Right(res) => res case Failure(cause) => fail(s"Failed to infer generated method type: $cause") }	ScType	fooBarAType
s""" |class A |trait B | |@$annotName |class $testClassName extends A with B { def foo: Int = 42 } """.stripMargin	String	code
ScalaCodeInsightSettings.getInstance	ScalaCodeInsightSettings	settings
if (member.isLocal) showLocalVariableType else showPropertyType	Boolean	flag
Set('\n', '(', '[', '{', ';', ',')	Set[Char]	NonIdentifierChars
getInstance	ScalaCodeInsightSettings	settings
new ScalaTypeHintsSettingsPanel	ScalaTypeHintsSettingsPanel	settingsPanel
_ == _	hints.Predicate	equal
delegate => (name, tpe) => delegate(fromLowerCase(name), tpe)	hints.Combinator	nameFirstLetterCase
delegate => (name, tpe) => delegate(name, fromLowerCase(tpe))	hints.Combinator	typeFirstLetterCase
delegate => (name, tpe) => (name, tpe) match { case (Singular(noun), SequenceTypeArgument(argument)) if delegate(noun, argument) => true case _ => delegate(name, tpe) }	hints.Combinator	plural
delegate => (name, tpe) => name match { case PrepositionPrefix(namePrefix) if delegate(namePrefix, tpe) => true case _ => delegate(name, tpe) }	hints.Combinator	prepositionSuffix
delegate => (name, tpe) => name match { case GetSuffix(nameSuffix) if delegate(nameSuffix, tpe) => true case _ => delegate(name, tpe) }	hints.Combinator	getPrefix
function.getModifierList.getTextRange match { case null => function.getTextOffset case range => range.getStartOffset }	Int	startOffset
delegate => (name, tpe) => name match { case BooleanSuffix(_) if tpe == "Boolean" => true case _ => delegate(name, tpe) }	hints.Combinator	booleanPrefix
template.getModifierList.getTextRange match { case null => definition.getTextOffset case range => range.getStartOffset }	Int	startOffset
delegate => (name, tpe) => (name, tpe) match { case (MaybeSuffix(nameSuffix), OptionArgument(typeArgument)) if delegate(nameSuffix, typeArgument) => true case _ => delegate(name, tpe) }	hints.Combinator	optionPrefix
delegate => (name, tpe) => (name, tpe) match { case ("i" | "j" | "k" | "n", "Int" | "Integer") | ("b" | "bool" | "flag", "Boolean") | ("o" | "obj", "Object") | ("c" | "char", "Char" | "Character") | ("s" | "str", "String") => true case _ => delegate(name, tpe) }	hints.Combinator	codingConvention
delegate => (name, tpe) => (name, tpe) match { case ("width" | "height" | "length" | "count" | "offset" | "index" | "start" | "begin" | "end", "Int" | "Integer") | ("name" | "message" | "text" | "description" | "prefix" | "suffix", "String") => true case _ => delegate(name, tpe) }	hints.Combinator	knownThing
delegate => (name, tpe) => name match { case NumberPrefix(namePrefix) if delegate(namePrefix, tpe) => true case _ => delegate(name, tpe) }	hints.Combinator	numberSuffix
Set("is", "has", "have", "maybe", "optionOf")	Set[Nothing]	TypeModifyingPrefixes
delegate => (name, tpe) => delegate(name, tpe) || (name match { case NameTailingWord(prefix, word) if !TypeModifyingPrefixes(prefix) => delegate(word, tpe) case _ => false })	hints.Combinator	nameTailing
Set("In", "Of", "From", "At", "On", "For", "To", "With", "Before", "After", "Inside")	Set[Nothing]	PrepositionSuffixes
delegate => (name, tpe) => delegate(name, tpe) || (tpe match { case TypeTailingWord(word) if !PrepositionSuffixes(word) => delegate(name, word) case _ => false })	hints.Combinator	typeTailing
Seq( booleanPrefix, optionPrefix, numberSuffix, prepositionSuffix, typeTailing, getPrefix, nameTailing, plural, nameFirstLetterCase, codingConvention, knownThing, typeFirstLetterCase, ).foldRight(equal)(_(_))	hints.Predicate	Predicate
function.returnTypeElement .fold(function.paramClauses.getTextRange.getEndOffset) { _.getTextRange.getEndOffset }	Int	endOffset
definition.getTextRange.getStartOffset	Int	startOffset
Seq.empty[Seq[AlignedHintTemplate]]	Seq[Seq[ScalaExprChainTypeHintsPass.AlignedHintTemplate]]	collectedHintTemplates
_	HighlightInfoHolder	myHolder
_	ScalaRefCountHolder	myRefCountHolder
_	AnnotationHolderImpl	myAnnotationHolder
HighlightingLevelManager.getInstance(project)	HighlightingLevelManager	manager
true	Boolean	success
ScalaRefCountHolder.findDirtyScope(file).flatten	Option[TextRange]	dirtyScope
file.findElementAt(offset) match { case _: PsiWhiteSpace if offset > 0 => file.findElementAt(offset - 1) case element => element }	PsiElement	elementAtOffset
chooseTarget(file, editor, project)	ScalaGenerateDelegateHandler.this.ClassMember	target
chooseMethods(target, file, editor, project)	Array[ScMethodMember]	candidates
file.findElementAt(editor.getCaretModel.getOffset)	PsiElement	elementAtOffset
inlayModel.addAfterLineEndElement( hint.expr.getTextRange.getEndOffset, false, new TextPartsHintRenderer(hint.textParts, typeHintsMenu) { override protected def getMargin(editor: Editor): Insets = new Insets(0, charWidth, 0, 0) } )	Inlay[TextPartsHintRenderer { def getMargin(editor: Editor): Any }]	inlay
Key.create[Boolean]("SCALA_EXPR_CHAIN_KEY")	Key[Boolean]	ScalaExprChainKey
Key.create[Disposable]("SCALA_EXPR_CHAIN_DISPOSABLE_KEY")	Key[Disposable]	ScalaExprChainDisposableKey
PsiDocumentManager.getInstance(editor.getProject)	PsiDocumentManager	manager
Some("TypeHintsMenu")	Some[Nothing]	typeHintsMenu
expr :: acc	List[ScExpression]	newAcc
minMargin * charWidthInPixel	Int	minMarginInPixel
maxMargin * charWidthInPixel	Int	maxMarginInPixel
if (params.length > 1) params(1).calculateResult(context).toString else null	Null	secondParamName
hints.groupBy(hint => lineOf(hint.expr)).mapValues(_.head)	Map[Int, ScalaExprChainTypeHintsPass.AlignedHintTemplate]	lineToHintMapping
lineToHintMapping.contains _	Int => Boolean	lineHasHint
createMethodFromSignature(signature, body = "???")(aClass.getManager).asInstanceOf[ScFunctionDefinition]	ScFunctionDefinition	prototype
0 max (lineOf(hints.head.expr) - 1)	Int	firstLine
(element match { case ResolveMethodCall(method) if GetSet(method.name) && !applyUpdateParameterNames.isEnabled => Seq.empty case call: ScMethodCall => call.matchedParameters.reverse case invocation: ScConstructorInvocation => invocation.matchedParameters case _ => Seq.empty }).filter { case (argument, _) => element.isAncestorOf(argument) }	Seq[(ScExpression, Parameter)]	matchedParameters
methodBody(target, prototype)	ScExpression	body
new ScalaGenerationInfo(member)	ScalaGenerationInfo	genInfo
document.getLineCount min (lineOf(hints.last.expr) + 1)	Int	lastLine
HintOption(s"<code>$Apply</code>, <code>$Update</code> methods", Apply, Update)	Option	applyUpdateParameterNames
HintOption(s"non-literal expressions", "references", "names")	Option	referenceParameterNames
secondParamName != null && !secondParamName.toBoolean	Boolean	isShortName
Option(secondParamName).flatMap { secondParamName => ScalaPsiManager.instance(project).getCachedClass(GlobalSearchScope.allScope(project), secondParamName) }	Option[PsiClass]	outerClass
"scala" +: idSegments :+ "hint"	IndexedSeq[String]	id
context	ExpressionContext	c
head.calculateResult(context) match { case ScalaTypeResult(scType) => Some(scType) case result => resultToScExpr(result)(context) }	Option[ScType]	maybeType
lineToHintMapping.get(line)	Option[ScalaExprChainTypeHintsPass.AlignedHintTemplate]	maybeHint
maybeHint match { case Some(hint) => Some(hint.expr.getTextRange.getEndOffset) case _ if lineHasHint(line - 1) || lineHasHint(line + 1) => Some(document.getLineEndOffset(line)) case _ => None }	Option[Int]	maybeOffset
{ def lineOf(expr: ScExpression): Int = document.getLineNumber(expr.getTextRange.getEndOffset) val lineToHintMapping = hints.groupBy(hint => lineOf(hint.expr)).mapValues(_.head) val lineHasHint = lineToHintMapping.contains _ val firstLine = 0 max (lineOf(hints.head.expr) - 1) val lastLine = document.getLineCount min (lineOf(hints.last.expr) + 1) (firstLine to lastLine).flatMap { line => val maybeHint = lineToHintMapping.get(line) val maybeOffset = maybeHint match { case Some(hint) => Some(hint.expr.getTextRange.getEndOffset) case _ if lineHasHint(line - 1) || lineHasHint(line + 1) => Some(document.getLineEndOffset(line)) case _ => None } maybeOffset.map(new AlignmentLine(_, maybeHint)(document)) } }	Seq[AlignedInlayGroup.this.AlignmentLine]	alignmentLines
context.getProject	ProjectContext	project
Option(context.getPsiElementAtStartOffset) .flatMap(offset => Option(getParentOfType(offset, classOf[ScFunction])))	Option[Nothing]	maybeFunction
context .getPsiElementAtStartOffset .parentOfType(classOf[PsiClass]) .map { case scalaObject: ScObject => scalaObject.fakeCompanionClassOrCompanionClass case other => other } .filterByType[ScClass]	Option[ScClass]	classElement
inlayModel.addAfterLineEndElement( hint.expr.getTextRange.getEndOffset, false, new AlignedInlayRenderer(line, hint.textParts) )	Inlay[AlignedInlayGroup.this.AlignedInlayRenderer]	inlay
for(line <- alignmentLines; hint <- line.maybeHint) yield { val inlay = inlayModel.addAfterLineEndElement( hint.expr.getTextRange.getEndOffset, false, new AlignedInlayRenderer(line, hint.textParts) ) inlay.putUserData(ScalaExprChainKey, true) inlay }	Seq[Inlay[AlignedInlayGroup.this.AlignedInlayRenderer]]	inlays
toQualifiedName(packageName(definition)(Nil, DefaultSeparator) :+ Right(definition))()	String	name
new ScalaLookupItem(definition, name, Option(definition.getContainingClass))	ScalaLookupItem	lookupItem
alignmentLines.map(_.lineEndX(editor))	IndexedSeq[Int]	allEndXs
argument.getTextRange.getStartOffset	Int	offset
clauses.map(clauseText)	IndexedSeq[String]	clausesStrings
alignmentLines.withFilter(_.hasHint).map(_.lineEndX(editor))	IndexedSeq[Int]	actualEndXs
allEndXs.max	Int	max
actualEndXs.sum / actualEndXs.length	Int	avg
param.getName	String	name
for (member <- candidates) yield { val ScMethodMember(signature, isOverride) = member val prototype: ScFunctionDefinition = createMethodFromSignature(signature, body = "???")(aClass.getManager).asInstanceOf[ScFunctionDefinition] TypeAnnotationUtil.removeTypeAnnotationIfNeeded(prototype, ScalaGenerationInfo.typeAnnotationsPolicy) prototype.setModifierProperty("override", value = isOverride) val body = methodBody(target, prototype) prototype.body.foreach(_.replace(body)) val genInfo = new ScalaGenerationInfo(member) val added = aClass.addMember(prototype, Option(genInfo.findInsertionAnchor(aClass, elementAtOffset))) .asInstanceOf[ScFunctionDefinition] if (added.superMethod.nonEmpty) added.setModifierProperty("override") added }	IndexedSeq[Any]	generatedMethods
max + math.max(minMarginInPixel, maxMarginInPixel - (max - avg) / 3)	Int	targetMaxX
inlay.getRenderer	AlignedInlayGroup.this.AlignedInlayRenderer	renderer
clause.parameters.map { param: ScParameter => val name = param.getName val typ = param.paramType.map(_.getText).getOrElse("Any") s"$name: $typ" }	Seq[String]	params
renderer.line.lineEndX(editor)	Int	endX
document.createRangeMarker(offset, offset)	RangeMarker	marker
Cached(0, 0)	AlignedInlayRenderer.this.Cached	cached
editor.getInlayModel	InlayModel	model
cached.margin	Int	oldMargin
method.containingClass match { case null => "" case clazz => s"${clazz.qualifiedName}." }	String	classFqn
params.commaSeparated()	String	paramsStr
expressions.headOption .map(_.calculateResult(context)) .filterByType[TextResult]	Option[TextResult]	argsVarResult
model.getElementAt(MouseHandler.mousePressLocation)	Inlay[_ <: EditorCustomElementRenderer]	inlay
method.parameters.map(_.name)	IndexedSeq[String]	names
Hint.elementOf(inlay)	PsiElement	element
prototype.typeParameters	Seq[ScTypeParam]	typeParams
parameters.clauses.headOption.map(_.parameters)	Option[Seq[ScParameter]]	firstParamClause
params.map(_.paramType.map(_.getText).getOrElse(""))	Seq[String]	types
ProjectContext.fromProject(e.getData(CommonDataKeys.PROJECT))	ProjectContext	context
inlay.getOffset	Int	startOffset
Try { val str = first match { case "option" => "scala.Option" case "foreach" => "foreach" } (new ScalaVariableOfTypeMacro.RegularVariable) .calculateLookups(Array(str), showOne = true) .map(_.getObject) .collectFirst { case typed: ScTypedDefinition if typed.name == second => typed }.flatMap(_.`type`().toOption) .collect { case ParameterizedType(_, typeArgs) => typeArgs.head case JavaArrayType(argument) => argument } }	Try[Any]	tried
{ val inlayText = inlay.getRenderer.asInstanceOf[HintRenderer].getText startOffset + inlayText.length + element.getTextLength + 1 }	Int	endOffset
findDefinitions.collectFirst { case (typed, scType) if typeText(expressions, scType) => new TextResult(typed.name) }	Option[TextResult]	maybeResult
if(inlay == null) Seq() else { val startOffset = inlay.getOffset val endOffset = { val inlayText = inlay.getRenderer.asInstanceOf[HintRenderer].getText startOffset + inlayText.length + element.getTextLength + 1 } model.getInlineElementsInRange(startOffset, endOffset).asScala }	Seq[Inlay[_]]	prefixAndSuffixInlays
prototype.parameters ++ prototype.returnTypeElement	IndexedSeq[ScalaPsiElement with Typeable]	parametersAndRetType
{ val typeParams = prototype.typeParameters val parametersAndRetType = prototype.parameters ++ prototype.returnTypeElement if (typeParams.exists(!typeParameterUsedIn(_, parametersAndRetType))) { typeParams.map(_.nameId.getText).mkString("[", ", ", "]") } else "" }	String	typeParamsForCall
Key.create("SCALA_IMPLICIT_HINT_ELEMENT")	Key[PsiElement]	ElementKey
delegateText(delegate)	String	dText
prototype.name	String	methodName
Key.create[Boolean]("SCALA_IMPLICIT_HINT")	Key[Boolean]	ScalaImplicitHintKey
if (suffix) element.getTextRange.getEndOffset else element.getTextRange.getStartOffset	Int	offset
new ModificationCount("IMPLICIT_HINTS_MODIFICATION_COUNT")	ModificationCount	ModificationCount
false	Boolean	_enabled
false	Boolean	_expanded
Seq( new KeyboardShortcut(KeyStroke.getKeyStroke("control alt shift EQUALS"), null), new KeyboardShortcut(KeyStroke.getKeyStroke("control alt shift ADD"), null))	Seq[KeyboardShortcut]	EnableShortcuts
Seq( new KeyboardShortcut(KeyStroke.getKeyStroke("control alt shift MINUS"), null), new KeyboardShortcut(KeyStroke.getKeyStroke("control alt shift SUBTRACT"), null))	Seq[KeyboardShortcut]	DisableShortcuts
new TextPartsHintRenderer(parts, menu) { override protected def getMargin(editor: Editor): Insets = margin.getOrElse(EmptyInsets) }	TextPartsHintRenderer { def getMargin(editor: Editor): Any }	renderer
KeymapManager.getInstance().getActiveKeymap	Keymap	keymap
prototype.effectiveParameterClauses.map(paramClauseApplicationText).mkString	String	params
0	Int	balance
Option.empty[(Inlay, Text)]	Option[(implicits.Inlay, Text)]	activeHyperlink
{ val renderer = new TextPartsHintRenderer(parts, menu) { override protected def getMargin(editor: Editor): Insets = margin.getOrElse(EmptyInsets) } if (ImplicitHints.expanded) { renderer.expand() } model.addInlineElement(offset + offsetDelta, relatesToPrecedingElement, renderer) }	Inlay[TextPartsHintRenderer { def getMargin(editor: Editor): Any }]	inlay
elements.dropWhile(_ != element).dropWhile { it => if (isOpening(it)) balance += 1 if (isClosing(it)) balance -= 1 balance != 0 }	Seq[T]	remainder
Set.empty[(Inlay, Text)]	Set[(implicits.Inlay, Text)]	highlightedMatches
Option.empty[LightweightHint]	Option[LightweightHint]	hyperlinkTooltip
Option.empty[LightweightHint]	Option[LightweightHint]	errorTooltip
e.getEditor	Editor	editor
new EditorMouseListener { override def mousePressed(e: EditorMouseEvent): Unit = { if (handlingRequired) { MouseHandler.mousePressLocation = e.getMouseEvent.getPoint } } override def mouseClicked(e: EditorMouseEvent): Unit = { if (handlingRequired && !e.isConsumed && project.isInitialized && !project.isDisposed) { val editor = e.getEditor val event = e.getMouseEvent if (SwingUtilities.isLeftMouseButton(event)) { if (SystemInfo.isMac && event.isMetaDown || event.isControlDown) { hyperlinkAt(editor, event.getPoint).foreach { case (_, text) => e.consume() deactivateActiveHyperlink(editor) navigateTo(text) } } else { expandableAt(editor, event.getPoint).foreach { case (inlay, text) => inlay.getRenderer.asOptionOf[TextPartsHintRenderer].foreach { renderer => renderer.expand(text) inlay.updateSize() if (!ImplicitHints.expanded) { addEscKeyListenerTo(editor) } } } } } else if (SwingUtilities.isMiddleMouseButton(event) && activeHyperlink.isEmpty) { hyperlinkAt(editor, event.getPoint).foreach { case (_, text) => e.consume() navigateTo(text) } } else { deactivateActiveHyperlink(editor) } } } }	EditorMouseListener { def mouseClicked(e: EditorMouseEvent): Unit def mousePressed(e: EditorMouseEvent): Unit }	mousePressListener
textAt(e.getEditor, e.getMouseEvent.getPoint)	Option[(implicits.Inlay, Text)]	textAtPoint
new EditorMouseMotionListener { override def mouseMoved(e: EditorMouseEvent): Unit = { if (handlingRequired && !e.isConsumed && project.isInitialized && !project.isDisposed) { val textAtPoint = textAt(e.getEditor, e.getMouseEvent.getPoint) if (SystemInfo.isMac && e.getMouseEvent.isMetaDown || e.getMouseEvent.isControlDown) { textAtPoint match { case Some((inlay, text)) if text.navigatable.isDefined => if (!activeHyperlink.contains((inlay, text))) { deactivateActiveHyperlink (e.getEditor) activateHyperlink(e.getEditor, inlay, text, e.getMouseEvent) } case _ => deactivateActiveHyperlink(e.getEditor) } textAtPoint match { case Some((inlay, text)) => highlightMatches(e.getEditor, inlay, text) case None => clearHighlightedMatches() } } else { textAtPoint.foreach { case (_, text) => if (text.errorTooltip.nonEmpty && !errorTooltip.exists(_.isVisible)) { errorTooltip = text.errorTooltip.map(showTooltip(e.getEditor, e.getMouseEvent, _)) errorTooltip.foreach(_.addHintListener(_ => errorTooltip = None)) } } deactivateActiveHyperlink(e.getEditor) } } } }	EditorMouseMotionListener { def mouseMoved(e: EditorMouseEvent): Unit }	mouseMovedListener
editorFactory.getEventMulticaster	EditorEventMulticaster	multicaster
Seq.empty	Seq[Hint]	hints
new KeyAdapter { override def keyTyped(keyEvent: KeyEvent): Unit = { if (keyEvent.getKeyChar == KeyEvent.VK_ESCAPE) { ImplicitHints.collapseIn(editor) } } }	{ def keyTyped(keyEvent: Any): Unit }	keyListener
ScalaProjectSettings.getInstance(rootElement.getProject)	ScalaProjectSettings	settings
try { val inlayImplClass = Class.forName("com.intellij.openapi.editor.impl.InlayImpl") val myOriginalOffsetField = inlayImplClass.getDeclaredField("myOriginalOffset") myOriginalOffsetField.setAccessible(true) val modifiersField = classOf[Field].getDeclaredField("modifiers") modifiersField.setAccessible(true) modifiersField.setInt(myOriginalOffsetField, myOriginalOffsetField.getModifiers & ~Modifier.FINAL) Some(myOriginalOffsetField) } catch { case _: Throwable => if (ApplicationManager.getApplication.isInternal) { val log = Logger.getInstance(classOf[Hint]) log.warn("No myOriginalOffset field in com.intellij.openapi.editor.impl.InlayImpl") } None }	Option[Any]	myOriginalOffsetField
{ // TODO Why HTML is rewritten by com.intellij.ide.IdeTooltipManager.initPane(com.intellij.util.ui.Html, com.intellij.ui.HintHint, javax.swing.JLayeredPane) ? val label = if (text.contains("Type mismatch.")) new JLabel(text) else HintUtil.createInformationLabel(text) label.setBorder(JBUI.Borders.empty(6, 6, 5, 6)) new LightweightHint(label) }	LightweightHint	hint
parts	Seq[Text]	originalParts
HintManager.ABOVE	Short	constraint
Key.create[Long](key)	Key[Long]	CountKey
delegate match { case field: ScalaFieldMember => field.name case ScMethodMember(PhysicalMethodSignature(method, _), _) => method match { case m: PsiMethod if m.isAccessor => m.getName case f: ScFunction if f.isEmptyParen => f.name + "()" case f: ScFunction if f.isParameterless => f.name } }	String	delegateText
ScalaAnnotator.isAdvancedHighlightingEnabled(rootElement) && settings.isShowNotFoundImplicitArguments	Boolean	showNotFoundImplicitForFile
for { (typed, scType) <- findDefinitions typeText <- this.typeText(expressions, scType) } yield LookupElementBuilder.create(typed, typed.name) .withTypeText(typeText)	IndexedSeq[Any]	elements
HintManagerImpl.getInstanceImpl	HintManagerImpl	manager
delegate.asInstanceOf[ScalaTypedMember].scType	ScType	delegateType
Array(Pass.UPDATE_ALL)	Array[Int]	runAfterAnnotator
Set((inlay, text), (pairInlay, pairText))	Set[(implicits.Inlay, Text)]	matches
editor.asInstanceOf[EditorImpl]	EditorImpl	editorImpl
editor.getDocument.getLineNumber(element._1.getOffset)	Int	line
showNotFoundImplicits(owner)	Boolean	showNotFoundArgs
ImplicitHints.enabled || showNotFoundArgs	Boolean	shouldSearch
editorImpl.getAscent	Int	ascent
editorImpl.getDescent	Int	descent
Key.create[KeyListener]("SCALA_IMPLICIT_HINTS_KEY_LISTENER")	Key[Any]	EscKeyListenerKey
element.getParent.asInstanceOf[ScArgumentExprList]	ScArgumentExprList	list
list.exprs.head	ScExpression	exp
list.projectContext	ProjectContext	projectContext
element.getParent.asInstanceOf[ScBlockExpr]	ScBlockExpr	block
getTextAttributes(editor)	TextAttributes	attributes
createExpressionWithContextFromText(delegateText(delegate), tBody, tBody.getFirstChild)	ScExpression	place
getFontMetrics0(editor)	MyFontMetrics	fontMetrics
block.getManager	ProjectContext	context
function.params	ScParameters	params
GraphicsUtil.setupAAPainting(g)	GraphicsConfig	config
function.parameters.exists(_.paramType.isDefined)	Boolean	hasSomeType
exp match { case funExpr: ScFunctionExpr => createAnonFunBlockFromFunExpr(funExpr) case _ => createBlockFromExpr(exp) }	ScExpression	block
infix.getTextRange.getStartOffset	Int	start
toMethodMembers(candidates, place)	Seq[ScMethodMember]	members
desugaredEnum.analogMethodCall	ScMethodCall	analogCall
new CaretVisualPositionKeeper(myEditor)	CaretVisualPositionKeeper	caretKeeper
myEditor.getInlayModel	InlayModel	inlayModel
new ScalaMemberChooser[ScMethodMember](members.toArray, false, true, false, true, false, aClass)	ScalaMemberChooser[ScMethodMember]	chooser
inlayModel.inlaysIn(rootElement.getTextRange)	Seq[implicits.Inlay]	existingInlays
targetElements(file, editor)	Seq[ScalaGenerateDelegateHandler.this.ClassMember]	elements
existingInlays.length + hints.length > BulkChangeThreshold	Boolean	bulkChange
1000	Int	BulkChangeThreshold
hasSomeType && !params.startsWithToken(ScalaTokenTypes.tLPARENTHESIS)	Boolean	newParentheses
arguments.filter(_.isImplicitParameterProblem)	Seq[ScalaResolveResult]	problems
editor.getCaretModel.getOffset - infix.operation.nameId.getTextRange.getStartOffset	Int	diff
infixExpr.operation	ScReferenceExpression	operation
operation.refName	String	refName
text.effective(editor, attributes)	TextAttributes	effectiveTextAttributes
infix.getParent match { case p: ScParenthesisedExpr => p.getParent case p => p }	PsiElement	parent
effectiveTextAttributes.getEffectType	EffectType	effectType
editor.getUserData(HintFontMetrics)	MyFontMetrics	metrics
new ScalaMemberChooser(elements.toArray, false, false, false, false, false, classAtOffset(editor.getCaretModel.getOffset, file))	ScalaMemberChooser[Nothing]	chooser
Text(foldedString, attributes = foldedAttributes(error = problems.nonEmpty), expansion = Some(() => expandedPresentationOf(arguments).drop(1).dropRight(1)) )	Text	folding
m.getContainingClass	PsiClass	cl
newExpr match { case infix: ScInfixExpr => infix.operation.nameId.getTextRange.getStartOffset - newExpr.getTextRange.getStartOffset - 2 case _ => 0 }	Int	size
createExpressionFromText("!(" + text + ")")	ScExpression	newExpr
newExpr.asInstanceOf[ScPrefixExpr].getLastChild.asInstanceOf[ScParenthesisedExpr].getChildren	Array[PsiElement]	children
result.element match { case f: ScFunction => Option(f.syntheticNavigationElement).getOrElse(f) case element => element }	PsiElement	delegate
statement.getTextRange	TextRange	range
children(0) match { case infix: ScInfixExpr => infix.operation. nameId.getTextRange.getStartOffset - newExpr.getTextRange.getStartOffset case _ => 0 }	Int	size
findReturnParent(element).filter(_.isValid) .getOrElse(return)	ScReturn	statement
ScalaDocumentationProvider.getQuickNavigateInfo(delegate, result.substitutor)	String	tooltip
parts.map(it => fontMetrics.stringWidth(it.string)).scanLeft(m.left + p.left)(_ + _)	IndexedSeq[Any]	xs
s"${negate(base)} ${Replacement(operation.refName)} ${negate(argument)}"	String	text
Map("" + "&&" -> "||", "||" -> "&&" )	Map[Nothing, Nothing]	Replacement
parts.indexOf(text)	Int	i
false	Boolean	expanded
Key.create[MyFontMetrics]("SCALA_IMPLICIT_HINT_FONT_METRICS")	Key[MyFontMetrics]	HintFontMetrics
0.55F	Float	BackgroundAlpha
statement match { case ScReturn(ScParenthesisedExpr(ElementText(text))) => text case ScReturn(ElementText(text)) => text case _ => return }	String	expressionText
statement.getTextRange.getStartOffset	Int	start
5	Int	ExpansionLevel
createExpressionFromText(s"if ($expressionText) { return true } else { return false }")	ScExpression	replacement
Text("?", likeWrongReference, navigatable = parameter.element.asOptionOf[Navigatable])	Text	qMarkText
Text(typeSuffix(parameter))	Text	paramTypeSuffix
methodCallExpr.getInvokedExpr.asInstanceOf[ScReferenceExpression].nameId.getTextRange	TextRange	range
mutable.HashSet[String]("==", "!=", "equals", "eq", "ne")	mutable.HashSet[String]	notChanged
if (probableArgs.size > 1) ambiguousTooltip(parameter) else notFoundTooltip(parameter)	String	errorTooltip
Map(">" -> "<", "<" -> ">", ">=" -> "<=", "<=" -> ">=")	Map[Nothing, Nothing]	replaceOper
if (!ImplicitHints.enabled) foldedString else foldedString + typeSuffix(parameter)	String	presentationString
editor.getCaretModel.getOffset - methodCallExpr.getInvokedExpr.asInstanceOf[ScReferenceExpression]. nameId.getTextRange.getStartOffset	Int	diff
new StringBuilder	StringBuilder	expr
new StringBuilder	StringBuilder	qualBuilder
s"$baseText ${Replacement(operation.refName)} $argumentText"	String	text
Map( "==" -> "!=", "!=" -> "==", ">" -> "<=", "<" -> ">=", ">=" -> "<", "<=" -> ">" )	Map[Nothing, Nothing]	Replacement
if (replacement != refName) s" to '$replacement'" else ""	String	suffix
Map("equals" -> "equals","==" -> "==", "!=" -> "!=", "eq" -> "eq", "ne" -> "ne", ">" -> "<", "<" -> ">", ">=" -> "<=", "<=" -> ">=")	Map[Nothing, Nothing]	replaceOper
methodCallExpr.getInvokedExpr.asInstanceOf[ScReferenceExpression].qualifier.get	ScExpression	qual
editor.getCaretModel.getOffset - operation.nameId.getTextRange.getStartOffset	Int	diff
methodCallExpr.getInvokedExpr.asInstanceOf[ScReferenceExpression]	ScReferenceExpression	invokedExpression
invokedExpression.nameId.getTextRange	TextRange	range
methodCallExpr.getInvokedExpr.asInstanceOf[ScReferenceExpression]	ScReferenceExpression	scReferenceExpression
createExpressionFromText(newQual)	ScExpression	newQualExpr
replaceOper(oper)	String	desiredOper
convertExpression(methodCallExpr, scReferenceExpression, desiredOper)	String	convertedExpr
new VariablesCompletionProcessor(StdKinds.valuesRef)(element)	VariablesCompletionProcessor	processor
argument.implicitParameters .join( Text("("), Text(", "), Text(")") )(presentationOf)	Seq[Text]	presentationOfParameters
createExpressionFromText(expr.toString())	ScExpression	newMethodCallExpr
newMethodCallExpr.asInstanceOf[ScMethodCall].getInvokedExpr.asInstanceOf[ScReferenceExpression].nameId. getTextRange.getStartOffset - newMethodCallExpr.getTextRange.getStartOffset	Int	size
createExpressionFromText(convertedExpr)(element.getManager)	ScExpression	newMethodCallExpr
createExpressionFromText(s"$baseText ${Replacement(operation.refName)} $argumentText").asInstanceOf[ScInfixExpr]	ScInfixExpr	newInfixExpr
parameter.implicitSearchState.map(_.presentableTypeText).getOrElse("NotInferred")	String	paramType
createExpressionFromText(s"$argumentText ${Replacement(operation.refName)} $baseText")	ScExpression	newInfixExpr
methodCallExpr.replaceExpression(newMethodCallExpr, removeParenthesis = true)	ScExpression	newExpr
newInfixExpr.operation.nameId.getTextRange.getStartOffset - newInfixExpr.getTextRange.getStartOffset	Int	size
Map( "equals" -> "==", "==" -> "equals" )	Map[Nothing, Nothing]	Replacement
PsiTreeUtil.getParentOfType(element, classOf[ScIf], false)	ScIf	ifStmt
newInfixExpr.asInstanceOf[ScInfixExpr].operation.nameId.getTextRange.getStartOffset - newInfixExpr.getTextRange.getStartOffset	Int	size
Map("equals" -> "==", "==" -> "equals")	Map[Nothing, Nothing]	replaceOper
Map( "equals" -> "equals", "==" -> "==", "!=" -> "!=", "eq" -> "eq", "ne" -> "ne", ">" -> "<", "<" -> ">", ">=" -> "<=", "<=" -> ">=", "&&" -> "&&", "||" -> "||" )	Map[Nothing, Nothing]	Replacement
methodCallArgs.getText	String	methodCallArgsText
if (methodCallArgs.getChildren.length == 1) methodCallArgsText.drop(1).dropRight(1) else methodCallArgsText	String	processArgs
if (desiredOper == "==") { val processArgs = //accounts for tuples if (methodCallArgs.getChildren.length == 1) methodCallArgsText.drop(1).dropRight(1) else methodCallArgsText s" $desiredOper $processArgs" } else s".$desiredOper$methodCallArgsText"	String	suffix
ifStmt.thenExpression.orNull	ScExpression	thenBranch
ifStmt.elseExpression.orNull	ScExpression	elseBranch
ifStmt.elseExpression.orNull	ScExpression	blockExpr
ifStmt.elseExpression.orNull	ScExpression	elseIfExpr
elseBranch.asInstanceOf[ScIf].thenExpression.orNull	ScExpression	innerThenBranch
ifStmt.getTextRange.getStartOffset	Int	start
ifStmt.thenExpression.get.getTextRange.getEndOffset - ifStmt.getTextRange.getStartOffset	Int	startIndex
ifStmt.elseExpression.get.getTextRange.getStartOffset - ifStmt.getTextRange.getStartOffset	Int	endIndex
new util.Comparator[PsiElement]() { def compare(element1: PsiElement, element2: PsiElement): Int = { (element1, element2) match { case _ if element1 == element2 => 0 case (block1: ScBlockExpr, block2: ScBlockExpr) if block1.exprs.size != block2.exprs.size => 1 case (block1: ScBlockExpr, block2: ScBlockExpr) if block1 == block2 => 0 case (expr1: ScExpression, expr2: ScExpression) if expr1 == expr2 => 0 case _ => 1 } } }	{ def compare(element1: PsiElement, element2: PsiElement): Int }	comparator
ifStmt.condition.orNull	ScExpression	condition
s"""if (${conditionText(base)}) |if (${conditionText(argument)}) $thenBranchText""".stripMargin	String	prefix
if (prefix.trim.endsWith("}")) ' ' else '\n'	Char	separator
editor.getCaretModel.getOffset - ifStmt.thenExpression.get.getTextRange.getEndOffset - elseIndex	Int	diff
ifStmt.elseExpression.get.asInstanceOf[ScIf]	ScIf	innerIfStmt
innerIfStmt.elseExpression.orNull	ScExpression	innerElseBranch
branch.exprs	Seq[ScExpression]	exprs
blockExpr.asInstanceOf[ScBlockExpr].exprs	Seq[ScExpression]	exprs
exprs.head.asInstanceOf[ScIf]	ScIf	innerIfStmt
branch.elseExpression.orNull	ScExpression	innerElseBranch
maybeElseBranch match { case Some(ElementText(text)) => val separator = if (prefix.trim.endsWith("}")) ' ' else '\n' s"""${separator}else $text |else $text""".stripMargin case _ => "" }	String	suffix
ifStmt.thenExpression.get match { case c: ScBlockExpr => c.exprs.head.asInstanceOf[ScIf] case c: ScIf => c }	ScIf	innerIfStmt
innerIfStmt.thenExpression.get	ScExpression	innerThenBranch
createExpressionFromText(prefix + suffix).asInstanceOf[ScIf]	ScIf	newIfStmt
newIfStmt.condition.get.getTextRange.getStartOffset - newIfStmt.getTextRange.getStartOffset	Int	diff
createExpressionFromText(expr.toString())(element.getManager)	ScExpression	newIfStmt
newIfStmt.asInstanceOf[ScIf].thenExpression.get.getTextRange.getEndOffset - newIfStmt.asInstanceOf[ScIf].getTextRange.getStartOffset	Int	size
ifStmt.thenExpression.orNull	ScExpression	thenExpression
ifStmt.elseExpression.orNull	ScExpression	elseExpression
ifStmt.getTextRange.getStartOffset <= offset && offset < condition.getTextRange.getStartOffset	Boolean	caretIsOnIf
isCaretOnElse(thenExpression, elseExpression, offset)	Boolean	caretIsOnElse
condition match { case ScInfixExpr.withAssoc(base, operation, argument) => val refName = operation.refName def negateBoolOperation(expression: ScExpression) = refName match { case "||" | "&&" => negate(expression) case _ => expression.getText } s"${negateBoolOperation(base)} ${Replacement(refName)} ${negateBoolOperation(argument)}" case _ => negate(condition) }	String	newCondition
elseExpression match { case null => "{\n\n}" case block: ScBlockExpr => block.getText case expr => "{\n" + expr.getText + "\n}" }	String	newThenExpression
thenExpression match { case block: ScBlockExpr => block.getText case expr => "{\n" + expr.getText + "\n}" }	String	newElseExpression
s"if ($newCondition) $newThenExpression else $newElseExpression"	String	newIfElseText
isCaretOnElse(thenExpression, elseExpression, caretModel.getOffset)	Boolean	oldCaretWasOnElse
createExpressionFromText(newIfElseText)(element.getManager)	ScExpression	newIfStmtDummy
ifStmt.replaceExpression(newIfStmtDummy, removeParenthesis = true)	ScExpression	newIfStmt
Map( "==" -> "!=", "!=" -> "==", ">" -> "<=", "<" -> ">=", ">=" -> "<", "<=" -> ">", "&&" -> "||", "||" -> "&&" )	Map[Nothing, Nothing]	Replacement
tb.resultExpression.orNull	ScExpression	lastExpr
ifStmt.thenExpression.getOrElse(return)	ScExpression	thenBranch
thenBranch.getNextSiblingNotWhitespaceComment	PsiElement	elseKeyWord
ifStmt.elseExpression.getOrElse(return)	ScExpression	elseBranch
elseBranch.copy().children.toList	List[PsiElement]	children
children.find(_.getNode.getElementType != ScalaTokenTypes.tLBRACE).getOrElse(return)	PsiElement	from
PsiTreeUtil.getParentOfType(element, classOf[ScWhile])	ScWhile	whileStmt
children.reverse.find(_.getNode.getElementType != ScalaTokenTypes.tRBRACE).getOrElse(return)	PsiElement	to
s"if ($condText) {\n do $bodyText while ($condText)\n}"	String	newStmtText
None	Option[String]	targetModifier
createExpressionFromText(newStmtText)(element.getManager)	ScExpression	newStmt
declaredNames(body).intersect(declaredNames(doStmtParent)).nonEmpty	Boolean	nameConflict
availableModifiers(member)	Seq[String]	available
for { member <- findMember(element) description <- getMemberDescription(member) } yield { val available = availableModifiers(member) available match { case Seq(one) => targetModifier = Some(one) setText(ScalaCodeInsightBundle.message("make.0.1", description, one)) case _ => targetModifier = None setText(getFamilyName) } available }	Option[Seq[String]]	availableOpt
createExpressionFromText(s"while (${condition.getText}) $bodyText")	ScExpression	newWhileStmt
createExpressionFromText(bodyText)	ScExpression	newBody
doStmt.getParent.children.map(_.getNode.getElementType).contains(ScalaTokenTypes.tLBRACE)	Boolean	parentBlockHasBraces
doStmtParent match { case _: ScalaFile => false case block: ScBlock => block.getParent match { case _: ScCaseClause => false case _ => true } case _ => true }	Boolean	parentBlockNeedBraces
availableModifiers(member)	Seq[String]	possibleModifiers
element.withParentsInFile.toList match { case list if eager => list.reverse case list => list }	List[PsiElement]	candidates
checkForConflicts(member, modifier)	Option[Map[PsiElement, String]]	conflicts
newDoStmt.replaceExpression(newWhileStmt, removeParenthesis = true)	ScExpression	newExpression
newExpression.getParent	PsiElement	parent
newBody match { case _: ScBlock => newBody.children case _: ScExpression => Iterator(newBody) }	Iterator[PsiElement]	bodyElements
formatter.format(parts)	String	stringFormatted
elem.getNode.getElementType	IElementType	elementType
modifierList .accessModifier .fold(TextRange.from(modifierList.getTextRange.getStartOffset, 0))(_.getTextRange)	TextRange	modifierRange
model.getOffset	Int	curCursorPos
document.createRangeMarker(curCursorPos, curCursorPos)	RangeMarker	originalCursorPositionMarker
new CompletionProcessor(StdKinds.refExprLastRef, firstChild, isImplicit = true)	CompletionProcessor	processor
ScalaPsiElementFactory.createExpressionFromText(stringFormatted)(element.getManager)	ScExpression	replacement
target.getParent match { case ref: ScReferenceExpression if ref.qualifier.contains(target) => true // in case of postfix/infix expressions brackets are not necessary, but the code becomes readable case postfix: ScPostfixExpr if postfix.operand == target => true case infix: ScInfixExpr if infix.rightOption.contains(target) => true case _ => false }	Boolean	needToWrapConcatWithBrackets
literalParent(element).collect { case lit if lit.isMultiLineString => "Convert to \"string\"" case lit if lit.isString => "Convert to \"\"\"string\"\"\"" }	Option[Nothing]	maybeText
collection.mutable.LinkedHashSet[ScNamedElement]()	mutable.LinkedHashSet[ScNamedElement]	myEqualsFields
new Panel(classMembers)((_: TableModelEvent) => updateButtons())	ScalaGenerateToStringWizard.Panel	toStringPanel
super.showAndGetOk()	AsyncResult[Nothing]	result
collection.mutable.LinkedHashSet[ScNamedElement]()	mutable.LinkedHashSet[ScNamedElement]	myHashCodeFields
findAllMethodCallsOnMLString(element, "replace")	Array[Array[ScExpression]]	calls
if (needEquals) new ScalaMemberSelectionPanel(CodeInsightBundle.message("generate.equals.hashcode.equals.fields.chooser.title"), getClassFields)(ScalaEqualsMemberInfoModel) else null	AbstractMemberSelectionPanel[ScNamedElement, ScalaMemberInfo]	getEqualsPanel
hasEquals(aClass)	Option[ScFunction]	equalsMethod
literalParent(element) .filter(_.isString) .getOrElse(return)	ScLiteral	lit
hasHashCode(aClass)	Option[ScFunction]	hashCodeMethod
equalsMethod.isEmpty	Boolean	needEquals
hashCodeMethod.isEmpty	Boolean	needHashCode
if (aClass.isInstanceOf[PsiAnonymousClass]) CodeInsightBundle.message("generate.equals.and.hashcode.already.defined.warning.anonymous") else CodeInsightBundle.message("generate.equals.and.hashcode.already.defined.warning", aClass.qualifiedName)	String	text
literal.getTextRange	TextRange	literalRange
new HashMap[ScNamedElement, ScalaMemberInfo]	HashMap[ScNamedElement, ScalaMemberInfo]	result
caretOffset - literalRange.getStartOffset - interpolatorLength	Int	caretShiftFromQuoteStart
if (needEquals && needHashCode) { val result = new HashMap[ScNamedElement, ScalaMemberInfo] for { (info, member) <- extractFields(Function.const(true)) } result.put(member, info) result } else null	HashMap[ScNamedElement, ScalaMemberInfo]	getFieldsToHashCode
StringUtils.countMatches(textBeforeCaret, "\\n")	Int	newLinesBeforeCaret
ApplicationManager.getApplication.runWriteAction(new Computable[Boolean] { def compute: Boolean = { try { equalsMethod.get.delete() hashCodeMethod.get.delete() true } catch { case _: IncorrectOperationException => false } } })	Boolean	deletedOk
new PhysicalMethodSignature( createMethodWithContext(declText + " = 0", aClass, aClass.extendsBlock), ScSubstitutor.empty)	PhysicalMethodSignature	signature
Option(if (!overridesFromJavaObject(aClass, signature)) "super.hashCode()" else null)	Option[Null]	superCall
MultilineStringUtil.addMarginsAndFormatMLString(literalReplaced, document, caretModel.getOffset)	Int	caretShift
interpolated.referenceName	String	prefix
InterpolatedStringParser.parse(interpolated).getOrElse(Nil)	Seq[StringPart]	parts
InterpolatedStringFormatter.formatContent(parts, toMultiline = true)	String	content
s"$prefix$Quotes$content$Quotes"	String	newLiteralText
try StartMarkAction.start(editor, project, getFamilyName()) catch { case e: StartMarkAction.AlreadyStartedException => Messages.showErrorDialog(project, e.getMessage, StringUtil.toTitleCase(getFamilyName())) return }	StartMarkAction	markAction
EditorColorsManager.getInstance.getGlobalScheme.getAttributes(EditorColors.LIVE_TEMPLATE_ATTRIBUTES)	TextAttributes	lvAttr
editor.getMarkupModel.addRangeHighlighter( modifierRange.getStartOffset, modifierRange.getEndOffset, HighlighterLayer.LAST + 1, lvAttr, HighlighterTargetArea.EXACT_RANGE )	RangeHighlighter	highlighter
new ModifierTextUpdater(file, document, modifierRange, getFamilyName)	ChangeAccessModifierIntention.ModifierTextUpdater	updater
s"val state = $stateText"	String	firstStmtText
definition.bindings.head.name	String	name
createExpressionFromText(newLiteralText)	ScExpression	newLiteral
interpolated.replace(newLiteral)	PsiElement	replaced
SmartPointerManager.createPointer(member)	SmartPsiElementPointer[ScMember]	memberPointer
new MultiMap[PsiElement, String]()	MultiMap[PsiElement, String]	conflictMap
new ConflictsDialog(modifierList.getProject, conflictMap, () => changeModifier(modifierList, modifier, hasConflicts = true))	ConflictsDialog	dialog
modifierList.getProject	Project	project
modifierList.getParent	PsiElement	parent
field.name	String	fieldName
if (withFieldNames) fieldName + "=" else ""	String	prefix
definition.`type`().getOrAny.canonicalText	String	typeText
definition.name	String	name
s"private[this] var _$name: $typeText = $defaultValue"	String	backingVarText
literal.replace(newLiteral)	PsiElement	replaced
createCompanionObject(clazz)	ScObject	obj
caretOffset - literalRange.getStartOffset - interpolatorLength	Int	caretShiftFromQuotesStart
createDefinition(backingVarText)	ScMember	backingVar_0
-2.min(caretShiftFromQuotesStart)	Int	shiftQuotes
s"$modifiers def $name: $typeText = _$name"	String	getterText
spacesBeforeCaretInsideMargin(textBeforeCaret)	Int	spacesInsideMargin
createDefinition(getterText)	ScMember	getter_0
ScalaPsiUtil.functionArrow(aClass.getProject)	String	arrow
literal match { case WithStrippedMargin(_, marginChar) => val allMarginsLength = textBeforeCaret.length - textBeforeCaret.stripMargin(marginChar).length // fix case when caret is placed inside margin itself val spacesInsideMargin = spacesBeforeCaretInsideMargin(textBeforeCaret) -allMarginsLength - spacesInsideMargin case _ => 0 }	Int	shiftStrippedMargins
s"state.map(_.hashCode()).foldLeft(0)((a, b) $arrow 31 * a + b)"	String	calculationText
if (needHashCode) { val classFields = getClassFields match { case fields if needEquals => updateInfos(fields) case fields => fields } new ScalaMemberSelectionPanel(CodeInsightBundle.message("generate.equals.hashcode.hashcode.fields.chooser.title"), classFields)(ScalaHashCodeMemberInfoModel) } else null	AbstractMemberSelectionPanel[ScNamedElement, ScalaMemberInfo]	getHashCodePanel
parent.addAfter(obj, clazz)	PsiElement	addedObj
addedObj.getTextRange.getStartOffset	Int	offset
document.getLineNumber(offset) + 1	Int	lineInside
InterpolatedStringFormatter.formatContent(parts)	String	content
createDefinition(setterText)	ScMember	setter_0
definition.getParent	PsiElement	parent
s"$prefix$Quote$content$Quote"	String	newLiteralText
mutable.ListBuffer[PsiElement]()	ListBuffer[PsiElement]	addedMembers
new PhysicalMethodSignature( createMethodWithContext(declText + " = true", aClass, aClass.extendsBlock), ScSubstitutor.empty)	PhysicalMethodSignature	sign
PsiDocumentManager.getInstance(aClass.getProject)	PsiDocumentManager	psiDocManager
Seq(backingVar_0, getter_0, setter_0).map { elem => parent.addBefore(createNewLine()(definition.getManager), definition) parent.addBefore(elem, definition) }	IndexedSeq[PsiElement]	added
ScalaChangeInfo( newVisibility = modifier, function = method, newName = method.name, newType = method.getReturnType.toScType(), newParams = ScalaParameterInfo.allForMethod(method), isAddDefaultArgs = false )	ScalaChangeInfo	changeInfo
new ScalaChangeSignatureProcessor(changeInfo)	ScalaChangeSignatureProcessor	processor
modifierList.getContainingFile	PsiFile	file
PsiParserFacade.SERVICE.getInstance(project).createWhiteSpaceFromText(" ")	PsiElement	whitespace
modifierList.getNextSibling	PsiElement	sibling
member.getProject	Project	project
parent.addBefore(member, anchor)	PsiElement	added
Map.empty[PsiElement, String]	Map[PsiElement, String]	conflicts
CodeStyleManager.getInstance(aClass.getProject)	CodeStyleManager	styleManager
overrideModifier(aClass, sign)	String	overrideMod
s"$overrideMod $declText = other.isInstanceOf[${aClass.name}]"	String	text
myEqualsFields.map(_.name).map(name => s"$name == that.$name")	IndexedSeq[String]	fieldComparisons
new PhysicalMethodSignature( createMethodWithContext(declText + " = false", aClass, aClass.extendsBlock), ScSubstitutor.empty)	PhysicalMethodSignature	signature
Option(if (!overridesFromJavaObject(aClass, signature)) "super.equals(that)" else null)	Option[Null]	superCheck
Option(if (aClass.hasFinalModifier) null else "(that canEqual this)")	Option[Null]	canEqualCheck
findClassAtCaret(editor, file).getOrElse(return)	ScClass	aClass
chooseOriginalMembers(aClass)(project, editor)	Boolean	isOk
hasHashCode(aClass).isEmpty	Boolean	needHashCode
Option( if (needHashCode) createHashCode(aClass) else null)	Option[ScFunction]	hashCodeMethod
hasEquals(aClass).isEmpty	Boolean	needEquals
Option( if (needEquals) createEquals(aClass, project) else null)	Option[ScFunction]	equalsMethod
needEquals && hasCanEqual(aClass).isEmpty && !aClass.hasFinalModifier	Boolean	needCanEqual
Option( if (needCanEqual) createCanEqual(aClass, project) else null)	Option[ScFunction]	canEqualMethod
clazz.projectContext.stdTypes	StdTypes	stdTypes
f.parameters.flatMap(_.`type`().toOption)	IndexedSeq[ScType]	funParamTypes
methodSignaturesToOverride(definition).exists { _.equiv(signature) }	Boolean	needModifier
ScalaPsiElementFactory .createScalaFileFromText(s"$modifier class a").typeDefinitions.head.getModifierList	ScModifierList	newModifierList
member.getUseScope	SearchScope	useScope
ReferencesSearch.search(declaredElement, useScope)	Query[PsiReference]	search
reference.getElement	PsiElement	referencedElement
!ProgressManager.getInstance.runProcessWithProgressSynchronously((() => ReadAction.run(() => { for (declaredElement <- getElementsToSearch(member)) { val search = ReferencesSearch.search(declaredElement, useScope) search.asScala.foreach { reference: PsiReference => val referencedElement = reference.getElement if (!ResolveUtils.isAccessibleWithNewModifiers(member, referencedElement, newModifierList)) { val context = PsiTreeUtil.getParentOfType(referencedElement, classOf[PsiMethod], classOf[PsiField], classOf[PsiClass], classOf[PsiFile]) if (context != null) { val message = ScalaCodeInsightBundle.message( "0.with.1.visibility.is.not.accessible.from.2", RefactoringUIUtil.getDescription(declaredElement, false), modifier, RefactoringUIUtil.getDescription(context, true) ) conflicts += (referencedElement -> message) } } } } })): Runnable, ScalaCodeInsightBundle.message("detecting.possible.conflicts"), true, project)	Boolean	canceled
Seq.newBuilder[String]	mutable.Builder[String, Seq[String]]	modifierSeq
member.getModifierList.accessModifier	Option[ScAccessModifier]	accessModifier
range.getStartOffset > 0 && !StringUtil.isWhiteSpace(sequence.charAt(range.getStartOffset - 1))	Boolean	myExtendLeft
range.getEndOffset < sequence.length && !StringUtil.isWhiteSpace(sequence.charAt(range.getEndOffset))	Boolean	myExtendRight
myDocument.createRangeMarker(range)	RangeMarker	marker
{ val marker = myDocument.createRangeMarker(range) marker.setGreedyToRight(true) marker.setGreedyToLeft(true) marker }	RangeMarker	myMarker
myFile.getProject	Project	project
fileEditorManager.getSelectedEditor(myFile.getVirtualFile)	FileEditor	fileEditor
UndoManager.getInstance(project)	UndoManager	manager
target	String	updatedText
new AbstractFixOnPsiElement( ScalaCodeInsightBundle.message("no.tailrec.annotation.fix"), function ) { override protected def doApplyFix(function: ScFunctionDefinition) (implicit project: Project): Unit = { addTailRecursionAnnotation(function) } }	AbstractFixOnPsiElement[ScFunctionDefinition] { def doApplyFix(function: ScFunctionDefinition) (implicit project: Project): Unit }	quickFix
addedMembers.map(_.getTextRange)	IndexedSeq[TextRange]	ranges
ranges.map(_.getStartOffset).min	Int	minOffset
ranges.map(_.getEndOffset).max	Int	maxOffset
document.getLineNumber(minOffset)	Int	minLine
document.getLineNumber(maxOffset)	Int	maxLine
definition match { case scClass: ScClass => scClass.constructor.toSeq.flatMap(_.parameters) case _ => Seq.empty }	Seq[ScClassParameter]	constructorParameters
s"$Quote$content$Quote"	String	newLiteralText
textBeforeCaret.length - 1	Int	idx
0	Int	spaces
option.getDefaultValue	Boolean	defaultValue
s"""class D { | def foo(x: Int): Int = x |} | |class A { | val d = new D | $CARET |}""".stripMargin	String	text
s"""class D { | def foo(x: Int): Int = x |} | |class A { | val d = new D | | def foo(x: Int): Int = d.foo(x) |}""".stripMargin	String	resultText
s"""class D { | def foo(x: Int): Int = x |} | |class A { | var d = new D | $CARET |}""".stripMargin	String	text
s"""class D { | def foo(x: Int): Int = x |} | |class A { | var d = new D | | def foo(x: Int): Int = d.foo(x) |}""".stripMargin	String	resultText
s"""class D { | def foo(x: Int): Int = x |} | |class A { | def d = new D | $CARET |}""".stripMargin	String	text
s"""class D { | def foo(x: Int): Int = x |} | |class A { | def d = new D | | def foo(x: Int): Int = d.foo(x) |}""".stripMargin	String	resultText
s"""class D { | def foo(x: Int): Int = x |} | |class A { | def d() = new D | $CARET |}""".stripMargin	String	text
s"""class D { | def foo(x: Int): Int = x |} | |class A { | def d() = new D | | def foo(x: Int): Int = d().foo(x) |}""".stripMargin	String	resultText
s"""trait DT { | def foo(x: Int): Int = x |} | |class DC {} | |class A { | val d = new DC with DT | $CARET |}""".stripMargin	String	text
s"""trait DT { | def foo(x: Int): Int = x |} | |class DC {} | |class A { | val d = new DC with DT | | def foo(x: Int): Int = d.foo(x) |}""".stripMargin	String	resultText
s"""class Base { | val d = new D() |} | |class D { | def foo() {} |} | |class A extends Base { | $CARET |}""".stripMargin	String	text
s"""class Base { | val d = new D() |} | |class D { | def foo() {} |} | |class A extends Base { | def foo(): Unit = d.foo() |}""".stripMargin	String	result
s"""class Base { | private val d = new D() |} | |class D { | def foo() {} |} | |class A extends Base { |$CARET |}""".stripMargin	String	text
s"""class Base { | private val d = new D() |} | |class D { | def foo() {} |} | |class A extends Base { | |}""".stripMargin	String	result
s"""trait DT { | def foo(x: Int): Int = x |} | |class DC extends DT | |class A extends DT { | val d = new DC | $CARET |}""".stripMargin	String	text
s"""trait DT { | def foo(x: Int): Int = x |} | |class DC extends DT | |class A extends DT { | val d = new DC | | override def foo(x: Int): Int = d.foo(x) |}""".stripMargin	String	result
s"""class D { | def foo(x: Int): Int = x |} | |class A { | val d = new D | val inner = new AnyRef { | $CARET | } |}""".stripMargin	String	text
s"""class D { | def foo(x: Int): Int = x |} | |class A { | val d = new D | val inner = new AnyRef { | def foo(x: Int): Int = d.foo(x) | } |}""".stripMargin	String	result
s"""class D { | def foo(x: Int): Int = x |} | |class A { | val inner = new AnyRef { |$CARET | } |}""".stripMargin	String	text
s"""class D { | def foo(x: Int): Int = x |} | |class A { | val inner = new AnyRef { | | } |}""".stripMargin	String	result
s"""class D { | def foo(x: Int)(y: Int): Int = x |} | |class A { | val d = new D() | $CARET |}""".stripMargin	String	text
s"""class D { | def foo(x: Int)(y: Int): Int = x |} | |class A { | val d = new D() | | def foo(x: Int)(y: Int): Int = d.foo(x)(y) |}""".stripMargin	String	result
s"""class D[T] { | def foo(x: T): T = x |} | |class A { | val d = new D[Int]() | $CARET |}""".stripMargin	String	text
s"""class D[T] { | def foo(x: T): T = x |} | |class A { | val d = new D[Int]() | | def foo(x: Int): Int = d.foo(x) |}""".stripMargin	String	result
s"""class D[T] { | def foo[S <: T](x: T): T = x |} | |class A { | val d = new D[AnyRef]() | $CARET |}""".stripMargin	String	text
s"""class D[T] { | def foo[S <: T](x: T): T = x |} | |class A { | val d = new D[AnyRef]() | | def foo[S <: AnyRef](x: AnyRef): AnyRef = d.foo[S](x) |}""".stripMargin	String	result
s"""class D[T] { | def foo[S >: AnyRef](x: T): S = null |} | |class A { | val d = new D[Int]() | $CARET |}""".stripMargin	String	text
s"""class D[T] { | def foo[S >: AnyRef](x: T): S = null |} | |class A { | val d = new D[Int]() | | def foo[S >: AnyRef](x: Int) = d.foo[S](x) |}""".stripMargin	String	result
s"""class D[T] { | def foo[S >: AnyRef](x: T): S = null |} | |class A { | val d = new D[Int]() | | def foo[S >: AnyRef](x: Int): S = d.foo(x) |}""".stripMargin	String	result
myFixture.configureByText("ScalaDummy.scala", convertLineSeparators(scalaText))	PsiFile	scalaFile
myFixture.getEditor	Editor	editor
s"""public class JavaClass { | public static class D { | public int foo(int i) { | return i; | } | } | | public D d = new D(); |}""".stripMargin	String	javaText
s"""class A extends JavaClass { | $CARET |}""".stripMargin	String	scalaText
s"""class A extends JavaClass { | def foo(i: Int): Int = d.foo(i) |}""".stripMargin	String	result
s"""public class JavaClass { | public static class D { | public int foo(int i) { | return i; | } | } | | public D getD() { | return new D(); | } |}""".stripMargin	String	javaText
s"""class A extends JavaClass { | def foo(i: Int): Int = getD.foo(i) |}""".stripMargin	String	result
s"""public class JavaClass { | public static class D { | public int foo(int i) { | return i; | } | } | | private D d = new D(); |}""".stripMargin	String	javaText
s"""class A extends JavaClass { |$CARET |}""".stripMargin	String	scalaText
s"""class A extends JavaClass { | |}""".stripMargin	String	result
s"""public class JavaClass { | public int foo(int i) { | return i; | } |}""".stripMargin	String	javaText
s"""class A { | val d = new JavaClass() | |}""".stripMargin	String	scalaText
s"""class A { | val d = new JavaClass() | | def foo(i: Int): Int = d.foo(i) |}""".stripMargin	String	result
s"""public class JavaClass<T> { | public T foo(T t) { | return t; | } |}""".stripMargin	String	javaText
s"""class A { | val d = new JavaClass[Int]() | $CARET |}""".stripMargin	String	scalaText
s"""class A { | val d = new JavaClass[Int]() | | def foo(t: Int): Int = d.foo(t) |}""".stripMargin	String	result
s"""public class JavaClass { | public <T> T foo() { | return null; | } |}""".stripMargin	String	javaText
s"""class A { | val d = new JavaClass() |$CARET |}""".stripMargin	String	scalaText
s"""class A { | val d = new JavaClass() | | def foo[T](): T = d.foo() |}""".stripMargin	String	result
s"""class A { | val d = new JavaClass() | | def foo[T]() = d.foo[T]() |}""".stripMargin	String	result
s"""class A() |object A { | $CARET |} |""".stripMargin	String	before
s"""class A() |object A { | def apply($CARET): A = new A() |} |""".stripMargin	String	after
s"""class A(param: Int) |object A { | $CARET |} |""".stripMargin	String	before
s"""class A(param: Int) |object A { | def apply(param: Int$CARET): A = new A(param) |} |""".stripMargin	String	after
s"""case class SomeClass(param1: String, | val param2: Boolean, | var param3: Int, | override val param4: Long, | final override var param5: String) extends SomeTrait |object SomeClass { | $CARET |} |""".stripMargin	String	before
s"""case class SomeClass(param1: String, | val param2: Boolean, | var param3: Int, | override val param4: Long, | final override var param5: String) extends SomeTrait |object SomeClass { | def apply(param1: String, param2: Boolean, param3: Int, param4: Long, param5: String$CARET): SomeClass = new SomeClass(param1, param2, param3, param4, param5) |} |""".stripMargin	String	after
s"""class A (p1: String, override val p2: Int)(implicit p3: Long, p4: String) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A (p1: String, override val p2: Int)(implicit p3: Long, p4: String) {} |object A { | def apply(p1: String, p2: Int)(implicit p3: Long, p4: String$CARET): A = new A(p1, p2)(p3, p4) |} |""".stripMargin	String	after
s"""class A (p1: (Int, Long), override val p2: Tuple4[Int, String, Int, Long]) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A (p1: (Int, Long), override val p2: Tuple4[Int, String, Int, Long]) {} |object A { | def apply(p1: (Int, Long), p2: Tuple4[Int, String, Int, Long]$CARET): A = new A(p1, p2) |} |""".stripMargin	String	after
s"""class A (x: Int, val y: String, override var z: Long = 42) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A (x: Int, val y: String, override var z: Long = 42) {} |object A { | def unapply(arg: A): Option[(Int, String, Long)$CARET] = ??? |} |""".stripMargin	String	after
s"""class A (x: Int) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A (x: Int) {} |object A { | def unapply(arg: A): Option[Int$CARET] = ??? |} |""".stripMargin	String	after
s"""class A ( | x: Int, // comment 1 | val y: String, // comment 2 | override var z: Long = 42 // comment 3 |) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A ( | x: Int, // comment 1 | val y: String, // comment 2 | override var z: Long = 42 // comment 3 |) {} |object A { | def unapply(arg: A): Option[(Int, String, Long)$CARET] = ??? |} |""".stripMargin	String	after
s"""class A () {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A () {} |object A { | def unapply(arg: A): Option[$CARET] = ??? |} |""".stripMargin	String	after
s"""class A (p1: String, override val p2: Int)(p3: Long, p4: String) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A (p1: String, override val p2: Int)(p3: Long, p4: String) {} |object A { | def unapply(arg: A): Option[(String, Int)$CARET] = ??? |} |""".stripMargin	String	after
s"""class A (p1: (Int, Long), override val p2: Tuple4[Int, String, Int, Long])(p3: Long, p4: String) {} |object A { | $CARET |} |""".stripMargin	String	before
s"""class A (p1: (Int, Long), override val p2: Tuple4[Int, String, Int, Long])(p3: Long, p4: String) {} |object A { | def unapply(arg: A): Option[((Int, Long), Tuple4[Int, String, Int, Long])$CARET] = ??? |} |""".stripMargin	String	after
TemplateSettings.getInstance.getTemplate(templateName, templateGroup)	TemplateImpl	template
s"`$templateGroup/$templateName`"	String	templateId
TemplateManager.getInstance(getProject)	TemplateManager	templateManager
ImplicitHints.enabled	Boolean	oldEnabled
s""" |class NameParameters { | def doSomething(flag: Boolean) {} | | doSomething(t${CARET}rue) |} """.stripMargin	String	text
s""" |class NameParameters { | def doSomething(flag: Boolean) {} | | doSomething(flag = t${CARET}rue) |} """.stripMargin	String	resultText
s""" |class NameParameters { | def doSomething(flag: Boolean, a: Int) {} | | doSomething(t${CARET}rue, 8) |} """.stripMargin	String	text
s""" |class NameParameters { | def doSomething(flag: Boolean, a: Int) {} | | doSomething(flag = t${CARET}rue, a = 8) |} """.stripMargin	String	resultText
s""" |class NameParameters { | def doSomething(flag: Boolean, a: Int, b: Int) {} | | doSomething(true, 8, ${CARET}9) |} """.stripMargin	String	text
s""" |class NameParameters { | def doSomething(flag: Boolean, a: Int, b: Int) {} | | doSomething(true, 8, ${CARET}b = 9) |} """.stripMargin	String	resultText
s""" |class Test { | method(x, y)$CARET( x => x) |} """.stripMargin	String	text
s""" |class Test { | method(x, y)$CARET { x => | x | } |} """.stripMargin	String	resultText
CodeStyleSettingsManager.getSettings(getProject)	CodeStyleSettings	settings
s""" |class Test { | method(x, y)$CARET { | x => | x | } |} """.stripMargin	String	resultText
s"""object Test { | Some(1).foreach(${CARET}one => println(one)) |} """.stripMargin	String	AFTER_SINGLE_EXPRESSION
s"""object Test { | Some(1).foreach {$CARET | one => | println(one) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one => | println(one) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one => { | println(one) | } } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach(${CARET}one => { | println(one) | }) |} """.stripMargin	String	after
s"""object Test { | Some(1).foreach {$CARET one => | "qwe" | .substring(0, 1) | .toString | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach(${CARET}one => { | "qwe" | .substring(0, 1) | .toString | }) |} """.stripMargin	String	after
s"""object Test { | Some(1).foreach($CARET(one: Int) => println(one)) |} """.stripMargin	String	AFTER_SINGLE_EXPRESSION_TYPED
s"""object Test { | Some(1).foreach {$CARET | one: Int => | println(one) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET | (one: Int) => | println(one) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one: Int => | println(one) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one: Int => { | println(one) | } } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach($CARET(one: Int) => { | println(one) | }) |} """.stripMargin	String	after
s"""object Test { | Some(1).foreach(${CARET}one => { | println(one) | val two = one + 1 | println(two) | }) |} """.stripMargin	String	AFTER_MULTIPLE_BLOCK_EXPRESSIONS
s"""object Test { | Some(1).foreach {$CARET | one => | println(one) | val two = one + 1 | println(two) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one => | println(one) | val two = one + 1 | println(two) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one => { | println(one) | val two = one + 1 | println(two) | } | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach($CARET(one: Int) => { | println(one) | val two = one + 1 | println(two) | }) |} """.stripMargin	String	AFTER_MULTIPLE_BLOCK_EXPRESSIONS_TYPED
s"""object Test { | Some(1).foreach {$CARET | one: Int => | println(one) | val two = one + 1 | println(two) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one: Int => | println(one) | val two = one + 1 | println(two) | } |} """.stripMargin	String	before
s"""object Test { | Some(1).foreach {$CARET one: Int => { | println(one) | val two = one + 1 | println(two) | } | } |} """.stripMargin	String	before
s"""Some(1).foreach {$CARET | print("out of lambda") | one => | println(one) | val two = one + 1 | println(two) |} """.stripMargin	String	text
s"""object Test { | identity {$CARET 42 } |} |""".stripMargin	String	before
s"""object Test { | identity {$CARET | 42 | } |} |""".stripMargin	String	before
s"""object Test { | identity {$CARET | println(42) | } |} |""".stripMargin	String	before
s"""object Test { | identity {$CARET | "hello".toUpperCase() | .substring(0) | } |} |""".stripMargin	String	before
s"""object Test { | identity {$CARET 42; 23 } |} |""".stripMargin	String	before
s"""object Test { | identity {$CARET | 42; | 23 | } |} |""".stripMargin	String	before
s"if (a |$CARET| b) {}"	String	text
s"if (!(!a &$CARET& !b)) {}"	String	resultText
s"if (a &$CARET& b) {}"	String	text
s"if (!(!a |$CARET| !b)) {}"	String	resultText
s"if (!a |$CARET| b) {}"	String	text
s"if (!(a &$CARET& !b)) {}"	String	resultText
s"if (a |$CARET| !b) {}"	String	text
s"if (!(!a &$CARET& b)) {}"	String	resultText
s"if (!a |$CARET| !b) {}"	String	text
s"if (!(a &$CARET& b)) {}"	String	resultText
s"if (!a &$CARET& b) {}"	String	text
s"if (!(a |$CARET| !b)) {}"	String	resultText
s"if (a $CARET&& !b) {}"	String	text
s"if (!(!a $CARET|| b)) {}"	String	resultText
s"if (!a &&$CARET !b) {}"	String	text
s"if (!(a ||$CARET b)) {}"	String	resultText
s"if (true |$CARET| false) {}"	String	text
s"if (!(false &$CARET& true)) {}"	String	resultText
s"!(!left &$CARET& !right)"	String	text
s"left |$CARET| right"	String	resultText
s""" |val % = true |!(!(%) &$CARET& !(%)) """.stripMargin	String	text
s""" |val % = true |% |$CARET| % """.stripMargin	String	resultText
s""" |val % = true |% |$CARET| % """.stripMargin	String	text
s""" |val % = true |!(!(%) &$CARET& !(%)) """.stripMargin	String	resultText
s""" |val b = true |(true equals b) |$CARET| true """.stripMargin	String	text
s""" |val b = true |!(!(true equals b) &$CARET& false) """.stripMargin	String	resultText
s""" |val b = true |!(!(true equals b) &$CARET& false) """.stripMargin	String	text
s""" |val b = true |(true equals b) |$CARET| true """.stripMargin	String	resultText
s""" |val % = true |(%) |$CARET| (%) """.stripMargin	String	text
s""" |class X { | def f(a: Int): Boolean = { | retur${CARET}n a > 0 | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Int): Boolean = { | ${CARET}if (a > 0) { | return true | } else { | return false | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Int): Boolean = { | retur${CARET}n (a > 0) | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Int, b: Int): Boolean = { | retur${CARET}n (a > 0 || b < 7) | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Int, b: Int): Boolean = { | ${CARET}if (a > 0 || b < 7) { | return true | } else { | return false | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Int, b: Int): Boolean = { | if (a > 0 || b < 7) { | ret${CARET}urn true | } else { | return false | } | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Int, b: Int): Boolean = { | if (a > 0 || b < 7) { | ${CARET}if (true) { | return true | } else { | return false | } | } else { | return false | } | } |}""".stripMargin	String	resultText
s"if (a ==$CARET b) {}"	String	text
s"if (!(a !=$CARET b)) {}"	String	resultText
s"if (a $CARET>= b) {}"	String	text
s"if (!(a $CARET< b)) {}"	String	resultText
s"if (a !=$CARET b) {}"	String	text
s"if (!(a ==$CARET b)) {}"	String	resultText
s"if (a $CARET< b) {}"	String	text
s"if (!(a $CARET>= b)) {}"	String	resultText
s"if (!(a $CARET< b)) {}"	String	text
s"if (a $CARET>= b) {}"	String	resultText
s"a =$CARET= b"	String	text
s"!(a !$CARET= b)"	String	resultText
s"if (!(!(a $CARET< b))) {}"	String	text
s"$CARET!true"	String	text
s"false"	String	result
s"""val a = true |${CARET}true == a""".stripMargin	String	text
s"""val a = true |a""".stripMargin	String	result
s"""val a = true |true $CARET&& a""".stripMargin	String	text
s"val a: Boolean = false; a $CARET| false"	String	text
s"val a: Boolean = false; a"	String	result
s"""val a = true |${CARET}true && (a || false)""".stripMargin	String	text
s"""val a = true |val flag: Boolean = ${CARET}true != a""".stripMargin	String	text
s"""val a = true |val flag: Boolean = !a""".stripMargin	String	result
s"""val a = true |!(${CARET}true != a)""".stripMargin	String	text
s"""val a = true |!(!a)""".stripMargin	String	result
s"""def trueAsAny: Any = { | true |} |if (trueAsAny =$CARET= true) { | println("true") |} else { | println("false") |}""".stripMargin	String	text
s"if (a =$CARET= b) return"	String	text
s"if (b =$CARET= a) return"	String	resultText
s"if (a equal${CARET}s b) return"	String	text
s"if (b equal${CARET}s a) return"	String	resultText
s"if (a >$CARET b) return"	String	text
s"if (b <$CARET a) return"	String	resultText
s"if (a <$CARET b) return"	String	text
s"if (b >$CARET a) return"	String	resultText
s"if (a <=$CARET b) return"	String	text
s"if (b >=$CARET a) return"	String	resultText
s"if (a >=$CARET b) return"	String	text
s"if (b <=$CARET a) return"	String	resultText
s"if (a !$CARET= b) return"	String	text
s"if (b !$CARET= a) return"	String	resultText
s"if (7 <$CARET (7 + 8)) return"	String	text
s"if ((7 + 8) >$CARET 7) return"	String	resultText
s"if ((7 + 8) <$CARET 7) return"	String	text
s"if (7 >$CARET (7 + 8)) return"	String	resultText
s"if (sourceClass == null || (sourceClass e${CARET}q clazz)) return null"	String	text
s"if (sourceClass == null || (clazz e${CARET}q sourceClass)) return null"	String	resultText
s"if (aClass n${CARET}e b) return"	String	text
s"if (b n${CARET}e aClass) return"	String	resultText
s"if (f.=$CARET=(false)) return"	String	text
s"if (false.=$CARET=(f)) return"	String	resultText
s"if (a.equal${CARET}s(b)) return"	String	text
s"if (b.equal${CARET}s(a)) return"	String	resultText
s"if (a.>$CARET(b)) return"	String	text
s"if (b.<$CARET(a)) return"	String	resultText
s"if (a.<$CARET(b)) return"	String	text
s"if (b.>$CARET(a)) return"	String	resultText
s"if (a.<=$CARET(b)) return"	String	text
s"if (b.>=$CARET(a)) return"	String	resultText
s"if (a.>=$CARET(b)) return"	String	text
s"if (b.<=$CARET(a)) return"	String	resultText
s"if (a.!$CARET=(b)) return"	String	text
s"if (b.!$CARET=(a)) return"	String	resultText
s"if (7.<$CARET(7 + 8)) return"	String	text
s"if ((7 + 8).>$CARET(7)) return"	String	resultText
s"if ((7 + 8).<$CARET(7)) return"	String	text
s"if (7.>$CARET(7 + 8)) return"	String	resultText
s"if (sourceClass == null || sourceClass.e${CARET}q(clazz)) return null"	String	text
s"if (sourceClass == null || clazz.e${CARET}q(sourceClass)) return null"	String	resultText
s"if (aClass.n${CARET}e(b)) return"	String	text
s"if (b.n${CARET}e(aClass)) return"	String	resultText
s"if (a ==$CARET b) return"	String	text
s"if (a ${CARET}equals b) return"	String	resultText
s"if (a ${CARET}equals false) return"	String	text
s"if (a $CARET== false) return"	String	resultText
s"if (a.$CARET==(b)) return"	String	text
s"if (a.${CARET}equals(b)) return"	String	resultText
s"if (a.eq${CARET}uals(false)) return"	String	text
s"if (a.${CARET}equals( false )) return"	String	text
s"(true, false).equ${CARET}als (false, false)"	String	text
s"(true, false) $CARET== (false, false)"	String	resultText
s"if((true, false).equ${CARET}als (false, false)) return "	String	text
s"if ((true, false) $CARET== (false, false)) return"	String	resultText
s"(x.eq${CARET}uals(y)).toString"	String	text
s"(x $CARET== y).toString"	String	resultText
s"x.eq${CARET}uals(y).toString"	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (a &$CARET& b) return | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a) | if (b) return | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if (a &$CARET& b) { | return | } else { | System.out.println() | } | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a) | if (b) { | return | } else { | System.out.println() | } | else { | System.out.println() | } | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if (a &$CARET& b) { | return | } | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a) | if (b) { | return | } | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if (a &$CARET& b) | System.out.println("if") | else | System.out.println("else") | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a) | if (b) System.out.println("if") | else System.out.println("else") | else System.out.println("else") | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if (a &$CARET& b) { | System.out.println("if") | } else | System.out.println("else") | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a) | if (b) { | System.out.println("if") | } else System.out.println("else") | else System.out.println("else") | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if (a &$CARET& b) System.out.println("if") | else { | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a) | if (b) System.out.println("if") | else { | System.out.println("else") | } | else { | System.out.println("else") | } | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if ((a || b) &$CARET& b) System.out.println("if") | else { | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a || b) | if (b) System.out.println("if") | else { | System.out.println("else") | } | else { | System.out.println("else") | } | } |}""".stripMargin	String	resultText
s"""class X { | def f(a: Boolean, b: Boolean) { | if ((a || b) &$CARET& (b && a)) System.out.println("if") | else { | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class X { | def f(a: Boolean, b: Boolean) { | if (${CARET}a || b) | if (b && a) System.out.println("if") | else { | System.out.println("else") | } | else { | System.out.println("else") | } | } |}""".stripMargin	String	resultText
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se { | if (a == 8) { | System.out.println("if2") | } else { | System.out.println("else") | } | } | } |}""".stripMargin	String	text
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se if (a == 8) { | System.out.println("if2") | } else { | System.out.println("else") | } | } |}""".stripMargin	String	resultText
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) System.out.println("if1") | el${CARET}se { | if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) System.out.println("if1") | el${CARET}se if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } |}""".stripMargin	String	resultText
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se { | if (a == 8) | System.out.println("if2") | else { | System.out.println("else") | } | } | } |}""".stripMargin	String	text
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se if (a == 8) | System.out.println("if2") | else { | System.out.println("else") | } | } |}""".stripMargin	String	resultText
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se { | if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } |}""".stripMargin	String	resultText
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) | System.out.println("if1") | else${CARET} { | if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) System.out.println("if1") | else${CARET} if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } |}""".stripMargin	String	resultText
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) | System.out.println("if1") | else${CARET} { | if (a == 8) | System.out.println("if2") | } | } |}""".stripMargin	String	text
s"""class MergeElseIf { | def mthd() { | val a: Int = 0 | if (a == 9) System.out.println("if1") | else${CARET} if (a == 8) | System.out.println("if2") | } |}""".stripMargin	String	resultText
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | i${CARET}f (a == 9) { | } else if (a == 7) { | } | } |}""".stripMargin	String	text
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | ${CARET}if (a == 9 || a == 7) { | } | } |}""".stripMargin	String	resultText
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | i${CARET}f (a == 9) { | System.out.println("if") | } else if (a == 7) { | System.out.println("if") | } else { | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | ${CARET}if (a == 9 || a == 7) { | System.out.println("if") | } else { | System.out.println("else") | } | } |} """.stripMargin	String	resultText
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | i${CARET}f (a == 9) | System.out.println("if") | else if (a == 7) | System.out.println("if") | } |}""".stripMargin	String	text
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | ${CARET}if (a == 9 || a == 7) System.out.println("if") | } |}""".stripMargin	String	resultText
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | i${CARET}f (a == 9) | System.out.println("if") | else if (a == 7) | System.out.println("if") | else if (a == 19) | System.out.println("if") | else | System.out.println("if") | } |}""".stripMargin	String	text
s"""class MergeIfToOr { | def mthd { | val a: Int = 0 | ${CARET}if (a == 9 || a == 7) System.out.println("if") | else if (a == 19) | System.out.println("if") | else | System.out.println("if") | } |}""".stripMargin	String	resultText
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se if (a == 8) { | System.out.println("if2") | } else { | System.out.println("else") | } | } |}""".stripMargin	String	text
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) { | System.out.println("if1") | } el${CARET}se { | if (a == 8) { | System.out.println("if2") | } else { | System.out.println("else") | } | } | } |}""".stripMargin	String	resultText
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) | System.out.println("if1") | el${CARET}se if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } |}""".stripMargin	String	text
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) System.out.println("if1") | el${CARET}se { | if (a == 8) | System.out.println("if2") | else | System.out.println("else") | } | } |}""".stripMargin	String	resultText
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) | System.out.println("if1") | el${CARET}se if (a == 8) | System.out.println("if2") | } |}""".stripMargin	String	text
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) System.out.println("if1") | el${CARET}se { | if (a == 8) | System.out.println("if2") | } | } |}""".stripMargin	String	resultText
s"""class SplitElseIf { | def mthd { | val a: Int = 0 | if (a == 9) | System.out.println("if1") | el${CARET}se | if (a == 8) | System.out.println("if2") | } |}""".stripMargin	String	text
s""" |class MergeIfToAnd { | def mthd() { | val a: Int = 0 | i${CARET}f (a == 9) { | if (a == 7) { | System.out.println("if") | } | } | } |}""".stripMargin	String	text
s""" |class MergeIfToAnd { | def mthd() { | val a: Int = 0 | i${CARET}f (a == 9 && a == 7) { | System.out.println("if") | } | } |}""".stripMargin	String	resultText
s""" |class MergeIfToAnd { | def mthd() { | val a: Int = 0 | i${CARET}f (a == 9) | if (a == 7) | System.out.println("if") | } |}""".stripMargin	String	text
s""" |class MergeIfToAnd { | def mthd() { | val a: Int = 0 | i${CARET}f (a == 9 && a == 7) System.out.println("if") | } |}""".stripMargin	String	resultText
s""" |class MergeIfToAnd { | def mthd() { | val a: Int = 0 | i${CARET}f (a == 9) { | if (a == 7) | System.out.println("if") | } | } |}""".stripMargin	String	text
s""" |class MergeIfToAnd { | def mthd() { | val a: Int = 0 | i${CARET}f (a == 9) | if (a == 7) { | System.out.println("if") | } | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | ${CARET}if (a) b = false | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | ${CARET}if (!a) { | | } else { | b = false | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (a) { | b = false | } | System.out.println() | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (!a) { | | } else { | b = false | } | System.out.println() | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (a == b) { | val c = false | } | println() | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (a != b) { | | } else { | val c = false | } | println() | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (!a) b = false | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (a) { | | } else { | b = false | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (true) b = false | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (false) { | | } else { | b = false | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (!(a == true)) b = false | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (a == true) { | | } else { | b = false | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | if$CARET (false) { | | } else { | System.out.print("else") | } | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | if$CARET (true) { | System.out.print("else") | } else { | | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (false) { | System.out.print("if") | } else { | System.out.print("else") | } | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (true) { | System.out.print("else") | } else { | System.out.print("if") | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (false) | System.out.print("if") | else | System.out.print("else") | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (false) System.out.print("if") | else System.out.print("else") | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (false) System.out.print("if") | else { | System.out.print("else1") | System.out.print("else2") | } | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (true) { | System.out.print("else1") | System.out.print("else2") | } else { | System.out.print("if") | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (false) { | System.out.print("if1") | System.out.print("if2") | } | else | System.out.print("else") | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | i${CARET}f (true) { | System.out.print("else") | } else { | System.out.print("if1") | System.out.print("if2") | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | if (false) { | System.out.print("if1") | System.out.print("if2") | } ${CARET}else { | System.out.print("else") | } | } |}""".stripMargin	String	text
s""" |class X { | def f(a: Boolean, b: Boolean) { | if (true) { | System.out.print("else") | }$CARET else { | System.out.print("if1") | System.out.print("if2") | } | } |}""".stripMargin	String	resultText
s""" |class X { | def f(a: Boolean, b: Boolean) { | if (false) { | System.out.print("if1") | System.out.print("if2") | } el${CARET}se { | System.out.print("else") | } | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int) { | if (i == 0) { | return | } e${CARET}lse { | val j = 0 | } | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int) { | if (i == 0) { | return | }$CARET | val j = 0 | } |}""".stripMargin	String	resultText
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) { | return true | } e${CARET}lse { | val j = 0 | } | return false | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) { | return true | }$CARET | val j = 0 | return false | } |}""".stripMargin	String	resultText
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) { | System.out.println("if") | return true | } e${CARET}lse { | System.out.println("else") | val j = 0 | } | return false | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) { | System.out.println("if") | return true | }$CARET | System.out.println("else") | val j = 0 | return false | } |}""".stripMargin	String	resultText
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) return true | e${CARET}lse { | System.out.println("else") | val j = 0 | } | return false | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) return true$CARET | System.out.println("else") | val j = 0 | return false | } |}""".stripMargin	String	resultText
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) | return true | e${CARET}lse | System.out.println("else") | return false | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) | return true$CARET | System.out.println("else") | return false | } |} """.stripMargin	String	resultText
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) | throw new Exception | e${CARET}lse | System.out.println("else") | return false | } |}""".stripMargin	String	text
s"""class X { | def f(i: Int): Boolean = { | if (i == 0) | throw new Exception$CARET | System.out.println("else") | return false | } |}""".stripMargin	String	resultText
s"""class X { | val flag: Boolean | | def f { | <caret>do { | print("") | //comment | } while(flag) | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | print("") | //comment | while (flag) { | print("") | //comment | } | } |}""".stripMargin	String	resultText
s"""class X { | val flag: Boolean | | def f { | do<caret> { | print("") | //comment | } while(flag) | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | do { | print("") | //comment | } <caret>while(flag) | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | do { | print("") | //comment | } while<caret>(flag) | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | if (true) | do { | print("") | } while<caret>(flag) | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | if (true) { | print("") | while (flag) { | print("") | } | } | } |}""".stripMargin	String	resultText
s"""class X { | val flag: Boolean | | def f { | <caret>do print("") | while(flag) | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | print("") | while (flag) print("") | } |}""".stripMargin	String	resultText
s"""class X { | val flag: Boolean | | def f { | <caret>do print("") while(flag) | } |}""".stripMargin	String	text
s"""class X { | 1 match { | case 1 => | <caret>do { | print("") | } while (true) | } |}""".stripMargin	String	text
s"""class X { | 1 match { | case 1 => | print("") | while (true) { | print("") | } | } |}""".stripMargin	String	resultText
s""" |class X { | val flag: Boolean | | def f { | ${CARET}while(flag) { | //looping | } | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | if (flag) { | do { | //looping | } while (flag) | } | } |}""".stripMargin	String	resultText
s"""class X { | val flag: Boolean | | def f { | while$CARET(flag) { | //looping | } | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | while$CARET(flag) print("") | } |}""".stripMargin	String	text
s"""class X { | val flag: Boolean | | def f { | if (flag) { | do print("") while (flag) | } | } |}""".stripMargin	String	resultText
Seq("public", "protected", "private").filter(_ != modifierCodeToName(current))	Seq[Nothing]	expectedModifiers
s""" |$context ExampleClass { | $originalModifier$originalSpace$declType$CARET example = Unit |} |""".stripMargin	String	original
s""" |$context ExampleClass { | $newModifier$newSpace$declType example = Unit |} |""".stripMargin	String	result
Seq("", "protected", "private")	Seq[Nothing]	modifier
s"""object A { | val x = 42 | ${CARET}s"one $$x two" |} |"""	String	before
s"""object A { | val x = 42 | $CARET"one " + x + " two" |} |"""	String	after
s"""object A { | val x = 42 | ${CARET}s"one $$x two".length |} |"""	String	before
s"""object A { | val x = 42 | $CARET("one " + x + " two").length |} |"""	String	after
s"""object A { | val x = 42 | ${CARET}s"one $$x two".substring(23) |} |"""	String	before
s"""object A { | val x = 42 | $CARET("one " + x + " two").substring(23) |} |"""	String	after
s"""object A { | val x = 42 | ${CARET}s"one $$x two" length |} |"""	String	before
s"""object A { | val x = 42 | $CARET("one " + x + " two") length |} |"""	String	after
s"""object A { | val x = 42 | obj foo ${CARET}s"one $$x two" |} |"""	String	before
s"""object A { | val x = 42 | obj foo $CARET("one " + x + " two") |} |"""	String	after
s"""object A { | "one ${CARET}two" |} """	String	before
s"""object A { | \"\"\"one ${CARET}two\"\"\" |} """	String	after
s"""object A { | $CARET"one two" |} """	String	before
s"""object A { | $CARET\"\"\"one two\"\"\" |} """	String	after
s"""object A { | "$CARET" |} """	String	before
s"""object A { | \"\"\"$CARET\"\"\" |} """	String	after
s"""object A { | ${CARET}interp"one$${iterpVal}two" |} """	String	before
s"""object A { | ${CARET}interp\"\"\"one$${iterpVal}two\"\"\" |} """	String	after
s"""object A { | interp$CARET"one$${iterpVal}two" |} """	String	before
s"""object A { | interp$CARET\"\"\"one$${iterpVal}two\"\"\" |} """	String	after
s"""object A { | s"one$${iterpVal}${CARET}two" |} """	String	before
s"""object A { | s\"\"\"one$${iterpVal}${CARET}two\"\"\" |} """	String	after
s"""object A { | interp"one$${iterpVal}${CARET}two" |} """	String	before
s"""object A { | interp\"\"\"one$${iterpVal}${CARET}two\"\"\" |} """	String	after
s"""object A { | interp"one$${iterp${CARET}Val}two" |} """	String	before
s"""object A { | interp\"\"\"one$${iterp${CARET}Val}two\"\"\" |} """	String	after
s"""object A { | "${CARET}one\\ntwo\\nthree\\nfour" |} """	String	before
s"""object A { | \"\"\"${CARET}one | |two | |three | |four\"\"\".stripMargin |} """	String	after
s"""object A { | "one\\n${CARET}two\\nthree\\nfour" |} """	String	before
s"""object A { | \"\"\"one | |${CARET}two | |three | |four\"\"\".stripMargin |} """	String	after
s"""object A { | "one\\ntwo\\nthree\\n${CARET}four" |} """	String	before
s"""object A { | \"\"\"one | |two | |three | |${CARET}four\"\"\".stripMargin |} """	String	after
s"""object A { | "one\\ntwo\\nthree\\nfour\\n${CARET}five" |} """	String	before
s"""object A { | \"\"\"one | |two | |three | |four | |${CARET}five\"\"\".stripMargin |} """	String	after
s"""object A { | \"\"\"one | |${CARET}two\"\"\" |} """	String	before
s"""object A { | "one\\n |${CARET}two" |} """	String	after
s"""object A { | \"\"\"one | |two | |${CARET}three\"\"\".stripMargin |} """	String	before
s"""object A { | "one\\ntwo\\n${CARET}three" |} """	String	after
s"""object A { | \"\"\"one | |two | $CARET |three\"\"\".stripMargin |} """	String	before
s"""object A { | val value = $CARET"one\\ntwo\\nthree\\nfour" |} """	String	before
s"""object A { | val value = | $CARET\"\"\"one | |two | |three | |four\"\"\".stripMargin |} """	String	after
s"""object A { | val value = | $CARET"one\\ntwo\\nthree\\nfour" |} """	String	afterAfter
s"""object A { | val value = "${CARET}one\\ntwo\\nthree\\nfour" |} """	String	before
s"""object A { | val value = | \"\"\"${CARET}one | |two | |three | |four\"\"\".stripMargin |} """	String	after
s"""object A { | val value = | "${CARET}one\\ntwo\\nthree\\nfour" |} """	String	afterAfter
s"""object A { | val value = "one\\n${CARET}two\\nthree\\nfour" |} """	String	before
s"""object A { | val value = | \"\"\"one | |${CARET}two | |three | |four\"\"\".stripMargin |} """	String	after
s"""object A { | val value = | "one\\n${CARET}two\\nthree\\nfour" |} """	String	afterAfter
s"""object A { | val value = "one\\ntwo\\nthree\\n${CARET}four" |} """	String	before
s"""object A { | val value = | \"\"\"one | |two | |three | |${CARET}four\"\"\".stripMargin |} """	String	after
s"""object A { | val value = | "one\\ntwo\\nthree\\n${CARET}four" |} """	String	afterAfter
s"""object A { | val value = interp"one\\ntwo\\nthree\\n${CARET}four" |} """	String	before
s"""object A { | val value = | interp\"\"\"one | |two | |three | |${CARET}four\"\"\".stripMargin |} """	String	after
s"""object A { | val value = | interp"one\\ntwo\\nthree\\n${CARET}four" |} """	String	afterAfter
s"""val InjectedVar = "42" |val x = s"class$CARET A { val a = f\\\"\\\"\\\"$$InjectedVar\\\"\\\"\\\" }" |"""	String	before
s"""val InjectedVar = "42" |val x = s\"\"\"class$CARET A { val a = f\\\"\\\"\\\"$$InjectedVar\\\"\\\"\\\" }\"\"\" |"""	String	after
s"""val InjectedVar = "42" |val x = "class$CARET A { val a = f\\\"\\\"\\\"$$InjectedVar\\\"\\\"\\\" }" |"""	String	before
s"""val InjectedVar = "42" |val x = s\"\"\"class$CARET A { val a = f\\\"\\\"\\\"$$$$InjectedVar\\\"\\\"\\\" }\"\"\" |"""	String	after
s"""val x = "A \\\"\\\"\\\" $$ $CARET B" |""".stripMargin	String	before
s"""val x = s\"\"\"A \\\"\\\"\\\" $$$$ $CARET B\"\"\" |"""	String	after
s"""val InjectedVar = "42" |val x = "class$CARET A { val a = f\\\"\\\"$$InjectedVar\\\"\\\" }" |"""	String	before
s"""val InjectedVar = "42" |val x = \"\"\"class$CARET A { val a = f\"\"$$InjectedVar\"\" }\"\"\" |"""	String	after
new ScalaGenerateEqualsAction.Handler	LanguageCodeInsightActionHandler	handler
s"""class A (i: Int, val j: Int) { | val x = 0$CARET_MARKER | var y = 0 | private val z = 0 |}"""	String	text
s"""final class$CARET_MARKER A (i: Int, val j: Int) { | private val z = 0 |}"""	String	text
s"""abstract class A (i: Int, val j: Int) extends Set[Int] { | private val z = 0 | |$CARET_MARKER}"""	String	text
s"""abstract class A (i: Int, val j: Int) extends Set[Int] { | private val z = 0 | | override def canEqual(other: Any): Boolean = other.isInstanceOf[A] | | override def equals(other: Any): Boolean = other match { | case that: A => | super.equals(that) && | (that canEqual this) && | z == that.z && | j == that.j | case _ => false | } | | override def hashCode(): Int = { | val state = Seq(super.hashCode(), z, j) | state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b) | } |}"""	String	result
s"""class A { | val a = 0 | | def canEqual(other: Any): Boolean = other.isInstanceOf[A] | | override def equals(other: Any): Boolean = other match { | case that: A => | (that canEqual this) && | a == that.a | case _ => false | } | | override def hashCode(): Int = { | val state = Seq(a) | state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b) | } |} | |class B (i: Int, val j: Int) extends A { | val z = 0$CARET_MARKER |}"""	String	text
s"""class A { | val a = 0 |} | |class B (i: Int, val j: Int) extends A { | val z = 0$CARET_MARKER |}"""	String	text
new ScalaGeneratePropertyAction.Handler	LanguageCodeInsightActionHandler	handler
s"""class A { | ${CARET_MARKER}var a: Int = 0 |}"""	String	text
s"""class A { | private[this] var _a: Int = 0 | | def a: Int = _a | | def a_=(value: Int): Unit = { | _a = value | } |}"""	String	result
s"""object A { | ${CARET_MARKER}var a = 0 |}"""	String	text
s"""object A { | private[this] var _a: Int = 0 | | def a: Int = _a | | def a_=(value: Int): Unit = { | _a = value | } |}"""	String	result
s"""class A { | protected ${CARET_MARKER}var a = 0 |}"""	String	text
s"""class A { | private[this] var _a: Int = 0 | | protected def a: Int = _a | | protected def a_=(value: Int): Unit = { | _a = value | } |}"""	String	result
new ScalaGenerateToStringAction.Handler	LanguageCodeInsightActionHandler	handler
s"""class A (i: Int, val j: Int) { | val x = 0$CARET_MARKER | var y = 0 | | def w(x: Int) = 42 | | def v = -3 | | def u() = 123 | | private val z = 0 |}"""	String	text
s"""class A() { | $CARET_MARKER |}"""	String	text
s"""object Obj { | val a = 1 | | def b = 2 | $CARET_MARKER |}"""	String	text
s"""trait T { | val a = 1 | | def b = 2 | $CARET_MARKER |}"""	String	text
true	Boolean	stripTrailingSpaces
new ScalaGenerateCompanionObjectAction.Handler	LanguageCodeInsightActionHandler	handler
s"""case class A(x: Int, s: String) { | def foo() {} | $CARET_MARKER |}"""	String	text
s"""class A(x: Int, s: String) { | def foo() {} | $CARET_MARKER |} | |object A {} |"""	String	text
s"""object A { $CARET_MARKER | def foo() {} | val bar = 1 |}"""	String	text
s"""object A { | val runnable = new Runnable { | def run() {} $CARET_MARKER | } |}"""	String	text
s"""class A(x: Int, s: String) { | def foo() {} |$CARET_MARKER |}"""	String	text
s"""class A(x: Int, s: String) { | def foo() {} | |} | |object A { | $CARET_MARKER |}"""	String	result
s"""trait A { | def foo() {$CARET_MARKER} | |}"""	String	text
s"""trait A { | def foo() {} | |} | |object A { | $CARET_MARKER |}"""	String	result
s"""trait A { | def foo() | class B { | def bar()$CARET_MARKER = 1 | } |}"""	String	text
s"""trait A { | def foo() | class B { | def bar() = 1 | } | | object B { | $CARET_MARKER | } | |}"""	String	result
'\"'	Char	QuoteCharacter
'`'	Char	PatternCharacter
'\''	Char	CharCharacter
QuoteCharacter + (QuoteCharacter + Caret + QuoteCharacter) + QuoteCharacter	Int	QuotedCaret
(_: Inlay[_]).getRenderer match { case renderer: HintRenderer => Some(renderer.getText) case _ => None }	Inlay[_] => Option[Nothing]	inlayText
configuration.plugins.map(id => mavenProject.localPathTo(id).getPath)	IndexedSeq[Any]	plugins
{ val plugins = configuration.plugins.map(id => mavenProject.localPathTo(id).getPath) configuration.compilerOptions ++ plugins.map(path => "-Xplugin:" + path) }	IndexedSeq[Any]	compilerOptions
modelsProvider.getAllLibraries .find { library => library.getName.contains("scala-library") && library.compilerVersion.contains(version) }.getOrElse { throw new ExternalSystemException(s"Cannot find project Scala library $version for module ${module.getName}") }	Library	scalaLibrary
s"${id.artifactId}-${id.version}$suffix.jar"	String	jarName
elements("args", "arg").map(_.getTextTrim)	Seq[String]	args
resolvePluginConfig(configElementName = "addScalacArgs", userPropertyName = "addScalacArgs")	Option[String]	addScalacArgs
addScalacArgs.toSeq.flatMap(_.split("\\|"))	Seq[String]	addScalacArgsSplit
Seq( options.isDeprecation -> "-deprecation", options.isUnchecked -> "-unchecked", options.isOptimize -> "-optimise", !isEmpty(options.getDebugLevel) -> s"-g:${options.getDebugLevel}", !isEmpty(options.getEncoding) -> s"-encoding", // the encoding value needs to be a separate option, otherwise the -encoding flag and the value will be // treated as a single flag !isEmpty(options.getEncoding) -> options.getEncoding, !isEmpty(data.getTargetCompatibility) -> s"-target:jvm-${data.getTargetCompatibility}")	Seq[(Boolean, String)]	presentations
new NotificationData("Gradle Sync", message, NotificationCategory.WARNING, NotificationSource.PROJECT_SYNC)	NotificationData	notification
scalaVersion.map { version => new library { name := "org.scala-lang:scala-library:" + version } }	Option[ExternalSystemDataDsl.library]	scalaLibrary
new ScalaModelData(SbtProjectSystem.Id)	ScalaModelData	data
new javaModule { val moduleName = "module_main" name := moduleName projectId := moduleName projectURI := myProjectURI moduleFileDirectoryPath := getProject.getBasePath + "/module" externalConfigPath := getProject.getBasePath + "/module" scalaLibrary.foreach(libraryDependencies += _) }	ExternalSystemDataDsl.javaModule	productionModule
new ScalaCompileOptionsData()	ScalaCompileOptionsData	options
ModuleManager.getInstance(getProject).findModuleByName("module")	Module	module
{ val module = ModuleManager.getInstance(getProject).findModuleByName("module") ScalaCompilerConfiguration.instanceIn(getProject).getSettingsForModule(module) }	ScalaCompilerSettings	compilerConfiguration
Seq( "-Xplugin:test-plugin1.jar;test-plugin2.jar", "-Xexperimental", "-P:continuations:enable", "-language:dynamics", "-language:existentials", "-explaintypes", "-feature", "-language:higherKinds", "-language:implicitConversions", "-language:macros", "-language:postfixOps", "-language:reflectiveCalls", "-no-specialization", "-nowarn" )	Seq[Nothing]	additionalOptions
new ScalaCompileOptionsData	ScalaCompileOptionsData	options
ModuleManager.getInstance(getProject).findModuleByName("module_main")	Module	module
{ val module = ModuleManager.getInstance(getProject).findModuleByName("module_main") ScalaCompilerConfiguration.instanceIn(getProject).getSettingsForModule(module) }	ScalaCompilerSettings	compilerConfiguration
ModuleManager.getInstance(getProject).findModuleByName("module_test")	Module	module
{ val module = ModuleManager.getInstance(getProject).findModuleByName("module_test") ScalaCompilerConfiguration.instanceIn(getProject).getSettingsForModule(module) }	ScalaCompilerSettings	testCompilerConfiguration
new project { name := getProject.getName ideDirectoryPath := getProject.getBasePath linkedProjectPath := getProject.getBasePath arbitraryNodes += new Node[ScalaModelData] { override protected val data: ScalaModelData = new ScalaModelData(SbtProjectSystem.Id) override protected def key: Key[ScalaModelData] = ScalaModelData.KEY } }.build.toDataNode	DataNode[ProjectData]	testProject
fst.toInt	Int	fstInt
snd.toInt	Int	sndInt
for { sdk <- allAndroidSdks platform <- Option(AndroidPlatform.getInstance(sdk)) platformVersion = platform.getApiLevel.toString if isGEQAsInt(platformVersion, version) } yield sdk	IndexedSeq[Sdk]	matchingSdks
getModifiableFacetModel(module)	ModifiableFacetModel	model
new AndroidFacetType	AndroidFacetType	facetType
facetType.createFacet(module, "Android", facetType.createDefaultConfiguration(), null)	AndroidFacet	facet
facet.getConfiguration.getState	JpsAndroidModuleProperties	configuration
FacetManager.getInstance(module).getFacetByType(AndroidFacet.ID)	AndroidFacet	facet
facet.getConfiguration.getState	JpsAndroidModuleProperties	properties
using(Source.fromFile(proguardConfigPath))(_.getLines().toVector)	Vector[String]	actualProguardConfig
new project { name := getProject.getName ideDirectoryPath := getProject.getBasePath linkedProjectPath := getProject.getBasePath arbitraryNodes += new AndroidFacetNode(AndroidFacetData("", null, null, null, null, null, null, false, Seq.empty)) }.build.toDataNode	DataNode[ProjectData]	testProject
child match { case statement: ScImportStmt => statement :: result case _ => result }	List[ScImportStmt]	newResult
new PsiReferenceProvider { override def acceptsTarget(target: PsiElement): Boolean = target.isInstanceOf[IProperty] override def getReferencesByElement(element: PsiElement, context: ProcessingContext): Array[PsiReference] = element match { case ScalaPropertyReference(reference) => Array(reference) case _ => EMPTY_ARRAY } }	PsiReferenceProvider { def acceptsTarget(target: PsiElement): Boolean def getReferencesByElement(element: PsiElement, context: ProcessingContext): Array[PsiReference] }	scalaPropertiesReferenceProvider
(element: PsiElement, _: ProcessingContext) => Array(new ResourceBundleReference(element))	PsiReferenceProvider	resourceBundleReferenceProvider
(element: PsiElement, _: ProcessingContext) => element match { case JavaPropertyReferences(references) => references case _ => EMPTY_ARRAY }	PsiReferenceProvider	propertyValueReferenceProvider
new JavaClassReferenceProvider	JavaClassReferenceProvider	provider
{ val provider = new JavaClassReferenceProvider provider.setSoft(true) provider }	JavaClassReferenceProvider	referenceProvider
element.asInstanceOf[ScalaFile]	ScalaFile	file
ScalaI18nUtil.getI18nProperty(project, literal)	IProperty	property
argsList.exprsArray	Array[ScExpression]	exprs
ScalaI18nUtil.formatI18nProperty(literal, property)	String	msg
ScalaI18nUtil.getPropertyValueParamsMaxCount(literal)	Int	count
argsList.exprsArray	Array[ScExpression]	args
new ScalaConstantExpressionEvaluator	ScalaConstantExpressionEvaluator	evaluator
args.drop(1).forall { arg => arg.isInstanceOf[ScReferenceExpression] || evaluator.computeConstantExpression(arg, throwExceptionOnOverflow = false) != null }	Boolean	refOrValue
element.getTextRange.getStartOffset	Int	offset
new PropertyImpl(new PropertyStubImpl(null, null), PropertiesElementTypes.PROPERTY)	IProperty	NULL
50	Int	FOLD_MAX_LENGTH
Key.create("i18n.property.cache")	Key[IProperty]	CACHE
literal.getUserData(CACHE)	IProperty	property
new mutable.HashMap[String, AnyRef]	mutable.HashMap[String, AnyRef]	annotationAttributeValues
mustBePropertyKey(literal, annotationAttributeValues)	Boolean	isI18n
argList.exprs.indexOf(literal)	Int	idx
expression.withParentsInFile.takeWhile(_.isInstanceOf[ScExpression])	Iterator[PsiElement]	exprs
myProcessed	mutable.HashSet[PsiMethod]	processed
null	PsiParameter	param
params.last	PsiParameter	lastParam
AnnotationUtil.findAnnotation(param, annFqn)	PsiAnnotation	annotation
annotation.getParameterList	PsiAnnotationParameterList	parameterList
parameterList.getAttributes	Array[PsiNameValuePair]	attributes
attribute.getName	String	name
method.findSuperMethods	Array[PsiMethod]	superMethods
false	Boolean	containedInPropertiesFile
context.getContainingFile	PsiFile	containingFile
containingFile.getContext	PsiElement	containingFileContext
containingFile.getVirtualFile	VirtualFile	virtualFile
ProjectRootManager.getInstance(project).getFileIndex.getModuleForFile(virtualFile)	Module	module
PropertiesReferenceManager.getInstance(project)	PropertiesReferenceManager	refManager
getI18nProperty(project, literal)	IProperty	property
literal.getUserData(CACHE).asInstanceOf[Property]	Property	property
literal.getReferences	Array[PsiReference]	references
polyVarRef.multiResolve(false)	Array[ResolveResult]	results
result.getElement	PsiElement	element
reference.resolve	PsiElement	element
-1	Int	maxCount
result.getElement.asInstanceOf[IProperty].getValue	String	value
format.getFormatsByArgumentIndex.length	Int	count
getPropertyValueParamsMaxCount(lit)	Int	count
getI18nMessage(project, lit)	String	text
file.findPropertyByKey(key)	IProperty	existingProperty
editor.getSelectionModel.getSelectedText	String	selectedText
psiFile.findElementAt(editor.getCaretModel.getOffset)	PsiElement	psiElement
new UnresolvedPropertyVisitor(manager, isOnTheFly)	ScalaInvalidPropertyKeyInspection.this.UnresolvedPropertyVisitor	visitor
CodeInsightBundle.message("inspection.unresolved.property.key.reference.message", key)	String	description
myExpression	ScExpression	expression
value.asInstanceOf[String]	String	key
new Ref[String]	Ref[String]	resourceBundleName
PropertiesReferenceManager.getInstance(expression.getProject)	PropertiesReferenceManager	manager
ModuleUtilCore.findModuleForPsiElement(expression)	Module	module
CodeInsightBundle.message("inspection.invalid.resource.bundle.reference", key)	String	description
myManager.createProblemDescriptor(expression, description, null.asInstanceOf[LocalQuickFix], ProblemHighlightType.LIKE_UNKNOWN_SYMBOL, onTheFly)	ProblemDescriptor	problem
new mutable.HashMap[String, AnyRef]	mutable.HashMap[String, AnyRef]	annotationParams
expressions.getParent.asInstanceOf[ScMethodCall]	ScMethodCall	methodCall
expressions.exprsArray	Array[ScExpression]	args
method.parameters	Seq[PsiParameter]	parameters
findReferenceAtCaret	PsiReference	reference
reference.resolve()	PsiElement	resolved
literalsOf(host)	Seq[ScalaLanguageInjector.StringLiteral]	literals
support	ScalaLanguageInjectionSupport	s
registrar	MultiHostRegistrar	r
ScalaProjectSettings.getInstance(host.getProject)	ScalaProjectSettings	projectSettings
host.depthFirst { case expression: ScExpression => !expression.getParent.isInstanceOf[ScInterpolatedStringLiteral] case _ => true }.toList.filter(_.isInstanceOf[ScExpression])	List[PsiElement]	expressions
expressions.forall { case l: ScLiteral if l.isString => true case _: ScInterpolatedPatternPrefix | _: ScInfixExpr => true case r: ScReferenceExpression if r.getText == "+" => true case expression => expression.getParent.isInstanceOf[ScInterpolatedStringLiteral] }	Boolean	suitable
for { interpolated <- interpolatedLiterals reference <- interpolated.reference langId = mapping.get(reference.getText) if StringUtils.isNotBlank(langId) } yield langId	IndexedSeq[Any]	languages
Language.findLanguageByID(langId)	Language	language
support.findCommentInjection(host, null)	BaseInjection	injection
injection.getInjectedLanguageId	String	langId
if (literalIdx == 0) prefix else ""	String	litPrefix
if (literalIdx == literals.size - 1) suffix else ""	String	litSuffix
extractMultiLineStringRanges(literal)	Seq[TextRange]	rangesCollected
lineIdx == rangesCollected.length - 1	Boolean	isLastLine
if (lineIdx == 0) litPrefix else ""	String	prefixActual
if (isLastLine) litSuffix else ""	String	suffixActual
if (isLastLine) lineRange else lineRange.grown(1)	TextRange	rangeActual
host match { case literal: ScLiteral => if (literal.isString) annotationOwnerForStringLiteral(literal) else None case _ => annotationOwnerFor(host) //.orElse(implicitAnnotationOwnerFor(host)) // TODO implicit conversion checking (SCL-2599), disabled (performance reasons) }	ScalaLanguageInjector.MaybeAnnotationOwner	maybeAnnotationOwner
for { annotationOwner <- maybeAnnotationOwner annotation <- annotationOwner.getAnnotations .find(_.getQualifiedName == qualifiedName) languageId <- readAttribute(annotation, "value") language = InjectedLanguage.findLanguageById(languageId) if language != null } yield (annotation, language)	Option[(PsiAnnotation, Language)]	maybePair
TemporaryPlacesRegistry.getInstance(host.getProject)	TemporaryPlacesRegistry	registry
Key.create[(MaybeAnnotationOwner, Long)]("scala.annotation.owner")	Key[(ScalaLanguageInjector.MaybeAnnotationOwner, Long)]	OwnerKey
InjectedLanguage.findLanguageById(langId)	Language	language
InjectedLanguage.create( langId, injection.getPrefix, injection.getSuffix, false )	InjectedLanguage	injectedLanguage
BlockModificationTracker(stringLiteral).getModificationCount	Long	modCount
annotationOwnerFor(stringLiteral)	ScalaLanguageInjector.MaybeAnnotationOwner	result
getRangeInElement(literal)	TextRange	range
range.getStartOffset	Int	rangeStartOffset
mutable.MutableList[TextRange]()	mutable.MutableList[TextRange]	rangesCollected
MultilineStringUtil.getMarginChar(literal)	Char	marginChar
new immutable.WrappedString(extractedText).lines	Iterator[String]	lines
line.length	Int	lineLength
line.prefixLength(_.isWhitespace)	Int	wsPrefixLength
wsPrefixLength < line.length && line.charAt(wsPrefixLength) == marginChar	Boolean	lineHasMargin
if (lineHasMargin) wsPrefixLength + 1 else 0	Int	shift
rangeStartOffset + count + shift	Int	start
count + 1 + rangeStartOffset	Int	end
injectedLanguage.getLanguage	Language	language
testExpr match { case MethodInvocation(ElementText(text), _) => text case ref: ScReferenceExpression => ref.refName case _ => null }	String	name
methodInv.getEffectiveInvokedExpr.asOptionOf[ScReferenceExpression]	Option[ScReferenceExpression]	refOpt
f.parameters	Seq[ScParameter]	parameters
m.parameters	Seq[PsiParameter]	parameters
target match { case p: ScReferencePattern => p.getParent.getParent case field: PsiField => field.getModifierList case _ => target }	PsiElement	context
ScalaProjectSettings.getInstance(module.getProject)	ScalaProjectSettings	settings
s"""//language=JSON |"{$Caret \\\"a\\\" : 42 }" |""".stripMargin	String	body
s"""//language=JSON |$Quotes{$Caret "a" : 42 }$Quotes |""".stripMargin	String	body
s"""class A { | //language=JSON | $Quotes{ | "a" : 42$Caret |}$Quotes |} |""".stripMargin	String	body
s"""//language=JSON |$Quotes{ | | "a" : 42$Caret | |}$Quotes.stripMargin |""".stripMargin	String	body
s"""//language=JSON |$Quotes{ | # "a" : 42$Caret | #}$Quotes.stripMargin('#') |""".stripMargin	String	body
s"""json"{$Caret \\\"a\\\" : 42 }""""	String	body
s"""json$Quotes{$Caret "a" : 42 }$Quotes"""	String	body
s"""class A { | json$Quotes{ | "a" : 42$Caret |}$Quotes |} |""".stripMargin	String	text
s"""json$Quotes{ | | "a" : 42$Caret | |}$Quotes.stripMargin |""".stripMargin	String	body
s"""def foo(@Language("JSON") param: String): Unit = ??? |foo("{$Caret \\\"a\\\" : 42 }") |""".stripMargin	String	body
s"""def foo(@Language("JSON") param: String): Unit = ??? |foo($Quotes{$Caret "a" : 42 }$Quotes) |""".stripMargin	String	body
s"""$LanguageAnnotationDef |class A { | def foo(@Language("JSON") param: String): Unit = ??? | foo($Quotes{ | "a" : 42$Caret |}$Quotes | ) |} |""".stripMargin	String	text
s"""$LanguageAnnotationDef |class A { | def foo(@Language("JSON") param: String): Unit = ??? | foo($Quotes{ | | "a" : 42$Caret | |}$Quotes.stripMargin) |} |""".stripMargin	String	text
s"""//language=JSON |"[{$Caret \\\"a\\\" : 42 }" + |", { \\\"b\\\" : 23 }]" |""".stripMargin	String	body
s"""//language=JSON |"[{$Caret \\\"a\\\" : 42 },\\n" + |"{ \\\"b\\\" : 23 }]" |""".stripMargin	String	body
s"""//language=JSON |$Quotes[{$Caret "a" : 42 }$Quotes + |$Quotes, { "b" : 23 }]$Quotes |""".stripMargin	String	body
s"""class A { | //language=JSON | $Quotes[{$Caret "a" : 42 }, |$Quotes + | $Quotes{ "b" : 23 }]$Quotes |} |""".stripMargin	String	body
s"""class A { | //language=JSON | $Quotes[{ | "a" : 42$Caret |}$Quotes + $Quotes, { | "b" : 23 |}]$Quotes |} |""".stripMargin	String	body
s"""class A { | //language=JSON | $Quotes[ | { | "a" : 42$Caret | },$Quotes + | $Quotes | { | "b" : 23 | } |]$Quotes |} |""".stripMargin	String	body
intelliLangConfig.getInjections("scala").asScala	Seq[BaseInjection]	injections
place.getElementPattern match { case laz: LazyPresentablePattern[_] => // in case of failure `PatternCompilerImpl.onCompilationFailed` will be called and test will fail laz.getCompiledPattern case p => p }	ElementPattern[_ <: PsiElement]	pattern
s"""val x = | //language=JSON | $Quotes{ | | "a" : 42,$Caret | | "b" : 23 | |}$Quotes.stripMargin |"""	String	before
s"""val x = | //language=JSON | $Quotes{ | | "a" : 42, | | $Caret | | "b" : 23 | |}$Quotes.stripMargin |"""	String	after
s"""val x = | //language=JSON | $Quotes{ | # "a" : 42,$Caret | # "b" : 23 | #}$Quotes.stripMargin('#') |"""	String	before
s"""val x = | //language=JSON | $Quotes{ | # "a" : 42, | # $Caret | # "b" : 23 | #}$Quotes.stripMargin('#') |"""	String	after
s"""val x = | //language=JSON | s$Quotes{ | | "a" : 42,$Caret | | "b" : 23 | |}$Quotes.stripMargin |"""	String	before
s"""val x = | //language=JSON | s$Quotes{ | | "a" : 42, | | $Caret | | "b" : 23 | |}$Quotes.stripMargin |"""	String	after
s"""val x = | //language=JSON | s$Quotes{ | # "a" : 42,$Caret | # "b" : 23 | #}$Quotes.stripMargin('#') |"""	String	before
s"""val x = | //language=JSON | s$Quotes{ | # "a" : 42, | # $Caret | # "b" : 23 | #}$Quotes.stripMargin('#') |"""	String	after
_	InjectionTestFixture	injectionTestFixture
_	Configuration	intelliLangConfig
s"class $LanguageAnnotationName(val value: String) extends scala.annotation.StaticAnnotation"	String	LanguageAnnotationDef
ExpectedInjection( injectedFileText.withNormalizedSeparator, injectedLangId )	AbstractLanguageInjectionTestCase.ExpectedInjection	expected
head._2	PsiFile	injectedFile
s"""class A { | $classBodyWithIndent |} |""".stripMargin	String	text
s"""$LanguageAnnotationDef |class A { | $classBodyWithIndent |} |""".stripMargin	String	text
s"""$LanguageAnnotationDef |$text |""".stripMargin	String	textFinal
getClassfile(event)	Option[ScFile]	classFile
ScalaDecompilerService().decompile(file)	Try[String]	tryDecompile
getOrCreateDummyRoot()	VirtualFile	root
DummyFileSystem.getInstance().createChildFile(null, root, decompiledName)	VirtualFile	result
s"dummy://$scalaDecompiledFolder"	String	scalaDecompiledRoot
inReadAction { mappingsForClassfile(file.getVirtualFile) }	Map[Any, ScalaDecompilerServiceImpl.FileContents]	mappings
new ScalaResultSaver	ScalaDecompilerServiceImpl.ScalaResultSaver	saver
(externalPath, _) => { val path = new File(FileUtil.toSystemIndependentName(externalPath)) mappings.get(path).map(_.apply()).orNull }	IBytecodeProvider	provider
new BaseDecompiler(provider, saver, options, new IdeaLogger())	BaseDecompiler	decompiler
mutable.Map.empty[String, String]	mutable.Map[String, String]	decompiledTexts
new AttachSourcesAction { override def getName: String = "Decompile to Java" override def getBusyText: String = "Scala Classfile" override def perform(list: ju.List[LibraryOrderEntry]): ActionCallback = { ScalaBytecodeDecompileTask.showDecompiledJavaCode(file) ActionCallback.DONE } }	AttachSourcesProvider.AttachSourcesAction { def perform(list: Any): ActionCallback def getBusyText: String def getName: String }	action
Option(file.getParent) .map(_.getName) .contains(ScalaBytecodeDecompileTask.scalaDecompiledFolder)	Boolean	isDecompiled
chunk.representativeTarget.getModule	JpsModule	module
SettingsManager.getScalaSdk(module) .fold(Right(None): Either[String, Option[CompilerJars]]) { sdk => compilerJarsInSdk(sdk).fold( { case (kind, files) => val (messagePrefix, messageInfix) = if (files.isEmpty) ("No", "") else ("Multiple", s" files (${files.map(_.name).mkString(", ")})") Left(s"$messagePrefix '$kind*$JarExtension'$messageInfix in Scala compiler classpath in Scala SDK ${sdk.getName}") }, { case jars @ CompilerJars(library, compiler, extra) => val absentJars = for { file <- library +: compiler +: extra if !file.exists } yield file.getPath Either.cond(absentJars.isEmpty, Some(jars), s"Scala compiler JARs not found (module '${module.getName}'): ${absentJars.mkString(", ")}" ) } ) }	Either[String, Option[CompilerJars]]	compilerJars
context.getProjectDescriptor	ProjectDescriptor	descriptor
model.getGlobal	JpsGlobal	global
chunk.representativeTarget	ModuleBuildTarget	target
target.getModule	JpsModule	module
SettingsManager.getProjectSettings(module.getProject).getCompilerSettings(chunk)	CompilerSettings	compilerSettings
scalaOptionsFor(compilerSettings, chunk)	Array[String]	scalaOptions
compilerSettings.getCompileOrder	CompileOrder	order
s"""Unknown build target output directory: $output |Current outputs: |${outputToCacheMap.keys.mkString("\n")} """.stripMargin	String	message
{ val encoding = context.getProjectDescriptor.getEncodingConfiguration.getPreferredModuleChunkEncoding(chunk) Option(encoding).map(Seq("-encoding", _)).getOrElse(Seq.empty) }	Seq[Nothing]	commonOptions
javaOptionsFor(context, chunk)	Seq[String]	javaOptions
createOutputGroups(chunk)	Seq[(Any, Any)]	outputGroups
sources.map(_.getCanonicalFile)	IndexedSeq[Any]	canonicalSources
!JavaBuilderUtil.isCompileJavaIncrementally(context) && !JavaBuilderUtil.isForcedRecompilationAllJavaModules(context)	Boolean	isCompile
extraOptions(target, context, module, outputGroups)	Seq[String]	additionalOptions
if (CompilerData.needBootCp(chunk.getModules.asScala.toSet)) Seq("-nobootcp", "-javabootclasspath", File.pathSeparator) else Seq.empty	Seq[Nothing]	noBootCp
noBootCp ++: compilerSettings.getCompilerOptions	IndexedSeq[Nothing]	scalaOptions
context.getProjectDescriptor.getProject	JpsProject	project
{ val project = context.getProjectDescriptor.getProject JpsJavaExtensionService.getInstance.getOrCreateCompilerConfiguration(project) }	JpsJavaCompilerConfiguration	compilerConfig
{ val module = chunk.representativeTarget.getModule compilerConfig.getAnnotationProcessingProfile(module) }	ProcessorConfigProfile	annotationProcessingProfile
targetsIn(context).collect { case target if target.getOutputDir != null => (target, target.getOutputDir) }	IndexedSeq[(ModuleBuildTarget, Nothing)]	targetToOutput
context.getProjectDescriptor.dataManager.getDataPaths	BuildDataPaths	paths
new ModuleChunk(Collections.singleton(target))	ModuleChunk	chunk
context.getProjectDescriptor.getBuildTargetIndex	BuildTargetIndex	buildTargetIndex
targetToOutput.groupBy(_._2).mapValues(_.map(_._1))	Map[Any, IndexedSeq[ModuleBuildTarget]]	outputToTargetsMap
targets.map(_.getPresentableName).mkString(", ")	String	targetNames
outputToTargetsMap.collect { case (output, targets) if output != null && targets.length > 1 => val targetNames = targets.map(_.getPresentableName).mkString(", ") "Output path %s is shared between: %s".format(output, targetNames) }	IndexedSeq[Any]	errors
compileAnalysis.asInstanceOf[Analysis]	Analysis	analysis
analysis.relations.srcProd.reverseMap	Map[Any, Set[Any]]	binaryToSource
providers.flatMap(_.zincLogFilter())	IndexedSeq[ZincLogFilter]	filters
{ val filters = providers.flatMap(_.zincLogFilter()) (severity: Kind, msg: String) => filters.forall(_.shouldLog(severity, msg)) }	ZincLogFilter	zincLogFilter
ServiceLoader.load(classOf[CachedCompilationService]) .iterator().asScala.toList	List[CachedCompilationService]	cachedCompilationServices
cachedCompilationServices.flatMap(_.createProvider(compilationData))	IndexedSeq[CachedCompilationProvider]	cacheProviders
cacheProviders.map{ provider => try provider.loadCache(analysisFromLocalStore.toOption) catch { case NonFatal(e) => loaderErrored(e) case e: ClassNotFoundException => loaderErrored(e) case e: NoClassDefFoundError => loaderErrored(e) } }	List[CacheResult]	cachedResults
cachedResults.find(_.content.nonEmpty) orElse cachedResults.headOption	Option[CacheResult]	cacheToUse
compilationData.outputToCacheMap.get(forCpEntry)	Option[Any]	cache
cache.map(fileToStore)	Option[AnalysisStore]	anaysisStore
loadAnalysis(classpathEntry)	Option[CompileAnalysis]	loaded
loadAnalysis(classpathEntry).map(AnalysisBaseDefinesClass)	Option[IntellijEntryLookup.this.AnalysisBaseDefinesClass]	analysisBasedDefine
Nil	Seq[Array[Any]]	_deleted
Nil	Seq[Array[Any]]	_generated
compilationData.zincData.allSources.toSet	Set[Any]	all
compilationData.sources.toSet	Set[Any]	changedSources
new WorksheetInProcessRunnerFactory	WorksheetInProcessRunnerFactory	plainFactory
new ILoopWrapperFactoryHandler	ILoopWrapperFactoryHandler	replFactory
new MyEncodingOutputStream(out, standalone)	WorksheetServer.MyEncodingOutputStream	printStream
Option(javaArgs.getReplArgs) map (ra => ReplArgs(ra.getSessionId, ra.getCodeChunk))	Option[WorksheetServer.ReplArgs]	replArgs
commonArgs.compilerData.compilerJars.orNull	CompilerJars	compilerJars
WorksheetArgsJava.constructArgsFrom( commonArgs.worksheetFiles.asJava, commonArgs.compilationData.sources.headOption.map(_.getName).orNull, compilerJars.library, compilerJars.compiler, compilerJars.extra.asJava, commonArgs.compilationData.classpath.asJava )	WorksheetArgsJava	javaArgs
1200	Int	capacity
WorksheetOutputEvent(new String(buffer.array(), 0, buffer.position()))	WorksheetOutputEvent	event
_	(Any, JavaILoopWrapperFactory, String)	replFactory
commonArguments.compilerData.compilerJars.orNull	CompilerJars	compilerJars
CompilerFactoryImpl.createScalaInstance(compilerJars)	ScalaInstance	scalaInstance
findScalaVersionIn(scalaInstance)	String	scalaVersion
new JavaILoopWrapperFactory	JavaILoopWrapperFactory	iLoopWrapper
message => client.progress(message)	JavaClientProvider	clientProvider
findScalaVersionIn(scalaInstance)	String	version
version.startsWith("2.13")	Boolean	is213
s"repl-wrapper-$version-${sbtData.javaClassVersion}-$WRAPPER_VERSION-$iLoopWrapperClass.jar"	String	replLabel
NullLogger	NullLogger.type	logger
new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto(), logger) { override def apply(sources: Seq[File], classpath: Seq[File], outputDirectory: File, options: Seq[String]): Unit = { super.apply(sources.filter(filter), classpath, outputDirectory, options) } }	RawCompiler { def apply(sources: Seq[Any], classpath: Seq[Any], outputDirectory: Any, options: Seq[String]): Unit }	rawCompiler
2	Int	WRAPPER_VERSION
compilerJars.library +: compilerJars.compiler +: compilerJars.extra	IndexedSeq[Any]	jars
IsolatingClassLoader.scalaStdLibIsolatingLoader(this.getClass.getClassLoader)	IsolatingClassLoader	parent
None	Option[(Set[Any], Set[Any], Any)]	classLoader
compilerUrls.toSet	Set[Any]	compilerSet
classpathUrls.toSet	Set[Any]	classpathSet
21	Int	TRACE_PREFIX
(Seq(worksheetArgs.pathToRunners, worksheetArgs.worksheetTemp) ++ worksheetArgs.outputDirs).map(_.toURI.toURL)	IndexedSeq[Any]	worksheetUrls
worksheetArgs.classpathUrls	Seq[Any]	classpathUrls
Seq(worksheetArgs.compilerJars.library, worksheetArgs.compilerJars.compiler) ++ worksheetArgs.compilerJars.extra	IndexedSeq[Any]	jars
worksheetArgs.compiledClassName	String	className
cleanStackTrace(ex, worksheetArgs.nameForST, className + "$" + className)	Throwable	exClean
new Array[StackTraceElement](length - TRACE_PREFIX + 1)	Array[Any]	newTrace
new util.LinkedHashMap[K, SoftReference[V]](capacity, 0.75F, true) { override def removeEldestEntry(eldest: Entry[K, SoftReference[V]]): Boolean = size > capacity }	{ def removeEldestEntry(eldest: Any): Boolean }	map
value	V	v
""	String	lastProgressMessage
if (source.isEmpty) compilerName else ""	String	name
source.map(file => file.getPath)	Option[Any]	sourcePath
text.split('\n')	Array[String]	lines
if (sourcePath.isDefined && line.isDefined && column.isDefined) { val lines = text.split('\n') lines.filterNot(_.trim == "^").mkString("\n") } else text	String	withoutPointer
None	Option[CompilerFactory]	cachedCompilerFactory
compilerFactoryFrom(sbtData, compilerData)	CompilerFactory	compilerFactory
new CachingFactory(firstEnabledCompilerFactory.map(_.get(sbtData)).getOrElse(new CompilerFactoryImpl(sbtData)), 10, 600, 10)	CachingFactory	factory
JpsLogger.getInstance(LocalServer.getClass.getName)	Logger	Log
FileAnalysisStore.binary(cacheFile)	AnalysisStore	store
new IncrementalCompilerImpl	IncrementalCompilerImpl	incrementalCompiler
compilationData.order match { case CompileOrder.Mixed => xsbti.compile.CompileOrder.Mixed case CompileOrder.JavaThenScala => xsbti.compile.CompileOrder.JavaThenScala case CompileOrder.ScalaThenJava => xsbti.compile.CompileOrder.ScalaThenJava }	CompileOrder	order
fileToStore(compilationData.cacheFile)	AnalysisStore	analysisStore
CompilationMetadata.load(analysisStore, client, compilationData)	CompilationMetadata	zincMetadata
getProgress(client)	SbtCompiler.this.ClientProgress	progress
getReporter(client)	Reporter	reporter
getLogger(client, zincLogFilter)	Logger	logger
IntellijExternalLookup(compilationData, client, cacheDetails.isCached)	IntellijExternalLookup	intellijLookup
new IntellijClassfileManager	IntellijClassfileManager	intellijClassfileManager
IncOptions.of() .withExternalHooks(IntelljExternalHooks(intellijLookup, intellijClassfileManager)) .withRecompileOnMacroDef(Optional.of(false)) .withTransitiveStep(5)	IncOptions	incOptions
incrementalCompiler.compilers(javaTools, scalac)	Compilers	cs
incrementalCompiler.setup( IntellijEntryLookup(compilationData, fileToStore), /*skip = */ false, compilationData.cacheFile, CompilerCache.fresh, incOptions, reporter, Option(progress), Array.empty)	Setup	setup
PreviousResult.create(Optional.of(previousAnalysis), previousSetup.toOptional)	PreviousResult	previousResult
incrementalCompiler.inputs( compilationData.classpath.toArray, compilationData.zincData.allSources.toArray, compilationData.output, compilationData.scalaOptions.toArray, compilationData.javaOptions.toArray, 100, Array(), order, cs, setup, previousResult)	Inputs	inputs
incrementalCompiler.compile(inputs, logger)	CompileResult	result
BinaryToSource(result.analysis, compilationData)	BinaryToSource	binaryToSource
Try { client.progress("Collecting incremental compiler data...") val result: CompileResult = incrementalCompiler.compile(inputs, logger) if (result.hasModified || cacheDetails.isCached) { analysisStore.set(AnalysisContents.create(result.analysis(), result.setup())) intellijClassfileManager.deletedDuringCompilation().foreach(_.foreach(client.deleted)) val binaryToSource = BinaryToSource(result.analysis, compilationData) def processGeneratedFile(classFile: File): Unit = { for (source <- binaryToSource.classfileToSources(classFile)) client.generated(source, classFile, binaryToSource.className(classFile)) } intellijClassfileManager.generatedDuringCompilation().flatten.foreach(processGeneratedFile) if (cacheDetails.isCached) previousAnalysis.asInstanceOf[Analysis].stamps.allProducts.foreach(processGeneratedFile) } result }	Try[CompileResult]	compilationResult
if (intellijClassfileManager.deletedDuringCompilation().isEmpty) compilationData.sources else BinaryToSource(previousAnalysis, compilationData) .classfilesToSources(intellijClassfileManager.deletedDuringCompilation().last) ++ compilationData.sources	Iterable[Any]	sourcesForInvalidation
s"""Compilation faild when compiling to: ${compilationData.output} | ${e.getMessage} | ${e.getStackTrace.mkString("\n ")} """.stripMargin	String	msg
sourceToTarget(source).getOrElse { throw new RuntimeException("Unknown source file: " + source) }	BuildTarget[_ <: BuildRootDescriptor]	target
new LazyCompiledClass(outputFile, source, name)	LazyCompiledClass	compiledClass
context.getProjectDescriptor.dataManager.getSourceToFormMap	OneToManyPathsMapping	sourceToForm
{ val sourceToForm = context.getProjectDescriptor.dataManager.getSourceToFormMap val sourcePath = FileUtil.toCanonicalPath(source.getPath) Option(sourceToForm.getState(sourcePath)).map(_.asScala.map(new File(_))) }	Option[Iterable[Any]]	boundForms
mutable.Set[File]()	mutable.Set[Any]	tempSuccessfullyCompiled
ArrayBuffer[PackageObjectBaseClass]()	ArrayBuffer[IdeClientIdea.this.PackageObjectBaseClass]	packageObjectsBaseClasses
compiledClass.getContent	BinaryContent	content
false	Boolean	isTemp
FileUtil.toSystemIndependentName(source.getPath)	String	sourcePath
context.getProjectDescriptor.getBuildRootIndex.findJavaRootDescriptor(context, source)	JavaSourceRootDescriptor	rootDescriptor
new ClassReader(content.getBuffer, content.getOffset, content.getLength)	ClassReader	reader
"Class dependency information may be incomplete! Error parsing generated class " + outputFile.getPath	String	message
Option(reader.getSuperName).filterNot(_ == "java/lang/Object")	Option[Nothing]	superClass
reader.getInterfaces.toSeq	Seq[Nothing]	interfaces
{ val superClass = Option(reader.getSuperName).filterNot(_ == "java/lang/Object") val interfaces = reader.getInterfaces.toSeq interfaces ++ superClass }	Seq[String]	baseTypes
new Cache[CompilerData, Compiler](compilersLimit)	Cache[CompilerData, Compiler]	compilerCache
new Cache[File, AnalysisStore](analysisLimit)	Cache[Any, AnalysisStore]	analysisCache
new Cache[(SbtData, Option[CompilerJars]), Option[AnalyzingCompiler]](scalacLimit)	Cache[(SbtData, Option[CompilerJars]), Option[AnalyzingCompiler]]	scalacCache
(file: File) => analysisCache.getOrUpdate(file)(fileToStore(file))	Nothing => AnalysisStore	cachingFileToStore
1000L	Long	cancelThreshold
false	Boolean	errorSeen
false	Boolean	warningSeen
problem.severity() match { case Severity.Info => Kind.INFO case Severity.Warn => warningSeen = true Kind.WARNING case Severity.Error => errorSeen = true Kind.ERROR }	BuildMessage.Kind	kind
problem.position()	Position	pos
{ val pos = problem.position() val indent = pos.pointerSpace.toOption.map("\n" + _ + "^").getOrElse("") s"${problem.message()}\n${pos.lineContent}\n$indent" }	String	messageWithLineAndPointer
-1L	Long	cacheStamp
Locate.definesClass(file)	DefinesClass	newDefines
None	Option[JavacOutputParsing.this.Header]	header
Vector.empty	Vector[String]	lines
(lines :+ line).mkString("\n")	String	text
mutable.HashMap[File, Set[File]]()	mutable.HashMap[Any, Set[Any]]	baseSourceToPackageObjects
mutable.HashMap[File, Set[File]]()	mutable.HashMap[Any, Set[Any]]	packageObjectToBaseSources
"package$"	String	packageObjectClassName
mutable.HashMap[File, PackageObjectsData]()	mutable.HashMap[Any, PackageObjectsData]	instances
getScalac(sbtData, compilerData.compilerJars, client)	Option[AnalyzingCompiler]	scalac
getScalaInstance(compilerData.compilerJars) .getOrElse(new ScalaInstance("stub", null, new File(""), new File(""), Array.empty, None))	ScalaInstance	scala
ClasspathOptionsUtil.javac(false)	ClasspathOptions	classpathOptions
{ val scala = getScalaInstance(compilerData.compilerJars) .getOrElse(new ScalaInstance("stub", null, new File(""), new File(""), Array.empty, None)) val classpathOptions = ClasspathOptionsUtil.javac(false) JavaTools.directOrFork(scala, classpathOptions, compilerData.javaHome) }	JavaTools	javac
Some(new ClassLoaderCache(new URLClassLoader(Array())))	Some[ClassLoaderCache]	classloaderCache
JpsLogger.getInstance(CompilerFactoryImpl.getClass.getName)	Logger	Log
new Cache[CompilerJars, ScalaInstance](3)	Cache[CompilerJars, ScalaInstance]	scalaInstanceCache
Map[Seq[File], ClassLoader]()	Map[Seq[Any], Any]	classLoadersMap
jars.library +: jars.compiler +: jars.extra	IndexedSeq[Any]	paths
Path.toURLs(paths)	Array[Any]	urls
readScalaVersionIn(classLoader)	Option[String]	version
scalaInstance.actualVersion	String	scalaVersion
new RawCompiler(scalaInstance, ClasspathOptionsUtil.auto, NullLogger)	RawCompiler	raw
getProgress(client)	IdeaIncrementalCompiler.this.ClientProgress	progress
new ZincLogFilter { override def shouldLog(serverity: Kind, msg: String): Boolean = true }	ZincLogFilter { def shouldLog(serverity: BuildMessage.Kind, msg: String): Boolean }	logFilter
getLogger(client, logFilter)	Logger	logger
new ClientCallback(client, compilationData.output.toPath)	ClientCallback	clientCallback
if (compilationData.outputGroups.size <= 1) CompileOutput(compilationData.output) else CompileOutput(compilationData.outputGroups: _*)	Output	out
new CompilerArguments(scalac.scalaInstance, scalac.classpathOptions)	CompilerArguments	cArgs
"IntellijIdea.simpleAnalysis" +: cArgs(Nil, compilationData.classpath, None, compilationData.scalaOptions)	IndexedSeq[String]	options
new Array[File](0)	Array[Any]	modifiedBinaries
new Array[String](0)	Array[String]	modifiedClasses
new LocalServer()	LocalServer	server
new WorksheetServer	WorksheetServer	worksheetServer
(event: Event) => { val encoded = Base64Converter.encode(event.toBytes) val encodedNormalized = if (standalone && !encoded.endsWith("=")) encoded + "=" else encoded val bytes = encodedNormalized.getBytes out.write(bytes) }	Event => Any	eventHandler
{ val eventHandler = (event: Event) => { val encoded = Base64Converter.encode(event.toBytes) val encodedNormalized = if (standalone && !encoded.endsWith("=")) encoded + "=" else encoded val bytes = encodedNormalized.getBytes out.write(bytes) } new EventGeneratingClient(eventHandler, out.checkError) { override def error(text: String, source: Option[File], line: Option[Long], column: Option[Long]): Unit = { hasErrors = true super.error(text, source, line, column) } override def message(kind: Kind, text: String, source: Option[File], line: Option[Long], column: Option[Long]): Unit = { if (kind == Kind.ERROR) hasErrors = true super.message(kind, text, source, line, column) } } }	EventGeneratingClient	client
decodeArguments(argsEncoded)	Arguments	args
argsEncoded.map(decodeArgument)	IndexedSeq[String]	args
new String(decoded, "UTF-8")	String	str
try { new String(Files.readAllBytes(path)) } catch { case _: IOException => throw new TokenVerificationException("Cannot read token: " + path) }	String	expectedToken
Option(System.getProperty("shutdown.delay")).map(_.toInt)	Option[Any]	delay
new TimerTask { override def run(): Unit = context.getNGServer.shutdown(true) }	{ def run(): Unit }	shutdownTask
compilerData.compilerJars.map(jars => filesToPaths(jars.library +: jars.compiler +: jars.extra))	Option[String]	compilerJarPaths
compilerData.incrementalType	IncrementalityType	incrementalType
SbtData.SourceJars(sourceJar_2_10, sourceJar_2_11, sourceJar_2_13)	SbtData.SourceJars	sourceJars
SbtData(sbtInterfaceJar, compilerInterfaceJar, sourceJars, interfacesHome, javaClassVersion)	SbtData	sbtData
compilerJarPaths.map { case PathsToFiles(Seq(libraryJar, compilerJar, extraJars @ _*)) => CompilerJars(libraryJar, compilerJar, extraJars) }	Option[CompilerJars]	compilerJars
javaHomePath.map { case PathToFile(file) => file }	Option[Any]	javaHome
IncrementalityType.valueOf(incrementalTypeName)	IncrementalityType	incrementalType
CompilerData(compilerJars, javaHome, incrementalType)	CompilerData	compilerData
outputs.zip(caches).toMap	Map[Any, Any]	outputToCacheMap
sourceRoots zip outputDirs	IndexedSeq[(Any, Any)]	outputGroups
ZincData(allSources, startDate.toLong, isCompile)	ZincData	zincData
CompilationData(sources, classpath, output, scalaOptions, javaOptions, CompileOrder.valueOf(order), cacheFile, outputToCacheMap, outputGroups, zincData)	CompilationData	compilationData
extractor[String, File] { path: String => new File(path) }	scala.Extractor[String, Any]	PathToFile
extractor[String, Seq[File]] { paths: String => if (paths.isEmpty) Seq.empty else paths.split(Delimiter).map(new File(_)).toSeq }	scala.Extractor[String, Seq[Any]]	PathsToFiles
extractor[String, Option[String]] { s: String => if (s.isEmpty) None else Some(s) }	scala.Extractor[String, Option[String]]	StringToOption
extractor[String, Seq[String]] { s: String => if (s.isEmpty) Seq.empty else s.split(Delimiter).toSeq }	scala.Extractor[String, Seq[String]]	StringToSequence
extractor[String, Boolean] { s: String => s.toBoolean }	scala.Extractor[String, Boolean]	StringToBoolean
readStringFrom(tokenPathFor(port)).getOrElse("NO_TOKEN")	String	token
Arguments(token, sbtData, compilerData, compilationData, Seq.empty).asStrings	Seq[String]	arguments
s"Cannot connect to compile server at ${address.toString}:$port"	String	firstLine
s"$firstLine\n$secondLine"	String	message
new AsynchEventGenerator(writeEvent)	AsynchEventGenerator	eventGenerator
readCachedOptions(scalacOptsCacheFile)	Option[String]	previousScalacOpts
getCurrentOptions(context, chunk)	String	currentOpts
previousScalacOpts.isEmpty || previousScalacOpts.get != currentOpts	Boolean	changeDetected
new Key[Set[String]]("MODULES_FED_TO_ZINC") {}	Key[Set[String]]	dataKey
ModulesFedToZincStore.get(context)	Set[String]	modulesFedToZinc
getValue(context)	Set[String]	previous
previous ++ moduleNames	Set[String]	next
collectDirtyFiles(dirtyFilesHolder) ++ sourceDependenciesDirtyFiles(chunk, dirtyFilesStorage)	IndexedSeq[Any]	dirtyFilesFromIntellij
CompilerOptionsStore.updateCompilerOptionsCache(context, chunk, moduleNames)	Boolean	compilerOptionsChanged
collectCompilableFiles(context, chunk)	Map[Any, BuildTarget[_ <: BuildRootDescriptor]]	sourceToBuildTarget
sourceToBuildTarget.keySet.toSeq	Seq[Any]	allSources
new IdeClientSbt("scala", context, moduleNames, outputConsumer, sourceToBuildTarget.get)	IdeClientSbt	client
context.getProjectDescriptor	ProjectDescriptor	project
SourceDependenciesProviderService.getSourceDependenciesFor(chunk)	Seq[JpsModule]	sourceModules
chunk.representativeTarget.getTargetType match { case JavaModuleBuildTargetType.PRODUCTION => ResourcesTargetType.PRODUCTION case JavaModuleBuildTargetType.TEST => ResourcesTargetType.TEST case _ => ResourcesTargetType.PRODUCTION }	ResourcesTargetType	targetType
{ val sourceModules = SourceDependenciesProviderService.getSourceDependenciesFor(chunk) val targetType = chunk.representativeTarget.getTargetType match { case JavaModuleBuildTargetType.PRODUCTION => ResourcesTargetType.PRODUCTION case JavaModuleBuildTargetType.TEST => ResourcesTargetType.TEST case _ => ResourcesTargetType.PRODUCTION } sourceModules.map(new ResourcesTarget(_, targetType)) }	Seq[ResourcesTarget]	resourceTargets
project.getBuildRootIndex	BuildRootIndex	rootIndex
{ val rootIndex = project.getBuildRootIndex resourceTargets.flatMap(rootIndex.getTargetRoots(_, context).asScala) }	Seq[ResourceRootDescriptor]	resourceRoots
project.getModuleExcludeIndex	ModuleExcludeIndex	excludeIndex
SourceDependenciesProviderService.getSourceDependenciesFor(chunk)	Seq[JpsModule]	sourceDependencies
collection.mutable.Buffer.empty[File]	mutable.Buffer[Any]	result
mutable.ArrayBuffer.empty[File]	ArrayBuffer[Any]	result
context.getProjectDescriptor.getBuildRootIndex	BuildRootIndex	rootIndex
context.getProjectDescriptor.getModuleExcludeIndex	ModuleExcludeIndex	excludeIndex
sourceDependencyTargets(chunk)	Seq[ModuleBuildTarget]	sourceTargets
chunk.representativeTarget.getTargetType match { case javaBuildTarget: JavaModuleBuildTargetType => javaBuildTarget case _ => JavaModuleBuildTargetType.PRODUCTION }	JavaModuleBuildTargetType	targetType
projectSettings(context).getCompilerSettings(chunk)	CompilerSettings	settings
settings.getSbtIncrementalOptions	SbtIncrementalOptions	options
if (chunk.containsTests()) dirtyFilesTestKey else dirtyFilesProductionKey	Key[Any]	key
Key.create("source.dep.production.dirty.files")	Key[Any]	dirtyFilesProductionKey
Key.create("source.dep.test.dirty.files")	Key[Any]	dirtyFilesTestKey
getServer(context)	Server	server
JpsLogger.getInstance(ScalaBuilder.getClass.getName)	Logger	Log
None	Option[Server]	cachedServer
cachedServer.getOrElse(new local.LocalServer())	Server	server
{ val classLoader = getClass.getClassLoader val pluginRoot = new File(PathManager.getJarPathForClass(getClass)).getParentFile val javaClassVersion = System.getProperty("java.class.version") SbtData.from(classLoader, pluginRoot, javaClassVersion) }	Either[String, SbtData]	sbtData
modules.exists(SettingsManager.getScalaSdk(_).isDefined)	Boolean	hasScalaFacet
compilationData.classpath.exists(_.getName.startsWith("scala-library"))	Boolean	hasScalaLibrary
compilationData.sources.exists(_.getName.endsWith(".scala"))	Boolean	hasScalaSources
modules.map(_.getName).mkString(", ")	String	names
Key.create[Set[JpsModule]]("jps.scala.modules")	Key[Set[JpsModule]]	scalaModulesKey
using(new DataInputStream(new BufferedInputStream(new FileInputStream(file)))) { in => try { Some(IncrementalityType.valueOf(in.readUTF())) } catch { case _: IOException | _: IllegalArgumentException | _: NullPointerException => None } }	Some[IncrementalityType]	result
ScalaBuilder.projectSettings(context)	ProjectSettings	settings
getPreviousIncrementalType	Option[IncrementalityType]	previousIncrementalType
settings.getIncrementalityType	IncrementalityType	incrType
module.getModuleType	JpsModuleType[_]	moduleType
collectSources(context, chunk, dirtyFilesHolder)	Seq[Any]	sources
local.PackageObjectsData.getFor(context)	PackageObjectsData	packageObjectsData
context.getProjectDescriptor.dataManager.getMappings.createDelta()	Mappings	delta
delta.getCallback	Callbacks.Backend	callback
mutable.Set.empty[File]	mutable.Set[Any]	successfullyCompiled
new local.IdeClientIdea(compilerName, context, modules.map(_.getName).toSeq, outputConsumer, callback, successfullyCompiled, packageObjectsData)	IdeClientIdea	client
projectSettings(context)	ProjectSettings	settings
mutable.ListBuffer.empty[File]	ListBuffer[Any]	result
projectSettings(context).getCompilerSettings(chunk).getCompileOrder	CompileOrder	compileOrder
compileOrder match { case model.CompileOrder.Mixed => List(".scala", ".java") case _ => List(".scala") }	List[Nothing]	extensionsToCollect
context.getProjectDescriptor	ProjectDescriptor	pd
JpsCompilationInfo( allModules, Set.empty, allClasses, timestamp )	JpsCompilationInfo	info
context.getCompilationStartStamp(target)	Long	stamp
sys.props.get(rebuildPropertyKey).exists(java.lang.Boolean.valueOf(_))	Boolean	shouldBeNonIncremental
getTargetTimestamps(chunk.getTargets.asScala, context)	Long	timestamp
JpsCompilationInfo( affectedModules, removedSources, compiledClasses, timestamp )	JpsCompilationInfo	data
pd.getBuildTargetIndex	BuildTargetIndex	buildTargetIndex
pd.dataManager	BuildDataManager	dataManager
getTargetTimestamps(targets, context)	Long	timestamp
Set.newBuilder[CompiledClass]	mutable.Builder[CompiledClass, Set[CompiledClass]]	classes
Option(mapping.getOutputs(source)).fold(Iterable.empty[String])(_.asScala)	Iterable[String]	outputs
Option(System.getProperty(compilerInterfacesKey))	Option[Nothing]	customPath
encodeHex(md5(source_2_10))	String	checksum
SourceJars(source_2_10, source_2_11, source_2_13)	SbtData.SourceJars	sources
Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')	Array[Char]	HexChars
new StringBuilder(bytes.length * 2)	StringBuilder	out
bytes(i)	Byte	b
Seq("nameHashing", "recompileOnMacroDef", "transitiveStep", "recompileAllFraction")	Seq[Nothing]	names
this.productIterator.toSeq	Seq[Any]	values
SbtIncrementalOptions.Default.productIterator.toSeq	Seq[Any]	defaultValues
for { ((name, value), defaultValue) <- names.zip(values).zip(defaultValues) if value != defaultValue } yield s"$name = $value"	IndexedSeq[String]	differs
SbtIncrementalOptions(nameHashing = true, recompileOnMacroDef = true, transitiveStep = 3, recompileAllFraction = 0.5)	SbtIncrementalOptions	Default
None	Option[BinaryContent]	loadedContent
false	Boolean	contentIsSet
new BinaryContent(FileUtil.loadFileBytes(outputFile))	BinaryContent	content
arguments.map(s => Base64Converter.encode(s.getBytes("UTF-8")))	IndexedSeq[Nothing]	encodedArgs
new ClientEventProcessor(client)	ClientEventProcessor	processor
Event.fromBytes(Base64Converter.decode(data))	Event	event
new String(data)	String	s
fromBytes(data)	String	message
s"Unexpected server output: $data"	String	message
new Array[Byte](size)	Array[Byte]	buffer
{ val buffer = new Array[Byte](size) input.readFully(buffer) buffer }	Array[Byte]	data
if (message != null) s": $message" else ""	String	reason
data.toJson.compactPrint	String	json
new Array[Byte](8192)	Array[Byte]	buffer
0	Int	read
tryWith(new InflaterInputStream(bais)) { inflater => val out = new ByteArrayOutputStream val buffer = new Array[Byte](8192) var read = 0 while ({ read = inflater.read(buffer); read > 0 }) { out.write(buffer, 0, read) } out.close() out.toByteArray }	Try[Any]	inflated
taskKey[Classpath]("scalaCommunity module's fullClasspath in Compile and Test scopes")	TaskKey[Keys.Classpath]	communityFullClasspath
classpaths.foldLeft(Seq.empty[Attributed[File]]){(merged, cp) => merged ++ cp}	Seq[Attributed[sbt.File]]	merged
cat("SlowTests")	String	slowTests
cat("PerfCycleTests")	String	perfOptTests
cat("HighlightingTests")	String	highlightingTests
cat("DebuggerTests")	String	debuggerTests
cat("ScalacTests")	String	scalacTests
cat("TypecheckerTests")	String	typecheckerTests
cat("TestingSupportTests")	String	testingSupportTests
Scala.project	String	scalaVersion
Scala.binary_2_12	String	scalaBinaryVersion
Sbt.latest	String	sbtVersion
"2018.2.1+4-88400d3f"	String	sbtStructureVersion
"2018.3"	String	sbtIdeaShellVersion
latest_2_12	String	latest
latest_1_0	String	latest
"org.jetbrains" % "sbt-structure-extractor" % sbtStructureVersion	ModuleID	sbtStructureExtractor
sbtPluginDependency(sbtStructureExtractor, Sbt.binary_0_13)	ModuleID	sbtStructureExtractor_013
sbtPluginDependency(sbtStructureExtractor, Sbt.binary_1_0)	ModuleID	sbtStructureExtractor_100
"org.scala-sbt" % "sbt-launch" % sbtVersion intransitive()	ModuleID	sbtLaunch
"com.github.jbellis" % "jamm" % "0.3.1"	ModuleID	jamm
"org.scala-lang" % "scala-library" % scalaVersion	ModuleID	scalaLibrary
"org.scala-lang" % "scala-reflect" % scalaVersion	ModuleID	scalaReflect
"org.scala-lang" % "scala-compiler" % scalaVersion	ModuleID	scalaCompiler
"org.scala-lang.modules" %% "scala-xml" % "1.0.6"	ModuleID	scalaXml
"org.scala-lang.modules" %% "scala-parser-combinators" % "1.0.4"	ModuleID	scalaParserCombinators
"org.jetbrains" %% "sbt-structure-core" % sbtStructureVersion	ModuleID	sbtStructureCore
"org.atteo" % "evo-inflector" % "1.2"	ModuleID	evoInflector
"org.scalatest" % "scalatest-finders-patched" % "0.9.10"	ModuleID	scalatestFindersPatched
"org.specs2" %% "specs2-core" % "2.4.17" % "provided" excludeAll ExclusionRule(organization = "org.ow2.asm")	ModuleID	specs2
"commons-lang" % "commons-lang" % "2.6"	ModuleID	commonsLang
"com.novocode" % "junit-interface" % "0.11" % "test"	ModuleID	junitInterface
"org.apache.ivy" % "ivy" % "2.4.0"	ModuleID	ivy2
"org.scalastyle" %% "scalastyle" % "1.0.0"	ModuleID	scalastyle
"org.scalariform" %% "scalariform" % "0.2.2"	ModuleID	scalariform
Seq( "com.geirsson" %% "scalafmt-core" % "1.5.1", "com.geirsson" %% "metaconfig-core" % "0.4.0", "com.geirsson" %% "metaconfig-typesafe-config" % "0.4.0", "com.typesafe" % "config" % "1.2.1", "com.lihaoyi" %% "sourcecode" % "0.1.3" )	Seq[ModuleID]	scalafmt
"org.scalameta" % "paradise" % paradiseVersion cross CrossVersion.full	ModuleID	macroParadise
"org.scalameta" %% "scalameta" % scalaMetaVersion withSources() exclude("com.google.protobuf", "protobuf-java")	ModuleID	scalaMetaCore
"com.lihaoyi" % s"fastparse_$scalaBinaryVersion" % "0.4.3"	ModuleID	fastparse
"org.apache.bcel" % "bcel" % "6.0"	ModuleID	bcel
"io.github.sugakandrey" %% "scala-compiler-indices-protocol" % "0.1.1"	ModuleID	compilerIndicesProtocol
"org.jetbrains" % "nailgun-patched" % "1.0.0"	ModuleID	nailgun
{ file => file.getName.contains("lsp4j") // version conflict with bsp4j in ultimate platform }	sbt.File => Boolean	excludeJarsFromPlatformDependencies
Seq( zinc, zincInterface )	Seq[ModuleID]	sbtBundled
Seq( scalaLibrary, scalaReflect, scalaXml, scalaMetaCore, scalaParserCombinators, sbtStructureCore, evoInflector, scalatestFindersPatched, jamm, ivy2, scalastyle, scalariform, compilerIndicesProtocol )	Seq[ModuleID]	scalaCommunity
Seq( ("org.scala-sbt.ipcsocket" % "ipcsocket" % "1.0.0") .exclude("net.java.dev.jna","jna") // included in IDEA platform .exclude("net.java.dev.jna","jna-platform") // included in IDEA platform , ("ch.epfl.scala" % "bsp4j" % bspVersion) .exclude("com.google.code.gson", "gson") // included in IDEA platform .exclude("com.google.guava", "guava") // included in IDEA platform , "ch.epfl.scala" %% "bsp-testkit" % bspVersion % "test", "org.scalatest" %% "scalatest" % "3.0.5" % "test" )	Seq[ModuleID]	bsp
Seq( scalaLibrary, scalaReflect, scalaCompiler, commonsLang, bcel )	Seq[ModuleID]	decompiler
Seq( specs2, "org.scala-lang" % "scala-compiler" % scalaVersion, "org.scalatest" %% "scalatest" % "3.0.1" % "provided", "com.lihaoyi" %% "utest" % "0.5.4" % "provided" )	Seq[ModuleID]	runners
Seq( sbtLaunch, compilerBridgeSources_2_10, compilerBridgeSources_2_11, compilerBridgeSources_2_13 )	Seq[ModuleID]	sbtRuntime
jbBintrayResolver("scalatest-finders-patched", "scalatest", Resolver.ivyStylePatterns)	URLRepository	scalaTestFindersPatched
jbBintrayResolver("scala-plugin-deps", "scala-plugin-deps", Resolver.ivyStylePatterns)	URLRepository	scalaPluginDeps
Resolver.sonatypeRepo("releases")	MavenRepository	sonatypeReleases
Resolver.sonatypeRepo("staging")	MavenRepository	sonatypeStaging
Resolver.bintrayRepo("scalamacros", "maven")	MavenRepository	macrosMaven
jbSbtResolver("jetbrains-sbt", Resolver.ivyStylePatterns)	URLRepository	jbSbtPlugins
Resolver.bintrayRepo("scalacenter","releases")	MavenRepository	scalaCenter
Seq(Resolvers.mavenPatched, Resolvers.metaBintray, Resolvers.jbSbtPlugins, Resolvers.scalaTestFindersPatched, Resolvers.scalaPluginDeps, Resolvers.sonatypeReleases, Resolvers.macrosMaven, Resolvers.scalaCenter, Resolvers.sonatypeStaging)	Seq[Resolver with Product with Serializable]	allResolvers
relativePathSbt1(artifactId, version)	String	plugin_sbt1
relativePathSbt013(artifactId, version)	String	plugin_sbt013
paths.map { path => val downloadUrl = remoteRepo.resolve(path).normalize().toURL val localFile = (localRepo / path).getCanonicalFile // Place dummy javadoc files for artifacts to avoid resolve errors without packaging large-ish but useless files. if (!localFile.exists) { if (path.endsWith("-javadoc.jar")) { IO.write(localFile, Array.empty[Byte]) } else if (path.endsWith("-javadoc.jar.md5")) { IO.write(localFile, emptyMD5.getBytes(StandardCharsets.US_ASCII)) } else IO.download(downloadUrl, localFile) } localFile }	Seq[Any]	downloadedArtifactFiles
relativePathSbt013(artifactId, version)	String	artifactPath
relativePathSbt1(artifactId, version)	String	artifactPath
relativeJarPath(artifactPath, id)	String	path
s"$artifactPath/srcs/$id-sources.jar"	String	path
s"$artifactPath/docs/$id-javadoc.jar"	String	path
s"$artifactPath/ivys/ivy.xml"	String	path
taskKey[Seq[File]]("run all sourceGenerators in current project")	TaskKey[Seq[sbt.File]]	generateSources
taskKey[Unit]("run all sourceGenerators in ALL project")	TaskKey[Unit]	generateAllSources
(Keys.sourceGenerators in Compile).value	Seq[Task[Seq[sbt.File]]]	gens
newProject("scalaCommunity", file(".")) .dependsOn( bsp % "test->test;compile->compile", codeInsight % "test->test;compile->compile", conversion % "test->test;compile->compile", uast % "test->test;compile->compile", worksheet % "test->test;compile->compile", scalaImpl % "test->test;compile->compile", devKitIntegration % "test->test;compile->compile", androidIntegration % "test->test;compile->compile", copyrightIntegration % "test->test;compile->compile", gradleIntegration % "test->test;compile->compile", intelliLangIntegration % "test->test;compile->compile", mavenIntegration % "test->test;compile->compile", propertiesIntegration % "test->test;compile->compile", javaDecompilerIntegration) .settings( ideExcludedDirectories := Seq(baseDirectory.value / "target"), packageAdditionalProjects := Seq(scalaApi, compilerJps, repackagedZinc, decompiler, compilerShared, nailgunRunners, runners, sbtRuntimeDependencies), packageLibraryMappings := Dependencies.scalaLibrary -> Some("lib/scala-library.jar") :: Nil, definedTests in Test := { // all sub-project tests need to be run within main project's classpath definedTests.all(ScopeFilter(inDependencies(scalaCommunity, includeRoot = false), inConfigurations(Test))).value.flatten } )	Project	scalaCommunity
newProject( "scala-api", file("scala/scala-api") )	Project	scalaApi
newProject( "codeInsight", file("scala/codeInsight") ).dependsOn( scalaImpl % "test->test;compile->compile" )	Project	codeInsight
newProject( "conversion", file("scala/conversion") ).dependsOn( codeInsight % "test->test;compile->compile" )	Project	conversion
newProject( "uast", file("scala/uast") ).dependsOn( scalaImpl % "test->test;compile->compile" )	Project	uast
newProject( "worksheet", file("scala/worksheet") ).dependsOn( scalaImpl % "test->test;compile->compile" )	Project	worksheet
newProject("scala-impl", file("scala/scala-impl")) .dependsOn( compilerShared, scalaApi, macroAnnotations, decompiler % "test->test;compile->compile", runners % "test->test;compile->compile") .enablePlugins(BuildInfoPlugin) .settings( ideExcludedDirectories := Seq(baseDirectory.value / "testdata" / "projects"), javacOptions in Global ++= Seq("-source", "1.8", "-target", "1.8", "-Xlint:unchecked"), scalacOptions in Global ++= Seq("-target:jvm-1.8", "-deprecation"), //scalacOptions in Global += "-Xmacro-settings:analyze-caches", libraryDependencies ++= DependencyGroups.scalaCommunity, addCompilerPlugin(Dependencies.macroParadise), ideaInternalPlugins := Seq( "IntelliLang", "java-i18n", "android", "stats-collector", // required for ml completion testing "smali", // required by Android "gradle", // required by Android "Groovy", // required by Gradle "properties", // required by Gradle "maven", // TODO remove after extracting the SBT module (which depends on Maven) "junit" ), ideaPluginJars := ideaPluginJars.value.filterNot(cp => cp.data.getName.contains("junit-jupiter-api")), packageMethod := PackagingMethod.MergeIntoOther(scalaCommunity), packageLibraryMappings ++= Seq( "org.scalameta" %% ".*" % ".*" -> Some("lib/scalameta.jar"), "com.trueaccord.scalapb" %% "scalapb-runtime" % ".*" -> None, "com.google.protobuf" % "protobuf-java" % ".*" -> None, "com.trueaccord.lenses" %% "lenses" % ".*" -> None, "com.lihaoyi" %% "fastparse-utils" % ".*" -> None, "commons-lang" % "commons-lang" % ".*" -> None, Dependencies.scalaXml -> Some("lib/scala-xml.jar"), Dependencies.scalaReflect -> Some("lib/scala-reflect.jar"), Dependencies.scalaLibrary -> None ), packageFileMappings ++= Seq( baseDirectory.in(compilerJps).value / "resources" / "ILoopWrapperImpl.scala" -> "lib/jps/repl-interface-sources.jar", baseDirectory.in(compilerJps).value / "resources" / "ILoopWrapper213Impl.scala" -> "lib/jps/repl-interface-sources.jar" ), buildInfoPackage := "org.jetbrains.plugins.scala.buildinfo", buildInfoKeys := Seq( name, version, scalaVersion, sbtVersion, BuildInfoKey.constant("sbtStructureVersion", Versions.sbtStructureVersion), BuildInfoKey.constant("sbtIdeaShellVersion", Versions.sbtIdeaShellVersion), BuildInfoKey.constant("sbtIdeaCompilerIndicesVersion", Versions.sbtIdeaCompilerIndicesVersion), BuildInfoKey.constant("sbtLatest_0_12", Versions.Sbt.latest_0_12), BuildInfoKey.constant("sbtLatest_0_13", Versions.Sbt.latest_0_13), BuildInfoKey.constant("sbtLatest_1_0", Versions.Sbt.latest_1_0), BuildInfoKey.constant("sbtLatestVersion", Versions.sbtVersion), BuildInfoKey.constant("sbtStructurePath_0_13", LocalRepoPackager.relativeJarPath013("sbt-structure-extractor", Versions.sbtStructureVersion)), BuildInfoKey.constant("sbtStructurePath_1_0", LocalRepoPackager.relativeJarPath1("sbt-structure-extractor", Versions.sbtStructureVersion)) ) )	Project	scalaImpl
newProject("compiler-jps", file("scala/compiler-jps")) .dependsOn(compilerShared, repackagedZinc) .settings( packageMethod := PackagingMethod.Standalone("lib/jps/compiler-jps.jar", static = true), libraryDependencies ++= Dependencies.nailgun :: Dependencies.zincInterface :: Nil, packageLibraryMappings ++= Dependencies.nailgun -> Some("lib/jps/nailgun.jar") :: Dependencies.zincInterface -> Some("lib/jps/compiler-interface.jar") :: Nil)	Project	compilerJps
newProject("repackagedZinc", file("target/tools/zinc")) .settings( packageOutputDir := baseDirectory.value / "plugin", packageAssembleLibraries := true, shadePatterns += ShadePattern("com.google.protobuf.**", "zinc.protobuf.@1"), packageMethod := PackagingMethod.DepsOnly("lib/jps/incremental-compiler.jar"), libraryDependencies += Dependencies.zinc)	Project	repackagedZinc
newProject("compiler-shared", file("scala/compiler-shared")) .settings( libraryDependencies ++= Seq(Dependencies.nailgun, Dependencies.compilerIndicesProtocol), packageLibraryMappings ++= Seq( Dependencies.nailgun -> Some("lib/jps/nailgun.jar"), Dependencies.compilerIndicesProtocol -> Some("lib/scala-compiler-indices-protocol_2.12-0.1.1.jar") ), packageMethod := PackagingMethod.Standalone("lib/compiler-shared.jar", static = true) )	Project	compilerShared
newProject("runners", file("scala/runners")) .settings( packageMethod := PackagingMethod.Standalone(static = true), libraryDependencies ++= DependencyGroups.runners, // WORKAROUND fixes build error in sbt 0.13.12+ analogously to https://github.com/scala/scala/pull/5386/ ivyScala ~= (_ map (_ copy (overrideScalaVersion = false))) )	Project	runners
newProject("nailgun", file("scala/nailgun")) .dependsOn(runners) .settings( libraryDependencies += Dependencies.nailgun, packageLibraryMappings += Dependencies.nailgun -> Some("lib/jps/nailgun.jar"), packageMethod := PackagingMethod.Standalone("lib/scala-nailgun-runner.jar", static = true) )	Project	nailgunRunners
newProject("decompiler", file("scala/decompiler")) .settings( libraryDependencies ++= DependencyGroups.decompiler, packageMethod := PackagingMethod.Standalone("lib/scalap.jar") )	Project	decompiler
newProject("macros", file("scala/macros")) .settings( addCompilerPlugin(Dependencies.macroParadise), libraryDependencies ++= Seq(Dependencies.scalaReflect, Dependencies.scalaCompiler), packageMethod := PackagingMethod.Skip() )	Project	macroAnnotations
newProject("bsp", file("bsp")) .dependsOn(scalaImpl % "test->test;compile->compile") .settings( libraryDependencies ++= DependencyGroups.bsp, ideaMainJars := Seq.empty )	Project	bsp
newProject( "devKit", file("scala/integration/devKit") ).settings( ideaInternalPlugins += "devkit" )	Project	devKitIntegration
newProject("android", file("scala/integration/android")) .dependsOn(scalaImpl % "test->test;compile->compile") .settings( ideaInternalPlugins ++= Seq( "android", "smali", // required by Android "gradle", // required by Android "Groovy", // required by Gradle "properties") // required by Gradle )	Project	androidIntegration
newProject("copyright", file("scala/integration/copyright")) .dependsOn(scalaImpl % "test->test;compile->compile") .settings( ideaInternalPlugins ++= Seq("copyright") )	Project	copyrightIntegration
newProject("gradle", file("scala/integration/gradle")) .dependsOn(scalaImpl % "test->test;compile->compile") .settings( ideaInternalPlugins ++= Seq( "gradle", "Groovy", // required by Gradle "properties") // required by Gradle )	Project	gradleIntegration
newProject( "intelliLang", file("scala/integration/intellilang") ).dependsOn( scalaImpl % "test->test;compile->compile" ).settings( ideaInternalPlugins ++= Seq("IntelliLang") )	Project	intelliLangIntegration
newProject("maven", file("scala/integration/maven")) .dependsOn(scalaImpl % "test->test;compile->compile") .settings( ideaInternalPlugins ++= Seq("maven") )	Project	mavenIntegration
newProject("properties", file("scala/integration/properties")) .dependsOn(scalaImpl % "test->test;compile->compile") .settings( ideaInternalPlugins ++= Seq("properties") )	Project	propertiesIntegration
newProject("java-decompiler", file("scala/integration/java-decompiler")) .dependsOn(scalaApi % Compile) .settings( ideaInternalPlugins ++= Seq("java-decompiler") )	Project	javaDecompilerIntegration
(sbtStructureExtractor.name, Versions.sbtStructureVersion) :: ("sbt-idea-shell", Versions.sbtIdeaShellVersion) :: ("sbt-idea-compiler-indices", Versions.sbtIdeaCompilerIndicesVersion) :: Nil	List[(String, String)]	localRepoArtifacts
LocalRepoPackager.localPluginRepoPaths(localRepoArtifacts)	Seq[String]	localRepoPaths
(project in file("target/tools/sbt-runtime-dependencies")) .settings( libraryDependencies := DependencyGroups.sbtRuntime, managedScalaInstance := false, conflictManager := ConflictManager.all, conflictWarning := ConflictWarning.disable, resolvers += sbt.Classpaths.sbtPluginReleases, ideSkipProject := true, packageMethod := PackagingMethod.DepsOnly(), packageLibraryMappings ++= Seq( Dependencies.sbtLaunch -> Some("launcher/sbt-launch.jar"), Dependencies.sbtInterface -> Some("lib/jps/sbt-interface.jar"), Dependencies.zincInterface -> Some("lib/jps/compiler-interface.jar"), Dependencies.compilerBridgeSources_2_13 -> Some("lib/jps/compiler-interface-sources-2.13.jar"), Dependencies.compilerBridgeSources_2_11 -> Some("lib/jps/compiler-interface-sources-2.11.jar"), Dependencies.compilerBridgeSources_2_10 -> Some("lib/jps/compiler-interface-sources-2.10.jar") ), update := { LocalRepoPackager.localPluginRepo(target.value / "repo", localRepoPaths) update.value }, packageFileMappings ++= { val repoBase = target.value / "repo" localRepoPaths.map { path => repoBase / path -> s"repo/$path" } } )	Project	sbtRuntimeDependencies
createRunnerProject(scalaCommunity, "idea-runner")	Project	ideaRunner
new utils.ActionCallbackProfilerStopper	ActionCallbackProfilerStopper	actionCallback
Map( (s"${CMD_PREFIX}scalaCleanCaches", new ScalaCleanCachesCommand(_, _)) )	Map[String, CreateCommand]	commands
new CommonDuplicateIndexConfiguration(languageName)	CommonDuplicateIndexConfiguration	config
languageName	String	getLanguageName
file.getExtension == "sc"	Boolean	isWorksheet